
build/bin/melox.bin:     file format elf32-i386


Disassembly of section .virk_init_text:

00100000 <start-0xc>:
  100000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
  100006:	00 00                	add    %al,(%eax)
  100008:	fb                   	sti    
  100009:	4f                   	dec    %edi
  10000a:	52                   	push   %edx
  10000b:	e4                   	.byte 0xe4

0010000c <start>:
  10000c:	bc 00 60 10 00       	mov    $0x106000,%esp
  100011:	68 00 10 10 00       	push   $0x101000
  100016:	53                   	push   %ebx
  100017:	e8 64 00 00 00       	call   100080 <save_multiboot_info>
  10001c:	58                   	pop    %eax
  10001d:	58                   	pop    %eax
  10001e:	68 00 60 00 00       	push   $0x6000
  100023:	68 00 c0 12 00       	push   $0x12c000
  100028:	e8 a4 02 00 00       	call   1002d1 <kerner_init>
  10002d:	8b 04 24             	mov    (%esp),%eax
  100030:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  100035:	0f 22 d8             	mov    %eax,%cr3
  100038:	0f 20 c0             	mov    %cr0,%eax
  10003b:	0d 00 00 00 80       	or     $0x80000000,%eax
  100040:	0f 22 c0             	mov    %eax,%cr0
  100043:	58                   	pop    %eax
  100044:	58                   	pop    %eax
  100045:	68 9d 7b 10 c0       	push   $0xc0107b9d
  10004a:	c3                   	ret    

0010004b <_save_>:
extern uint8_t virkernel_start;
extern uint8_t virkernel_end ;
extern uint8_t __init_phykernel_end;
extern uint8_t _kernel_stack;

uint32_t _save_(uint8_t* destination, uint8_t* base, multiboot_uint32_t size) {
  10004b:	55                   	push   %ebp
  10004c:	89 e5                	mov    %esp,%ebp
  10004e:	83 ec 10             	sub    $0x10,%esp
    multiboot_uint32_t i = 0;
  100051:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    for (; i < size; i++)
  100058:	eb 19                	jmp    100073 <_save_+0x28>
    {
        *(destination + i) = *(base + i);
  10005a:	8b 55 0c             	mov    0xc(%ebp),%edx
  10005d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100060:	01 d0                	add    %edx,%eax
  100062:	8b 4d 08             	mov    0x8(%ebp),%ecx
  100065:	8b 55 fc             	mov    -0x4(%ebp),%edx
  100068:	01 ca                	add    %ecx,%edx
  10006a:	0f b6 00             	movzbl (%eax),%eax
  10006d:	88 02                	mov    %al,(%edx)
    for (; i < size; i++)
  10006f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  100073:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100076:	3b 45 10             	cmp    0x10(%ebp),%eax
  100079:	72 df                	jb     10005a <_save_+0xf>
    }
    return i;
  10007b:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  10007e:	c9                   	leave  
  10007f:	c3                   	ret    

00100080 <save_multiboot_info>:

void save_multiboot_info(multiboot_info_t* mb_info, multiboot_uint8_t* dest)
{
  100080:	55                   	push   %ebp
  100081:	89 e5                	mov    %esp,%ebp
  100083:	53                   	push   %ebx
  100084:	83 ec 10             	sub    $0x10,%esp
    uint32_t current = 0;
  100087:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    uint8_t* info_b = (uint8_t*) mb_info;
  10008e:	8b 45 08             	mov    0x8(%ebp),%eax
  100091:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for (; current < sizeof(multiboot_info_t); current++)
  100094:	eb 19                	jmp    1000af <save_multiboot_info+0x2f>
    {
        *(dest + current) = *(info_b + current);
  100096:	8b 55 f4             	mov    -0xc(%ebp),%edx
  100099:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10009c:	01 d0                	add    %edx,%eax
  10009e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1000a1:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1000a4:	01 ca                	add    %ecx,%edx
  1000a6:	0f b6 00             	movzbl (%eax),%eax
  1000a9:	88 02                	mov    %al,(%edx)
    for (; current < sizeof(multiboot_info_t); current++)
  1000ab:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  1000af:	83 7d f8 77          	cmpl   $0x77,-0x8(%ebp)
  1000b3:	76 e1                	jbe    100096 <save_multiboot_info+0x16>
    }

    ((multiboot_info_t*) dest)->mmap_addr = (uintptr_t)dest + current;
  1000b5:	8b 55 0c             	mov    0xc(%ebp),%edx
  1000b8:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1000bb:	01 c2                	add    %eax,%edx
  1000bd:	8b 45 0c             	mov    0xc(%ebp),%eax
  1000c0:	89 50 30             	mov    %edx,0x30(%eax)
    current += _save_(dest + current, (uint8_t*)mb_info->mmap_addr, mb_info->mmap_length);
  1000c3:	8b 45 08             	mov    0x8(%ebp),%eax
  1000c6:	8b 40 2c             	mov    0x2c(%eax),%eax
  1000c9:	8b 55 08             	mov    0x8(%ebp),%edx
  1000cc:	8b 52 30             	mov    0x30(%edx),%edx
  1000cf:	89 d1                	mov    %edx,%ecx
  1000d1:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  1000d4:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1000d7:	01 da                	add    %ebx,%edx
  1000d9:	50                   	push   %eax
  1000da:	51                   	push   %ecx
  1000db:	52                   	push   %edx
  1000dc:	e8 6a ff ff ff       	call   10004b <_save_>
  1000e1:	83 c4 0c             	add    $0xc,%esp
  1000e4:	01 45 f8             	add    %eax,-0x8(%ebp)

    if (present(mb_info->flags, MULTIBOOT_INFO_DRIVE_INFO)) {
  1000e7:	8b 45 08             	mov    0x8(%ebp),%eax
  1000ea:	8b 00                	mov    (%eax),%eax
  1000ec:	25 80 00 00 00       	and    $0x80,%eax
  1000f1:	85 c0                	test   %eax,%eax
  1000f3:	74 32                	je     100127 <save_multiboot_info+0xa7>
        ((multiboot_info_t*) dest)->drives_addr = (uintptr_t)dest + current;
  1000f5:	8b 55 0c             	mov    0xc(%ebp),%edx
  1000f8:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1000fb:	01 c2                	add    %eax,%edx
  1000fd:	8b 45 0c             	mov    0xc(%ebp),%eax
  100100:	89 50 38             	mov    %edx,0x38(%eax)
        current += _save_(dest + current, (uint8_t*)mb_info->drives_addr, mb_info->drives_length);
  100103:	8b 45 08             	mov    0x8(%ebp),%eax
  100106:	8b 40 34             	mov    0x34(%eax),%eax
  100109:	8b 55 08             	mov    0x8(%ebp),%edx
  10010c:	8b 52 38             	mov    0x38(%edx),%edx
  10010f:	89 d1                	mov    %edx,%ecx
  100111:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  100114:	8b 55 f8             	mov    -0x8(%ebp),%edx
  100117:	01 da                	add    %ebx,%edx
  100119:	50                   	push   %eax
  10011a:	51                   	push   %ecx
  10011b:	52                   	push   %edx
  10011c:	e8 2a ff ff ff       	call   10004b <_save_>
  100121:	83 c4 0c             	add    $0xc,%esp
  100124:	01 45 f8             	add    %eax,-0x8(%ebp)
    }
    multiboot_info_t* test = (multiboot_info_t*) dest;
  100127:	8b 45 0c             	mov    0xc(%ebp),%eax
  10012a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    multiboot_memory_map_t* testmap = (multiboot_memory_map_t*)mb_info->mmap_addr;
  10012d:	8b 45 08             	mov    0x8(%ebp),%eax
  100130:	8b 40 30             	mov    0x30(%eax),%eax
  100133:	89 45 ec             	mov    %eax,-0x14(%ebp)
}
  100136:	90                   	nop
  100137:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10013a:	c9                   	leave  
  10013b:	c3                   	ret    

0010013c <init_page>:

void init_page(ptd_t* pt)
{
  10013c:	55                   	push   %ebp
  10013d:	89 e5                	mov    %esp,%ebp
  10013f:	83 ec 30             	sub    $0x30,%esp
    SET_PDE(pt, 0, PDE(PG_PRESENT, pt + PG_MAX_ENTRIES));
  100142:	8b 45 08             	mov    0x8(%ebp),%eax
  100145:	05 00 10 00 00       	add    $0x1000,%eax
  10014a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  10014f:	83 c8 01             	or     $0x1,%eax
  100152:	89 c2                	mov    %eax,%edx
  100154:	8b 45 08             	mov    0x8(%ebp),%eax
  100157:	89 10                	mov    %edx,(%eax)
    ptd_t * tmp_paged_phy_addr = pt;
  100159:	8b 45 08             	mov    0x8(%ebp),%eax
  10015c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    ptd_t * tmp_paget_phy_addr = pt + 1024;
  10015f:	8b 45 08             	mov    0x8(%ebp),%eax
  100162:	05 00 10 00 00       	add    $0x1000,%eax
  100167:	89 45 e8             	mov    %eax,-0x18(%ebp)
    //identity map 1M memory
    for(uint32_t i = 0; i < 256; i++)
  10016a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  100171:	eb 20                	jmp    100193 <init_page+0x57>
        *(tmp_paget_phy_addr + i) = (((i << 12) & 0xFFFFF000UL) | (PG_PREM_RW & 0xfff));
  100173:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100176:	c1 e0 0c             	shl    $0xc,%eax
  100179:	89 c2                	mov    %eax,%edx
  10017b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10017e:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
  100185:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100188:	01 c8                	add    %ecx,%eax
  10018a:	83 ca 03             	or     $0x3,%edx
  10018d:	89 10                	mov    %edx,(%eax)
    for(uint32_t i = 0; i < 256; i++)
  10018f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  100193:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%ebp)
  10019a:	76 d7                	jbe    100173 <init_page+0x37>

    //identity map virkernel_init memory
    for(uint32_t i = 0; i < LOADOS_PAGE_COUNT; i++)
  10019c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  1001a3:	eb 29                	jmp    1001ce <init_page+0x92>
        *(tmp_paget_phy_addr + i + 256) = ((((i << 12) + MEM_1M) & 0xFFFFF000UL) | (PG_PREM_RW & 0xfff));
  1001a5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1001a8:	c1 e0 0c             	shl    $0xc,%eax
  1001ab:	8d 90 00 00 10 00    	lea    0x100000(%eax),%edx
  1001b1:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1001b4:	05 00 01 00 00       	add    $0x100,%eax
  1001b9:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
  1001c0:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1001c3:	01 c8                	add    %ecx,%eax
  1001c5:	83 ca 03             	or     $0x3,%edx
  1001c8:	89 10                	mov    %edx,(%eax)
    for(uint32_t i = 0; i < LOADOS_PAGE_COUNT; i++)
  1001ca:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  1001ce:	b8 00 60 10 00       	mov    $0x106000,%eax
  1001d3:	2d 01 f0 0f 00       	sub    $0xff001,%eax
  1001d8:	c1 e8 0c             	shr    $0xc,%eax
  1001db:	39 45 f8             	cmp    %eax,-0x8(%ebp)
  1001de:	72 c5                	jb     1001a5 <init_page+0x69>

    //now we map the kernel
    //calculate the virtrue kernrl page index
    uint32_t virk_pde_index = PD_INDEX(sym_val(virkernel_start));
  1001e0:	b8 00 60 10 c0       	mov    $0xc0106000,%eax
  1001e5:	c1 e8 16             	shr    $0x16,%eax
  1001e8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uint32_t virk_pte_index = PT_INDEX(sym_val(virkernel_start));
  1001eb:	b8 00 60 10 c0       	mov    $0xc0106000,%eax
  1001f0:	c1 e8 0c             	shr    $0xc,%eax
  1001f3:	25 ff 03 00 00       	and    $0x3ff,%eax
  1001f8:	89 45 e0             	mov    %eax,-0x20(%ebp)
    uint32_t virk_pg_counts = KERNEL_PAGE_COUNT;
  1001fb:	b8 00 20 13 c0       	mov    $0xc0132000,%eax
  100200:	05 00 10 00 00       	add    $0x1000,%eax
  100205:	83 e8 01             	sub    $0x1,%eax
  100208:	ba 00 60 10 c0       	mov    $0xc0106000,%edx
  10020d:	29 d0                	sub    %edx,%eax
  10020f:	c1 e8 0c             	shr    $0xc,%eax
  100212:	89 45 dc             	mov    %eax,-0x24(%ebp)

    //regist the vir_kernel page to page direction
    //we give 3 pagetable to virkel, is 3 * 4 = 12 mib size
    for(uint32_t i = 0; i < PG_TABLE_STACK - PG_TABLE_KERNEL; i++)
  100215:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  10021c:	eb 34                	jmp    100252 <init_page+0x116>
    {
        *(pt + virk_pde_index + i) = PDE(PG_PREM_RW, PT_ADDR(pt, PG_TABLE_KERNEL + i));
  10021e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100221:	83 c0 02             	add    $0x2,%eax
  100224:	c1 e0 0c             	shl    $0xc,%eax
  100227:	89 c2                	mov    %eax,%edx
  100229:	8b 45 08             	mov    0x8(%ebp),%eax
  10022c:	01 d0                	add    %edx,%eax
  10022e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  100233:	89 c2                	mov    %eax,%edx
  100235:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  100238:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10023b:	01 c8                	add    %ecx,%eax
  10023d:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
  100244:	8b 45 08             	mov    0x8(%ebp),%eax
  100247:	01 c8                	add    %ecx,%eax
  100249:	83 ca 03             	or     $0x3,%edx
  10024c:	89 10                	mov    %edx,(%eax)
    for(uint32_t i = 0; i < PG_TABLE_STACK - PG_TABLE_KERNEL; i++)
  10024e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  100252:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
  100256:	76 c6                	jbe    10021e <init_page+0xe2>
    }

    //avoid kernel size > prepared page count
    if(virk_pg_counts > (PG_TABLE_STACK - PG_TABLE_KERNEL) * 1024)
  100258:	81 7d dc 00 0c 00 00 	cmpl   $0xc00,-0x24(%ebp)
  10025f:	76 02                	jbe    100263 <init_page+0x127>
    {
        while(1);
  100261:	eb fe                	jmp    100261 <init_page+0x125>
    }

    //calcul the phy address
    uint32_t virk_phy_addr = V2P(&virkernel_start);
  100263:	b8 00 60 10 c0       	mov    $0xc0106000,%eax
  100268:	05 00 00 00 40       	add    $0x40000000,%eax
  10026d:	89 45 d8             	mov    %eax,-0x28(%ebp)
    //map virtrue kernel page
    for(uint32_t i = 0; i < virk_pg_counts; i++)
  100270:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  100277:	eb 36                	jmp    1002af <init_page+0x173>
    {
        *(tmp_paget_phy_addr + 1024 + virk_pte_index + i) = (((virk_phy_addr + (i << 12)) & 0xFFFFF000UL) | (PG_PREM_RW & 0xfff));
  100279:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10027c:	c1 e0 0c             	shl    $0xc,%eax
  10027f:	89 c2                	mov    %eax,%edx
  100281:	8b 45 d8             	mov    -0x28(%ebp),%eax
  100284:	01 d0                	add    %edx,%eax
  100286:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  10028b:	89 c2                	mov    %eax,%edx
  10028d:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  100290:	8b 45 f0             	mov    -0x10(%ebp),%eax
  100293:	01 c8                	add    %ecx,%eax
  100295:	05 00 04 00 00       	add    $0x400,%eax
  10029a:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
  1002a1:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1002a4:	01 c8                	add    %ecx,%eax
  1002a6:	83 ca 03             	or     $0x3,%edx
  1002a9:	89 10                	mov    %edx,(%eax)
    for(uint32_t i = 0; i < virk_pg_counts; i++)
  1002ab:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
  1002af:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1002b2:	3b 45 dc             	cmp    -0x24(%ebp),%eax
  1002b5:	72 c2                	jb     100279 <init_page+0x13d>
    }

    //self map pd, to give the pd virture address
    SET_PDE(pt, 1023, PDE(T_SELF_REF_PERM, pt));
  1002b7:	8b 45 08             	mov    0x8(%ebp),%eax
  1002ba:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  1002bf:	89 c2                	mov    %eax,%edx
  1002c1:	8b 45 08             	mov    0x8(%ebp),%eax
  1002c4:	05 fc 0f 00 00       	add    $0xffc,%eax
  1002c9:	83 ca 13             	or     $0x13,%edx
  1002cc:	89 10                	mov    %edx,(%eax)
}
  1002ce:	90                   	nop
  1002cf:	c9                   	leave  
  1002d0:	c3                   	ret    

001002d1 <kerner_init>:

void kerner_init(ptd_t* pt, uint32_t pt_size)
{
  1002d1:	55                   	push   %ebp
  1002d2:	89 e5                	mov    %esp,%ebp
  1002d4:	83 ec 10             	sub    $0x10,%esp
    uint8_t* kpg = (uint8_t*) pt;
  1002d7:	8b 45 08             	mov    0x8(%ebp),%eax
  1002da:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for (uint32_t i = 0; i < pt_size; i++)
  1002dd:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1002e4:	eb 0f                	jmp    1002f5 <kerner_init+0x24>
    {
        *(kpg + i) = 0;
  1002e6:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1002e9:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1002ec:	01 d0                	add    %edx,%eax
  1002ee:	c6 00 00             	movb   $0x0,(%eax)
    for (uint32_t i = 0; i < pt_size; i++)
  1002f1:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  1002f5:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1002f8:	3b 45 0c             	cmp    0xc(%ebp),%eax
  1002fb:	72 e9                	jb     1002e6 <kerner_init+0x15>
    }
    init_page(pt);
  1002fd:	ff 75 08             	push   0x8(%ebp)
  100300:	e8 37 fe ff ff       	call   10013c <init_page>
  100305:	83 c4 04             	add    $0x4,%esp
  100308:	90                   	nop
  100309:	c9                   	leave  
  10030a:	c3                   	ret    

Disassembly of section .text:

c0106000 <init_vga_buffer>:
int XPOS = 0;

vga_attr *video;

void init_vga_buffer()
{
c0106000:	55                   	push   %ebp
c0106001:	89 e5                	mov    %esp,%ebp
    video = (vga_attr *) VIDEO;
c0106003:	c7 05 0c 90 10 c0 00 	movl   $0xb8000,0xc010900c
c010600a:	80 0b 00 
}
c010600d:	90                   	nop
c010600e:	5d                   	pop    %ebp
c010600f:	c3                   	ret    

c0106010 <set_vga_buffer>:

void set_vga_buffer(void* vga_buf)
{
c0106010:	55                   	push   %ebp
c0106011:	89 e5                	mov    %esp,%ebp
    video = (vga_attr*)vga_buf;
c0106013:	8b 45 08             	mov    0x8(%ebp),%eax
c0106016:	a3 0c 90 10 c0       	mov    %eax,0xc010900c
}
c010601b:	90                   	nop
c010601c:	5d                   	pop    %ebp
c010601d:	c3                   	ret    

c010601e <vga_put_char>:

void vga_put_char(char c)
{
c010601e:	55                   	push   %ebp
c010601f:	89 e5                	mov    %esp,%ebp
c0106021:	53                   	push   %ebx
c0106022:	83 ec 14             	sub    $0x14,%esp
c0106025:	8b 45 08             	mov    0x8(%ebp),%eax
c0106028:	88 45 f4             	mov    %al,-0xc(%ebp)
    if(c == '\n')
c010602b:	80 7d f4 0a          	cmpb   $0xa,-0xc(%ebp)
c010602f:	75 19                	jne    c010604a <vga_put_char+0x2c>
    {
        YPOS++;
c0106031:	a1 04 90 10 c0       	mov    0xc0109004,%eax
c0106036:	83 c0 01             	add    $0x1,%eax
c0106039:	a3 04 90 10 c0       	mov    %eax,0xc0109004
        XPOS = 0;
c010603e:	c7 05 08 90 10 c0 00 	movl   $0x0,0xc0109008
c0106045:	00 00 00 
c0106048:	eb 54                	jmp    c010609e <vga_put_char+0x80>
    }else if(c == '\r')
c010604a:	80 7d f4 0d          	cmpb   $0xd,-0xc(%ebp)
c010604e:	75 0c                	jne    c010605c <vga_put_char+0x3e>
        XPOS = 0;
c0106050:	c7 05 08 90 10 c0 00 	movl   $0x0,0xc0109008
c0106057:	00 00 00 
c010605a:	eb 42                	jmp    c010609e <vga_put_char+0x80>
    else{
        *(video + XPOS + YPOS * WIDTH) = (theme_color | c);
c010605c:	66 0f be 55 f4       	movsbw -0xc(%ebp),%dx
c0106061:	0f b7 05 00 90 10 c0 	movzwl 0xc0109000,%eax
c0106068:	09 c2                	or     %eax,%edx
c010606a:	8b 0d 0c 90 10 c0    	mov    0xc010900c,%ecx
c0106070:	a1 04 90 10 c0       	mov    0xc0109004,%eax
c0106075:	89 c3                	mov    %eax,%ebx
c0106077:	89 d8                	mov    %ebx,%eax
c0106079:	c1 e0 02             	shl    $0x2,%eax
c010607c:	01 d8                	add    %ebx,%eax
c010607e:	c1 e0 04             	shl    $0x4,%eax
c0106081:	89 c3                	mov    %eax,%ebx
c0106083:	a1 08 90 10 c0       	mov    0xc0109008,%eax
c0106088:	01 d8                	add    %ebx,%eax
c010608a:	01 c0                	add    %eax,%eax
c010608c:	01 c8                	add    %ecx,%eax
c010608e:	66 89 10             	mov    %dx,(%eax)
        XPOS++;
c0106091:	a1 08 90 10 c0       	mov    0xc0109008,%eax
c0106096:	83 c0 01             	add    $0x1,%eax
c0106099:	a3 08 90 10 c0       	mov    %eax,0xc0109008
    }
    if (XPOS >= WIDTH)
c010609e:	a1 08 90 10 c0       	mov    0xc0109008,%eax
c01060a3:	83 f8 4f             	cmp    $0x4f,%eax
c01060a6:	7e 17                	jle    c01060bf <vga_put_char+0xa1>
    {
        YPOS++;
c01060a8:	a1 04 90 10 c0       	mov    0xc0109004,%eax
c01060ad:	83 c0 01             	add    $0x1,%eax
c01060b0:	a3 04 90 10 c0       	mov    %eax,0xc0109004
        XPOS = 0;
c01060b5:	c7 05 08 90 10 c0 00 	movl   $0x0,0xc0109008
c01060bc:	00 00 00 
    }
    if(YPOS >= HIGHT)
c01060bf:	a1 04 90 10 c0       	mov    0xc0109004,%eax
c01060c4:	83 f8 18             	cmp    $0x18,%eax
c01060c7:	7e 05                	jle    c01060ce <vga_put_char+0xb0>
        vga_scrollup();
c01060c9:	e8 be 00 00 00       	call   c010618c <vga_scrollup>
}
c01060ce:	90                   	nop
c01060cf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c01060d2:	c9                   	leave  
c01060d3:	c3                   	ret    

c01060d4 <vga_set_show>:

void vga_set_show(vga_attr flashing, vga_attr backgroud, vga_attr frontcolor)
{
c01060d4:	55                   	push   %ebp
c01060d5:	89 e5                	mov    %esp,%ebp
c01060d7:	83 ec 0c             	sub    $0xc,%esp
c01060da:	8b 4d 08             	mov    0x8(%ebp),%ecx
c01060dd:	8b 55 0c             	mov    0xc(%ebp),%edx
c01060e0:	8b 45 10             	mov    0x10(%ebp),%eax
c01060e3:	66 89 4d fc          	mov    %cx,-0x4(%ebp)
c01060e7:	66 89 55 f8          	mov    %dx,-0x8(%ebp)
c01060eb:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
    theme_color = (flashing << 7 | backgroud << 4 | frontcolor) << 8;
c01060ef:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
c01060f3:	c1 e0 07             	shl    $0x7,%eax
c01060f6:	89 c2                	mov    %eax,%edx
c01060f8:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
c01060fc:	c1 e0 04             	shl    $0x4,%eax
c01060ff:	09 c2                	or     %eax,%edx
c0106101:	0f b7 45 f4          	movzwl -0xc(%ebp),%eax
c0106105:	09 d0                	or     %edx,%eax
c0106107:	c1 e0 08             	shl    $0x8,%eax
c010610a:	66 a3 00 90 10 c0    	mov    %ax,0xc0109000
}
c0106110:	90                   	nop
c0106111:	c9                   	leave  
c0106112:	c3                   	ret    

c0106113 <vga_put_str>:

void vga_put_str(char* str)
{
c0106113:	55                   	push   %ebp
c0106114:	89 e5                	mov    %esp,%ebp
c0106116:	83 ec 08             	sub    $0x8,%esp
    while (*str != '\0')
c0106119:	eb 19                	jmp    c0106134 <vga_put_str+0x21>
    {
        vga_put_char(*str);
c010611b:	8b 45 08             	mov    0x8(%ebp),%eax
c010611e:	0f b6 00             	movzbl (%eax),%eax
c0106121:	0f be c0             	movsbl %al,%eax
c0106124:	83 ec 0c             	sub    $0xc,%esp
c0106127:	50                   	push   %eax
c0106128:	e8 f1 fe ff ff       	call   c010601e <vga_put_char>
c010612d:	83 c4 10             	add    $0x10,%esp
        str++;
c0106130:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    while (*str != '\0')
c0106134:	8b 45 08             	mov    0x8(%ebp),%eax
c0106137:	0f b6 00             	movzbl (%eax),%eax
c010613a:	84 c0                	test   %al,%al
c010613c:	75 dd                	jne    c010611b <vga_put_str+0x8>
    }
}
c010613e:	90                   	nop
c010613f:	90                   	nop
c0106140:	c9                   	leave  
c0106141:	c3                   	ret    

c0106142 <vga_clear>:

void vga_clear()
{
c0106142:	55                   	push   %ebp
c0106143:	89 e5                	mov    %esp,%ebp
c0106145:	83 ec 10             	sub    $0x10,%esp
  
    for(int i = 0; i < WIDTH * HIGHT; i++)
c0106148:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c010614f:	eb 1b                	jmp    c010616c <vga_clear+0x2a>
        *(video + i) = theme_color;
c0106151:	8b 15 0c 90 10 c0    	mov    0xc010900c,%edx
c0106157:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010615a:	01 c0                	add    %eax,%eax
c010615c:	01 c2                	add    %eax,%edx
c010615e:	0f b7 05 00 90 10 c0 	movzwl 0xc0109000,%eax
c0106165:	66 89 02             	mov    %ax,(%edx)
    for(int i = 0; i < WIDTH * HIGHT; i++)
c0106168:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c010616c:	81 7d fc cf 07 00 00 	cmpl   $0x7cf,-0x4(%ebp)
c0106173:	7e dc                	jle    c0106151 <vga_clear+0xf>

    XPOS = 0;
c0106175:	c7 05 08 90 10 c0 00 	movl   $0x0,0xc0109008
c010617c:	00 00 00 
    YPOS = 0;
c010617f:	c7 05 04 90 10 c0 00 	movl   $0x0,0xc0109004
c0106186:	00 00 00 
}
c0106189:	90                   	nop
c010618a:	c9                   	leave  
c010618b:	c3                   	ret    

c010618c <vga_scrollup>:

void vga_scrollup()
{
c010618c:	55                   	push   %ebp
c010618d:	89 e5                	mov    %esp,%ebp
c010618f:	83 ec 10             	sub    $0x10,%esp
    unsigned int last_line = WIDTH * (HIGHT - 1);
c0106192:	c7 45 f4 80 07 00 00 	movl   $0x780,-0xc(%ebp)
    for (unsigned int i = 0; i < last_line; i++) {
c0106199:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c01061a0:	eb 27                	jmp    c01061c9 <vga_scrollup+0x3d>
        *(video + i) = *(video + WIDTH + i);
c01061a2:	8b 15 0c 90 10 c0    	mov    0xc010900c,%edx
c01061a8:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01061ab:	83 c0 50             	add    $0x50,%eax
c01061ae:	01 c0                	add    %eax,%eax
c01061b0:	01 d0                	add    %edx,%eax
c01061b2:	8b 0d 0c 90 10 c0    	mov    0xc010900c,%ecx
c01061b8:	8b 55 fc             	mov    -0x4(%ebp),%edx
c01061bb:	01 d2                	add    %edx,%edx
c01061bd:	01 ca                	add    %ecx,%edx
c01061bf:	0f b7 00             	movzwl (%eax),%eax
c01061c2:	66 89 02             	mov    %ax,(%edx)
    for (unsigned int i = 0; i < last_line; i++) {
c01061c5:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c01061c9:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01061cc:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c01061cf:	72 d1                	jb     c01061a2 <vga_scrollup+0x16>
    }
    for (unsigned int i = 0; i < WIDTH; i++) {
c01061d1:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c01061d8:	eb 20                	jmp    c01061fa <vga_scrollup+0x6e>
        *(video + i + last_line) = theme_color;
c01061da:	8b 15 0c 90 10 c0    	mov    0xc010900c,%edx
c01061e0:	8b 4d f8             	mov    -0x8(%ebp),%ecx
c01061e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01061e6:	01 c8                	add    %ecx,%eax
c01061e8:	01 c0                	add    %eax,%eax
c01061ea:	01 c2                	add    %eax,%edx
c01061ec:	0f b7 05 00 90 10 c0 	movzwl 0xc0109000,%eax
c01061f3:	66 89 02             	mov    %ax,(%edx)
    for (unsigned int i = 0; i < WIDTH; i++) {
c01061f6:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c01061fa:	83 7d f8 4f          	cmpl   $0x4f,-0x8(%ebp)
c01061fe:	76 da                	jbe    c01061da <vga_scrollup+0x4e>
    }
    YPOS = YPOS == 0 ? 0 : HIGHT - 1;
c0106200:	a1 04 90 10 c0       	mov    0xc0109004,%eax
c0106205:	85 c0                	test   %eax,%eax
c0106207:	75 07                	jne    c0106210 <vga_scrollup+0x84>
c0106209:	b8 00 00 00 00       	mov    $0x0,%eax
c010620e:	eb 05                	jmp    c0106215 <vga_scrollup+0x89>
c0106210:	b8 18 00 00 00       	mov    $0x18,%eax
c0106215:	a3 04 90 10 c0       	mov    %eax,0xc0109004
c010621a:	90                   	nop
c010621b:	c9                   	leave  
c010621c:	c3                   	ret    

c010621d <_kernel_init>:

/* Forward declarations. */
void _kernel_init (unsigned long addr);

void _kernel_init(unsigned long addr)
{
c010621d:	55                   	push   %ebp
c010621e:	89 e5                	mov    %esp,%ebp
c0106220:	53                   	push   %ebx
c0106221:	83 ec 44             	sub    $0x44,%esp
    multiboot_info_t *mbi;
    mbi = (multiboot_info_t *) addr;
c0106224:	8b 45 08             	mov    0x8(%ebp),%eax
c0106227:	89 45 e8             	mov    %eax,-0x18(%ebp)
    multiboot_memory_map_t* map = (multiboot_memory_map_t*)mbi->mmap_addr;
c010622a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010622d:	8b 40 30             	mov    0x30(%eax),%eax
c0106230:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    _init_idt();
c0106233:	e8 3c 18 00 00       	call   c0107a74 <_init_idt>
    pmm_init(MEM_1MB + (mbi->mem_upper << 10));
c0106238:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010623b:	8b 40 08             	mov    0x8(%eax),%eax
c010623e:	c1 e0 0a             	shl    $0xa,%eax
c0106241:	05 00 00 10 00       	add    $0x100000,%eax
c0106246:	83 ec 0c             	sub    $0xc,%esp
c0106249:	50                   	push   %eax
c010624a:	e8 2f 04 00 00       	call   c010667e <pmm_init>
c010624f:	83 c4 10             	add    $0x10,%esp
    vmm_init();
c0106252:	e8 7d 0c 00 00       	call   c0106ed4 <vmm_init>

    init_vga_buffer();
c0106257:	e8 a4 fd ff ff       	call   c0106000 <init_vga_buffer>
    vga_set_show(0,VGA_COLOR_BLACK,VGA_COLOR_LIGHT_WHITE);
c010625c:	83 ec 04             	sub    $0x4,%esp
c010625f:	6a 0f                	push   $0xf
c0106261:	6a 00                	push   $0x0
c0106263:	6a 00                	push   $0x0
c0106265:	e8 6a fe ff ff       	call   c01060d4 <vga_set_show>
c010626a:	83 c4 10             	add    $0x10,%esp
    /* Clear the screen. */
    vga_clear();
c010626d:	e8 d0 fe ff ff       	call   c0106142 <vga_clear>
    // }

    /* Set MBI to the address of the Multiboot information structure. */

    /* Print out the flags. */
    kprintf("flags = 0x%x\n", (unsigned) mbi->flags);
c0106272:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0106275:	8b 00                	mov    (%eax),%eax
c0106277:	83 ec 08             	sub    $0x8,%esp
c010627a:	50                   	push   %eax
c010627b:	68 00 b0 12 c0       	push   $0xc012b000
c0106280:	e8 73 1f 00 00       	call   c01081f8 <kprintf>
c0106285:	83 c4 10             	add    $0x10,%esp

    /* Are mem_* valid? */
    if (CHECK_FLAG(mbi->flags, 0))
c0106288:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010628b:	8b 00                	mov    (%eax),%eax
c010628d:	83 e0 01             	and    $0x1,%eax
c0106290:	85 c0                	test   %eax,%eax
c0106292:	74 1e                	je     c01062b2 <_kernel_init+0x95>
        kprintf("mem_lower = %uKB, mem_upper = %uKB\n",(unsigned) mbi->mem_lower, (unsigned) mbi->mem_upper);
c0106294:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0106297:	8b 50 08             	mov    0x8(%eax),%edx
c010629a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010629d:	8b 40 04             	mov    0x4(%eax),%eax
c01062a0:	83 ec 04             	sub    $0x4,%esp
c01062a3:	52                   	push   %edx
c01062a4:	50                   	push   %eax
c01062a5:	68 10 b0 12 c0       	push   $0xc012b010
c01062aa:	e8 49 1f 00 00       	call   c01081f8 <kprintf>
c01062af:	83 c4 10             	add    $0x10,%esp
    
    unsigned int map_size = mbi->mmap_length / sizeof(multiboot_memory_map_t);
c01062b2:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01062b5:	8b 40 2c             	mov    0x2c(%eax),%eax
c01062b8:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
c01062bd:	f7 e2                	mul    %edx
c01062bf:	89 d0                	mov    %edx,%eax
c01062c1:	c1 e8 04             	shr    $0x4,%eax
c01062c4:	89 45 e0             	mov    %eax,-0x20(%ebp)
    for (unsigned int i = 0; i < map_size; i++) {
c01062c7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c01062ce:	e9 1e 01 00 00       	jmp    c01063f1 <_kernel_init+0x1d4>
        multiboot_memory_map_t mmap = map[i];
c01062d3:	8b 55 f4             	mov    -0xc(%ebp),%edx
c01062d6:	89 d0                	mov    %edx,%eax
c01062d8:	01 c0                	add    %eax,%eax
c01062da:	01 d0                	add    %edx,%eax
c01062dc:	c1 e0 03             	shl    $0x3,%eax
c01062df:	89 c2                	mov    %eax,%edx
c01062e1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01062e4:	01 d0                	add    %edx,%eax
c01062e6:	8b 10                	mov    (%eax),%edx
c01062e8:	89 55 bc             	mov    %edx,-0x44(%ebp)
c01062eb:	8b 50 04             	mov    0x4(%eax),%edx
c01062ee:	89 55 c0             	mov    %edx,-0x40(%ebp)
c01062f1:	8b 50 08             	mov    0x8(%eax),%edx
c01062f4:	89 55 c4             	mov    %edx,-0x3c(%ebp)
c01062f7:	8b 50 0c             	mov    0xc(%eax),%edx
c01062fa:	89 55 c8             	mov    %edx,-0x38(%ebp)
c01062fd:	8b 50 10             	mov    0x10(%eax),%edx
c0106300:	89 55 cc             	mov    %edx,-0x34(%ebp)
c0106303:	8b 40 14             	mov    0x14(%eax),%eax
c0106306:	89 45 d0             	mov    %eax,-0x30(%ebp)
        kprintf("[MM] Base: 0x%x, len: %u KiB, type: %u\n",
               map[i].addr_low,
               map[i].len_low >> 10,
               map[i].type);
c0106309:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010630c:	89 d0                	mov    %edx,%eax
c010630e:	01 c0                	add    %eax,%eax
c0106310:	01 d0                	add    %edx,%eax
c0106312:	c1 e0 03             	shl    $0x3,%eax
c0106315:	89 c2                	mov    %eax,%edx
c0106317:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010631a:	01 d0                	add    %edx,%eax
        kprintf("[MM] Base: 0x%x, len: %u KiB, type: %u\n",
c010631c:	8b 50 14             	mov    0x14(%eax),%edx
               map[i].len_low >> 10,
c010631f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c0106322:	89 c8                	mov    %ecx,%eax
c0106324:	01 c0                	add    %eax,%eax
c0106326:	01 c8                	add    %ecx,%eax
c0106328:	c1 e0 03             	shl    $0x3,%eax
c010632b:	89 c1                	mov    %eax,%ecx
c010632d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0106330:	01 c8                	add    %ecx,%eax
c0106332:	8b 40 0c             	mov    0xc(%eax),%eax
        kprintf("[MM] Base: 0x%x, len: %u KiB, type: %u\n",
c0106335:	c1 e8 0a             	shr    $0xa,%eax
c0106338:	89 c3                	mov    %eax,%ebx
               map[i].addr_low,
c010633a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c010633d:	89 c8                	mov    %ecx,%eax
c010633f:	01 c0                	add    %eax,%eax
c0106341:	01 c8                	add    %ecx,%eax
c0106343:	c1 e0 03             	shl    $0x3,%eax
c0106346:	89 c1                	mov    %eax,%ecx
c0106348:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010634b:	01 c8                	add    %ecx,%eax
        kprintf("[MM] Base: 0x%x, len: %u KiB, type: %u\n",
c010634d:	8b 40 04             	mov    0x4(%eax),%eax
c0106350:	52                   	push   %edx
c0106351:	53                   	push   %ebx
c0106352:	50                   	push   %eax
c0106353:	68 34 b0 12 c0       	push   $0xc012b034
c0106358:	e8 9b 1e 00 00       	call   c01081f8 <kprintf>
c010635d:	83 c4 10             	add    $0x10,%esp
        if (mmap.type == MULTIBOOT_MEMORY_AVAILABLE) {
c0106360:	8b 45 d0             	mov    -0x30(%ebp),%eax
c0106363:	83 f8 01             	cmp    $0x1,%eax
c0106366:	0f 85 81 00 00 00    	jne    c01063ed <_kernel_init+0x1d0>
            // 整数向上取整除法
            uintptr_t pg = map[i].addr_low + 0x0fffU;
c010636c:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010636f:	89 d0                	mov    %edx,%eax
c0106371:	01 c0                	add    %eax,%eax
c0106373:	01 d0                	add    %edx,%eax
c0106375:	c1 e0 03             	shl    $0x3,%eax
c0106378:	89 c2                	mov    %eax,%edx
c010637a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010637d:	01 d0                	add    %edx,%eax
c010637f:	8b 40 04             	mov    0x4(%eax),%eax
c0106382:	05 ff 0f 00 00       	add    $0xfff,%eax
c0106387:	89 45 d4             	mov    %eax,-0x2c(%ebp)
            pmm_mark_chunk_free(pg >> 12, map[i].len_low >> 12);
c010638a:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010638d:	89 d0                	mov    %edx,%eax
c010638f:	01 c0                	add    %eax,%eax
c0106391:	01 d0                	add    %edx,%eax
c0106393:	c1 e0 03             	shl    $0x3,%eax
c0106396:	89 c2                	mov    %eax,%edx
c0106398:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010639b:	01 d0                	add    %edx,%eax
c010639d:	8b 40 0c             	mov    0xc(%eax),%eax
c01063a0:	c1 e8 0c             	shr    $0xc,%eax
c01063a3:	89 c2                	mov    %eax,%edx
c01063a5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c01063a8:	c1 e8 0c             	shr    $0xc,%eax
c01063ab:	83 ec 08             	sub    $0x8,%esp
c01063ae:	52                   	push   %edx
c01063af:	50                   	push   %eax
c01063b0:	e8 79 03 00 00       	call   c010672e <pmm_mark_chunk_free>
c01063b5:	83 c4 10             	add    $0x10,%esp
            kprintf("[MM] Freed %u pages start from 0x%x\n",
c01063b8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c01063bb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c01063c0:	89 c1                	mov    %eax,%ecx
                   map[i].len_low >> 12,
c01063c2:	8b 55 f4             	mov    -0xc(%ebp),%edx
c01063c5:	89 d0                	mov    %edx,%eax
c01063c7:	01 c0                	add    %eax,%eax
c01063c9:	01 d0                	add    %edx,%eax
c01063cb:	c1 e0 03             	shl    $0x3,%eax
c01063ce:	89 c2                	mov    %eax,%edx
c01063d0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01063d3:	01 d0                	add    %edx,%eax
c01063d5:	8b 40 0c             	mov    0xc(%eax),%eax
            kprintf("[MM] Freed %u pages start from 0x%x\n",
c01063d8:	c1 e8 0c             	shr    $0xc,%eax
c01063db:	83 ec 04             	sub    $0x4,%esp
c01063de:	51                   	push   %ecx
c01063df:	50                   	push   %eax
c01063e0:	68 5c b0 12 c0       	push   $0xc012b05c
c01063e5:	e8 0e 1e 00 00       	call   c01081f8 <kprintf>
c01063ea:	83 c4 10             	add    $0x10,%esp
    for (unsigned int i = 0; i < map_size; i++) {
c01063ed:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c01063f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01063f4:	3b 45 e0             	cmp    -0x20(%ebp),%eax
c01063f7:	0f 82 d6 fe ff ff    	jb     c01062d3 <_kernel_init+0xb6>
                   pg & ~0x0fffU);
        }
    }

    // 将内核占据的页设为已占用
    size_t pg_count = (uintptr_t)(&virkernel_end  - &virkernel_start) >> 12;
c01063fd:	b8 00 20 13 c0       	mov    $0xc0132000,%eax
c0106402:	2d 00 60 10 c0       	sub    $0xc0106000,%eax
c0106407:	c1 e8 0c             	shr    $0xc,%eax
c010640a:	89 45 dc             	mov    %eax,-0x24(%ebp)
    pmm_mark_chunk_occupied(V2P(&virkernel_start) >> 12, pg_count);
c010640d:	b8 00 60 10 c0       	mov    $0xc0106000,%eax
c0106412:	05 00 00 00 40       	add    $0x40000000,%eax
c0106417:	c1 e8 0c             	shr    $0xc,%eax
c010641a:	83 ec 08             	sub    $0x8,%esp
c010641d:	ff 75 dc             	push   -0x24(%ebp)
c0106420:	50                   	push   %eax
c0106421:	e8 6c 03 00 00       	call   c0106792 <pmm_mark_chunk_occupied>
c0106426:	83 c4 10             	add    $0x10,%esp
    kprintf("[MM] Allocated %d pages for kernel.\n", pg_count);
c0106429:	83 ec 08             	sub    $0x8,%esp
c010642c:	ff 75 dc             	push   -0x24(%ebp)
c010642f:	68 84 b0 12 c0       	push   $0xc012b084
c0106434:	e8 bf 1d 00 00       	call   c01081f8 <kprintf>
c0106439:	83 c4 10             	add    $0x10,%esp

    size_t vga_buf_pgs = VGA_BUFFER_SIZE >> 12;
c010643c:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
    
    // 首先，标记VGA部分为已占用
    pmm_mark_chunk_occupied(VIDEO >> 12, vga_buf_pgs);
c0106443:	83 ec 08             	sub    $0x8,%esp
c0106446:	ff 75 d8             	push   -0x28(%ebp)
c0106449:	68 b8 00 00 00       	push   $0xb8
c010644e:	e8 3f 03 00 00       	call   c0106792 <pmm_mark_chunk_occupied>
c0106453:	83 c4 10             	add    $0x10,%esp
    
    // 重映射VGA文本缓冲区（以后会变成显存，i.e., framebuffer）
    for (size_t i = 0; i < vga_buf_pgs; i++)
c0106456:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c010645d:	eb 2a                	jmp    c0106489 <_kernel_init+0x26c>
    {
        vmm_map_page(VGA_BUFFER_VADDR + (i << 12), VIDEO + (i << 12), PG_PREM_RW, PG_PREM_RW);
c010645f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106462:	c1 e0 0c             	shl    $0xc,%eax
c0106465:	05 00 80 0b 00       	add    $0xb8000,%eax
c010646a:	89 c2                	mov    %eax,%edx
c010646c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010646f:	c1 e0 0c             	shl    $0xc,%eax
c0106472:	2d 00 00 00 50       	sub    $0x50000000,%eax
c0106477:	6a 03                	push   $0x3
c0106479:	6a 03                	push   $0x3
c010647b:	52                   	push   %edx
c010647c:	50                   	push   %eax
c010647d:	e8 db 0a 00 00       	call   c0106f5d <vmm_map_page>
c0106482:	83 c4 10             	add    $0x10,%esp
    for (size_t i = 0; i < vga_buf_pgs; i++)
c0106485:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0106489:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010648c:	3b 45 d8             	cmp    -0x28(%ebp),%eax
c010648f:	72 ce                	jb     c010645f <_kernel_init+0x242>
    }
    set_vga_buffer(VGA_BUFFER_VADDR);
c0106491:	83 ec 0c             	sub    $0xc,%esp
c0106494:	68 00 00 00 b0       	push   $0xb0000000
c0106499:	e8 72 fb ff ff       	call   c0106010 <set_vga_buffer>
c010649e:	83 c4 10             	add    $0x10,%esp
    kprintf("[MM] Mapped VGA to %x.\n", VGA_BUFFER_VADDR);
c01064a1:	83 ec 08             	sub    $0x8,%esp
c01064a4:	68 00 00 00 b0       	push   $0xb0000000
c01064a9:	68 a9 b0 12 c0       	push   $0xc012b0a9
c01064ae:	e8 45 1d 00 00       	call   c01081f8 <kprintf>
c01064b3:	83 c4 10             	add    $0x10,%esp

    // 为内核创建一个专属栈空间。
    for (size_t i = 0; i < (K_STACK_SIZE >> 12); i++) {
c01064b6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c01064bd:	eb 1f                	jmp    c01064de <_kernel_init+0x2c1>
        vmm_alloc_page(K_STACK_START + (i << 12), PG_PREM_RW, PG_PREM_RW);
c01064bf:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01064c2:	c1 e0 0c             	shl    $0xc,%eax
c01064c5:	2d 00 00 50 00       	sub    $0x500000,%eax
c01064ca:	83 ec 04             	sub    $0x4,%esp
c01064cd:	6a 03                	push   $0x3
c01064cf:	6a 03                	push   $0x3
c01064d1:	50                   	push   %eax
c01064d2:	e8 4c 0c 00 00       	call   c0107123 <vmm_alloc_page>
c01064d7:	83 c4 10             	add    $0x10,%esp
    for (size_t i = 0; i < (K_STACK_SIZE >> 12); i++) {
c01064da:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c01064de:	81 7d ec ff 00 00 00 	cmpl   $0xff,-0x14(%ebp)
c01064e5:	76 d8                	jbe    c01064bf <_kernel_init+0x2a2>
    }
    kprintf("[MM] Allocated %d pages for stack start at %p\n", K_STACK_SIZE>>12, K_STACK_START);
c01064e7:	83 ec 04             	sub    $0x4,%esp
c01064ea:	68 00 00 b0 ff       	push   $0xffb00000
c01064ef:	68 00 01 00 00       	push   $0x100
c01064f4:	68 c4 b0 12 c0       	push   $0xc012b0c4
c01064f9:	e8 fa 1c 00 00       	call   c01081f8 <kprintf>
c01064fe:	83 c4 10             	add    $0x10,%esp

    //give malloc init
    mem_init();
c0106501:	e8 45 07 00 00       	call   c0106c4b <mem_init>
    kprintf("[MM] Malloc Init Success \n");
c0106506:	83 ec 0c             	sub    $0xc,%esp
c0106509:	68 f3 b0 12 c0       	push   $0xc012b0f3
c010650e:	e8 e5 1c 00 00       	call   c01081f8 <kprintf>
c0106513:	83 c4 10             	add    $0x10,%esp
    kprintf("[KERNEL] === Initialization Done === \n\n");
c0106516:	83 ec 0c             	sub    $0xc,%esp
c0106519:	68 10 b1 12 c0       	push   $0xc012b110
c010651e:	e8 d5 1c 00 00       	call   c01081f8 <kprintf>
c0106523:	83 c4 10             	add    $0x10,%esp

    vga_put_str("MELOX OS\n");
c0106526:	83 ec 0c             	sub    $0xc,%esp
c0106529:	68 38 b1 12 c0       	push   $0xc012b138
c010652e:	e8 e0 fb ff ff       	call   c0106113 <vga_put_str>
c0106533:	83 c4 10             	add    $0x10,%esp
     //__asm__("int $1");
}
c0106536:	90                   	nop
c0106537:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010653a:	c9                   	leave  
c010653b:	c3                   	ret    

c010653c <_kernel_finnal_init>:

void _kernel_finnal_init() {
c010653c:	55                   	push   %ebp
c010653d:	89 e5                	mov    %esp,%ebp
c010653f:	83 ec 18             	sub    $0x18,%esp
    //kprintf("[KERNEL] === Post Initialization === \n");
    size_t virk_init_pg_count = ((uintptr_t)(&__init_phykernel_end)) >> 12;
c0106542:	b8 00 60 10 00       	mov    $0x106000,%eax
c0106547:	c1 e8 0c             	shr    $0xc,%eax
c010654a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    kprintf("[MM] Releaseing %d pages from 0x0.\n", virk_init_pg_count);
c010654d:	83 ec 08             	sub    $0x8,%esp
c0106550:	ff 75 f0             	push   -0x10(%ebp)
c0106553:	68 44 b1 12 c0       	push   $0xc012b144
c0106558:	e8 9b 1c 00 00       	call   c01081f8 <kprintf>
c010655d:	83 c4 10             	add    $0x10,%esp
    
    // // 清除 hhk_init 与前1MiB的映射
    for (size_t i = 0; i < virk_init_pg_count; i++) {
c0106560:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0106567:	eb 16                	jmp    c010657f <_kernel_finnal_init+0x43>

        vmm_unmap_page((i << 12));
c0106569:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010656c:	c1 e0 0c             	shl    $0xc,%eax
c010656f:	83 ec 0c             	sub    $0xc,%esp
c0106572:	50                   	push   %eax
c0106573:	e8 e9 0b 00 00       	call   c0107161 <vmm_unmap_page>
c0106578:	83 c4 10             	add    $0x10,%esp
    for (size_t i = 0; i < virk_init_pg_count; i++) {
c010657b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010657f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106582:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0106585:	72 e2                	jb     c0106569 <_kernel_finnal_init+0x2d>
    // }
    // for (size_t i = 256; i < virk_init_pg_count; i++) {

    //     vmm_unmap_page((i << 12));
    // }
    kprintf("[KERNEL] === Post Initialization Done === \n\n");
c0106587:	83 ec 0c             	sub    $0xc,%esp
c010658a:	68 68 b1 12 c0       	push   $0xc012b168
c010658f:	e8 64 1c 00 00       	call   c01081f8 <kprintf>
c0106594:	83 c4 10             	add    $0x10,%esp
}
c0106597:	90                   	nop
c0106598:	c9                   	leave  
c0106599:	c3                   	ret    

c010659a <_kernel_main>:

void _kernel_main()
{
c010659a:	55                   	push   %ebp
c010659b:	89 e5                	mov    %esp,%ebp
c010659d:	81 ec 18 01 00 00    	sub    $0x118,%esp
    char* buf[64];
    
    kprintf("We are now running in virtual address space!\n\n");
c01065a3:	83 ec 0c             	sub    $0xc,%esp
c01065a6:	68 98 b1 12 c0       	push   $0xc012b198
c01065ab:	e8 48 1c 00 00       	call   c01081f8 <kprintf>
c01065b0:	83 c4 10             	add    $0x10,%esp
    
    cpu_get_brand(buf);
c01065b3:	83 ec 0c             	sub    $0xc,%esp
c01065b6:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
c01065bc:	50                   	push   %eax
c01065bd:	e8 b1 11 00 00       	call   c0107773 <cpu_get_brand>
c01065c2:	83 c4 10             	add    $0x10,%esp
    kprintf("CPU: %s\n\n", buf);
c01065c5:	83 ec 08             	sub    $0x8,%esp
c01065c8:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
c01065ce:	50                   	push   %eax
c01065cf:	68 c7 b1 12 c0       	push   $0xc012b1c7
c01065d4:	e8 1f 1c 00 00       	call   c01081f8 <kprintf>
c01065d9:	83 c4 10             	add    $0x10,%esp

    uintptr_t k_start = vmm_v2p(&virkernel_start);
c01065dc:	83 ec 0c             	sub    $0xc,%esp
c01065df:	68 00 60 10 c0       	push   $0xc0106000
c01065e4:	e8 13 0c 00 00       	call   c01071fc <vmm_v2p>
c01065e9:	83 c4 10             	add    $0x10,%esp
c01065ec:	89 45 f4             	mov    %eax,-0xc(%ebp)
    kprintf("The kernel's base address mapping: %x->%x\n", &virkernel_start, k_start);
c01065ef:	83 ec 04             	sub    $0x4,%esp
c01065f2:	ff 75 f4             	push   -0xc(%ebp)
c01065f5:	68 00 60 10 c0       	push   $0xc0106000
c01065fa:	68 d4 b1 12 c0       	push   $0xc012b1d4
c01065ff:	e8 f4 1b 00 00       	call   c01081f8 <kprintf>
c0106604:	83 c4 10             	add    $0x10,%esp
    //__asm__("int $0");
    // test malloc & free

    uint8_t* big_ = k_malloc(1000);
c0106607:	83 ec 0c             	sub    $0xc,%esp
c010660a:	68 e8 03 00 00       	push   $0x3e8
c010660f:	e8 1e 08 00 00       	call   c0106e32 <k_malloc>
c0106614:	83 c4 10             	add    $0x10,%esp
c0106617:	89 45 f0             	mov    %eax,-0x10(%ebp)
    big_[0] = 123;
c010661a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010661d:	c6 00 7b             	movb   $0x7b,(%eax)
    big_[1] = 23;
c0106620:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106623:	83 c0 01             	add    $0x1,%eax
c0106626:	c6 00 17             	movb   $0x17,(%eax)
    big_[2] = 3;
c0106629:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010662c:	83 c0 02             	add    $0x2,%eax
c010662f:	c6 00 03             	movb   $0x3,(%eax)

    kprintf("malloc %d, %d, %d\n", big_[0], big_[1], big_[2]);
c0106632:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106635:	83 c0 02             	add    $0x2,%eax
c0106638:	0f b6 00             	movzbl (%eax),%eax
c010663b:	0f b6 c8             	movzbl %al,%ecx
c010663e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106641:	83 c0 01             	add    $0x1,%eax
c0106644:	0f b6 00             	movzbl (%eax),%eax
c0106647:	0f b6 d0             	movzbl %al,%edx
c010664a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010664d:	0f b6 00             	movzbl (%eax),%eax
c0106650:	0f b6 c0             	movzbl %al,%eax
c0106653:	51                   	push   %ecx
c0106654:	52                   	push   %edx
c0106655:	50                   	push   %eax
c0106656:	68 ff b1 12 c0       	push   $0xc012b1ff
c010665b:	e8 98 1b 00 00       	call   c01081f8 <kprintf>
c0106660:	83 c4 10             	add    $0x10,%esp
    malloc_free(big_);
c0106663:	83 ec 0c             	sub    $0xc,%esp
c0106666:	ff 75 f0             	push   -0x10(%ebp)
c0106669:	e8 7f 07 00 00       	call   c0106ded <malloc_free>
c010666e:	83 c4 10             	add    $0x10,%esp

    timer_init();
c0106671:	e8 ae 0c 00 00       	call   c0107324 <timer_init>
    init_keyboard();
c0106676:	e8 92 18 00 00       	call   c0107f0d <init_keyboard>
c010667b:	90                   	nop
c010667c:	c9                   	leave  
c010667d:	c3                   	ret    

c010667e <pmm_init>:
#include <kernel/memory/page.h>
size_t pg_lookup_ptr;
uint8_t pm_bitmap[PM_BMP_MAX_SIZE];
uintptr_t max_pg;
void pmm_init(uintptr_t mem_upper_lim)
{
c010667e:	55                   	push   %ebp
c010667f:	89 e5                	mov    %esp,%ebp
c0106681:	83 ec 10             	sub    $0x10,%esp
    pg_lookup_ptr = LOOKUP_START;
c0106684:	c7 05 20 90 10 c0 01 	movl   $0x1,0xc0109020
c010668b:	00 00 00 
    max_pg = (PG_ALIGN(mem_upper_lim) >> 12);
c010668e:	8b 45 08             	mov    0x8(%ebp),%eax
c0106691:	c1 e8 0c             	shr    $0xc,%eax
c0106694:	a3 40 90 12 c0       	mov    %eax,0xc0129040

    for(int i = 0; i < PM_BMP_MAX_SIZE; i++)
c0106699:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c01066a0:	eb 0f                	jmp    c01066b1 <pmm_init+0x33>
    {
        pm_bitmap[i] = 0xffU;
c01066a2:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01066a5:	05 40 90 10 c0       	add    $0xc0109040,%eax
c01066aa:	c6 00 ff             	movb   $0xff,(%eax)
    for(int i = 0; i < PM_BMP_MAX_SIZE; i++)
c01066ad:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c01066b1:	81 7d fc ff ff 01 00 	cmpl   $0x1ffff,-0x4(%ebp)
c01066b8:	7e e8                	jle    c01066a2 <pmm_init+0x24>
    }
}
c01066ba:	90                   	nop
c01066bb:	90                   	nop
c01066bc:	c9                   	leave  
c01066bd:	c3                   	ret    

c01066be <pmm_mark_page_free>:

void pmm_mark_page_free(uintptr_t ppn)
{
c01066be:	55                   	push   %ebp
c01066bf:	89 e5                	mov    %esp,%ebp
c01066c1:	53                   	push   %ebx
    pm_bitmap[ppn / 8] = pm_bitmap[ppn / 8] & (0xff7fU >> (ppn % 8));
c01066c2:	8b 45 08             	mov    0x8(%ebp),%eax
c01066c5:	c1 e8 03             	shr    $0x3,%eax
c01066c8:	0f b6 90 40 90 10 c0 	movzbl -0x3fef6fc0(%eax),%edx
c01066cf:	8b 45 08             	mov    0x8(%ebp),%eax
c01066d2:	83 e0 07             	and    $0x7,%eax
c01066d5:	bb 7f ff 00 00       	mov    $0xff7f,%ebx
c01066da:	89 c1                	mov    %eax,%ecx
c01066dc:	d3 eb                	shr    %cl,%ebx
c01066de:	89 d8                	mov    %ebx,%eax
c01066e0:	89 c1                	mov    %eax,%ecx
c01066e2:	8b 45 08             	mov    0x8(%ebp),%eax
c01066e5:	c1 e8 03             	shr    $0x3,%eax
c01066e8:	21 ca                	and    %ecx,%edx
c01066ea:	88 90 40 90 10 c0    	mov    %dl,-0x3fef6fc0(%eax)
}
c01066f0:	90                   	nop
c01066f1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c01066f4:	c9                   	leave  
c01066f5:	c3                   	ret    

c01066f6 <pmm_mark_page_occupied>:

void pmm_mark_page_occupied(uintptr_t ppn)
{
c01066f6:	55                   	push   %ebp
c01066f7:	89 e5                	mov    %esp,%ebp
c01066f9:	53                   	push   %ebx
    pm_bitmap[ppn / 8] = pm_bitmap[ppn / 8] | (0x80U >> (ppn % 8));
c01066fa:	8b 45 08             	mov    0x8(%ebp),%eax
c01066fd:	c1 e8 03             	shr    $0x3,%eax
c0106700:	0f b6 90 40 90 10 c0 	movzbl -0x3fef6fc0(%eax),%edx
c0106707:	8b 45 08             	mov    0x8(%ebp),%eax
c010670a:	83 e0 07             	and    $0x7,%eax
c010670d:	bb 80 00 00 00       	mov    $0x80,%ebx
c0106712:	89 c1                	mov    %eax,%ecx
c0106714:	d3 eb                	shr    %cl,%ebx
c0106716:	89 d8                	mov    %ebx,%eax
c0106718:	89 c1                	mov    %eax,%ecx
c010671a:	8b 45 08             	mov    0x8(%ebp),%eax
c010671d:	c1 e8 03             	shr    $0x3,%eax
c0106720:	09 ca                	or     %ecx,%edx
c0106722:	88 90 40 90 10 c0    	mov    %dl,-0x3fef6fc0(%eax)
}
c0106728:	90                   	nop
c0106729:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010672c:	c9                   	leave  
c010672d:	c3                   	ret    

c010672e <pmm_mark_chunk_free>:

void pmm_mark_chunk_free(uintptr_t start_ppn, size_t page_count)
{
c010672e:	55                   	push   %ebp
c010672f:	89 e5                	mov    %esp,%ebp
c0106731:	53                   	push   %ebx
c0106732:	83 ec 10             	sub    $0x10,%esp
    for(int i = start_ppn; i < page_count; i++)
c0106735:	8b 45 08             	mov    0x8(%ebp),%eax
c0106738:	89 45 f8             	mov    %eax,-0x8(%ebp)
c010673b:	eb 46                	jmp    c0106783 <pmm_mark_chunk_free+0x55>
        pm_bitmap[i / 8] = pm_bitmap[i / 8] & (0xff7fU >> (i % 8));
c010673d:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0106740:	8d 50 07             	lea    0x7(%eax),%edx
c0106743:	85 c0                	test   %eax,%eax
c0106745:	0f 48 c2             	cmovs  %edx,%eax
c0106748:	c1 f8 03             	sar    $0x3,%eax
c010674b:	0f b6 98 40 90 10 c0 	movzbl -0x3fef6fc0(%eax),%ebx
c0106752:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0106755:	83 e0 07             	and    $0x7,%eax
c0106758:	ba 7f ff 00 00       	mov    $0xff7f,%edx
c010675d:	89 c1                	mov    %eax,%ecx
c010675f:	d3 ea                	shr    %cl,%edx
c0106761:	89 d0                	mov    %edx,%eax
c0106763:	89 c1                	mov    %eax,%ecx
c0106765:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0106768:	8d 50 07             	lea    0x7(%eax),%edx
c010676b:	85 c0                	test   %eax,%eax
c010676d:	0f 48 c2             	cmovs  %edx,%eax
c0106770:	c1 f8 03             	sar    $0x3,%eax
c0106773:	89 c2                	mov    %eax,%edx
c0106775:	89 d8                	mov    %ebx,%eax
c0106777:	21 c8                	and    %ecx,%eax
c0106779:	88 82 40 90 10 c0    	mov    %al,-0x3fef6fc0(%edx)
    for(int i = start_ppn; i < page_count; i++)
c010677f:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c0106783:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0106786:	39 45 0c             	cmp    %eax,0xc(%ebp)
c0106789:	77 b2                	ja     c010673d <pmm_mark_chunk_free+0xf>
}
c010678b:	90                   	nop
c010678c:	90                   	nop
c010678d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0106790:	c9                   	leave  
c0106791:	c3                   	ret    

c0106792 <pmm_mark_chunk_occupied>:

void pmm_mark_chunk_occupied(uintptr_t start_ppn, size_t page_count)
{
c0106792:	55                   	push   %ebp
c0106793:	89 e5                	mov    %esp,%ebp
c0106795:	53                   	push   %ebx
c0106796:	83 ec 10             	sub    $0x10,%esp
    for(int i = start_ppn; i < page_count; i++)
c0106799:	8b 45 08             	mov    0x8(%ebp),%eax
c010679c:	89 45 f8             	mov    %eax,-0x8(%ebp)
c010679f:	eb 46                	jmp    c01067e7 <pmm_mark_chunk_occupied+0x55>
        pm_bitmap[i / 8] = pm_bitmap[i / 8] | (0x80U >> (i % 8));
c01067a1:	8b 45 f8             	mov    -0x8(%ebp),%eax
c01067a4:	8d 50 07             	lea    0x7(%eax),%edx
c01067a7:	85 c0                	test   %eax,%eax
c01067a9:	0f 48 c2             	cmovs  %edx,%eax
c01067ac:	c1 f8 03             	sar    $0x3,%eax
c01067af:	0f b6 98 40 90 10 c0 	movzbl -0x3fef6fc0(%eax),%ebx
c01067b6:	8b 45 f8             	mov    -0x8(%ebp),%eax
c01067b9:	83 e0 07             	and    $0x7,%eax
c01067bc:	ba 80 00 00 00       	mov    $0x80,%edx
c01067c1:	89 c1                	mov    %eax,%ecx
c01067c3:	d3 ea                	shr    %cl,%edx
c01067c5:	89 d0                	mov    %edx,%eax
c01067c7:	89 c1                	mov    %eax,%ecx
c01067c9:	8b 45 f8             	mov    -0x8(%ebp),%eax
c01067cc:	8d 50 07             	lea    0x7(%eax),%edx
c01067cf:	85 c0                	test   %eax,%eax
c01067d1:	0f 48 c2             	cmovs  %edx,%eax
c01067d4:	c1 f8 03             	sar    $0x3,%eax
c01067d7:	89 c2                	mov    %eax,%edx
c01067d9:	89 d8                	mov    %ebx,%eax
c01067db:	09 c8                	or     %ecx,%eax
c01067dd:	88 82 40 90 10 c0    	mov    %al,-0x3fef6fc0(%edx)
    for(int i = start_ppn; i < page_count; i++)
c01067e3:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c01067e7:	8b 45 f8             	mov    -0x8(%ebp),%eax
c01067ea:	39 45 0c             	cmp    %eax,0xc(%ebp)
c01067ed:	77 b2                	ja     c01067a1 <pmm_mark_chunk_occupied+0xf>
}
c01067ef:	90                   	nop
c01067f0:	90                   	nop
c01067f1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c01067f4:	c9                   	leave  
c01067f5:	c3                   	ret    

c01067f6 <pmm_alloc_page>:

void* pmm_alloc_page()
{
c01067f6:	55                   	push   %ebp
c01067f7:	89 e5                	mov    %esp,%ebp
c01067f9:	53                   	push   %ebx
c01067fa:	83 ec 20             	sub    $0x20,%esp
    // Next fit approach. Maximize the throughput!
    uintptr_t good_page_found = NULL;
c01067fd:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    size_t old_pg_ptr = pg_lookup_ptr;
c0106804:	a1 20 90 10 c0       	mov    0xc0109020,%eax
c0106809:	89 45 f4             	mov    %eax,-0xc(%ebp)
    size_t upper_lim = max_pg;
c010680c:	a1 40 90 12 c0       	mov    0xc0129040,%eax
c0106811:	89 45 f0             	mov    %eax,-0x10(%ebp)
    uint8_t chunk = 0;
c0106814:	c6 45 eb 00          	movb   $0x0,-0x15(%ebp)
    while (!good_page_found && pg_lookup_ptr < upper_lim) {
c0106818:	e9 a5 00 00 00       	jmp    c01068c2 <pmm_alloc_page+0xcc>
        chunk = pm_bitmap[pg_lookup_ptr >> 3];
c010681d:	a1 20 90 10 c0       	mov    0xc0109020,%eax
c0106822:	c1 e8 03             	shr    $0x3,%eax
c0106825:	0f b6 80 40 90 10 c0 	movzbl -0x3fef6fc0(%eax),%eax
c010682c:	88 45 eb             	mov    %al,-0x15(%ebp)

        // skip the fully occupied chunk, reduce # of iterations
        if (chunk != 0xFFU) {
c010682f:	80 7d eb ff          	cmpb   $0xff,-0x15(%ebp)
c0106833:	74 59                	je     c010688e <pmm_alloc_page+0x98>
            for (size_t i = pg_lookup_ptr % 8; i < 8; i++, pg_lookup_ptr++) {
c0106835:	a1 20 90 10 c0       	mov    0xc0109020,%eax
c010683a:	83 e0 07             	and    $0x7,%eax
c010683d:	89 45 ec             	mov    %eax,-0x14(%ebp)
c0106840:	eb 44                	jmp    c0106886 <pmm_alloc_page+0x90>
                if (!(chunk & (0x80U >> i))) {
c0106842:	0f b6 55 eb          	movzbl -0x15(%ebp),%edx
c0106846:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0106849:	bb 80 00 00 00       	mov    $0x80,%ebx
c010684e:	89 c1                	mov    %eax,%ecx
c0106850:	d3 eb                	shr    %cl,%ebx
c0106852:	89 d8                	mov    %ebx,%eax
c0106854:	21 d0                	and    %edx,%eax
c0106856:	85 c0                	test   %eax,%eax
c0106858:	75 1b                	jne    c0106875 <pmm_alloc_page+0x7f>
                    pmm_mark_page_occupied(pg_lookup_ptr);
c010685a:	a1 20 90 10 c0       	mov    0xc0109020,%eax
c010685f:	50                   	push   %eax
c0106860:	e8 91 fe ff ff       	call   c01066f6 <pmm_mark_page_occupied>
c0106865:	83 c4 04             	add    $0x4,%esp
                    good_page_found = pg_lookup_ptr << 12;
c0106868:	a1 20 90 10 c0       	mov    0xc0109020,%eax
c010686d:	c1 e0 0c             	shl    $0xc,%eax
c0106870:	89 45 f8             	mov    %eax,-0x8(%ebp)
                    break;
c0106873:	eb 4d                	jmp    c01068c2 <pmm_alloc_page+0xcc>
            for (size_t i = pg_lookup_ptr % 8; i < 8; i++, pg_lookup_ptr++) {
c0106875:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0106879:	a1 20 90 10 c0       	mov    0xc0109020,%eax
c010687e:	83 c0 01             	add    $0x1,%eax
c0106881:	a3 20 90 10 c0       	mov    %eax,0xc0109020
c0106886:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
c010688a:	76 b6                	jbe    c0106842 <pmm_alloc_page+0x4c>
c010688c:	eb 34                	jmp    c01068c2 <pmm_alloc_page+0xcc>
                }
            }
        } else {
            pg_lookup_ptr += 8;
c010688e:	a1 20 90 10 c0       	mov    0xc0109020,%eax
c0106893:	83 c0 08             	add    $0x8,%eax
c0106896:	a3 20 90 10 c0       	mov    %eax,0xc0109020

            // We've searched the interval [old_pg_ptr, max_pg) but failed
            //   may be chances in [1, old_pg_ptr) ?
            // Let's find out!
            if (pg_lookup_ptr >= upper_lim && old_pg_ptr != LOOKUP_START) {
c010689b:	a1 20 90 10 c0       	mov    0xc0109020,%eax
c01068a0:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c01068a3:	77 1d                	ja     c01068c2 <pmm_alloc_page+0xcc>
c01068a5:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c01068a9:	74 17                	je     c01068c2 <pmm_alloc_page+0xcc>
                upper_lim = old_pg_ptr;
c01068ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01068ae:	89 45 f0             	mov    %eax,-0x10(%ebp)
                pg_lookup_ptr = LOOKUP_START;
c01068b1:	c7 05 20 90 10 c0 01 	movl   $0x1,0xc0109020
c01068b8:	00 00 00 
                old_pg_ptr = LOOKUP_START;
c01068bb:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
    while (!good_page_found && pg_lookup_ptr < upper_lim) {
c01068c2:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c01068c6:	75 0e                	jne    c01068d6 <pmm_alloc_page+0xe0>
c01068c8:	a1 20 90 10 c0       	mov    0xc0109020,%eax
c01068cd:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c01068d0:	0f 87 47 ff ff ff    	ja     c010681d <pmm_alloc_page+0x27>
            }
        }
    }
    return (void*)good_page_found;
c01068d6:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
c01068d9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c01068dc:	c9                   	leave  
c01068dd:	c3                   	ret    

c01068de <pmm_free_page>:

int
pmm_free_page(void* page)
{
c01068de:	55                   	push   %ebp
c01068df:	89 e5                	mov    %esp,%ebp
c01068e1:	83 ec 10             	sub    $0x10,%esp
    // TODO: Add kernel reserved memory page check
    uint32_t pg = (uintptr_t)page >> 12;
c01068e4:	8b 45 08             	mov    0x8(%ebp),%eax
c01068e7:	c1 e8 0c             	shr    $0xc,%eax
c01068ea:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if (pg && pg < max_pg)
c01068ed:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c01068f1:	74 1c                	je     c010690f <pmm_free_page+0x31>
c01068f3:	a1 40 90 12 c0       	mov    0xc0129040,%eax
c01068f8:	39 45 fc             	cmp    %eax,-0x4(%ebp)
c01068fb:	73 12                	jae    c010690f <pmm_free_page+0x31>
    {
        pmm_mark_page_free(pg);
c01068fd:	ff 75 fc             	push   -0x4(%ebp)
c0106900:	e8 b9 fd ff ff       	call   c01066be <pmm_mark_page_free>
c0106905:	83 c4 04             	add    $0x4,%esp
        return 1;
c0106908:	b8 01 00 00 00       	mov    $0x1,%eax
c010690d:	eb 05                	jmp    c0106914 <pmm_free_page+0x36>
    }
    return 0;
c010690f:	b8 00 00 00 00       	mov    $0x0,%eax
c0106914:	c9                   	leave  
c0106915:	c3                   	ret    

c0106916 <extend_heap>:
 * @brief extend heap
 * 
 * @param extend size
 */
static void* extend_heap(size_t words)
{
c0106916:	55                   	push   %ebp
c0106917:	89 e5                	mov    %esp,%ebp
c0106919:	83 ec 18             	sub    $0x18,%esp
    char* bp = mem_brk;
c010691c:	a1 4c 90 12 c0       	mov    0xc012904c,%eax
c0106921:	89 45 f4             	mov    %eax,-0xc(%ebp)
    size_t size;
    //align
    size = (words % 2) ? words * WSIZE : (words + 1) * WSIZE;
c0106924:	8b 45 08             	mov    0x8(%ebp),%eax
c0106927:	83 e0 01             	and    $0x1,%eax
c010692a:	85 c0                	test   %eax,%eax
c010692c:	74 08                	je     c0106936 <extend_heap+0x20>
c010692e:	8b 45 08             	mov    0x8(%ebp),%eax
c0106931:	c1 e0 02             	shl    $0x2,%eax
c0106934:	eb 09                	jmp    c010693f <extend_heap+0x29>
c0106936:	8b 45 08             	mov    0x8(%ebp),%eax
c0106939:	83 c0 01             	add    $0x1,%eax
c010693c:	c1 e0 02             	shl    $0x2,%eax
c010693f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    mem_sbrk(size + WSIZE);
c0106942:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106945:	83 c0 04             	add    $0x4,%eax
c0106948:	83 ec 0c             	sub    $0xc,%esp
c010694b:	50                   	push   %eax
c010694c:	e8 60 03 00 00       	call   c0106cb1 <mem_sbrk>
c0106951:	83 c4 10             	add    $0x10,%esp

    //initialize free block header/footer and the epilogue header
    PUT(HDRP(bp), PACK(size, 0)); // free block header
c0106954:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106957:	8d 50 fc             	lea    -0x4(%eax),%edx
c010695a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010695d:	89 02                	mov    %eax,(%edx)
    PUT(FTRP(bp), PACK(size, 0)); // free block foot //TODO CRUSH HERE, ADD ONE PAGE OUT OF RANGE, WE ONLY GIVE ONE PAGE, MEYBE PAGE FAULT
c010695f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106962:	83 e8 04             	sub    $0x4,%eax
c0106965:	8b 00                	mov    (%eax),%eax
c0106967:	83 e0 f8             	and    $0xfffffff8,%eax
c010696a:	8d 50 f8             	lea    -0x8(%eax),%edx
c010696d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106970:	01 c2                	add    %eax,%edx
c0106972:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106975:	89 02                	mov    %eax,(%edx)
    PUT(HDRP(NEXT_BLKP(bp)), PACK(0, 1)); //NEW Epilogue header
c0106977:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010697a:	83 e8 04             	sub    $0x4,%eax
c010697d:	8b 00                	mov    (%eax),%eax
c010697f:	83 e0 f8             	and    $0xfffffff8,%eax
c0106982:	8d 50 fc             	lea    -0x4(%eax),%edx
c0106985:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106988:	01 d0                	add    %edx,%eax
c010698a:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

    //Coalesce if previous block is free
    return coalesce(bp);
c0106990:	83 ec 0c             	sub    $0xc,%esp
c0106993:	ff 75 f4             	push   -0xc(%ebp)
c0106996:	e8 05 00 00 00       	call   c01069a0 <coalesce>
c010699b:	83 c4 10             	add    $0x10,%esp
}
c010699e:	c9                   	leave  
c010699f:	c3                   	ret    

c01069a0 <coalesce>:
 * @brief Coalesce free blk
 * 
 * @param Coalesce bp pointer
 */
static void* coalesce(void* bp)
{
c01069a0:	55                   	push   %ebp
c01069a1:	89 e5                	mov    %esp,%ebp
c01069a3:	83 ec 10             	sub    $0x10,%esp
    size_t prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));
c01069a6:	8b 45 08             	mov    0x8(%ebp),%eax
c01069a9:	83 e8 04             	sub    $0x4,%eax
c01069ac:	8b 00                	mov    (%eax),%eax
c01069ae:	83 e0 f8             	and    $0xfffffff8,%eax
c01069b1:	8d 50 f8             	lea    -0x8(%eax),%edx
c01069b4:	8b 45 08             	mov    0x8(%ebp),%eax
c01069b7:	01 d0                	add    %edx,%eax
c01069b9:	8b 00                	mov    (%eax),%eax
c01069bb:	83 e0 01             	and    $0x1,%eax
c01069be:	89 45 fc             	mov    %eax,-0x4(%ebp)
    size_t next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));
c01069c1:	8b 45 08             	mov    0x8(%ebp),%eax
c01069c4:	83 e8 04             	sub    $0x4,%eax
c01069c7:	8b 00                	mov    (%eax),%eax
c01069c9:	83 e0 f8             	and    $0xfffffff8,%eax
c01069cc:	8d 50 fc             	lea    -0x4(%eax),%edx
c01069cf:	8b 45 08             	mov    0x8(%ebp),%eax
c01069d2:	01 d0                	add    %edx,%eax
c01069d4:	8b 00                	mov    (%eax),%eax
c01069d6:	83 e0 01             	and    $0x1,%eax
c01069d9:	89 45 f8             	mov    %eax,-0x8(%ebp)
    size_t size = GET_SIZE(HDRP(bp));
c01069dc:	8b 45 08             	mov    0x8(%ebp),%eax
c01069df:	83 e8 04             	sub    $0x4,%eax
c01069e2:	8b 00                	mov    (%eax),%eax
c01069e4:	83 e0 f8             	and    $0xfffffff8,%eax
c01069e7:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(prev_alloc && next_alloc)
c01069ea:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c01069ee:	74 0e                	je     c01069fe <coalesce+0x5e>
c01069f0:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c01069f4:	74 08                	je     c01069fe <coalesce+0x5e>
        return bp;
c01069f6:	8b 45 08             	mov    0x8(%ebp),%eax
c01069f9:	e9 3e 01 00 00       	jmp    c0106b3c <coalesce+0x19c>

    else if(prev_alloc && !next_alloc)
c01069fe:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0106a02:	74 49                	je     c0106a4d <coalesce+0xad>
c0106a04:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0106a08:	75 43                	jne    c0106a4d <coalesce+0xad>
    {
        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));
c0106a0a:	8b 45 08             	mov    0x8(%ebp),%eax
c0106a0d:	83 e8 04             	sub    $0x4,%eax
c0106a10:	8b 00                	mov    (%eax),%eax
c0106a12:	83 e0 f8             	and    $0xfffffff8,%eax
c0106a15:	8d 50 fc             	lea    -0x4(%eax),%edx
c0106a18:	8b 45 08             	mov    0x8(%ebp),%eax
c0106a1b:	01 d0                	add    %edx,%eax
c0106a1d:	8b 00                	mov    (%eax),%eax
c0106a1f:	83 e0 f8             	and    $0xfffffff8,%eax
c0106a22:	01 45 f4             	add    %eax,-0xc(%ebp)
        PUT(HDRP(bp), PACK(size, 0));
c0106a25:	8b 45 08             	mov    0x8(%ebp),%eax
c0106a28:	8d 50 fc             	lea    -0x4(%eax),%edx
c0106a2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106a2e:	89 02                	mov    %eax,(%edx)
        PUT(FTRP(bp), PACK(size, 0));
c0106a30:	8b 45 08             	mov    0x8(%ebp),%eax
c0106a33:	83 e8 04             	sub    $0x4,%eax
c0106a36:	8b 00                	mov    (%eax),%eax
c0106a38:	83 e0 f8             	and    $0xfffffff8,%eax
c0106a3b:	8d 50 f8             	lea    -0x8(%eax),%edx
c0106a3e:	8b 45 08             	mov    0x8(%ebp),%eax
c0106a41:	01 c2                	add    %eax,%edx
c0106a43:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106a46:	89 02                	mov    %eax,(%edx)
c0106a48:	e9 ec 00 00 00       	jmp    c0106b39 <coalesce+0x199>
    }

    else if(!prev_alloc && next_alloc)
c0106a4d:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0106a51:	75 6b                	jne    c0106abe <coalesce+0x11e>
c0106a53:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0106a57:	74 65                	je     c0106abe <coalesce+0x11e>
    {
        size += GET_SIZE(HDRP(PREV_BLKP(bp)));//TO DO ,THERE IS PEOBLEM, CRUSH HERE
c0106a59:	8b 45 08             	mov    0x8(%ebp),%eax
c0106a5c:	83 e8 08             	sub    $0x8,%eax
c0106a5f:	8b 00                	mov    (%eax),%eax
c0106a61:	83 e0 f8             	and    $0xfffffff8,%eax
c0106a64:	ba fc ff ff ff       	mov    $0xfffffffc,%edx
c0106a69:	29 c2                	sub    %eax,%edx
c0106a6b:	8b 45 08             	mov    0x8(%ebp),%eax
c0106a6e:	01 d0                	add    %edx,%eax
c0106a70:	8b 00                	mov    (%eax),%eax
c0106a72:	83 e0 f8             	and    $0xfffffff8,%eax
c0106a75:	01 45 f4             	add    %eax,-0xc(%ebp)
        PUT(FTRP(bp), PACK(size, 0));
c0106a78:	8b 45 08             	mov    0x8(%ebp),%eax
c0106a7b:	83 e8 04             	sub    $0x4,%eax
c0106a7e:	8b 00                	mov    (%eax),%eax
c0106a80:	83 e0 f8             	and    $0xfffffff8,%eax
c0106a83:	8d 50 f8             	lea    -0x8(%eax),%edx
c0106a86:	8b 45 08             	mov    0x8(%ebp),%eax
c0106a89:	01 c2                	add    %eax,%edx
c0106a8b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106a8e:	89 02                	mov    %eax,(%edx)
        PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0));
c0106a90:	8b 45 08             	mov    0x8(%ebp),%eax
c0106a93:	83 e8 08             	sub    $0x8,%eax
c0106a96:	8b 00                	mov    (%eax),%eax
c0106a98:	83 e0 f8             	and    $0xfffffff8,%eax
c0106a9b:	ba fc ff ff ff       	mov    $0xfffffffc,%edx
c0106aa0:	29 c2                	sub    %eax,%edx
c0106aa2:	8b 45 08             	mov    0x8(%ebp),%eax
c0106aa5:	01 c2                	add    %eax,%edx
c0106aa7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106aaa:	89 02                	mov    %eax,(%edx)
        bp = PREV_BLKP(bp);
c0106aac:	8b 45 08             	mov    0x8(%ebp),%eax
c0106aaf:	83 e8 08             	sub    $0x8,%eax
c0106ab2:	8b 00                	mov    (%eax),%eax
c0106ab4:	83 e0 f8             	and    $0xfffffff8,%eax
c0106ab7:	f7 d8                	neg    %eax
c0106ab9:	01 45 08             	add    %eax,0x8(%ebp)
c0106abc:	eb 7b                	jmp    c0106b39 <coalesce+0x199>
    }

    else{
        size += GET_SIZE(HDRP(PREV_BLKP(bp))) + GET_SIZE(FTRP(NEXT_BLKP(bp)));
c0106abe:	8b 45 08             	mov    0x8(%ebp),%eax
c0106ac1:	83 e8 08             	sub    $0x8,%eax
c0106ac4:	8b 00                	mov    (%eax),%eax
c0106ac6:	83 e0 f8             	and    $0xfffffff8,%eax
c0106ac9:	ba fc ff ff ff       	mov    $0xfffffffc,%edx
c0106ace:	29 c2                	sub    %eax,%edx
c0106ad0:	8b 45 08             	mov    0x8(%ebp),%eax
c0106ad3:	01 d0                	add    %edx,%eax
c0106ad5:	8b 00                	mov    (%eax),%eax
c0106ad7:	83 e0 f8             	and    $0xfffffff8,%eax
c0106ada:	89 c2                	mov    %eax,%edx
c0106adc:	8b 45 08             	mov    0x8(%ebp),%eax
c0106adf:	83 e8 04             	sub    $0x4,%eax
c0106ae2:	8b 00                	mov    (%eax),%eax
c0106ae4:	83 e0 f8             	and    $0xfffffff8,%eax
c0106ae7:	8d 48 f8             	lea    -0x8(%eax),%ecx
c0106aea:	8b 45 08             	mov    0x8(%ebp),%eax
c0106aed:	01 c8                	add    %ecx,%eax
c0106aef:	8b 00                	mov    (%eax),%eax
c0106af1:	83 e0 f8             	and    $0xfffffff8,%eax
c0106af4:	01 d0                	add    %edx,%eax
c0106af6:	01 45 f4             	add    %eax,-0xc(%ebp)
        PUT(FTRP(PREV_BLKP(bp)), PACK(size, 0));
c0106af9:	8b 45 08             	mov    0x8(%ebp),%eax
c0106afc:	83 e8 04             	sub    $0x4,%eax
c0106aff:	8b 00                	mov    (%eax),%eax
c0106b01:	83 e0 f8             	and    $0xfffffff8,%eax
c0106b04:	8d 50 f8             	lea    -0x8(%eax),%edx
c0106b07:	8b 45 08             	mov    0x8(%ebp),%eax
c0106b0a:	01 c2                	add    %eax,%edx
c0106b0c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106b0f:	89 02                	mov    %eax,(%edx)
        PUT(HDRP(NEXT_BLKP(bp)), PACK(size, 0));
c0106b11:	8b 45 08             	mov    0x8(%ebp),%eax
c0106b14:	83 e8 04             	sub    $0x4,%eax
c0106b17:	8b 00                	mov    (%eax),%eax
c0106b19:	83 e0 f8             	and    $0xfffffff8,%eax
c0106b1c:	8d 50 fc             	lea    -0x4(%eax),%edx
c0106b1f:	8b 45 08             	mov    0x8(%ebp),%eax
c0106b22:	01 c2                	add    %eax,%edx
c0106b24:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106b27:	89 02                	mov    %eax,(%edx)
        bp = PREV_BLKP(bp);
c0106b29:	8b 45 08             	mov    0x8(%ebp),%eax
c0106b2c:	83 e8 08             	sub    $0x8,%eax
c0106b2f:	8b 00                	mov    (%eax),%eax
c0106b31:	83 e0 f8             	and    $0xfffffff8,%eax
c0106b34:	f7 d8                	neg    %eax
c0106b36:	01 45 08             	add    %eax,0x8(%ebp)
    }
    return bp;
c0106b39:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0106b3c:	c9                   	leave  
c0106b3d:	c3                   	ret    

c0106b3e <find_fit>:
 * @brief find free blk
 * 
 * @param find size
 */
static void* find_fit(size_t asize)// we just traverse heap
{
c0106b3e:	55                   	push   %ebp
c0106b3f:	89 e5                	mov    %esp,%ebp
c0106b41:	83 ec 10             	sub    $0x10,%esp
    void* bp = heap_listp;
c0106b44:	a1 44 90 12 c0       	mov    0xc0129044,%eax
c0106b49:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while(GET_ALLOC(HDRP(bp)) || (GET_SIZE(HDRP(bp)) < asize))
c0106b4c:	eb 2f                	jmp    c0106b7d <find_fit+0x3f>
    {
        if(GET_SIZE(bp) != 0 && GET_ALLOC(bp) != 1)
c0106b4e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106b51:	8b 00                	mov    (%eax),%eax
c0106b53:	83 e0 f8             	and    $0xfffffff8,%eax
c0106b56:	85 c0                	test   %eax,%eax
c0106b58:	74 1c                	je     c0106b76 <find_fit+0x38>
c0106b5a:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106b5d:	8b 00                	mov    (%eax),%eax
c0106b5f:	83 e0 01             	and    $0x1,%eax
c0106b62:	85 c0                	test   %eax,%eax
c0106b64:	75 10                	jne    c0106b76 <find_fit+0x38>
            bp = NEXT_BLKP(bp);
c0106b66:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106b69:	83 e8 04             	sub    $0x4,%eax
c0106b6c:	8b 00                	mov    (%eax),%eax
c0106b6e:	83 e0 f8             	and    $0xfffffff8,%eax
c0106b71:	01 45 fc             	add    %eax,-0x4(%ebp)
c0106b74:	eb 07                	jmp    c0106b7d <find_fit+0x3f>
        else
            return NULL;
c0106b76:	b8 00 00 00 00       	mov    $0x0,%eax
c0106b7b:	eb 22                	jmp    c0106b9f <find_fit+0x61>
    while(GET_ALLOC(HDRP(bp)) || (GET_SIZE(HDRP(bp)) < asize))
c0106b7d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106b80:	83 e8 04             	sub    $0x4,%eax
c0106b83:	8b 00                	mov    (%eax),%eax
c0106b85:	83 e0 01             	and    $0x1,%eax
c0106b88:	85 c0                	test   %eax,%eax
c0106b8a:	75 c2                	jne    c0106b4e <find_fit+0x10>
c0106b8c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106b8f:	83 e8 04             	sub    $0x4,%eax
c0106b92:	8b 00                	mov    (%eax),%eax
c0106b94:	83 e0 f8             	and    $0xfffffff8,%eax
c0106b97:	39 45 08             	cmp    %eax,0x8(%ebp)
c0106b9a:	77 b2                	ja     c0106b4e <find_fit+0x10>
    }
    return bp;
c0106b9c:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0106b9f:	c9                   	leave  
c0106ba0:	c3                   	ret    

c0106ba1 <place>:
 * @brief place the blk
 * 
 * @param blk,size
 */
static void place(void* bp, size_t asize)
{
c0106ba1:	55                   	push   %ebp
c0106ba2:	89 e5                	mov    %esp,%ebp
c0106ba4:	83 ec 10             	sub    $0x10,%esp
    size_t bp_allsize = GET_SIZE(HDRP(bp));
c0106ba7:	8b 45 08             	mov    0x8(%ebp),%eax
c0106baa:	83 e8 04             	sub    $0x4,%eax
c0106bad:	8b 00                	mov    (%eax),%eax
c0106baf:	83 e0 f8             	and    $0xfffffff8,%eax
c0106bb2:	89 45 fc             	mov    %eax,-0x4(%ebp)
    size_t remain_size = bp_allsize - asize;
c0106bb5:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106bb8:	2b 45 0c             	sub    0xc(%ebp),%eax
c0106bbb:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if(remain_size >= 2*DSIZE)
c0106bbe:	83 7d f8 0f          	cmpl   $0xf,-0x8(%ebp)
c0106bc2:	76 5b                	jbe    c0106c1f <place+0x7e>
    {
        PUT(HDRP(bp), PACK(asize, 1));
c0106bc4:	8b 45 08             	mov    0x8(%ebp),%eax
c0106bc7:	83 e8 04             	sub    $0x4,%eax
c0106bca:	8b 55 0c             	mov    0xc(%ebp),%edx
c0106bcd:	83 ca 01             	or     $0x1,%edx
c0106bd0:	89 10                	mov    %edx,(%eax)
        PUT(FTRP(bp), PACK(asize, 1));
c0106bd2:	8b 45 08             	mov    0x8(%ebp),%eax
c0106bd5:	83 e8 04             	sub    $0x4,%eax
c0106bd8:	8b 00                	mov    (%eax),%eax
c0106bda:	83 e0 f8             	and    $0xfffffff8,%eax
c0106bdd:	8d 50 f8             	lea    -0x8(%eax),%edx
c0106be0:	8b 45 08             	mov    0x8(%ebp),%eax
c0106be3:	01 d0                	add    %edx,%eax
c0106be5:	8b 55 0c             	mov    0xc(%ebp),%edx
c0106be8:	83 ca 01             	or     $0x1,%edx
c0106beb:	89 10                	mov    %edx,(%eax)
        PUT(HDRP(NEXT_BLKP(bp)), PACK(remain_size, 0));
c0106bed:	8b 45 08             	mov    0x8(%ebp),%eax
c0106bf0:	83 e8 04             	sub    $0x4,%eax
c0106bf3:	8b 00                	mov    (%eax),%eax
c0106bf5:	83 e0 f8             	and    $0xfffffff8,%eax
c0106bf8:	8d 50 fc             	lea    -0x4(%eax),%edx
c0106bfb:	8b 45 08             	mov    0x8(%ebp),%eax
c0106bfe:	01 c2                	add    %eax,%edx
c0106c00:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0106c03:	89 02                	mov    %eax,(%edx)
        PUT(FTRP(NEXT_BLKP(bp)), PACK(remain_size, 0));
c0106c05:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c08:	83 e8 04             	sub    $0x4,%eax
c0106c0b:	8b 00                	mov    (%eax),%eax
c0106c0d:	83 e0 f8             	and    $0xfffffff8,%eax
c0106c10:	8d 50 f8             	lea    -0x8(%eax),%edx
c0106c13:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c16:	01 c2                	add    %eax,%edx
c0106c18:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0106c1b:	89 02                	mov    %eax,(%edx)
    }else{
        PUT(HDRP(bp), PACK(bp_allsize, 1));
        PUT(FTRP(bp), PACK(bp_allsize, 1));
    }
}
c0106c1d:	eb 29                	jmp    c0106c48 <place+0xa7>
        PUT(HDRP(bp), PACK(bp_allsize, 1));
c0106c1f:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c22:	83 e8 04             	sub    $0x4,%eax
c0106c25:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0106c28:	83 ca 01             	or     $0x1,%edx
c0106c2b:	89 10                	mov    %edx,(%eax)
        PUT(FTRP(bp), PACK(bp_allsize, 1));
c0106c2d:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c30:	83 e8 04             	sub    $0x4,%eax
c0106c33:	8b 00                	mov    (%eax),%eax
c0106c35:	83 e0 f8             	and    $0xfffffff8,%eax
c0106c38:	8d 50 f8             	lea    -0x8(%eax),%edx
c0106c3b:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c3e:	01 d0                	add    %edx,%eax
c0106c40:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0106c43:	83 ca 01             	or     $0x1,%edx
c0106c46:	89 10                	mov    %edx,(%eax)
}
c0106c48:	90                   	nop
c0106c49:	c9                   	leave  
c0106c4a:	c3                   	ret    

c0106c4b <mem_init>:

//following is head file function

void mem_init()
{
c0106c4b:	55                   	push   %ebp
c0106c4c:	89 e5                	mov    %esp,%ebp
c0106c4e:	83 ec 18             	sub    $0x18,%esp
    mem_heap = &__heap_start;
c0106c51:	c7 05 48 90 12 c0 00 	movl   $0xc0132000,0xc0129048
c0106c58:	20 13 c0 
    //mem_heap = (char*)Malloc(MAX_HEAP);
    mem_brk = mem_heap;
c0106c5b:	a1 48 90 12 c0       	mov    0xc0129048,%eax
c0106c60:	a3 4c 90 12 c0       	mov    %eax,0xc012904c
    //mem_max_addr = (char*)(mem_heap + MAX_HEAP);
    mem_max_addr = (char*)K_STACK_START;
c0106c65:	c7 05 50 90 12 c0 00 	movl   $0xffb00000,0xc0129050
c0106c6c:	00 b0 ff 
    uint8_t* pgaddr = 0;
c0106c6f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    if((pgaddr = vmm_alloc_page(mem_brk, PG_PREM_RW, PG_PREM_RW)) == NULL)
c0106c76:	a1 4c 90 12 c0       	mov    0xc012904c,%eax
c0106c7b:	83 ec 04             	sub    $0x4,%esp
c0106c7e:	6a 03                	push   $0x3
c0106c80:	6a 03                	push   $0x3
c0106c82:	50                   	push   %eax
c0106c83:	e8 9b 04 00 00       	call   c0107123 <vmm_alloc_page>
c0106c88:	83 c4 10             	add    $0x10,%esp
c0106c8b:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0106c8e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0106c92:	74 1a                	je     c0106cae <mem_init+0x63>
        return;
    kprintf("malloc init phy address is 0x%x\n", pgaddr);
c0106c94:	83 ec 08             	sub    $0x8,%esp
c0106c97:	ff 75 f4             	push   -0xc(%ebp)
c0106c9a:	68 14 b2 12 c0       	push   $0xc012b214
c0106c9f:	e8 54 15 00 00       	call   c01081f8 <kprintf>
c0106ca4:	83 c4 10             	add    $0x10,%esp
    malloc_init();
c0106ca7:	e8 b4 00 00 00       	call   c0106d60 <malloc_init>
c0106cac:	eb 01                	jmp    c0106caf <mem_init+0x64>
        return;
c0106cae:	90                   	nop
}
c0106caf:	c9                   	leave  
c0106cb0:	c3                   	ret    

c0106cb1 <mem_sbrk>:

void* mem_sbrk(int incr)
{
c0106cb1:	55                   	push   %ebp
c0106cb2:	89 e5                	mov    %esp,%ebp
c0106cb4:	83 ec 18             	sub    $0x18,%esp
    char* old = mem_brk;
c0106cb7:	a1 4c 90 12 c0       	mov    0xc012904c,%eax
c0106cbc:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if((incr < 0) || ((mem_brk + incr) > mem_max_addr))
c0106cbf:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0106cc3:	78 14                	js     c0106cd9 <mem_sbrk+0x28>
c0106cc5:	8b 15 4c 90 12 c0    	mov    0xc012904c,%edx
c0106ccb:	8b 45 08             	mov    0x8(%ebp),%eax
c0106cce:	01 c2                	add    %eax,%edx
c0106cd0:	a1 50 90 12 c0       	mov    0xc0129050,%eax
c0106cd5:	39 c2                	cmp    %eax,%edx
c0106cd7:	76 07                	jbe    c0106ce0 <mem_sbrk+0x2f>
    {
        return (void*)-1;
c0106cd9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0106cde:	eb 7e                	jmp    c0106d5e <mem_sbrk+0xad>
    }
    char* new = mem_brk + incr;
c0106ce0:	8b 15 4c 90 12 c0    	mov    0xc012904c,%edx
c0106ce6:	8b 45 08             	mov    0x8(%ebp),%eax
c0106ce9:	01 d0                	add    %edx,%eax
c0106ceb:	89 45 f0             	mov    %eax,-0x10(%ebp)
    unsigned int diff = PG_ALIGN(new) - PG_ALIGN(old);
c0106cee:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106cf1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0106cf6:	89 c2                	mov    %eax,%edx
c0106cf8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106cfb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0106d00:	89 c1                	mov    %eax,%ecx
c0106d02:	89 d0                	mov    %edx,%eax
c0106d04:	29 c8                	sub    %ecx,%eax
c0106d06:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(diff)
c0106d09:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0106d0d:	74 3c                	je     c0106d4b <mem_sbrk+0x9a>
    {
        uint8_t* pgaddr = -1;
c0106d0f:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,-0x18(%ebp)
        if(!(pgaddr = vmm_alloc_page(new,PG_PREM_RW,PG_PREM_RW)))
c0106d16:	83 ec 04             	sub    $0x4,%esp
c0106d19:	6a 03                	push   $0x3
c0106d1b:	6a 03                	push   $0x3
c0106d1d:	ff 75 f0             	push   -0x10(%ebp)
c0106d20:	e8 fe 03 00 00       	call   c0107123 <vmm_alloc_page>
c0106d25:	83 c4 10             	add    $0x10,%esp
c0106d28:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0106d2b:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0106d2f:	75 07                	jne    c0106d38 <mem_sbrk+0x87>
        {
            return NULL;
c0106d31:	b8 00 00 00 00       	mov    $0x0,%eax
c0106d36:	eb 26                	jmp    c0106d5e <mem_sbrk+0xad>
        }
        kprintf("head new page is 0x%x\n", pgaddr);
c0106d38:	83 ec 08             	sub    $0x8,%esp
c0106d3b:	ff 75 e8             	push   -0x18(%ebp)
c0106d3e:	68 35 b2 12 c0       	push   $0xc012b235
c0106d43:	e8 b0 14 00 00       	call   c01081f8 <kprintf>
c0106d48:	83 c4 10             	add    $0x10,%esp
    }
    mem_brk += incr;
c0106d4b:	8b 15 4c 90 12 c0    	mov    0xc012904c,%edx
c0106d51:	8b 45 08             	mov    0x8(%ebp),%eax
c0106d54:	01 d0                	add    %edx,%eax
c0106d56:	a3 4c 90 12 c0       	mov    %eax,0xc012904c
    return (void*)old;
c0106d5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0106d5e:	c9                   	leave  
c0106d5f:	c3                   	ret    

c0106d60 <malloc_init>:

int malloc_init()
{
c0106d60:	55                   	push   %ebp
c0106d61:	89 e5                	mov    %esp,%ebp
c0106d63:	83 ec 08             	sub    $0x8,%esp
    if((heap_listp = mem_sbrk(4 * WSIZE)) == (void*) - 1)
c0106d66:	83 ec 0c             	sub    $0xc,%esp
c0106d69:	6a 10                	push   $0x10
c0106d6b:	e8 41 ff ff ff       	call   c0106cb1 <mem_sbrk>
c0106d70:	83 c4 10             	add    $0x10,%esp
c0106d73:	a3 44 90 12 c0       	mov    %eax,0xc0129044
c0106d78:	a1 44 90 12 c0       	mov    0xc0129044,%eax
c0106d7d:	83 f8 ff             	cmp    $0xffffffff,%eax
c0106d80:	75 07                	jne    c0106d89 <malloc_init+0x29>
        return -1;
c0106d82:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0106d87:	eb 62                	jmp    c0106deb <malloc_init+0x8b>
    PUT(heap_listp, 0);
c0106d89:	a1 44 90 12 c0       	mov    0xc0129044,%eax
c0106d8e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    PUT(heap_listp + (1*WSIZE), PACK(DSIZE, 1));
c0106d94:	a1 44 90 12 c0       	mov    0xc0129044,%eax
c0106d99:	83 c0 04             	add    $0x4,%eax
c0106d9c:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
    PUT(heap_listp + (2*WSIZE), PACK(DSIZE, 1));
c0106da2:	a1 44 90 12 c0       	mov    0xc0129044,%eax
c0106da7:	83 c0 08             	add    $0x8,%eax
c0106daa:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
    PUT(heap_listp + (3*WSIZE), PACK(0, 1));
c0106db0:	a1 44 90 12 c0       	mov    0xc0129044,%eax
c0106db5:	83 c0 0c             	add    $0xc,%eax
c0106db8:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    heap_listp += (2*WSIZE);
c0106dbe:	a1 44 90 12 c0       	mov    0xc0129044,%eax
c0106dc3:	83 c0 08             	add    $0x8,%eax
c0106dc6:	a3 44 90 12 c0       	mov    %eax,0xc0129044

    //extend free heap with free blk og CHUNKSIZE size
    //mem_sbrk((CHUNKSIZE - WSIZE));
    if(extend_heap((CHUNKSIZE - WSIZE)  / WSIZE) == NULL)
c0106dcb:	83 ec 0c             	sub    $0xc,%esp
c0106dce:	68 ff 03 00 00       	push   $0x3ff
c0106dd3:	e8 3e fb ff ff       	call   c0106916 <extend_heap>
c0106dd8:	83 c4 10             	add    $0x10,%esp
c0106ddb:	85 c0                	test   %eax,%eax
c0106ddd:	75 07                	jne    c0106de6 <malloc_init+0x86>
        return -1;
c0106ddf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0106de4:	eb 05                	jmp    c0106deb <malloc_init+0x8b>
    return 0;
c0106de6:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0106deb:	c9                   	leave  
c0106dec:	c3                   	ret    

c0106ded <malloc_free>:

void malloc_free(void* bp)
{
c0106ded:	55                   	push   %ebp
c0106dee:	89 e5                	mov    %esp,%ebp
c0106df0:	83 ec 10             	sub    $0x10,%esp
    size_t size = GET_SIZE(HDRP(bp));
c0106df3:	8b 45 08             	mov    0x8(%ebp),%eax
c0106df6:	83 e8 04             	sub    $0x4,%eax
c0106df9:	8b 00                	mov    (%eax),%eax
c0106dfb:	83 e0 f8             	and    $0xfffffff8,%eax
c0106dfe:	89 45 fc             	mov    %eax,-0x4(%ebp)

    PUT(HDRP(bp), PACK(size, 0));
c0106e01:	8b 45 08             	mov    0x8(%ebp),%eax
c0106e04:	8d 50 fc             	lea    -0x4(%eax),%edx
c0106e07:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106e0a:	89 02                	mov    %eax,(%edx)
    PUT(FTRP(bp), PACK(size, 0));
c0106e0c:	8b 45 08             	mov    0x8(%ebp),%eax
c0106e0f:	83 e8 04             	sub    $0x4,%eax
c0106e12:	8b 00                	mov    (%eax),%eax
c0106e14:	83 e0 f8             	and    $0xfffffff8,%eax
c0106e17:	8d 50 f8             	lea    -0x8(%eax),%edx
c0106e1a:	8b 45 08             	mov    0x8(%ebp),%eax
c0106e1d:	01 c2                	add    %eax,%edx
c0106e1f:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106e22:	89 02                	mov    %eax,(%edx)
    coalesce(bp);
c0106e24:	ff 75 08             	push   0x8(%ebp)
c0106e27:	e8 74 fb ff ff       	call   c01069a0 <coalesce>
c0106e2c:	83 c4 04             	add    $0x4,%esp
}
c0106e2f:	90                   	nop
c0106e30:	c9                   	leave  
c0106e31:	c3                   	ret    

c0106e32 <k_malloc>:

void* k_malloc(size_t size)
{
c0106e32:	55                   	push   %ebp
c0106e33:	89 e5                	mov    %esp,%ebp
c0106e35:	83 ec 18             	sub    $0x18,%esp
    size_t asize;
    size_t extendsize;
    char* bp;

    if(size == 0)
c0106e38:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0106e3c:	75 0a                	jne    c0106e48 <k_malloc+0x16>
        return NULL;
c0106e3e:	b8 00 00 00 00       	mov    $0x0,%eax
c0106e43:	e9 8a 00 00 00       	jmp    c0106ed2 <k_malloc+0xa0>
    
    //THE MIN blk is 2*DSIZE, ONE DSIZE means head and foot, one is align
    if(size <= DSIZE)
c0106e48:	83 7d 08 08          	cmpl   $0x8,0x8(%ebp)
c0106e4c:	77 09                	ja     c0106e57 <k_malloc+0x25>
        asize = 2 * DSIZE;
c0106e4e:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
c0106e55:	eb 0e                	jmp    c0106e65 <k_malloc+0x33>
    else
        asize = DSIZE * ((size + DSIZE) + (DSIZE - 1)) / DSIZE; // Round up 
c0106e57:	8b 45 08             	mov    0x8(%ebp),%eax
c0106e5a:	83 c0 0f             	add    $0xf,%eax
c0106e5d:	25 ff ff ff 1f       	and    $0x1fffffff,%eax
c0106e62:	89 45 f4             	mov    %eax,-0xc(%ebp)
    //search the free list of fit
    if((bp = find_fit(asize)) != NULL)
c0106e65:	ff 75 f4             	push   -0xc(%ebp)
c0106e68:	e8 d1 fc ff ff       	call   c0106b3e <find_fit>
c0106e6d:	83 c4 04             	add    $0x4,%esp
c0106e70:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0106e73:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0106e77:	74 13                	je     c0106e8c <k_malloc+0x5a>
    {
        place(bp, asize);
c0106e79:	ff 75 f4             	push   -0xc(%ebp)
c0106e7c:	ff 75 f0             	push   -0x10(%ebp)
c0106e7f:	e8 1d fd ff ff       	call   c0106ba1 <place>
c0106e84:	83 c4 08             	add    $0x8,%esp
        return bp;
c0106e87:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106e8a:	eb 46                	jmp    c0106ed2 <k_malloc+0xa0>
    }

    //no fit found try to extend head mem
    extendsize = MAX(asize, CHUNKSIZE);
c0106e8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106e8f:	ba 00 10 00 00       	mov    $0x1000,%edx
c0106e94:	39 d0                	cmp    %edx,%eax
c0106e96:	0f 42 c2             	cmovb  %edx,%eax
c0106e99:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if((bp = extend_heap(extendsize / WSIZE)) == NULL)
c0106e9c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0106e9f:	c1 e8 02             	shr    $0x2,%eax
c0106ea2:	83 ec 0c             	sub    $0xc,%esp
c0106ea5:	50                   	push   %eax
c0106ea6:	e8 6b fa ff ff       	call   c0106916 <extend_heap>
c0106eab:	83 c4 10             	add    $0x10,%esp
c0106eae:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0106eb1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0106eb5:	75 07                	jne    c0106ebe <k_malloc+0x8c>
        return NULL;
c0106eb7:	b8 00 00 00 00       	mov    $0x0,%eax
c0106ebc:	eb 14                	jmp    c0106ed2 <k_malloc+0xa0>
    place(bp, asize);
c0106ebe:	83 ec 08             	sub    $0x8,%esp
c0106ec1:	ff 75 f4             	push   -0xc(%ebp)
c0106ec4:	ff 75 f0             	push   -0x10(%ebp)
c0106ec7:	e8 d5 fc ff ff       	call   c0106ba1 <place>
c0106ecc:	83 c4 10             	add    $0x10,%esp
    return bp;
c0106ecf:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106ed2:	c9                   	leave  
c0106ed3:	c3                   	ret    

c0106ed4 <vmm_init>:
#include <kernel/memory/vir_mem.h>
#include <libs/mstring.h>

void vmm_init() {
c0106ed4:	55                   	push   %ebp
c0106ed5:	89 e5                	mov    %esp,%ebp
    // TODO: something here?
}
c0106ed7:	90                   	nop
c0106ed8:	5d                   	pop    %ebp
c0106ed9:	c3                   	ret    

c0106eda <get_pd>:

// TODO: Move these nasty inline asm stuff into hal
//      These should be arch dependent
ptd_t* get_pd() {
c0106eda:	55                   	push   %ebp
c0106edb:	89 e5                	mov    %esp,%ebp
c0106edd:	83 ec 10             	sub    $0x10,%esp
    ptd_t* pd;
    #ifdef __ARCH_IA32
    __asm__(
c0106ee0:	0f 20 d8             	mov    %cr3,%eax
c0106ee3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0106ee8:	89 45 fc             	mov    %eax,-0x4(%ebp)
        "movl %%cr3, %0\n"
        "andl $0xfffff000, %0"
        : "=r"(pd)
    );
    #endif
    return P2V(pd);
c0106eeb:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106eee:	2d 00 00 00 40       	sub    $0x40000000,%eax
}
c0106ef3:	c9                   	leave  
c0106ef4:	c3                   	ret    

c0106ef5 <set_pd>:

void set_pd(ptd_t* pd) {
c0106ef5:	55                   	push   %ebp
c0106ef6:	89 e5                	mov    %esp,%ebp
    #ifdef __ARCH_IA32
    __asm__(
c0106ef8:	8b 45 08             	mov    0x8(%ebp),%eax
c0106efb:	89 c0                	mov    %eax,%eax
c0106efd:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0106f02:	0f 22 d8             	mov    %eax,%cr3
        "movl %%eax, %%cr3\n"
        :
        : "r" (pd)
    );
    #endif
}
c0106f05:	90                   	nop
c0106f06:	5d                   	pop    %ebp
c0106f07:	c3                   	ret    

c0106f08 <vmm_init_pd>:

ptd_t* vmm_init_pd() {
c0106f08:	55                   	push   %ebp
c0106f09:	89 e5                	mov    %esp,%ebp
c0106f0b:	83 ec 18             	sub    $0x18,%esp
    ptd_t* dir = pmm_alloc_page();
c0106f0e:	e8 e3 f8 ff ff       	call   c01067f6 <pmm_alloc_page>
c0106f13:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for (size_t i = 0; i < 1024; i++)
c0106f16:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0106f1d:	eb 19                	jmp    c0106f38 <vmm_init_pd+0x30>
    {
        dir[i] = 0;
c0106f1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106f22:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0106f29:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106f2c:	01 d0                	add    %edx,%eax
c0106f2e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    for (size_t i = 0; i < 1024; i++)
c0106f34:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0106f38:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
c0106f3f:	76 de                	jbe    c0106f1f <vmm_init_pd+0x17>
    }
    
    // 自己映射自己，方便我们在软件层面进行查表地址转换
    dir[1023] = PDE(T_SELF_REF_PERM, dir);
c0106f41:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106f44:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0106f49:	89 c2                	mov    %eax,%edx
c0106f4b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106f4e:	05 fc 0f 00 00       	add    $0xffc,%eax
c0106f53:	83 ca 13             	or     $0x13,%edx
c0106f56:	89 10                	mov    %edx,(%eax)

    return dir;
c0106f58:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0106f5b:	c9                   	leave  
c0106f5c:	c3                   	ret    

c0106f5d <vmm_map_page>:

void* vmm_map_page(void* va, void* pa, pt_attr dattr, pt_attr tattr) {
c0106f5d:	55                   	push   %ebp
c0106f5e:	89 e5                	mov    %esp,%ebp
c0106f60:	53                   	push   %ebx
c0106f61:	83 ec 24             	sub    $0x24,%esp
    // 显然，对空指针进行映射没有意义。
    if (!pa || !va) {
c0106f64:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0106f68:	74 06                	je     c0106f70 <vmm_map_page+0x13>
c0106f6a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0106f6e:	75 0a                	jne    c0106f7a <vmm_map_page+0x1d>
        return NULL;
c0106f70:	b8 00 00 00 00       	mov    $0x0,%eax
c0106f75:	e9 a4 01 00 00       	jmp    c010711e <vmm_map_page+0x1c1>
    }

    uintptr_t pd_offset = PD_INDEX(va);
c0106f7a:	8b 45 08             	mov    0x8(%ebp),%eax
c0106f7d:	c1 e8 16             	shr    $0x16,%eax
c0106f80:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uintptr_t pt_offset = PT_INDEX(va);
c0106f83:	8b 45 08             	mov    0x8(%ebp),%eax
c0106f86:	c1 e8 0c             	shr    $0xc,%eax
c0106f89:	25 ff 03 00 00       	and    $0x3ff,%eax
c0106f8e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    ptd_t* ptd = (ptd_t*)PTD_BASE_VADDR;
c0106f91:	c7 45 e4 00 f0 ff ff 	movl   $0xfffff000,-0x1c(%ebp)

    // 在页表与页目录中找到一个可用的空位进行映射（位于va或其附近）
    ptd_t* pde = ptd[pd_offset];
c0106f98:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106f9b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0106fa2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0106fa5:	01 d0                	add    %edx,%eax
c0106fa7:	8b 00                	mov    (%eax),%eax
c0106fa9:	89 45 ec             	mov    %eax,-0x14(%ebp)
    pt_t* pt = (uintptr_t)PT_VADDR(pd_offset);
c0106fac:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106faf:	c1 e0 0c             	shl    $0xc,%eax
c0106fb2:	0d 00 00 c0 ff       	or     $0xffc00000,%eax
c0106fb7:	89 45 e8             	mov    %eax,-0x18(%ebp)
    while (pde && pd_offset < 1024) {
c0106fba:	e9 9b 00 00 00       	jmp    c010705a <vmm_map_page+0xfd>
        if (pt_offset == 1024) {
c0106fbf:	81 7d f0 00 04 00 00 	cmpl   $0x400,-0x10(%ebp)
c0106fc6:	75 2d                	jne    c0106ff5 <vmm_map_page+0x98>
            pd_offset++;
c0106fc8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
            pt_offset = 0;
c0106fcc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            pde = ptd[pd_offset];
c0106fd3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106fd6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0106fdd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0106fe0:	01 d0                	add    %edx,%eax
c0106fe2:	8b 00                	mov    (%eax),%eax
c0106fe4:	89 45 ec             	mov    %eax,-0x14(%ebp)
            pt = (pt_t*)PT_VADDR(pd_offset);
c0106fe7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106fea:	c1 e0 0c             	shl    $0xc,%eax
c0106fed:	0d 00 00 c0 ff       	or     $0xffc00000,%eax
c0106ff2:	89 45 e8             	mov    %eax,-0x18(%ebp)
        }
        // 页表有空位，只需要开辟一个新的 PTE
        if (pt && !pt[pt_offset]) {
c0106ff5:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0106ff9:	74 5b                	je     c0107056 <vmm_map_page+0xf9>
c0106ffb:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106ffe:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0107005:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0107008:	01 d0                	add    %edx,%eax
c010700a:	8b 00                	mov    (%eax),%eax
c010700c:	85 c0                	test   %eax,%eax
c010700e:	75 46                	jne    c0107056 <vmm_map_page+0xf9>
            pt[pt_offset] = PTE(tattr, pa);
c0107010:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107013:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0107018:	89 c1                	mov    %eax,%ecx
c010701a:	8b 45 14             	mov    0x14(%ebp),%eax
c010701d:	25 ff 0f 00 00       	and    $0xfff,%eax
c0107022:	89 c2                	mov    %eax,%edx
c0107024:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107027:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
c010702e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0107031:	01 d8                	add    %ebx,%eax
c0107033:	09 ca                	or     %ecx,%edx
c0107035:	89 10                	mov    %edx,(%eax)
            return V_ADDR(pd_offset, pt_offset, PG_OFFSET(va));
c0107037:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010703a:	c1 e0 16             	shl    $0x16,%eax
c010703d:	89 c2                	mov    %eax,%edx
c010703f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107042:	c1 e0 0c             	shl    $0xc,%eax
c0107045:	09 c2                	or     %eax,%edx
c0107047:	8b 45 08             	mov    0x8(%ebp),%eax
c010704a:	25 ff 0f 00 00       	and    $0xfff,%eax
c010704f:	09 d0                	or     %edx,%eax
c0107051:	e9 c8 00 00 00       	jmp    c010711e <vmm_map_page+0x1c1>
        }
        pt_offset++;
c0107056:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    while (pde && pd_offset < 1024) {
c010705a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c010705e:	74 0d                	je     c010706d <vmm_map_page+0x110>
c0107060:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
c0107067:	0f 86 52 ff ff ff    	jbe    c0106fbf <vmm_map_page+0x62>
    }
    
    // 页目录与所有页表已满！
    if (pd_offset > 1024) {
c010706d:	81 7d f4 00 04 00 00 	cmpl   $0x400,-0xc(%ebp)
c0107074:	76 0a                	jbe    c0107080 <vmm_map_page+0x123>
        return NULL;
c0107076:	b8 00 00 00 00       	mov    $0x0,%eax
c010707b:	e9 9e 00 00 00       	jmp    c010711e <vmm_map_page+0x1c1>
    }

    // 页目录有空位，需要开辟一个新的 PDE
    uint8_t* new_pt_pa = pmm_alloc_page();
c0107080:	e8 71 f7 ff ff       	call   c01067f6 <pmm_alloc_page>
c0107085:	89 45 e0             	mov    %eax,-0x20(%ebp)
    
    // 物理内存已满！
    if (!new_pt_pa) {
c0107088:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c010708c:	75 0a                	jne    c0107098 <vmm_map_page+0x13b>
        return NULL;
c010708e:	b8 00 00 00 00       	mov    $0x0,%eax
c0107093:	e9 86 00 00 00       	jmp    c010711e <vmm_map_page+0x1c1>
    }
    
    ptd[pd_offset] = PDE(dattr, new_pt_pa);
c0107098:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010709b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c01070a0:	89 c1                	mov    %eax,%ecx
c01070a2:	8b 45 10             	mov    0x10(%ebp),%eax
c01070a5:	25 ff 0f 00 00       	and    $0xfff,%eax
c01070aa:	89 c2                	mov    %eax,%edx
c01070ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01070af:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
c01070b6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01070b9:	01 d8                	add    %ebx,%eax
c01070bb:	09 ca                	or     %ecx,%edx
c01070bd:	89 10                	mov    %edx,(%eax)
    
    memset((void*)PT_VADDR(pd_offset), 0, PM_PAGE_SIZE);
c01070bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01070c2:	c1 e0 0c             	shl    $0xc,%eax
c01070c5:	0d 00 00 c0 ff       	or     $0xffc00000,%eax
c01070ca:	83 ec 04             	sub    $0x4,%esp
c01070cd:	68 00 10 00 00       	push   $0x1000
c01070d2:	6a 00                	push   $0x0
c01070d4:	50                   	push   %eax
c01070d5:	e8 b5 13 00 00       	call   c010848f <memset>
c01070da:	83 c4 10             	add    $0x10,%esp
    pt[pt_offset] = PTE(tattr, pa);
c01070dd:	8b 45 0c             	mov    0xc(%ebp),%eax
c01070e0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c01070e5:	89 c1                	mov    %eax,%ecx
c01070e7:	8b 45 14             	mov    0x14(%ebp),%eax
c01070ea:	25 ff 0f 00 00       	and    $0xfff,%eax
c01070ef:	89 c2                	mov    %eax,%edx
c01070f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01070f4:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
c01070fb:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01070fe:	01 d8                	add    %ebx,%eax
c0107100:	09 ca                	or     %ecx,%edx
c0107102:	89 10                	mov    %edx,(%eax)

    return V_ADDR(pd_offset, pt_offset, PG_OFFSET(va));
c0107104:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107107:	c1 e0 16             	shl    $0x16,%eax
c010710a:	89 c2                	mov    %eax,%edx
c010710c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010710f:	c1 e0 0c             	shl    $0xc,%eax
c0107112:	09 c2                	or     %eax,%edx
c0107114:	8b 45 08             	mov    0x8(%ebp),%eax
c0107117:	25 ff 0f 00 00       	and    $0xfff,%eax
c010711c:	09 d0                	or     %edx,%eax
}
c010711e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0107121:	c9                   	leave  
c0107122:	c3                   	ret    

c0107123 <vmm_alloc_page>:

void* vmm_alloc_page(void* vpn, pt_attr dattr, pt_attr tattr) {
c0107123:	55                   	push   %ebp
c0107124:	89 e5                	mov    %esp,%ebp
c0107126:	83 ec 18             	sub    $0x18,%esp
    void* pp = pmm_alloc_page();
c0107129:	e8 c8 f6 ff ff       	call   c01067f6 <pmm_alloc_page>
c010712e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    void* result = vmm_map_page(vpn, pp, dattr, tattr);
c0107131:	ff 75 10             	push   0x10(%ebp)
c0107134:	ff 75 0c             	push   0xc(%ebp)
c0107137:	ff 75 f4             	push   -0xc(%ebp)
c010713a:	ff 75 08             	push   0x8(%ebp)
c010713d:	e8 1b fe ff ff       	call   c0106f5d <vmm_map_page>
c0107142:	83 c4 10             	add    $0x10,%esp
c0107145:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (!result) {
c0107148:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c010714c:	75 0e                	jne    c010715c <vmm_alloc_page+0x39>
        pmm_free_page(pp);
c010714e:	83 ec 0c             	sub    $0xc,%esp
c0107151:	ff 75 f4             	push   -0xc(%ebp)
c0107154:	e8 85 f7 ff ff       	call   c01068de <pmm_free_page>
c0107159:	83 c4 10             	add    $0x10,%esp
    }
    return result;
c010715c:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c010715f:	c9                   	leave  
c0107160:	c3                   	ret    

c0107161 <vmm_unmap_page>:

void vmm_unmap_page(void* vpn) {
c0107161:	55                   	push   %ebp
c0107162:	89 e5                	mov    %esp,%ebp
c0107164:	83 ec 28             	sub    $0x28,%esp
    uintptr_t pd_offset = PD_INDEX(vpn);
c0107167:	8b 45 08             	mov    0x8(%ebp),%eax
c010716a:	c1 e8 16             	shr    $0x16,%eax
c010716d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uintptr_t pt_offset = PT_INDEX(vpn);
c0107170:	8b 45 08             	mov    0x8(%ebp),%eax
c0107173:	c1 e8 0c             	shr    $0xc,%eax
c0107176:	25 ff 03 00 00       	and    $0x3ff,%eax
c010717b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    ptd_t* self_pde = PTD_BASE_VADDR;
c010717e:	c7 45 ec 00 f0 ff ff 	movl   $0xfffff000,-0x14(%ebp)

    ptd_t pde = self_pde[pd_offset];
c0107185:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107188:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010718f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0107192:	01 d0                	add    %edx,%eax
c0107194:	8b 00                	mov    (%eax),%eax
c0107196:	89 45 e8             	mov    %eax,-0x18(%ebp)

    if (pde) {
c0107199:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c010719d:	74 5a                	je     c01071f9 <vmm_unmap_page+0x98>
        pt_t* pt = (pt_t*)PT_VADDR(pd_offset);
c010719f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01071a2:	c1 e0 0c             	shl    $0xc,%eax
c01071a5:	0d 00 00 c0 ff       	or     $0xffc00000,%eax
c01071aa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        uint32_t pte = pt[pt_offset];
c01071ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01071b0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c01071b7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01071ba:	01 d0                	add    %edx,%eax
c01071bc:	8b 00                	mov    (%eax),%eax
c01071be:	89 45 e0             	mov    %eax,-0x20(%ebp)
        if (IS_CACHED(pte) && pmm_free_page(pte)) {
c01071c1:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01071c4:	83 e0 01             	and    $0x1,%eax
c01071c7:	85 c0                	test   %eax,%eax
c01071c9:	74 19                	je     c01071e4 <vmm_unmap_page+0x83>
c01071cb:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01071ce:	83 ec 0c             	sub    $0xc,%esp
c01071d1:	50                   	push   %eax
c01071d2:	e8 07 f7 ff ff       	call   c01068de <pmm_free_page>
c01071d7:	83 c4 10             	add    $0x10,%esp
c01071da:	85 c0                	test   %eax,%eax
c01071dc:	74 06                	je     c01071e4 <vmm_unmap_page+0x83>
            // 刷新TLB
            #ifdef __ARCH_IA32
            __asm__("invlpg (%0)" :: "r"((uintptr_t)vpn) : "memory");
c01071de:	8b 45 08             	mov    0x8(%ebp),%eax
c01071e1:	0f 01 38             	invlpg (%eax)
            #endif
        }
        //if(pt_offset != 8)
        pt[pt_offset] = 0;
c01071e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01071e7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c01071ee:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01071f1:	01 d0                	add    %edx,%eax
c01071f3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
}
c01071f9:	90                   	nop
c01071fa:	c9                   	leave  
c01071fb:	c3                   	ret    

c01071fc <vmm_v2p>:

void* vmm_v2p(void* va) {
c01071fc:	55                   	push   %ebp
c01071fd:	89 e5                	mov    %esp,%ebp
c01071ff:	83 ec 20             	sub    $0x20,%esp
    uintptr_t pd_offset = PD_INDEX(va);
c0107202:	8b 45 08             	mov    0x8(%ebp),%eax
c0107205:	c1 e8 16             	shr    $0x16,%eax
c0107208:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uintptr_t pt_offset = PT_INDEX(va);
c010720b:	8b 45 08             	mov    0x8(%ebp),%eax
c010720e:	c1 e8 0c             	shr    $0xc,%eax
c0107211:	25 ff 03 00 00       	and    $0x3ff,%eax
c0107216:	89 45 f8             	mov    %eax,-0x8(%ebp)
    uintptr_t po = PG_OFFSET(va);
c0107219:	8b 45 08             	mov    0x8(%ebp),%eax
c010721c:	25 ff 0f 00 00       	and    $0xfff,%eax
c0107221:	89 45 f4             	mov    %eax,-0xc(%ebp)
    ptd_t* self_pde = PTD_BASE_VADDR;
c0107224:	c7 45 f0 00 f0 ff ff 	movl   $0xfffff000,-0x10(%ebp)

    ptd_t pde = self_pde[pd_offset];
c010722b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010722e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0107235:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107238:	01 d0                	add    %edx,%eax
c010723a:	8b 00                	mov    (%eax),%eax
c010723c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (pde) {
c010723f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0107243:	74 36                	je     c010727b <vmm_v2p+0x7f>
        pt_t pte = ((pt_t*)PT_VADDR(pd_offset))[pt_offset];
c0107245:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0107248:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010724f:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0107252:	c1 e0 0c             	shl    $0xc,%eax
c0107255:	0d 00 00 c0 ff       	or     $0xffc00000,%eax
c010725a:	01 d0                	add    %edx,%eax
c010725c:	8b 00                	mov    (%eax),%eax
c010725e:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if (pte) {
c0107261:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0107265:	74 14                	je     c010727b <vmm_v2p+0x7f>
            uintptr_t ppn = pte >> 12;
c0107267:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010726a:	c1 e8 0c             	shr    $0xc,%eax
c010726d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            return (void*)P_ADDR(ppn, po);
c0107270:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0107273:	c1 e0 0c             	shl    $0xc,%eax
c0107276:	0b 45 f4             	or     -0xc(%ebp),%eax
c0107279:	eb 05                	jmp    c0107280 <vmm_v2p+0x84>
        }
    }

    return NULL;
c010727b:	b8 00 00 00 00       	mov    $0x0,%eax
c0107280:	c9                   	leave  
c0107281:	c3                   	ret    

c0107282 <io_outb>:
                 : "memory", "cc");
}

static inline void
io_outb(int port, uint8_t data)
{
c0107282:	55                   	push   %ebp
c0107283:	89 e5                	mov    %esp,%ebp
c0107285:	83 ec 04             	sub    $0x4,%esp
c0107288:	8b 45 0c             	mov    0xc(%ebp),%eax
c010728b:	88 45 fc             	mov    %al,-0x4(%ebp)
    asm volatile("outb %0, %w1" : : "a"(data), "d"(port));
c010728e:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0107292:	8b 55 08             	mov    0x8(%ebp),%edx
c0107295:	ee                   	out    %al,(%dx)
}
c0107296:	90                   	nop
c0107297:	c9                   	leave  
c0107298:	c3                   	ret    

c0107299 <frequence_set>:
#define PIT_CONTROL_PORT 0X43

//WRITE COUNTER
static void frequence_set(uint8_t counter_port, uint8_t counter_no, 
                         uint8_t rwl, uint8_t counter_mode, uint16_t counter_value)
{
c0107299:	55                   	push   %ebp
c010729a:	89 e5                	mov    %esp,%ebp
c010729c:	57                   	push   %edi
c010729d:	56                   	push   %esi
c010729e:	53                   	push   %ebx
c010729f:	83 ec 14             	sub    $0x14,%esp
c01072a2:	8b 75 08             	mov    0x8(%ebp),%esi
c01072a5:	8b 5d 0c             	mov    0xc(%ebp),%ebx
c01072a8:	8b 4d 10             	mov    0x10(%ebp),%ecx
c01072ab:	8b 55 14             	mov    0x14(%ebp),%edx
c01072ae:	8b 7d 18             	mov    0x18(%ebp),%edi
c01072b1:	89 f0                	mov    %esi,%eax
c01072b3:	88 45 f0             	mov    %al,-0x10(%ebp)
c01072b6:	88 5d ec             	mov    %bl,-0x14(%ebp)
c01072b9:	88 4d e8             	mov    %cl,-0x18(%ebp)
c01072bc:	88 55 e4             	mov    %dl,-0x1c(%ebp)
c01072bf:	89 f8                	mov    %edi,%eax
c01072c1:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
    io_outb(PIT_CONTROL_PORT, (uint8_t)(counter_no << 6 | rwl << 4 | counter_mode << 1));
c01072c5:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c01072c9:	c1 e0 06             	shl    $0x6,%eax
c01072cc:	89 c2                	mov    %eax,%edx
c01072ce:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c01072d2:	c1 e0 04             	shl    $0x4,%eax
c01072d5:	09 c2                	or     %eax,%edx
c01072d7:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c01072db:	01 c0                	add    %eax,%eax
c01072dd:	09 d0                	or     %edx,%eax
c01072df:	0f b6 c0             	movzbl %al,%eax
c01072e2:	50                   	push   %eax
c01072e3:	6a 43                	push   $0x43
c01072e5:	e8 98 ff ff ff       	call   c0107282 <io_outb>
c01072ea:	83 c4 08             	add    $0x8,%esp
    io_outb(counter_port, (uint8_t)counter_value);
c01072ed:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
c01072f1:	0f b6 d0             	movzbl %al,%edx
c01072f4:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
c01072f8:	52                   	push   %edx
c01072f9:	50                   	push   %eax
c01072fa:	e8 83 ff ff ff       	call   c0107282 <io_outb>
c01072ff:	83 c4 08             	add    $0x8,%esp
    io_outb(counter_port, (uint8_t)(counter_value >> 8));
c0107302:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
c0107306:	66 c1 e8 08          	shr    $0x8,%ax
c010730a:	0f b6 d0             	movzbl %al,%edx
c010730d:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
c0107311:	52                   	push   %edx
c0107312:	50                   	push   %eax
c0107313:	e8 6a ff ff ff       	call   c0107282 <io_outb>
c0107318:	83 c4 08             	add    $0x8,%esp
}
c010731b:	90                   	nop
c010731c:	8d 65 f4             	lea    -0xc(%ebp),%esp
c010731f:	5b                   	pop    %ebx
c0107320:	5e                   	pop    %esi
c0107321:	5f                   	pop    %edi
c0107322:	5d                   	pop    %ebp
c0107323:	c3                   	ret    

c0107324 <timer_init>:

void timer_init(){
c0107324:	55                   	push   %ebp
c0107325:	89 e5                	mov    %esp,%ebp
c0107327:	83 ec 08             	sub    $0x8,%esp
    kprintf("timer intr start\n");
c010732a:	83 ec 0c             	sub    $0xc,%esp
c010732d:	68 4c b2 12 c0       	push   $0xc012b24c
c0107332:	e8 c1 0e 00 00       	call   c01081f8 <kprintf>
c0107337:	83 c4 10             	add    $0x10,%esp
    frequence_set(CURRENTR0_PORT, CURRENTR0_NO, READ_WRITE_LATCH, CURRENTR_MODE, CURRENTR0_VALUE);
c010733a:	83 ec 0c             	sub    $0xc,%esp
c010733d:	68 9b 2e 00 00       	push   $0x2e9b
c0107342:	6a 02                	push   $0x2
c0107344:	6a 03                	push   $0x3
c0107346:	6a 00                	push   $0x0
c0107348:	6a 40                	push   $0x40
c010734a:	e8 4a ff ff ff       	call   c0107299 <frequence_set>
c010734f:	83 c4 20             	add    $0x20,%esp
    kprintf("timer init down\n");
c0107352:	83 ec 0c             	sub    $0xc,%esp
c0107355:	68 5e b2 12 c0       	push   $0xc012b25e
c010735a:	e8 99 0e 00 00       	call   c01081f8 <kprintf>
c010735f:	83 c4 10             	add    $0x10,%esp
c0107362:	90                   	nop
c0107363:	c9                   	leave  
c0107364:	c3                   	ret    

c0107365 <_divide_err>:
#include <libs/mstdio.h>
#include <kernel/interrupt/interupt_fun.h>
#include <vga/vga.h>

void _divide_err(unsigned long addr, int err_code)
{
c0107365:	55                   	push   %ebp
c0107366:	89 e5                	mov    %esp,%ebp
c0107368:	83 ec 08             	sub    $0x8,%esp
    vga_set_show(1,VGA_COLOR_BLACK,VGA_COLOR_BLUE);
c010736b:	83 ec 04             	sub    $0x4,%esp
c010736e:	6a 01                	push   $0x1
c0107370:	6a 00                	push   $0x0
c0107372:	6a 01                	push   $0x1
c0107374:	e8 5b ed ff ff       	call   c01060d4 <vga_set_show>
c0107379:	83 c4 10             	add    $0x10,%esp
    kprintf("divide err addr = 0x%x,err code = %d\n", addr,err_code);
c010737c:	83 ec 04             	sub    $0x4,%esp
c010737f:	ff 75 0c             	push   0xc(%ebp)
c0107382:	ff 75 08             	push   0x8(%ebp)
c0107385:	68 70 b2 12 c0       	push   $0xc012b270
c010738a:	e8 69 0e 00 00       	call   c01081f8 <kprintf>
c010738f:	83 c4 10             	add    $0x10,%esp
}
c0107392:	90                   	nop
c0107393:	c9                   	leave  
c0107394:	c3                   	ret    

c0107395 <do_double_fault>:

void do_double_fault(unsigned long addr, int err_code)
{
c0107395:	55                   	push   %ebp
c0107396:	89 e5                	mov    %esp,%ebp
c0107398:	83 ec 08             	sub    $0x8,%esp
	kprintf("double_fault addr = 0x%x,err code = %d\n", addr,err_code);
c010739b:	83 ec 04             	sub    $0x4,%esp
c010739e:	ff 75 0c             	push   0xc(%ebp)
c01073a1:	ff 75 08             	push   0x8(%ebp)
c01073a4:	68 98 b2 12 c0       	push   $0xc012b298
c01073a9:	e8 4a 0e 00 00       	call   c01081f8 <kprintf>
c01073ae:	83 c4 10             	add    $0x10,%esp
}
c01073b1:	90                   	nop
c01073b2:	c9                   	leave  
c01073b3:	c3                   	ret    

c01073b4 <do_general_protection>:

void do_general_protection(unsigned long addr, int err_code)
{
c01073b4:	55                   	push   %ebp
c01073b5:	89 e5                	mov    %esp,%ebp
c01073b7:	83 ec 08             	sub    $0x8,%esp
	kprintf("general_protection addr = 0x%x,err code = %d\n", addr,err_code);
c01073ba:	83 ec 04             	sub    $0x4,%esp
c01073bd:	ff 75 0c             	push   0xc(%ebp)
c01073c0:	ff 75 08             	push   0x8(%ebp)
c01073c3:	68 c0 b2 12 c0       	push   $0xc012b2c0
c01073c8:	e8 2b 0e 00 00       	call   c01081f8 <kprintf>
c01073cd:	83 c4 10             	add    $0x10,%esp
}
c01073d0:	90                   	nop
c01073d1:	c9                   	leave  
c01073d2:	c3                   	ret    

c01073d3 <do_int3>:


void do_int3(unsigned long addr, int err_code)
{
c01073d3:	55                   	push   %ebp
c01073d4:	89 e5                	mov    %esp,%ebp
c01073d6:	83 ec 08             	sub    $0x8,%esp
    kprintf("int3 addr = 0x%x,err code = %d\n", addr,err_code);
c01073d9:	83 ec 04             	sub    $0x4,%esp
c01073dc:	ff 75 0c             	push   0xc(%ebp)
c01073df:	ff 75 08             	push   0x8(%ebp)
c01073e2:	68 f0 b2 12 c0       	push   $0xc012b2f0
c01073e7:	e8 0c 0e 00 00       	call   c01081f8 <kprintf>
c01073ec:	83 c4 10             	add    $0x10,%esp
}
c01073ef:	90                   	nop
c01073f0:	c9                   	leave  
c01073f1:	c3                   	ret    

c01073f2 <do_nmi>:

void do_nmi(unsigned long addr, int err_code)
{
c01073f2:	55                   	push   %ebp
c01073f3:	89 e5                	mov    %esp,%ebp
c01073f5:	83 ec 08             	sub    $0x8,%esp
	kprintf("nmi addr = 0x%x,err code = %d\n", addr,err_code);
c01073f8:	83 ec 04             	sub    $0x4,%esp
c01073fb:	ff 75 0c             	push   0xc(%ebp)
c01073fe:	ff 75 08             	push   0x8(%ebp)
c0107401:	68 10 b3 12 c0       	push   $0xc012b310
c0107406:	e8 ed 0d 00 00       	call   c01081f8 <kprintf>
c010740b:	83 c4 10             	add    $0x10,%esp
}
c010740e:	90                   	nop
c010740f:	c9                   	leave  
c0107410:	c3                   	ret    

c0107411 <do_debug>:

void do_debug(unsigned long addr, int err_code)
{
c0107411:	55                   	push   %ebp
c0107412:	89 e5                	mov    %esp,%ebp
c0107414:	83 ec 08             	sub    $0x8,%esp
	kprintf("debug addr = 0x%x,err code = %d\n", addr,err_code);
c0107417:	83 ec 04             	sub    $0x4,%esp
c010741a:	ff 75 0c             	push   0xc(%ebp)
c010741d:	ff 75 08             	push   0x8(%ebp)
c0107420:	68 30 b3 12 c0       	push   $0xc012b330
c0107425:	e8 ce 0d 00 00       	call   c01081f8 <kprintf>
c010742a:	83 c4 10             	add    $0x10,%esp
}
c010742d:	90                   	nop
c010742e:	c9                   	leave  
c010742f:	c3                   	ret    

c0107430 <do_overflow>:

void do_overflow(unsigned long addr, int err_code)
{
c0107430:	55                   	push   %ebp
c0107431:	89 e5                	mov    %esp,%ebp
c0107433:	83 ec 08             	sub    $0x8,%esp
	kprintf("overflow addr = 0x%x,err code = %d\n", addr,err_code);
c0107436:	83 ec 04             	sub    $0x4,%esp
c0107439:	ff 75 0c             	push   0xc(%ebp)
c010743c:	ff 75 08             	push   0x8(%ebp)
c010743f:	68 54 b3 12 c0       	push   $0xc012b354
c0107444:	e8 af 0d 00 00       	call   c01081f8 <kprintf>
c0107449:	83 c4 10             	add    $0x10,%esp
}
c010744c:	90                   	nop
c010744d:	c9                   	leave  
c010744e:	c3                   	ret    

c010744f <do_bounds>:

void do_bounds(unsigned long addr, int err_code)
{
c010744f:	55                   	push   %ebp
c0107450:	89 e5                	mov    %esp,%ebp
c0107452:	83 ec 08             	sub    $0x8,%esp
	kprintf("bounds addr = 0x%x,err code = %d\n", addr,err_code);
c0107455:	83 ec 04             	sub    $0x4,%esp
c0107458:	ff 75 0c             	push   0xc(%ebp)
c010745b:	ff 75 08             	push   0x8(%ebp)
c010745e:	68 78 b3 12 c0       	push   $0xc012b378
c0107463:	e8 90 0d 00 00       	call   c01081f8 <kprintf>
c0107468:	83 c4 10             	add    $0x10,%esp
}
c010746b:	90                   	nop
c010746c:	c9                   	leave  
c010746d:	c3                   	ret    

c010746e <do_invalid_op>:

void do_invalid_op(unsigned long addr, int err_code)
{
c010746e:	55                   	push   %ebp
c010746f:	89 e5                	mov    %esp,%ebp
c0107471:	83 ec 08             	sub    $0x8,%esp
	kprintf("invalid_op addr = 0x%x,err code = %d\n", addr,err_code);
c0107474:	83 ec 04             	sub    $0x4,%esp
c0107477:	ff 75 0c             	push   0xc(%ebp)
c010747a:	ff 75 08             	push   0x8(%ebp)
c010747d:	68 9c b3 12 c0       	push   $0xc012b39c
c0107482:	e8 71 0d 00 00       	call   c01081f8 <kprintf>
c0107487:	83 c4 10             	add    $0x10,%esp
}
c010748a:	90                   	nop
c010748b:	c9                   	leave  
c010748c:	c3                   	ret    

c010748d <do_device_not_available>:

void do_device_not_available(unsigned long addr, int err_code)
{
c010748d:	55                   	push   %ebp
c010748e:	89 e5                	mov    %esp,%ebp
c0107490:	83 ec 08             	sub    $0x8,%esp
	kprintf("device_not_availabel addr = 0x%x,err code = %d\n", addr,err_code);
c0107493:	83 ec 04             	sub    $0x4,%esp
c0107496:	ff 75 0c             	push   0xc(%ebp)
c0107499:	ff 75 08             	push   0x8(%ebp)
c010749c:	68 c4 b3 12 c0       	push   $0xc012b3c4
c01074a1:	e8 52 0d 00 00       	call   c01081f8 <kprintf>
c01074a6:	83 c4 10             	add    $0x10,%esp
}
c01074a9:	90                   	nop
c01074aa:	c9                   	leave  
c01074ab:	c3                   	ret    

c01074ac <do_coprocessor_segment_overrun>:

void do_coprocessor_segment_overrun(unsigned long addr, int err_code)
{
c01074ac:	55                   	push   %ebp
c01074ad:	89 e5                	mov    %esp,%ebp
c01074af:	83 ec 08             	sub    $0x8,%esp
	kprintf("coprprocessor_segment_overrun addr = 0x%x,err code = %d\n", addr,err_code);
c01074b2:	83 ec 04             	sub    $0x4,%esp
c01074b5:	ff 75 0c             	push   0xc(%ebp)
c01074b8:	ff 75 08             	push   0x8(%ebp)
c01074bb:	68 f4 b3 12 c0       	push   $0xc012b3f4
c01074c0:	e8 33 0d 00 00       	call   c01081f8 <kprintf>
c01074c5:	83 c4 10             	add    $0x10,%esp
}
c01074c8:	90                   	nop
c01074c9:	c9                   	leave  
c01074ca:	c3                   	ret    

c01074cb <do_invalid_TSS>:

void do_invalid_TSS(unsigned long addr, int err_code)
{
c01074cb:	55                   	push   %ebp
c01074cc:	89 e5                	mov    %esp,%ebp
c01074ce:	83 ec 08             	sub    $0x8,%esp
	kprintf("invalid_TSS addr = 0x%x,err code = %d\n", addr,err_code);
c01074d1:	83 ec 04             	sub    $0x4,%esp
c01074d4:	ff 75 0c             	push   0xc(%ebp)
c01074d7:	ff 75 08             	push   0x8(%ebp)
c01074da:	68 30 b4 12 c0       	push   $0xc012b430
c01074df:	e8 14 0d 00 00       	call   c01081f8 <kprintf>
c01074e4:	83 c4 10             	add    $0x10,%esp
}
c01074e7:	90                   	nop
c01074e8:	c9                   	leave  
c01074e9:	c3                   	ret    

c01074ea <do_segment_not_present>:

void do_segment_not_present(unsigned long addr, int err_code)
{
c01074ea:	55                   	push   %ebp
c01074eb:	89 e5                	mov    %esp,%ebp
c01074ed:	83 ec 08             	sub    $0x8,%esp
	kprintf("segment not present addr = 0x%x,err code = %d\n", addr,err_code);
c01074f0:	83 ec 04             	sub    $0x4,%esp
c01074f3:	ff 75 0c             	push   0xc(%ebp)
c01074f6:	ff 75 08             	push   0x8(%ebp)
c01074f9:	68 58 b4 12 c0       	push   $0xc012b458
c01074fe:	e8 f5 0c 00 00       	call   c01081f8 <kprintf>
c0107503:	83 c4 10             	add    $0x10,%esp
}
c0107506:	90                   	nop
c0107507:	c9                   	leave  
c0107508:	c3                   	ret    

c0107509 <do_stack_segment>:

void do_stack_segment(unsigned long addr, int err_code)
{
c0107509:	55                   	push   %ebp
c010750a:	89 e5                	mov    %esp,%ebp
c010750c:	83 ec 08             	sub    $0x8,%esp
	kprintf("stack_segment addr = 0x%x,err code = %d\n", addr,err_code);
c010750f:	83 ec 04             	sub    $0x4,%esp
c0107512:	ff 75 0c             	push   0xc(%ebp)
c0107515:	ff 75 08             	push   0x8(%ebp)
c0107518:	68 88 b4 12 c0       	push   $0xc012b488
c010751d:	e8 d6 0c 00 00       	call   c01081f8 <kprintf>
c0107522:	83 c4 10             	add    $0x10,%esp
}
c0107525:	90                   	nop
c0107526:	c9                   	leave  
c0107527:	c3                   	ret    

c0107528 <do_coprocessor_error>:

void do_coprocessor_error(unsigned long addr, int err_code)
{
c0107528:	55                   	push   %ebp
c0107529:	89 e5                	mov    %esp,%ebp
c010752b:	83 ec 08             	sub    $0x8,%esp
    kprintf("coprocessor_err addr = 0x%x,err code = %d\n", addr,err_code);
c010752e:	83 ec 04             	sub    $0x4,%esp
c0107531:	ff 75 0c             	push   0xc(%ebp)
c0107534:	ff 75 08             	push   0x8(%ebp)
c0107537:	68 b4 b4 12 c0       	push   $0xc012b4b4
c010753c:	e8 b7 0c 00 00       	call   c01081f8 <kprintf>
c0107541:	83 c4 10             	add    $0x10,%esp
}
c0107544:	90                   	nop
c0107545:	c9                   	leave  
c0107546:	c3                   	ret    

c0107547 <do_reserved>:

void do_reserved(unsigned long addr, int err_code)
{
c0107547:	55                   	push   %ebp
c0107548:	89 e5                	mov    %esp,%ebp
c010754a:	83 ec 08             	sub    $0x8,%esp
	kprintf("reserved addr = 0x%x,err code = %d\n", addr,err_code);
c010754d:	83 ec 04             	sub    $0x4,%esp
c0107550:	ff 75 0c             	push   0xc(%ebp)
c0107553:	ff 75 08             	push   0x8(%ebp)
c0107556:	68 e0 b4 12 c0       	push   $0xc012b4e0
c010755b:	e8 98 0c 00 00       	call   c01081f8 <kprintf>
c0107560:	83 c4 10             	add    $0x10,%esp
}
c0107563:	90                   	nop
c0107564:	c9                   	leave  
c0107565:	c3                   	ret    

c0107566 <_no_err_code>:
c0107566:	87 04 24             	xchg   %eax,(%esp)
c0107569:	53                   	push   %ebx
c010756a:	52                   	push   %edx
c010756b:	55                   	push   %ebp
c010756c:	1e                   	push   %ds
c010756d:	06                   	push   %es
c010756e:	0f a0                	push   %fs
c0107570:	6a 00                	push   $0x0
c0107572:	8d 54 24 20          	lea    0x20(%esp),%edx
c0107576:	52                   	push   %edx
c0107577:	ba 10 00 00 00       	mov    $0x10,%edx
c010757c:	8e da                	mov    %edx,%ds
c010757e:	8e c2                	mov    %edx,%es
c0107580:	8e e2                	mov    %edx,%fs
c0107582:	ff d0                	call   *%eax
c0107584:	83 c4 08             	add    $0x8,%esp
c0107587:	0f a1                	pop    %fs
c0107589:	07                   	pop    %es
c010758a:	1f                   	pop    %ds
c010758b:	5d                   	pop    %ebp
c010758c:	5a                   	pop    %edx
c010758d:	5b                   	pop    %ebx
c010758e:	58                   	pop    %eax
c010758f:	cf                   	iret   

c0107590 <_err_code>:
c0107590:	87 44 24 04          	xchg   %eax,0x4(%esp)
c0107594:	87 1c 24             	xchg   %ebx,(%esp)
c0107597:	52                   	push   %edx
c0107598:	55                   	push   %ebp
c0107599:	1e                   	push   %ds
c010759a:	06                   	push   %es
c010759b:	0f a0                	push   %fs
c010759d:	50                   	push   %eax
c010759e:	8d 44 24 20          	lea    0x20(%esp),%eax
c01075a2:	50                   	push   %eax
c01075a3:	b8 10 00 00 00       	mov    $0x10,%eax
c01075a8:	8e d8                	mov    %eax,%ds
c01075aa:	8e c0                	mov    %eax,%es
c01075ac:	8e e0                	mov    %eax,%fs
c01075ae:	ff d3                	call   *%ebx
c01075b0:	83 c4 08             	add    $0x8,%esp
c01075b3:	0f a1                	pop    %fs
c01075b5:	07                   	pop    %es
c01075b6:	1f                   	pop    %ds
c01075b7:	5d                   	pop    %ebp
c01075b8:	5a                   	pop    %edx
c01075b9:	5b                   	pop    %ebx
c01075ba:	58                   	pop    %eax
c01075bb:	cf                   	iret   

c01075bc <divide_error>:
c01075bc:	68 65 73 10 c0       	push   $0xc0107365
c01075c1:	eb a3                	jmp    c0107566 <_no_err_code>

c01075c3 <debug>:
c01075c3:	68 d3 73 10 c0       	push   $0xc01073d3
c01075c8:	eb 9c                	jmp    c0107566 <_no_err_code>

c01075ca <nmi>:
c01075ca:	68 f2 73 10 c0       	push   $0xc01073f2
c01075cf:	eb 95                	jmp    c0107566 <_no_err_code>

c01075d1 <int3>:
c01075d1:	68 d3 73 10 c0       	push   $0xc01073d3
c01075d6:	eb 8e                	jmp    c0107566 <_no_err_code>

c01075d8 <overflow>:
c01075d8:	68 30 74 10 c0       	push   $0xc0107430
c01075dd:	eb 87                	jmp    c0107566 <_no_err_code>

c01075df <bounds>:
c01075df:	68 4f 74 10 c0       	push   $0xc010744f
c01075e4:	eb 80                	jmp    c0107566 <_no_err_code>

c01075e6 <invalid_op>:
c01075e6:	68 6e 74 10 c0       	push   $0xc010746e
c01075eb:	e9 76 ff ff ff       	jmp    c0107566 <_no_err_code>

c01075f0 <coprocessor_segment_overrun>:
c01075f0:	68 ac 74 10 c0       	push   $0xc01074ac
c01075f5:	e9 6c ff ff ff       	jmp    c0107566 <_no_err_code>

c01075fa <reserved>:
c01075fa:	68 47 75 10 c0       	push   $0xc0107547
c01075ff:	e9 62 ff ff ff       	jmp    c0107566 <_no_err_code>

c0107604 <invalid_TSS>:
c0107604:	68 cb 74 10 c0       	push   $0xc01074cb
c0107609:	eb 85                	jmp    c0107590 <_err_code>

c010760b <segment_not_present>:
c010760b:	68 ea 74 10 c0       	push   $0xc01074ea
c0107610:	e9 7b ff ff ff       	jmp    c0107590 <_err_code>

c0107615 <stack_segment>:
c0107615:	68 09 75 10 c0       	push   $0xc0107509
c010761a:	e9 71 ff ff ff       	jmp    c0107590 <_err_code>

c010761f <general_protection>:
c010761f:	68 b4 73 10 c0       	push   $0xc01073b4
c0107624:	e9 67 ff ff ff       	jmp    c0107590 <_err_code>

c0107629 <__get_cpuid_max>:
   pointer is non-null, then first four bytes of the signature
   (as found in ebx register) are returned in location pointed by sig.  */

static __inline unsigned int
__get_cpuid_max (unsigned int __ext, unsigned int *__sig)
{
c0107629:	55                   	push   %ebp
c010762a:	89 e5                	mov    %esp,%ebp
c010762c:	53                   	push   %ebx
c010762d:	83 ec 10             	sub    $0x10,%esp
  unsigned int __eax, __ebx, __ecx, __edx;

#ifndef __x86_64__
  /* See if we can use cpuid.  On AMD64 we always can.  */
#if __GNUC__ >= 3
  __asm__ ("pushf{l|d}\n\t"
c0107630:	9c                   	pushf  
c0107631:	9c                   	pushf  
c0107632:	5a                   	pop    %edx
c0107633:	89 d0                	mov    %edx,%eax
c0107635:	81 f2 00 00 20 00    	xor    $0x200000,%edx
c010763b:	52                   	push   %edx
c010763c:	9d                   	popf   
c010763d:	9c                   	pushf  
c010763e:	5a                   	pop    %edx
c010763f:	9d                   	popf   
c0107640:	89 55 f8             	mov    %edx,-0x8(%ebp)
c0107643:	89 45 f4             	mov    %eax,-0xc(%ebp)
	   "popfl\n\t"
	   : "=&r" (__eax), "=&r" (__ebx)
	   : "i" (0x00200000));
#endif

  if (!((__eax ^ __ebx) & 0x00200000))
c0107646:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0107649:	33 45 f4             	xor    -0xc(%ebp),%eax
c010764c:	25 00 00 20 00       	and    $0x200000,%eax
c0107651:	85 c0                	test   %eax,%eax
c0107653:	75 07                	jne    c010765c <__get_cpuid_max+0x33>
    return 0;
c0107655:	b8 00 00 00 00       	mov    $0x0,%eax
c010765a:	eb 30                	jmp    c010768c <__get_cpuid_max+0x63>
#endif

  /* Host supports cpuid.  Return highest supported cpuid input value.  */
  __cpuid (__ext, __eax, __ebx, __ecx, __edx);
c010765c:	8b 45 08             	mov    0x8(%ebp),%eax
c010765f:	b9 00 00 00 00       	mov    $0x0,%ecx
c0107664:	ba 00 00 00 00       	mov    $0x0,%edx
c0107669:	89 cb                	mov    %ecx,%ebx
c010766b:	89 d1                	mov    %edx,%ecx
c010766d:	0f a2                	cpuid  
c010766f:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0107672:	89 5d f4             	mov    %ebx,-0xc(%ebp)
c0107675:	89 4d f0             	mov    %ecx,-0x10(%ebp)
c0107678:	89 55 ec             	mov    %edx,-0x14(%ebp)

  if (__sig)
c010767b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c010767f:	74 08                	je     c0107689 <__get_cpuid_max+0x60>
    *__sig = __ebx;
c0107681:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107684:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0107687:	89 10                	mov    %edx,(%eax)

  return __eax;
c0107689:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
c010768c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010768f:	c9                   	leave  
c0107690:	c3                   	ret    

c0107691 <__get_cpuid>:

static __inline int
__get_cpuid (unsigned int __leaf,
	     unsigned int *__eax, unsigned int *__ebx,
	     unsigned int *__ecx, unsigned int *__edx)
{
c0107691:	55                   	push   %ebp
c0107692:	89 e5                	mov    %esp,%ebp
c0107694:	56                   	push   %esi
c0107695:	53                   	push   %ebx
c0107696:	83 ec 10             	sub    $0x10,%esp
  unsigned int __ext = __leaf & 0x80000000;
c0107699:	8b 45 08             	mov    0x8(%ebp),%eax
c010769c:	25 00 00 00 80       	and    $0x80000000,%eax
c01076a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned int __maxlevel = __get_cpuid_max (__ext, 0);
c01076a4:	6a 00                	push   $0x0
c01076a6:	ff 75 f4             	push   -0xc(%ebp)
c01076a9:	e8 7b ff ff ff       	call   c0107629 <__get_cpuid_max>
c01076ae:	83 c4 08             	add    $0x8,%esp
c01076b1:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if (__maxlevel == 0 || __maxlevel < __leaf)
c01076b4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c01076b8:	74 08                	je     c01076c2 <__get_cpuid+0x31>
c01076ba:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01076bd:	3b 45 08             	cmp    0x8(%ebp),%eax
c01076c0:	73 07                	jae    c01076c9 <__get_cpuid+0x38>
    return 0;
c01076c2:	b8 00 00 00 00       	mov    $0x0,%eax
c01076c7:	eb 2c                	jmp    c01076f5 <__get_cpuid+0x64>

  __cpuid (__leaf, *__eax, *__ebx, *__ecx, *__edx);
c01076c9:	8b 45 08             	mov    0x8(%ebp),%eax
c01076cc:	b9 00 00 00 00       	mov    $0x0,%ecx
c01076d1:	ba 00 00 00 00       	mov    $0x0,%edx
c01076d6:	89 cb                	mov    %ecx,%ebx
c01076d8:	89 d1                	mov    %edx,%ecx
c01076da:	0f a2                	cpuid  
c01076dc:	8b 75 0c             	mov    0xc(%ebp),%esi
c01076df:	89 06                	mov    %eax,(%esi)
c01076e1:	8b 45 10             	mov    0x10(%ebp),%eax
c01076e4:	89 18                	mov    %ebx,(%eax)
c01076e6:	8b 45 14             	mov    0x14(%ebp),%eax
c01076e9:	89 08                	mov    %ecx,(%eax)
c01076eb:	8b 45 18             	mov    0x18(%ebp),%eax
c01076ee:	89 10                	mov    %edx,(%eax)
  return 1;
c01076f0:	b8 01 00 00 00       	mov    $0x1,%eax
}
c01076f5:	8d 65 f8             	lea    -0x8(%ebp),%esp
c01076f8:	5b                   	pop    %ebx
c01076f9:	5e                   	pop    %esi
c01076fa:	5d                   	pop    %ebp
c01076fb:	c3                   	ret    

c01076fc <cpu_get_model>:
#include <kernel/cpu/cpu.h>
#include <stdint.h>
#include <cpuid.h>

void cpu_get_model(char* model_out) {
c01076fc:	55                   	push   %ebp
c01076fd:	89 e5                	mov    %esp,%ebp
c01076ff:	83 ec 20             	sub    $0x20,%esp
    uint32_t* out = (uint32_t*)model_out;
c0107702:	8b 45 08             	mov    0x8(%ebp),%eax
c0107705:	89 45 fc             	mov    %eax,-0x4(%ebp)
    reg32 eax, ebx, edx, ecx;
    
    __get_cpuid(0, &eax, &ebx, &ecx, &edx);
c0107708:	8d 45 f0             	lea    -0x10(%ebp),%eax
c010770b:	50                   	push   %eax
c010770c:	8d 45 ec             	lea    -0x14(%ebp),%eax
c010770f:	50                   	push   %eax
c0107710:	8d 45 f4             	lea    -0xc(%ebp),%eax
c0107713:	50                   	push   %eax
c0107714:	8d 45 f8             	lea    -0x8(%ebp),%eax
c0107717:	50                   	push   %eax
c0107718:	6a 00                	push   $0x0
c010771a:	e8 72 ff ff ff       	call   c0107691 <__get_cpuid>
c010771f:	83 c4 14             	add    $0x14,%esp

    out[0] = ebx;
c0107722:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0107725:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0107728:	89 10                	mov    %edx,(%eax)
    out[1] = edx;
c010772a:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010772d:	8d 50 04             	lea    0x4(%eax),%edx
c0107730:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107733:	89 02                	mov    %eax,(%edx)
    out[2] = ecx;
c0107735:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0107738:	8d 50 08             	lea    0x8(%eax),%edx
c010773b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010773e:	89 02                	mov    %eax,(%edx)
    model_out[12] = '\0';
c0107740:	8b 45 08             	mov    0x8(%ebp),%eax
c0107743:	83 c0 0c             	add    $0xc,%eax
c0107746:	c6 00 00             	movb   $0x0,(%eax)
}
c0107749:	90                   	nop
c010774a:	c9                   	leave  
c010774b:	c3                   	ret    

c010774c <cpu_brand_string_supported>:

#define BRAND_LEAF 0x80000000UL

int cpu_brand_string_supported() {
c010774c:	55                   	push   %ebp
c010774d:	89 e5                	mov    %esp,%ebp
c010774f:	83 ec 10             	sub    $0x10,%esp
    reg32 supported = __get_cpuid_max(BRAND_LEAF, 0);
c0107752:	6a 00                	push   $0x0
c0107754:	68 00 00 00 80       	push   $0x80000000
c0107759:	e8 cb fe ff ff       	call   c0107629 <__get_cpuid_max>
c010775e:	83 c4 08             	add    $0x8,%esp
c0107761:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return (supported >= 0x80000004UL);
c0107764:	81 7d fc 03 00 00 80 	cmpl   $0x80000003,-0x4(%ebp)
c010776b:	0f 97 c0             	seta   %al
c010776e:	0f b6 c0             	movzbl %al,%eax
}
c0107771:	c9                   	leave  
c0107772:	c3                   	ret    

c0107773 <cpu_get_brand>:

void cpu_get_brand(char* brand_out) {
c0107773:	55                   	push   %ebp
c0107774:	89 e5                	mov    %esp,%ebp
c0107776:	83 ec 20             	sub    $0x20,%esp
    if(!cpu_brand_string_supported()) {
c0107779:	e8 ce ff ff ff       	call   c010774c <cpu_brand_string_supported>
c010777e:	85 c0                	test   %eax,%eax
c0107780:	75 0f                	jne    c0107791 <cpu_get_brand+0x1e>
        brand_out[0] = '?';
c0107782:	8b 45 08             	mov    0x8(%ebp),%eax
c0107785:	c6 00 3f             	movb   $0x3f,(%eax)
        brand_out[1] = '\0';
c0107788:	8b 45 08             	mov    0x8(%ebp),%eax
c010778b:	83 c0 01             	add    $0x1,%eax
c010778e:	c6 00 00             	movb   $0x0,(%eax)
    }
    uint32_t* out = (uint32_t*) brand_out;
c0107791:	8b 45 08             	mov    0x8(%ebp),%eax
c0107794:	89 45 f4             	mov    %eax,-0xc(%ebp)
    reg32 eax, ebx, edx, ecx;
    for (uint32_t i = 2, j = 0; i < 5; i++)
c0107797:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
c010779e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c01077a5:	e9 83 00 00 00       	jmp    c010782d <cpu_get_brand+0xba>
    {
        __get_cpuid(BRAND_LEAF + i, &eax, &ebx, &ecx, &edx);
c01077aa:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01077ad:	8d 90 00 00 00 80    	lea    -0x80000000(%eax),%edx
c01077b3:	8d 45 e8             	lea    -0x18(%ebp),%eax
c01077b6:	50                   	push   %eax
c01077b7:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c01077ba:	50                   	push   %eax
c01077bb:	8d 45 ec             	lea    -0x14(%ebp),%eax
c01077be:	50                   	push   %eax
c01077bf:	8d 45 f0             	lea    -0x10(%ebp),%eax
c01077c2:	50                   	push   %eax
c01077c3:	52                   	push   %edx
c01077c4:	e8 c8 fe ff ff       	call   c0107691 <__get_cpuid>
c01077c9:	83 c4 14             	add    $0x14,%esp
        out[j] = eax;
c01077cc:	8b 45 f8             	mov    -0x8(%ebp),%eax
c01077cf:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c01077d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01077d9:	01 c2                	add    %eax,%edx
c01077db:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01077de:	89 02                	mov    %eax,(%edx)
        out[j + 1] = ebx;
c01077e0:	8b 45 f8             	mov    -0x8(%ebp),%eax
c01077e3:	83 c0 01             	add    $0x1,%eax
c01077e6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c01077ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01077f0:	01 c2                	add    %eax,%edx
c01077f2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01077f5:	89 02                	mov    %eax,(%edx)
        out[j + 2] = ecx;
c01077f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
c01077fa:	83 c0 02             	add    $0x2,%eax
c01077fd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0107804:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107807:	01 c2                	add    %eax,%edx
c0107809:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010780c:	89 02                	mov    %eax,(%edx)
        out[j + 3] = edx;
c010780e:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0107811:	83 c0 03             	add    $0x3,%eax
c0107814:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010781b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010781e:	01 c2                	add    %eax,%edx
c0107820:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0107823:	89 02                	mov    %eax,(%edx)
        j+=4;
c0107825:	83 45 f8 04          	addl   $0x4,-0x8(%ebp)
    for (uint32_t i = 2, j = 0; i < 5; i++)
c0107829:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c010782d:	83 7d fc 04          	cmpl   $0x4,-0x4(%ebp)
c0107831:	0f 86 73 ff ff ff    	jbe    c01077aa <cpu_get_brand+0x37>
    }
    brand_out[48] = '\0';
c0107837:	8b 45 08             	mov    0x8(%ebp),%eax
c010783a:	83 c0 30             	add    $0x30,%eax
c010783d:	c6 00 00             	movb   $0x0,(%eax)
}
c0107840:	90                   	nop
c0107841:	c9                   	leave  
c0107842:	c3                   	ret    

c0107843 <cpu_r_cr0>:

reg32 cpu_r_cr0() {
c0107843:	55                   	push   %ebp
c0107844:	89 e5                	mov    %esp,%ebp
    asm volatile ("mov %cr0, %eax");
c0107846:	0f 20 c0             	mov    %cr0,%eax
}
c0107849:	90                   	nop
c010784a:	5d                   	pop    %ebp
c010784b:	c3                   	ret    

c010784c <cpu_r_cr2>:

reg32 cpu_r_cr2() {
c010784c:	55                   	push   %ebp
c010784d:	89 e5                	mov    %esp,%ebp
    asm volatile ("mov %cr2, %eax");
c010784f:	0f 20 d0             	mov    %cr2,%eax
}
c0107852:	90                   	nop
c0107853:	5d                   	pop    %ebp
c0107854:	c3                   	ret    

c0107855 <cpu_r_cr3>:

reg32 cpu_r_cr3() {
c0107855:	55                   	push   %ebp
c0107856:	89 e5                	mov    %esp,%ebp
    asm volatile ("mov %cr3, %eax");
c0107858:	0f 20 d8             	mov    %cr3,%eax
}
c010785b:	90                   	nop
c010785c:	5d                   	pop    %ebp
c010785d:	c3                   	ret    

c010785e <cpu_w_cr0>:

void cpu_w_cr0(reg32 v) {
c010785e:	55                   	push   %ebp
c010785f:	89 e5                	mov    %esp,%ebp
    asm volatile (
c0107861:	8b 45 08             	mov    0x8(%ebp),%eax
c0107864:	0f 22 c0             	mov    %eax,%cr0
        "mov %0, %%cr0"
        :: "r"(v)
    );
}
c0107867:	90                   	nop
c0107868:	5d                   	pop    %ebp
c0107869:	c3                   	ret    

c010786a <cpu_w_cr2>:

void cpu_w_cr2(reg32 v) {
c010786a:	55                   	push   %ebp
c010786b:	89 e5                	mov    %esp,%ebp
    asm volatile (
c010786d:	8b 45 08             	mov    0x8(%ebp),%eax
c0107870:	0f 22 d0             	mov    %eax,%cr2
        "mov %0, %%cr2"
        :: "r"(v)
    );
}
c0107873:	90                   	nop
c0107874:	5d                   	pop    %ebp
c0107875:	c3                   	ret    

c0107876 <cpu_w_cr3>:

void cpu_w_cr3(reg32 v) {
c0107876:	55                   	push   %ebp
c0107877:	89 e5                	mov    %esp,%ebp
    asm volatile (
c0107879:	8b 45 08             	mov    0x8(%ebp),%eax
c010787c:	0f 22 d8             	mov    %eax,%cr3
        "mov %0, %%cr3"
        :: "r"(v)
    );
}
c010787f:	90                   	nop
c0107880:	5d                   	pop    %ebp
c0107881:	c3                   	ret    

c0107882 <_set_gdt_entry>:
#define GDT_ENTRY 5

uint64_t _gdt[5];
uint16_t _gdt_limit = sizeof(_gdt) - 1;

void _set_gdt_entry(uint32_t index, uint32_t base, uint32_t limit, uint32_t flags) {
c0107882:	55                   	push   %ebp
c0107883:	89 e5                	mov    %esp,%ebp
c0107885:	57                   	push   %edi
c0107886:	56                   	push   %esi
c0107887:	53                   	push   %ebx
c0107888:	83 ec 0c             	sub    $0xc,%esp
    _gdt[index] = SEG_BASE_H(base) | flags | SEG_LIM_H(limit) | SEG_BASE_M(base);
c010788b:	8b 45 0c             	mov    0xc(%ebp),%eax
c010788e:	25 00 00 00 ff       	and    $0xff000000,%eax
c0107893:	0b 45 14             	or     0x14(%ebp),%eax
c0107896:	89 c2                	mov    %eax,%edx
c0107898:	8b 45 10             	mov    0x10(%ebp),%eax
c010789b:	25 00 00 0f 00       	and    $0xf0000,%eax
c01078a0:	09 c2                	or     %eax,%edx
c01078a2:	8b 45 0c             	mov    0xc(%ebp),%eax
c01078a5:	c1 e8 10             	shr    $0x10,%eax
c01078a8:	0f b6 c0             	movzbl %al,%eax
c01078ab:	09 d0                	or     %edx,%eax
c01078ad:	ba 00 00 00 00       	mov    $0x0,%edx
c01078b2:	8b 75 08             	mov    0x8(%ebp),%esi
c01078b5:	89 04 f5 60 90 12 c0 	mov    %eax,-0x3fed6fa0(,%esi,8)
c01078bc:	89 14 f5 64 90 12 c0 	mov    %edx,-0x3fed6f9c(,%esi,8)
    _gdt[index] <<= 32;
c01078c3:	8b 45 08             	mov    0x8(%ebp),%eax
c01078c6:	8b 14 c5 64 90 12 c0 	mov    -0x3fed6f9c(,%eax,8),%edx
c01078cd:	8b 04 c5 60 90 12 c0 	mov    -0x3fed6fa0(,%eax,8),%eax
c01078d4:	89 c2                	mov    %eax,%edx
c01078d6:	b8 00 00 00 00       	mov    $0x0,%eax
c01078db:	8b 75 08             	mov    0x8(%ebp),%esi
c01078de:	89 04 f5 60 90 12 c0 	mov    %eax,-0x3fed6fa0(,%esi,8)
c01078e5:	89 14 f5 64 90 12 c0 	mov    %edx,-0x3fed6f9c(,%esi,8)
    _gdt[index] |= SEG_BASE_L(base) | SEG_LIM_L(limit);
c01078ec:	8b 45 08             	mov    0x8(%ebp),%eax
c01078ef:	8b 14 c5 64 90 12 c0 	mov    -0x3fed6f9c(,%eax,8),%edx
c01078f6:	8b 04 c5 60 90 12 c0 	mov    -0x3fed6fa0(,%eax,8),%eax
c01078fd:	8b 75 0c             	mov    0xc(%ebp),%esi
c0107900:	89 f7                	mov    %esi,%edi
c0107902:	c1 e7 10             	shl    $0x10,%edi
c0107905:	8b 75 10             	mov    0x10(%ebp),%esi
c0107908:	0f b7 f6             	movzwl %si,%esi
c010790b:	09 fe                	or     %edi,%esi
c010790d:	bf 00 00 00 00       	mov    $0x0,%edi
c0107912:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0107915:	89 55 ec             	mov    %edx,-0x14(%ebp)
c0107918:	09 f0                	or     %esi,%eax
c010791a:	89 c1                	mov    %eax,%ecx
c010791c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010791f:	09 f8                	or     %edi,%eax
c0107921:	89 c3                	mov    %eax,%ebx
c0107923:	8b 45 08             	mov    0x8(%ebp),%eax
c0107926:	89 0c c5 60 90 12 c0 	mov    %ecx,-0x3fed6fa0(,%eax,8)
c010792d:	89 1c c5 64 90 12 c0 	mov    %ebx,-0x3fed6f9c(,%eax,8)
}
c0107934:	90                   	nop
c0107935:	83 c4 0c             	add    $0xc,%esp
c0107938:	5b                   	pop    %ebx
c0107939:	5e                   	pop    %esi
c010793a:	5f                   	pop    %edi
c010793b:	5d                   	pop    %ebp
c010793c:	c3                   	ret    

c010793d <_init_gdt>:
// 
void
_init_gdt() {
c010793d:	55                   	push   %ebp
c010793e:	89 e5                	mov    %esp,%ebp
    _set_gdt_entry(0, 0, 0, 0);
c0107940:	6a 00                	push   $0x0
c0107942:	6a 00                	push   $0x0
c0107944:	6a 00                	push   $0x0
c0107946:	6a 00                	push   $0x0
c0107948:	e8 35 ff ff ff       	call   c0107882 <_set_gdt_entry>
c010794d:	83 c4 10             	add    $0x10,%esp
    _set_gdt_entry(1, 0, 0xfffff, SEG_R0_CODE);
c0107950:	68 00 9a c0 00       	push   $0xc09a00
c0107955:	68 ff ff 0f 00       	push   $0xfffff
c010795a:	6a 00                	push   $0x0
c010795c:	6a 01                	push   $0x1
c010795e:	e8 1f ff ff ff       	call   c0107882 <_set_gdt_entry>
c0107963:	83 c4 10             	add    $0x10,%esp
    _set_gdt_entry(2, 0, 0xfffff, SEG_R0_DATA);
c0107966:	68 00 92 c0 00       	push   $0xc09200
c010796b:	68 ff ff 0f 00       	push   $0xfffff
c0107970:	6a 00                	push   $0x0
c0107972:	6a 02                	push   $0x2
c0107974:	e8 09 ff ff ff       	call   c0107882 <_set_gdt_entry>
c0107979:	83 c4 10             	add    $0x10,%esp
    _set_gdt_entry(3, 0, 0xfffff, SEG_R3_CODE);
c010797c:	68 00 fa c0 00       	push   $0xc0fa00
c0107981:	68 ff ff 0f 00       	push   $0xfffff
c0107986:	6a 00                	push   $0x0
c0107988:	6a 03                	push   $0x3
c010798a:	e8 f3 fe ff ff       	call   c0107882 <_set_gdt_entry>
c010798f:	83 c4 10             	add    $0x10,%esp
    _set_gdt_entry(4, 0, 0xfffff, SEG_R3_DATA);
c0107992:	68 00 f2 c0 00       	push   $0xc0f200
c0107997:	68 ff ff 0f 00       	push   $0xfffff
c010799c:	6a 00                	push   $0x0
c010799e:	6a 04                	push   $0x4
c01079a0:	e8 dd fe ff ff       	call   c0107882 <_set_gdt_entry>
c01079a5:	83 c4 10             	add    $0x10,%esp
c01079a8:	90                   	nop
c01079a9:	c9                   	leave  
c01079aa:	c3                   	ret    

c01079ab <_set_idt_entry>:
#define IDT_ENTRY 80

uint64_t _idt[IDT_ENTRY];
uint16_t _idt_limit = sizeof(_idt) - 1;

void _set_idt_entry(uint32_t vector, uint16_t seg_selector, void (*isr)(), uint8_t dpl) {
c01079ab:	55                   	push   %ebp
c01079ac:	89 e5                	mov    %esp,%ebp
c01079ae:	57                   	push   %edi
c01079af:	56                   	push   %esi
c01079b0:	53                   	push   %ebx
c01079b1:	83 ec 24             	sub    $0x24,%esp
c01079b4:	8b 45 0c             	mov    0xc(%ebp),%eax
c01079b7:	8b 55 14             	mov    0x14(%ebp),%edx
c01079ba:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
c01079be:	89 d0                	mov    %edx,%eax
c01079c0:	88 45 d8             	mov    %al,-0x28(%ebp)
    uintptr_t offset = (uintptr_t)isr;
c01079c3:	8b 45 10             	mov    0x10(%ebp),%eax
c01079c6:	89 45 ec             	mov    %eax,-0x14(%ebp)
    _idt[vector] = (offset & 0xffff0000) | IDT_ATTR(dpl);
c01079c9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01079cc:	66 b8 00 00          	mov    $0x0,%ax
c01079d0:	89 c2                	mov    %eax,%edx
c01079d2:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
c01079d6:	c1 e0 0d             	shl    $0xd,%eax
c01079d9:	25 00 60 00 00       	and    $0x6000,%eax
c01079de:	09 d0                	or     %edx,%eax
c01079e0:	80 cc 8e             	or     $0x8e,%ah
c01079e3:	ba 00 00 00 00       	mov    $0x0,%edx
c01079e8:	8b 75 08             	mov    0x8(%ebp),%esi
c01079eb:	89 04 f5 a0 90 12 c0 	mov    %eax,-0x3fed6f60(,%esi,8)
c01079f2:	89 14 f5 a4 90 12 c0 	mov    %edx,-0x3fed6f5c(,%esi,8)
    _idt[vector] <<= 32;
c01079f9:	8b 45 08             	mov    0x8(%ebp),%eax
c01079fc:	8b 14 c5 a4 90 12 c0 	mov    -0x3fed6f5c(,%eax,8),%edx
c0107a03:	8b 04 c5 a0 90 12 c0 	mov    -0x3fed6f60(,%eax,8),%eax
c0107a0a:	89 c2                	mov    %eax,%edx
c0107a0c:	b8 00 00 00 00       	mov    $0x0,%eax
c0107a11:	8b 75 08             	mov    0x8(%ebp),%esi
c0107a14:	89 04 f5 a0 90 12 c0 	mov    %eax,-0x3fed6f60(,%esi,8)
c0107a1b:	89 14 f5 a4 90 12 c0 	mov    %edx,-0x3fed6f5c(,%esi,8)
    _idt[vector] |= (seg_selector << 16) | (offset & 0x0000ffff);
c0107a22:	8b 45 08             	mov    0x8(%ebp),%eax
c0107a25:	8b 14 c5 a4 90 12 c0 	mov    -0x3fed6f5c(,%eax,8),%edx
c0107a2c:	8b 04 c5 a0 90 12 c0 	mov    -0x3fed6f60(,%eax,8),%eax
c0107a33:	0f b7 75 dc          	movzwl -0x24(%ebp),%esi
c0107a37:	c1 e6 10             	shl    $0x10,%esi
c0107a3a:	89 f7                	mov    %esi,%edi
c0107a3c:	8b 75 ec             	mov    -0x14(%ebp),%esi
c0107a3f:	0f b7 f6             	movzwl %si,%esi
c0107a42:	09 fe                	or     %edi,%esi
c0107a44:	bf 00 00 00 00       	mov    $0x0,%edi
c0107a49:	89 45 d0             	mov    %eax,-0x30(%ebp)
c0107a4c:	89 55 d4             	mov    %edx,-0x2c(%ebp)
c0107a4f:	09 f0                	or     %esi,%eax
c0107a51:	89 c1                	mov    %eax,%ecx
c0107a53:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0107a56:	09 f8                	or     %edi,%eax
c0107a58:	89 c3                	mov    %eax,%ebx
c0107a5a:	8b 45 08             	mov    0x8(%ebp),%eax
c0107a5d:	89 0c c5 a0 90 12 c0 	mov    %ecx,-0x3fed6f60(,%eax,8)
c0107a64:	89 1c c5 a4 90 12 c0 	mov    %ebx,-0x3fed6f5c(,%eax,8)
}
c0107a6b:	90                   	nop
c0107a6c:	83 c4 24             	add    $0x24,%esp
c0107a6f:	5b                   	pop    %ebx
c0107a70:	5e                   	pop    %esi
c0107a71:	5f                   	pop    %edi
c0107a72:	5d                   	pop    %ebp
c0107a73:	c3                   	ret    

c0107a74 <_init_idt>:

void _init_idt()
{
c0107a74:	55                   	push   %ebp
c0107a75:	89 e5                	mov    %esp,%ebp
c0107a77:	83 ec 10             	sub    $0x10,%esp
    _set_idt_entry(FAULT_DIVISION_ERROR, 0x08, &divide_error, 0);
c0107a7a:	6a 00                	push   $0x0
c0107a7c:	68 bc 75 10 c0       	push   $0xc01075bc
c0107a81:	6a 08                	push   $0x8
c0107a83:	6a 00                	push   $0x0
c0107a85:	e8 21 ff ff ff       	call   c01079ab <_set_idt_entry>
c0107a8a:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(FAULT_TRAP_DEBUG_EXCEPTION, 0x08, &debug, 0);
c0107a8d:	6a 00                	push   $0x0
c0107a8f:	68 c3 75 10 c0       	push   $0xc01075c3
c0107a94:	6a 08                	push   $0x8
c0107a96:	6a 01                	push   $0x1
c0107a98:	e8 0e ff ff ff       	call   c01079ab <_set_idt_entry>
c0107a9d:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(INT_NMI, 0x08, &nmi, 0);
c0107aa0:	6a 00                	push   $0x0
c0107aa2:	68 ca 75 10 c0       	push   $0xc01075ca
c0107aa7:	6a 08                	push   $0x8
c0107aa9:	6a 02                	push   $0x2
c0107aab:	e8 fb fe ff ff       	call   c01079ab <_set_idt_entry>
c0107ab0:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(TRAP_BREAKPOINT, 0x08, &int3, 0);
c0107ab3:	6a 00                	push   $0x0
c0107ab5:	68 d1 75 10 c0       	push   $0xc01075d1
c0107aba:	6a 08                	push   $0x8
c0107abc:	6a 03                	push   $0x3
c0107abe:	e8 e8 fe ff ff       	call   c01079ab <_set_idt_entry>
c0107ac3:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(TRAP_OVERFLOW, 0x08, &overflow, 0);
c0107ac6:	6a 00                	push   $0x0
c0107ac8:	68 d8 75 10 c0       	push   $0xc01075d8
c0107acd:	6a 08                	push   $0x8
c0107acf:	6a 04                	push   $0x4
c0107ad1:	e8 d5 fe ff ff       	call   c01079ab <_set_idt_entry>
c0107ad6:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(FAULT_BOUND_EXCEED, 0x08, &bounds, 0);
c0107ad9:	6a 00                	push   $0x0
c0107adb:	68 df 75 10 c0       	push   $0xc01075df
c0107ae0:	6a 08                	push   $0x8
c0107ae2:	6a 05                	push   $0x5
c0107ae4:	e8 c2 fe ff ff       	call   c01079ab <_set_idt_entry>
c0107ae9:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(FAULT_INVALID_OPCODE, 0x08, &invalid_op, 0);
c0107aec:	6a 00                	push   $0x0
c0107aee:	68 e6 75 10 c0       	push   $0xc01075e6
c0107af3:	6a 08                	push   $0x8
c0107af5:	6a 06                	push   $0x6
c0107af7:	e8 af fe ff ff       	call   c01079ab <_set_idt_entry>
c0107afc:	83 c4 10             	add    $0x10,%esp
    //_set_idt_entry(FAULT_NO_MATH_PROCESSOR, 0x08, &device_not_available, 0);
    //_set_idt_entry(ABORT_DOUBLE_FAULT, 0x08, &double_fault, 0);
    _set_idt_entry(FAULT_RESERVED_0, 0x08, &coprocessor_segment_overrun, 0);
c0107aff:	6a 00                	push   $0x0
c0107b01:	68 f0 75 10 c0       	push   $0xc01075f0
c0107b06:	6a 08                	push   $0x8
c0107b08:	6a 09                	push   $0x9
c0107b0a:	e8 9c fe ff ff       	call   c01079ab <_set_idt_entry>
c0107b0f:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(FAULT_INVALID_TSS, 0x08, &invalid_TSS, 0);
c0107b12:	6a 00                	push   $0x0
c0107b14:	68 04 76 10 c0       	push   $0xc0107604
c0107b19:	6a 08                	push   $0x8
c0107b1b:	6a 0a                	push   $0xa
c0107b1d:	e8 89 fe ff ff       	call   c01079ab <_set_idt_entry>
c0107b22:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(FAULT_SEG_NOT_PRESENT, 0x08, &segment_not_present, 0);
c0107b25:	6a 00                	push   $0x0
c0107b27:	68 0b 76 10 c0       	push   $0xc010760b
c0107b2c:	6a 08                	push   $0x8
c0107b2e:	6a 0b                	push   $0xb
c0107b30:	e8 76 fe ff ff       	call   c01079ab <_set_idt_entry>
c0107b35:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(FAULT_STACK_SEG_FAULT, 0x08, &stack_segment, 0);
c0107b38:	6a 00                	push   $0x0
c0107b3a:	68 15 76 10 c0       	push   $0xc0107615
c0107b3f:	6a 08                	push   $0x8
c0107b41:	6a 0c                	push   $0xc
c0107b43:	e8 63 fe ff ff       	call   c01079ab <_set_idt_entry>
c0107b48:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(FAULT_GENERAL_PROTECTION, 0x08, &general_protection, 0);
c0107b4b:	6a 00                	push   $0x0
c0107b4d:	68 1f 76 10 c0       	push   $0xc010761f
c0107b52:	6a 08                	push   $0x8
c0107b54:	6a 0d                	push   $0xd
c0107b56:	e8 50 fe ff ff       	call   c01079ab <_set_idt_entry>
c0107b5b:	83 c4 10             	add    $0x10,%esp
    //_set_idt_entry(FAULT_PAGE_FAULT, 0x08, page_fault, 0);
    _set_idt_entry(FAULT_RESERVED_1, 0x08, &reserved, 0);
c0107b5e:	6a 00                	push   $0x0
c0107b60:	68 fa 75 10 c0       	push   $0xc01075fa
c0107b65:	6a 08                	push   $0x8
c0107b67:	6a 0f                	push   $0xf
c0107b69:	e8 3d fe ff ff       	call   c01079ab <_set_idt_entry>
c0107b6e:	83 c4 10             	add    $0x10,%esp
    //_set_idt_entry(FAULT_X87_FAULT, 0x08, coprocessor_error, 0);
    for (int i=17;i < 48;i++)
c0107b71:	c7 45 fc 11 00 00 00 	movl   $0x11,-0x4(%ebp)
c0107b78:	eb 19                	jmp    c0107b93 <_init_idt+0x11f>
		  _set_idt_entry(i, 0x08, &reserved, 0);
c0107b7a:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0107b7d:	6a 00                	push   $0x0
c0107b7f:	68 fa 75 10 c0       	push   $0xc01075fa
c0107b84:	6a 08                	push   $0x8
c0107b86:	50                   	push   %eax
c0107b87:	e8 1f fe ff ff       	call   c01079ab <_set_idt_entry>
c0107b8c:	83 c4 10             	add    $0x10,%esp
    for (int i=17;i < 48;i++)
c0107b8f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0107b93:	83 7d fc 2f          	cmpl   $0x2f,-0x4(%ebp)
c0107b97:	7e e1                	jle    c0107b7a <_init_idt+0x106>
    //_set_idt_entry(45, 0x08, irq13, 0);
c0107b99:	90                   	nop
c0107b9a:	90                   	nop
c0107b9b:	c9                   	leave  
c0107b9c:	c3                   	ret    

c0107b9d <_kernel_start>:
c0107b9d:	e8 9b fd ff ff       	call   c010793d <_init_gdt>
c0107ba2:	68 60 90 12 c0       	push   $0xc0129060
c0107ba7:	66 ff 35 00 a0 12 c0 	pushw  0xc012a000
c0107bae:	0f 01 14 24          	lgdtl  (%esp)
c0107bb2:	66 b9 10 00          	mov    $0x10,%cx
c0107bb6:	8e c1                	mov    %ecx,%es
c0107bb8:	8e d9                	mov    %ecx,%ds
c0107bba:	8e e1                	mov    %ecx,%fs
c0107bbc:	8e e9                	mov    %ecx,%gs
c0107bbe:	8e d1                	mov    %ecx,%ss
c0107bc0:	66 6a 08             	pushw  $0x8
c0107bc3:	68 c9 7b 10 c0       	push   $0xc0107bc9
c0107bc8:	cb                   	lret   

c0107bc9 <_after_gdt>:
c0107bc9:	c7 04 24 00 10 10 00 	movl   $0x101000,(%esp)
c0107bd0:	e8 48 e6 ff ff       	call   c010621d <_kernel_init>
c0107bd5:	bc f0 ff bf ff       	mov    $0xffbffff0,%esp
c0107bda:	e8 5d e9 ff ff       	call   c010653c <_kernel_finnal_init>
c0107bdf:	83 ec 06             	sub    $0x6,%esp
c0107be2:	c7 44 24 02 a0 90 12 	movl   $0xc01290a0,0x2(%esp)
c0107be9:	c0 
c0107bea:	66 a1 02 a0 12 c0    	mov    0xc012a002,%ax
c0107bf0:	66 89 04 24          	mov    %ax,(%esp)
c0107bf4:	0f 01 1c 24          	lidtl  (%esp)
c0107bf8:	83 c4 06             	add    $0x6,%esp
c0107bfb:	e8 9a e9 ff ff       	call   c010659a <_kernel_main>

c0107c00 <j_>:
c0107c00:	f4                   	hlt    
c0107c01:	eb fd                	jmp    c0107c00 <j_>

c0107c03 <io_inb>:
{
c0107c03:	55                   	push   %ebp
c0107c04:	89 e5                	mov    %esp,%ebp
c0107c06:	83 ec 10             	sub    $0x10,%esp
    asm volatile("inb %w1,%0" : "=a"(data) : "d"(port));
c0107c09:	8b 45 08             	mov    0x8(%ebp),%eax
c0107c0c:	89 c2                	mov    %eax,%edx
c0107c0e:	ec                   	in     (%dx),%al
c0107c0f:	88 45 ff             	mov    %al,-0x1(%ebp)
    return data;
c0107c12:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c0107c16:	c9                   	leave  
c0107c17:	c3                   	ret    

c0107c18 <io_outb>:
{
c0107c18:	55                   	push   %ebp
c0107c19:	89 e5                	mov    %esp,%ebp
c0107c1b:	83 ec 04             	sub    $0x4,%esp
c0107c1e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107c21:	88 45 fc             	mov    %al,-0x4(%ebp)
    asm volatile("outb %0, %w1" : : "a"(data), "d"(port));
c0107c24:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0107c28:	8b 55 08             	mov    0x8(%ebp),%edx
c0107c2b:	ee                   	out    %al,(%dx)
}
c0107c2c:	90                   	nop
c0107c2d:	c9                   	leave  
c0107c2e:	c3                   	ret    

c0107c2f <cpu_delay>:
io_outl(int port, uint32_t data)
{
    asm volatile("outl %0,%w1" : : "a"(data), "d"(port));
}

static inline void cpu_delay(){
c0107c2f:	55                   	push   %ebp
c0107c30:	89 e5                	mov    %esp,%ebp
c0107c32:	83 ec 10             	sub    $0x10,%esp
    for(int i = 0; i < 3; i++);
c0107c35:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0107c3c:	eb 04                	jmp    c0107c42 <cpu_delay+0x13>
c0107c3e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0107c42:	83 7d fc 02          	cmpl   $0x2,-0x4(%ebp)
c0107c46:	7e f6                	jle    c0107c3e <cpu_delay+0xf>
}
c0107c48:	90                   	nop
c0107c49:	90                   	nop
c0107c4a:	c9                   	leave  
c0107c4b:	c3                   	ret    

c0107c4c <init_8259>:
//other keys tmp do not hand
};
#endif

void init_8259()
{
c0107c4c:	55                   	push   %ebp
c0107c4d:	89 e5                	mov    %esp,%ebp
    asm volatile("cli");
c0107c4f:	fa                   	cli    

    //ICW1
    io_outb(0x20, 0x11);
c0107c50:	6a 11                	push   $0x11
c0107c52:	6a 20                	push   $0x20
c0107c54:	e8 bf ff ff ff       	call   c0107c18 <io_outb>
c0107c59:	83 c4 08             	add    $0x8,%esp
    cpu_delay();
c0107c5c:	e8 ce ff ff ff       	call   c0107c2f <cpu_delay>
    io_outb(0xa0, 0x11);
c0107c61:	6a 11                	push   $0x11
c0107c63:	68 a0 00 00 00       	push   $0xa0
c0107c68:	e8 ab ff ff ff       	call   c0107c18 <io_outb>
c0107c6d:	83 c4 08             	add    $0x8,%esp
    cpu_delay();
c0107c70:	e8 ba ff ff ff       	call   c0107c2f <cpu_delay>

    //ICW2
    io_outb(0x21, 0x20);
c0107c75:	6a 20                	push   $0x20
c0107c77:	6a 21                	push   $0x21
c0107c79:	e8 9a ff ff ff       	call   c0107c18 <io_outb>
c0107c7e:	83 c4 08             	add    $0x8,%esp
    cpu_delay();
c0107c81:	e8 a9 ff ff ff       	call   c0107c2f <cpu_delay>
    io_outb(0xa1, 0x28);
c0107c86:	6a 28                	push   $0x28
c0107c88:	68 a1 00 00 00       	push   $0xa1
c0107c8d:	e8 86 ff ff ff       	call   c0107c18 <io_outb>
c0107c92:	83 c4 08             	add    $0x8,%esp
    cpu_delay();
c0107c95:	e8 95 ff ff ff       	call   c0107c2f <cpu_delay>

    //ICW3
    io_outb(0x21, 0x04);
c0107c9a:	6a 04                	push   $0x4
c0107c9c:	6a 21                	push   $0x21
c0107c9e:	e8 75 ff ff ff       	call   c0107c18 <io_outb>
c0107ca3:	83 c4 08             	add    $0x8,%esp
    cpu_delay();
c0107ca6:	e8 84 ff ff ff       	call   c0107c2f <cpu_delay>
    io_outb(0xa1, 0x02);
c0107cab:	6a 02                	push   $0x2
c0107cad:	68 a1 00 00 00       	push   $0xa1
c0107cb2:	e8 61 ff ff ff       	call   c0107c18 <io_outb>
c0107cb7:	83 c4 08             	add    $0x8,%esp
    cpu_delay();
c0107cba:	e8 70 ff ff ff       	call   c0107c2f <cpu_delay>

    //ICW4
    io_outb(0x21, 0x01);
c0107cbf:	6a 01                	push   $0x1
c0107cc1:	6a 21                	push   $0x21
c0107cc3:	e8 50 ff ff ff       	call   c0107c18 <io_outb>
c0107cc8:	83 c4 08             	add    $0x8,%esp
    cpu_delay();
c0107ccb:	e8 5f ff ff ff       	call   c0107c2f <cpu_delay>
    io_outb(0xa1, 0x01);
c0107cd0:	6a 01                	push   $0x1
c0107cd2:	68 a1 00 00 00       	push   $0xa1
c0107cd7:	e8 3c ff ff ff       	call   c0107c18 <io_outb>
c0107cdc:	83 c4 08             	add    $0x8,%esp
    cpu_delay();
c0107cdf:	e8 4b ff ff ff       	call   c0107c2f <cpu_delay>

    //OCW1
    io_outb(0x21, 0xff);
c0107ce4:	68 ff 00 00 00       	push   $0xff
c0107ce9:	6a 21                	push   $0x21
c0107ceb:	e8 28 ff ff ff       	call   c0107c18 <io_outb>
c0107cf0:	83 c4 08             	add    $0x8,%esp
    cpu_delay();
c0107cf3:	e8 37 ff ff ff       	call   c0107c2f <cpu_delay>
    io_outb(0xa1, 0xff);
c0107cf8:	68 ff 00 00 00       	push   $0xff
c0107cfd:	68 a1 00 00 00       	push   $0xa1
c0107d02:	e8 11 ff ff ff       	call   c0107c18 <io_outb>
c0107d07:	83 c4 08             	add    $0x8,%esp

    asm volatile("sti");
c0107d0a:	fb                   	sti    
}
c0107d0b:	90                   	nop
c0107d0c:	c9                   	leave  
c0107d0d:	c3                   	ret    

c0107d0e <ps2_post_cmd>:


static void ps2_post_cmd(uint8_t port, char cmd, uint16_t arg) {
c0107d0e:	55                   	push   %ebp
c0107d0f:	89 e5                	mov    %esp,%ebp
c0107d11:	83 ec 1c             	sub    $0x1c,%esp
c0107d14:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0107d17:	8b 55 0c             	mov    0xc(%ebp),%edx
c0107d1a:	8b 45 10             	mov    0x10(%ebp),%eax
c0107d1d:	88 4d ec             	mov    %cl,-0x14(%ebp)
c0107d20:	88 55 e8             	mov    %dl,-0x18(%ebp)
c0107d23:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    char result;
    // 等待PS/2输入缓冲区清空，这样我们才可以写入命令
    while((result = io_inb(PS2_PORT_CTRL_STATUS)) & PS2_STATUS_IFULL);
c0107d27:	90                   	nop
c0107d28:	6a 64                	push   $0x64
c0107d2a:	e8 d4 fe ff ff       	call   c0107c03 <io_inb>
c0107d2f:	83 c4 04             	add    $0x4,%esp
c0107d32:	88 45 ff             	mov    %al,-0x1(%ebp)
c0107d35:	0f be 45 ff          	movsbl -0x1(%ebp),%eax
c0107d39:	83 e0 02             	and    $0x2,%eax
c0107d3c:	85 c0                	test   %eax,%eax
c0107d3e:	75 e8                	jne    c0107d28 <ps2_post_cmd+0x1a>

    io_outb(port, cmd);
c0107d40:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c0107d44:	0f b6 d0             	movzbl %al,%edx
c0107d47:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0107d4b:	52                   	push   %edx
c0107d4c:	50                   	push   %eax
c0107d4d:	e8 c6 fe ff ff       	call   c0107c18 <io_outb>
c0107d52:	83 c4 08             	add    $0x8,%esp
    if (!(arg & PS2_NO_ARG)) {
c0107d55:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
c0107d59:	25 00 ff 00 00       	and    $0xff00,%eax
c0107d5e:	85 c0                	test   %eax,%eax
c0107d60:	75 12                	jne    c0107d74 <ps2_post_cmd+0x66>
        // 所有参数一律通过0x60传入。
        io_outb(PS2_PORT_ENC_CMDREG, (uint8_t)(arg & 0x00ff));
c0107d62:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
c0107d66:	0f b6 c0             	movzbl %al,%eax
c0107d69:	50                   	push   %eax
c0107d6a:	6a 60                	push   $0x60
c0107d6c:	e8 a7 fe ff ff       	call   c0107c18 <io_outb>
c0107d71:	83 c4 08             	add    $0x8,%esp
    }
}
c0107d74:	90                   	nop
c0107d75:	c9                   	leave  
c0107d76:	c3                   	ret    

c0107d77 <ps2_issue_cmd>:

static uint8_t ps2_issue_cmd(char cmd, uint16_t arg) {
c0107d77:	55                   	push   %ebp
c0107d78:	89 e5                	mov    %esp,%ebp
c0107d7a:	83 ec 18             	sub    $0x18,%esp
c0107d7d:	8b 55 08             	mov    0x8(%ebp),%edx
c0107d80:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107d83:	88 55 ec             	mov    %dl,-0x14(%ebp)
c0107d86:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
    ps2_post_cmd(PS2_PORT_CTRL_CMDREG, cmd, arg);
c0107d8a:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
c0107d8e:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
c0107d92:	52                   	push   %edx
c0107d93:	50                   	push   %eax
c0107d94:	6a 64                	push   $0x64
c0107d96:	e8 73 ff ff ff       	call   c0107d0e <ps2_post_cmd>
c0107d9b:	83 c4 0c             	add    $0xc,%esp

    char result;
    
    // 等待PS/2控制器返回。通过轮询（polling）状态寄存器的 bit 0
    // 如置位，则表明返回代码此时就在 0x60 IO口上等待读取。
    while(!((result = io_inb(PS2_PORT_CTRL_STATUS)) & PS2_STATUS_OFULL));
c0107d9e:	90                   	nop
c0107d9f:	6a 64                	push   $0x64
c0107da1:	e8 5d fe ff ff       	call   c0107c03 <io_inb>
c0107da6:	83 c4 04             	add    $0x4,%esp
c0107da9:	88 45 ff             	mov    %al,-0x1(%ebp)
c0107dac:	0f be 45 ff          	movsbl -0x1(%ebp),%eax
c0107db0:	83 e0 01             	and    $0x1,%eax
c0107db3:	85 c0                	test   %eax,%eax
c0107db5:	74 e8                	je     c0107d9f <ps2_issue_cmd+0x28>

    return io_inb(PS2_PORT_ENC_CMDREG);
c0107db7:	6a 60                	push   $0x60
c0107db9:	e8 45 fe ff ff       	call   c0107c03 <io_inb>
c0107dbe:	83 c4 04             	add    $0x4,%esp
}
c0107dc1:	c9                   	leave  
c0107dc2:	c3                   	ret    

c0107dc3 <ps2_issue_dev_cmd>:

static uint8_t ps2_issue_dev_cmd(char cmd, uint16_t arg) {
c0107dc3:	55                   	push   %ebp
c0107dc4:	89 e5                	mov    %esp,%ebp
c0107dc6:	83 ec 18             	sub    $0x18,%esp
c0107dc9:	8b 55 08             	mov    0x8(%ebp),%edx
c0107dcc:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107dcf:	88 55 ec             	mov    %dl,-0x14(%ebp)
c0107dd2:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
    ps2_post_cmd(PS2_PORT_ENC_CMDREG, cmd, arg);
c0107dd6:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
c0107dda:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
c0107dde:	52                   	push   %edx
c0107ddf:	50                   	push   %eax
c0107de0:	6a 60                	push   $0x60
c0107de2:	e8 27 ff ff ff       	call   c0107d0e <ps2_post_cmd>
c0107de7:	83 c4 0c             	add    $0xc,%esp

    char result;
    
    // 等待PS/2控制器返回。通过轮询（polling）状态寄存器的 bit 0
    // 如置位，则表明返回代码此时就在 0x60 IO口上等待读取。
    while(!((result = io_inb(PS2_PORT_CTRL_STATUS)) & PS2_STATUS_OFULL));
c0107dea:	90                   	nop
c0107deb:	6a 64                	push   $0x64
c0107ded:	e8 11 fe ff ff       	call   c0107c03 <io_inb>
c0107df2:	83 c4 04             	add    $0x4,%esp
c0107df5:	88 45 ff             	mov    %al,-0x1(%ebp)
c0107df8:	0f be 45 ff          	movsbl -0x1(%ebp),%eax
c0107dfc:	83 e0 01             	and    $0x1,%eax
c0107dff:	85 c0                	test   %eax,%eax
c0107e01:	74 e8                	je     c0107deb <ps2_issue_dev_cmd+0x28>

    return io_inb(PS2_PORT_ENC_CMDREG);
c0107e03:	6a 60                	push   $0x60
c0107e05:	e8 f9 fd ff ff       	call   c0107c03 <io_inb>
c0107e0a:	83 c4 04             	add    $0x4,%esp
}
c0107e0d:	c9                   	leave  
c0107e0e:	c3                   	ret    

c0107e0f <init_ps2k>:

void init_ps2k()
{
c0107e0f:	55                   	push   %ebp
c0107e10:	89 e5                	mov    %esp,%ebp
c0107e12:	83 ec 18             	sub    $0x18,%esp
    asm volatile("cli");
c0107e15:	fa                   	cli    

     // 1、禁用任何的PS/2设备
    ps2_post_cmd(PS2_PORT_CTRL_CMDREG, PS2_CMD_PORT1_DISABLE, PS2_NO_ARG);
c0107e16:	68 00 ff 00 00       	push   $0xff00
c0107e1b:	6a ad                	push   $0xffffffad
c0107e1d:	6a 64                	push   $0x64
c0107e1f:	e8 ea fe ff ff       	call   c0107d0e <ps2_post_cmd>
c0107e24:	83 c4 0c             	add    $0xc,%esp
    ps2_post_cmd(PS2_PORT_CTRL_CMDREG, PS2_CMD_PORT2_DISABLE, PS2_NO_ARG);
c0107e27:	68 00 ff 00 00       	push   $0xff00
c0107e2c:	6a a7                	push   $0xffffffa7
c0107e2e:	6a 64                	push   $0x64
c0107e30:	e8 d9 fe ff ff       	call   c0107d0e <ps2_post_cmd>
c0107e35:	83 c4 0c             	add    $0xc,%esp
    
    // 2、清空控制器缓冲区
    io_inb(PS2_PORT_ENC_DATA);
c0107e38:	6a 60                	push   $0x60
c0107e3a:	e8 c4 fd ff ff       	call   c0107c03 <io_inb>
c0107e3f:	83 c4 04             	add    $0x4,%esp

    char result;

    // 3、屏蔽所有PS/2设备（端口1&2）IRQ，并且禁用键盘键码转换功能
    result = ps2_issue_cmd(PS2_CMD_READ_CFG, PS2_NO_ARG);
c0107e42:	68 00 ff 00 00       	push   $0xff00
c0107e47:	6a 20                	push   $0x20
c0107e49:	e8 29 ff ff ff       	call   c0107d77 <ps2_issue_cmd>
c0107e4e:	83 c4 08             	add    $0x8,%esp
c0107e51:	88 45 f7             	mov    %al,-0x9(%ebp)
    result = result & ~(PS2_CFG_P1INT | PS2_CFG_P2INT | PS2_CFG_TRANSLATION);
c0107e54:	80 65 f7 bc          	andb   $0xbc,-0x9(%ebp)
    ps2_post_cmd(PS2_PORT_CTRL_CMDREG, PS2_CMD_WRITE_CFG, result);
c0107e58:	66 0f be 45 f7       	movsbw -0x9(%ebp),%ax
c0107e5d:	0f b7 c0             	movzwl %ax,%eax
c0107e60:	50                   	push   %eax
c0107e61:	6a 60                	push   $0x60
c0107e63:	6a 64                	push   $0x64
c0107e65:	e8 a4 fe ff ff       	call   c0107d0e <ps2_post_cmd>
c0107e6a:	83 c4 0c             	add    $0xc,%esp

    // 4、控制器自检
    result = ps2_issue_cmd(PS2_CMD_SELFTEST, PS2_NO_ARG);
c0107e6d:	68 00 ff 00 00       	push   $0xff00
c0107e72:	6a aa                	push   $0xffffffaa
c0107e74:	e8 fe fe ff ff       	call   c0107d77 <ps2_issue_cmd>
c0107e79:	83 c4 08             	add    $0x8,%esp
c0107e7c:	88 45 f7             	mov    %al,-0x9(%ebp)
    if (result != PS2_RESULT_TEST_OK) {
c0107e7f:	80 7d f7 55          	cmpb   $0x55,-0x9(%ebp)
c0107e83:	74 12                	je     c0107e97 <init_ps2k+0x88>
        kprintf("Controller self-test failed.");
c0107e85:	83 ec 0c             	sub    $0xc,%esp
c0107e88:	68 04 b5 12 c0       	push   $0xc012b504
c0107e8d:	e8 66 03 00 00       	call   c01081f8 <kprintf>
c0107e92:	83 c4 10             	add    $0x10,%esp
        goto done;
c0107e95:	eb 72                	jmp    c0107f09 <init_ps2k+0xfa>
    }

    // 5、设备自检（端口1自检，通常是我们的键盘）
    result = ps2_issue_cmd(PS2_CMD_SELFTEST_PORT1, PS2_NO_ARG);
c0107e97:	83 ec 08             	sub    $0x8,%esp
c0107e9a:	68 00 ff 00 00       	push   $0xff00
c0107e9f:	6a ab                	push   $0xffffffab
c0107ea1:	e8 d1 fe ff ff       	call   c0107d77 <ps2_issue_cmd>
c0107ea6:	83 c4 10             	add    $0x10,%esp
c0107ea9:	88 45 f7             	mov    %al,-0x9(%ebp)
    if (result != 0) {
c0107eac:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
c0107eb0:	74 12                	je     c0107ec4 <init_ps2k+0xb5>
        kprintf("Interface test on port 1 failed.");
c0107eb2:	83 ec 0c             	sub    $0xc,%esp
c0107eb5:	68 24 b5 12 c0       	push   $0xc012b524
c0107eba:	e8 39 03 00 00       	call   c01081f8 <kprintf>
c0107ebf:	83 c4 10             	add    $0x10,%esp
        goto done;
c0107ec2:	eb 45                	jmp    c0107f09 <init_ps2k+0xfa>
    }

    // 6、开启位于端口1的 IRQ，并启用端口1。不用理会端口2，那儿一般是鼠标。
    ps2_post_cmd(PS2_PORT_CTRL_CMDREG, PS2_CMD_PORT1_ENABLE, PS2_NO_ARG);
c0107ec4:	83 ec 04             	sub    $0x4,%esp
c0107ec7:	68 00 ff 00 00       	push   $0xff00
c0107ecc:	6a ae                	push   $0xffffffae
c0107ece:	6a 64                	push   $0x64
c0107ed0:	e8 39 fe ff ff       	call   c0107d0e <ps2_post_cmd>
c0107ed5:	83 c4 10             	add    $0x10,%esp
    result = ps2_issue_cmd(PS2_CMD_READ_CFG, PS2_NO_ARG);
c0107ed8:	83 ec 08             	sub    $0x8,%esp
c0107edb:	68 00 ff 00 00       	push   $0xff00
c0107ee0:	6a 20                	push   $0x20
c0107ee2:	e8 90 fe ff ff       	call   c0107d77 <ps2_issue_cmd>
c0107ee7:	83 c4 10             	add    $0x10,%esp
c0107eea:	88 45 f7             	mov    %al,-0x9(%ebp)
    result = result | PS2_CFG_P1INT;
c0107eed:	80 4d f7 01          	orb    $0x1,-0x9(%ebp)
    ps2_post_cmd(PS2_PORT_CTRL_CMDREG, PS2_CMD_WRITE_CFG, result);
c0107ef1:	66 0f be 45 f7       	movsbw -0x9(%ebp),%ax
c0107ef6:	0f b7 c0             	movzwl %ax,%eax
c0107ef9:	83 ec 04             	sub    $0x4,%esp
c0107efc:	50                   	push   %eax
c0107efd:	6a 60                	push   $0x60
c0107eff:	6a 64                	push   $0x64
c0107f01:	e8 08 fe ff ff       	call   c0107d0e <ps2_post_cmd>
c0107f06:	83 c4 10             	add    $0x10,%esp

    // 至此，PS/2控制器和设备已完成初始化，可以正常使用。

done:
    asm volatile("sti");
c0107f09:	fb                   	sti    
}
c0107f0a:	90                   	nop
c0107f0b:	c9                   	leave  
c0107f0c:	c3                   	ret    

c0107f0d <init_keyboard>:



void init_keyboard()
{
c0107f0d:	55                   	push   %ebp
c0107f0e:	89 e5                	mov    %esp,%ebp
c0107f10:	83 ec 18             	sub    $0x18,%esp
    init_8259();
c0107f13:	e8 34 fd ff ff       	call   c0107c4c <init_8259>

    uint8_t result = io_inb(0x21);
c0107f18:	6a 21                	push   $0x21
c0107f1a:	e8 e4 fc ff ff       	call   c0107c03 <io_inb>
c0107f1f:	83 c4 04             	add    $0x4,%esp
c0107f22:	88 45 f7             	mov    %al,-0x9(%ebp)
    io_outb(0x21, result & 0xfd);
c0107f25:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0107f29:	25 fd 00 00 00       	and    $0xfd,%eax
c0107f2e:	50                   	push   %eax
c0107f2f:	6a 21                	push   $0x21
c0107f31:	e8 e2 fc ff ff       	call   c0107c18 <io_outb>
c0107f36:	83 c4 08             	add    $0x8,%esp
    cpu_delay();
c0107f39:	e8 f1 fc ff ff       	call   c0107c2f <cpu_delay>
    result = io_inb(0x21);
c0107f3e:	6a 21                	push   $0x21
c0107f40:	e8 be fc ff ff       	call   c0107c03 <io_inb>
c0107f45:	83 c4 04             	add    $0x4,%esp
c0107f48:	88 45 f7             	mov    %al,-0x9(%ebp)

    init_ps2k();
c0107f4b:	e8 bf fe ff ff       	call   c0107e0f <init_ps2k>
    
    _set_idt_entry(0x21, 0x08, &handle_keywords, 0);
c0107f50:	6a 00                	push   $0x0
c0107f52:	68 66 7f 10 c0       	push   $0xc0107f66
c0107f57:	6a 08                	push   $0x8
c0107f59:	6a 21                	push   $0x21
c0107f5b:	e8 4b fa ff ff       	call   c01079ab <_set_idt_entry>
c0107f60:	83 c4 10             	add    $0x10,%esp
}
c0107f63:	90                   	nop
c0107f64:	c9                   	leave  
c0107f65:	c3                   	ret    

c0107f66 <handle_keywords>:

static void handle_keywords()
{
c0107f66:	55                   	push   %ebp
c0107f67:	89 e5                	mov    %esp,%ebp
c0107f69:	83 ec 18             	sub    $0x18,%esp
    crtl_status, shift_status, alt_status, caps_lock_status, ext_scancode = 0;
c0107f6c:	c6 05 24 93 12 c0 00 	movb   $0x0,0xc0129324
    asm volatile("cli");
c0107f73:	fa                   	cli    
    io_outb(0x61, 0x20);
c0107f74:	6a 20                	push   $0x20
c0107f76:	6a 61                	push   $0x61
c0107f78:	e8 9b fc ff ff       	call   c0107c18 <io_outb>
c0107f7d:	83 c4 08             	add    $0x8,%esp
    uint8_t ctrl_down_last = crtl_status;
c0107f80:	0f b6 05 20 93 12 c0 	movzbl 0xc0129320,%eax
c0107f87:	88 45 f4             	mov    %al,-0xc(%ebp)
    uint8_t shift_down_last = shift_status;
c0107f8a:	0f b6 05 21 93 12 c0 	movzbl 0xc0129321,%eax
c0107f91:	88 45 f3             	mov    %al,-0xd(%ebp)
    uint8_t caps_lock_last = caps_lock_status;
c0107f94:	0f b6 05 23 93 12 c0 	movzbl 0xc0129323,%eax
c0107f9b:	88 45 f2             	mov    %al,-0xe(%ebp)

    uint8_t break_code;
    uint16_t scancode = io_inb(0x60);
c0107f9e:	6a 60                	push   $0x60
c0107fa0:	e8 5e fc ff ff       	call   c0107c03 <io_inb>
c0107fa5:	83 c4 04             	add    $0x4,%esp
c0107fa8:	0f b6 c0             	movzbl %al,%eax
c0107fab:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
    
    if(scancode == 0xe0){
c0107faf:	66 81 7d f6 e0 00    	cmpw   $0xe0,-0xa(%ebp)
c0107fb5:	75 25                	jne    c0107fdc <handle_keywords+0x76>
        ext_scancode = 1;
c0107fb7:	c6 05 24 93 12 c0 01 	movb   $0x1,0xc0129324
        io_outb(0x20, 0x20);
c0107fbe:	6a 20                	push   $0x20
c0107fc0:	6a 20                	push   $0x20
c0107fc2:	e8 51 fc ff ff       	call   c0107c18 <io_outb>
c0107fc7:	83 c4 08             	add    $0x8,%esp
        io_outb(0x20, 0x20);
c0107fca:	6a 20                	push   $0x20
c0107fcc:	6a 20                	push   $0x20
c0107fce:	e8 45 fc ff ff       	call   c0107c18 <io_outb>
c0107fd3:	83 c4 08             	add    $0x8,%esp
        asm volatile("sti");
c0107fd6:	fb                   	sti    
        return;
c0107fd7:	e9 1a 02 00 00       	jmp    c01081f6 <handle_keywords+0x290>
    }
    if(ext_scancode){
c0107fdc:	0f b6 05 24 93 12 c0 	movzbl 0xc0129324,%eax
c0107fe3:	84 c0                	test   %al,%al
c0107fe5:	74 0d                	je     c0107ff4 <handle_keywords+0x8e>
        scancode = ((0xe000) | scancode);
c0107fe7:	66 81 4d f6 00 e0    	orw    $0xe000,-0xa(%ebp)
        ext_scancode = 0;
c0107fed:	c6 05 24 93 12 c0 00 	movb   $0x0,0xc0129324
    }

    break_code = ((0x0080 & scancode) != 0);
c0107ff4:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c0107ff8:	66 25 80 00          	and    $0x80,%ax
c0107ffc:	66 85 c0             	test   %ax,%ax
c0107fff:	0f 95 c0             	setne  %al
c0108002:	88 45 f1             	mov    %al,-0xf(%ebp)

    if(break_code)//tan qi ma
c0108005:	80 7d f1 00          	cmpb   $0x0,-0xf(%ebp)
c0108009:	74 6d                	je     c0108078 <handle_keywords+0x112>
    {
        uint16_t make_code = (scancode & 0xff7f);
c010800b:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c010800f:	24 7f                	and    $0x7f,%al
c0108011:	66 89 45 ec          	mov    %ax,-0x14(%ebp)

        if(make_code == crtl_l_make || make_code == crtl_r_make)
c0108015:	66 83 7d ec 1d       	cmpw   $0x1d,-0x14(%ebp)
c010801a:	74 08                	je     c0108024 <handle_keywords+0xbe>
c010801c:	66 81 7d ec 1d e0    	cmpw   $0xe01d,-0x14(%ebp)
c0108022:	75 09                	jne    c010802d <handle_keywords+0xc7>
        {
            crtl_status = 0;
c0108024:	c6 05 20 93 12 c0 00 	movb   $0x0,0xc0129320
c010802b:	eb 2d                	jmp    c010805a <handle_keywords+0xf4>
        }else if(make_code == shift_l_make || make_code == shift_r_make){
c010802d:	66 83 7d ec 2a       	cmpw   $0x2a,-0x14(%ebp)
c0108032:	74 07                	je     c010803b <handle_keywords+0xd5>
c0108034:	66 83 7d ec 36       	cmpw   $0x36,-0x14(%ebp)
c0108039:	75 09                	jne    c0108044 <handle_keywords+0xde>
            shift_status = 0;
c010803b:	c6 05 21 93 12 c0 00 	movb   $0x0,0xc0129321
c0108042:	eb 16                	jmp    c010805a <handle_keywords+0xf4>
        }else if(make_code == alt_l_make || make_code == alt_r_make){
c0108044:	66 83 7d ec 38       	cmpw   $0x38,-0x14(%ebp)
c0108049:	74 08                	je     c0108053 <handle_keywords+0xed>
c010804b:	66 81 7d ec 38 e0    	cmpw   $0xe038,-0x14(%ebp)
c0108051:	75 07                	jne    c010805a <handle_keywords+0xf4>
            alt_status = 0;
c0108053:	c6 05 22 93 12 c0 00 	movb   $0x0,0xc0129322
        }
        io_outb(0x20, 0x20);
c010805a:	6a 20                	push   $0x20
c010805c:	6a 20                	push   $0x20
c010805e:	e8 b5 fb ff ff       	call   c0107c18 <io_outb>
c0108063:	83 c4 08             	add    $0x8,%esp
        io_outb(0x20, 0x20);
c0108066:	6a 20                	push   $0x20
c0108068:	6a 20                	push   $0x20
c010806a:	e8 a9 fb ff ff       	call   c0107c18 <io_outb>
c010806f:	83 c4 08             	add    $0x8,%esp
        asm volatile("sti");
c0108072:	fb                   	sti    
        return;
c0108073:	e9 7e 01 00 00       	jmp    c01081f6 <handle_keywords+0x290>
    }//if is common word, hand
    else if((scancode > 0x00 && scancode < 0x3b) ||\
c0108078:	66 83 7d f6 00       	cmpw   $0x0,-0xa(%ebp)
c010807d:	74 07                	je     c0108086 <handle_keywords+0x120>
c010807f:	66 83 7d f6 3a       	cmpw   $0x3a,-0xa(%ebp)
c0108084:	76 14                	jbe    c010809a <handle_keywords+0x134>
c0108086:	66 81 7d f6 38 e0    	cmpw   $0xe038,-0xa(%ebp)
c010808c:	74 0c                	je     c010809a <handle_keywords+0x134>
            (scancode == alt_r_make) || \
c010808e:	66 81 7d f6 1d e0    	cmpw   $0xe01d,-0xa(%ebp)
c0108094:	0f 85 20 01 00 00    	jne    c01081ba <handle_keywords+0x254>
            (scancode == crtl_r_make)){
        uint8_t shift = 0;
c010809a:	c6 45 f5 00          	movb   $0x0,-0xb(%ebp)
        if((scancode < 0x0e) || (scancode == 0x29) || \
c010809e:	66 83 7d f6 0d       	cmpw   $0xd,-0xa(%ebp)
c01080a3:	76 3f                	jbe    c01080e4 <handle_keywords+0x17e>
c01080a5:	66 83 7d f6 29       	cmpw   $0x29,-0xa(%ebp)
c01080aa:	74 38                	je     c01080e4 <handle_keywords+0x17e>
c01080ac:	66 83 7d f6 1a       	cmpw   $0x1a,-0xa(%ebp)
c01080b1:	74 31                	je     c01080e4 <handle_keywords+0x17e>
           (scancode == 0x1a) || (scancode == 0x1b) ||\
c01080b3:	66 83 7d f6 1b       	cmpw   $0x1b,-0xa(%ebp)
c01080b8:	74 2a                	je     c01080e4 <handle_keywords+0x17e>
c01080ba:	66 83 7d f6 2b       	cmpw   $0x2b,-0xa(%ebp)
c01080bf:	74 23                	je     c01080e4 <handle_keywords+0x17e>
           (scancode == 0x2b) || (scancode == 0x27) ||\
c01080c1:	66 83 7d f6 27       	cmpw   $0x27,-0xa(%ebp)
c01080c6:	74 1c                	je     c01080e4 <handle_keywords+0x17e>
c01080c8:	66 83 7d f6 28       	cmpw   $0x28,-0xa(%ebp)
c01080cd:	74 15                	je     c01080e4 <handle_keywords+0x17e>
           (scancode == 0x28) || (scancode == 0x33) ||\
c01080cf:	66 83 7d f6 33       	cmpw   $0x33,-0xa(%ebp)
c01080d4:	74 0e                	je     c01080e4 <handle_keywords+0x17e>
c01080d6:	66 83 7d f6 34       	cmpw   $0x34,-0xa(%ebp)
c01080db:	74 07                	je     c01080e4 <handle_keywords+0x17e>
           (scancode == 0x34) || (scancode == 0x35)){
c01080dd:	66 83 7d f6 35       	cmpw   $0x35,-0xa(%ebp)
c01080e2:	75 34                	jne    c0108118 <handle_keywords+0x1b2>
            if(shift_down_last)
c01080e4:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
c01080e8:	74 06                	je     c01080f0 <handle_keywords+0x18a>
                shift = 1;
c01080ea:	c6 45 f5 01          	movb   $0x1,-0xb(%ebp)
c01080ee:	eb 28                	jmp    c0108118 <handle_keywords+0x1b2>
            else{
                if(shift_down_last && caps_lock_last)
c01080f0:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
c01080f4:	74 0c                	je     c0108102 <handle_keywords+0x19c>
c01080f6:	80 7d f2 00          	cmpb   $0x0,-0xe(%ebp)
c01080fa:	74 06                	je     c0108102 <handle_keywords+0x19c>
                    shift = 0;
c01080fc:	c6 45 f5 00          	movb   $0x0,-0xb(%ebp)
c0108100:	eb 16                	jmp    c0108118 <handle_keywords+0x1b2>
                else if(shift_down_last || caps_lock_last)
c0108102:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
c0108106:	75 06                	jne    c010810e <handle_keywords+0x1a8>
c0108108:	80 7d f2 00          	cmpb   $0x0,-0xe(%ebp)
c010810c:	74 06                	je     c0108114 <handle_keywords+0x1ae>
                    shift = 1;
c010810e:	c6 45 f5 01          	movb   $0x1,-0xb(%ebp)
c0108112:	eb 04                	jmp    c0108118 <handle_keywords+0x1b2>
                else
                    shift = 0;
c0108114:	c6 45 f5 00          	movb   $0x0,-0xb(%ebp)
                }
           }
        uint8_t index = (scancode &= 0x00ff);
c0108118:	66 81 65 f6 ff 00    	andw   $0xff,-0xa(%ebp)
c010811e:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c0108122:	88 45 f0             	mov    %al,-0x10(%ebp)
        char cur_char = key_map[index][shift];
c0108125:	0f b6 55 f0          	movzbl -0x10(%ebp),%edx
c0108129:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
c010812d:	0f b6 84 50 20 a0 12 	movzbl -0x3fed5fe0(%eax,%edx,2),%eax
c0108134:	c0 
c0108135:	88 45 ef             	mov    %al,-0x11(%ebp)

        if(cur_char){
c0108138:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
c010813c:	74 34                	je     c0108172 <handle_keywords+0x20c>
            vga_put_char(cur_char);
c010813e:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
c0108142:	83 ec 0c             	sub    $0xc,%esp
c0108145:	50                   	push   %eax
c0108146:	e8 d3 de ff ff       	call   c010601e <vga_put_char>
c010814b:	83 c4 10             	add    $0x10,%esp
            io_outb(0x20, 0x20);
c010814e:	83 ec 08             	sub    $0x8,%esp
c0108151:	6a 20                	push   $0x20
c0108153:	6a 20                	push   $0x20
c0108155:	e8 be fa ff ff       	call   c0107c18 <io_outb>
c010815a:	83 c4 10             	add    $0x10,%esp
            io_outb(0x20, 0x20);
c010815d:	83 ec 08             	sub    $0x8,%esp
c0108160:	6a 20                	push   $0x20
c0108162:	6a 20                	push   $0x20
c0108164:	e8 af fa ff ff       	call   c0107c18 <io_outb>
c0108169:	83 c4 10             	add    $0x10,%esp
            asm volatile("sti");
c010816c:	fb                   	sti    
            return;
c010816d:	e9 84 00 00 00       	jmp    c01081f6 <handle_keywords+0x290>
        }

        if(scancode == crtl_l_make || scancode == crtl_r_make)
c0108172:	66 83 7d f6 1d       	cmpw   $0x1d,-0xa(%ebp)
c0108177:	74 08                	je     c0108181 <handle_keywords+0x21b>
c0108179:	66 81 7d f6 1d e0    	cmpw   $0xe01d,-0xa(%ebp)
c010817f:	75 09                	jne    c010818a <handle_keywords+0x224>
            crtl_status = 1;
c0108181:	c6 05 20 93 12 c0 01 	movb   $0x1,0xc0129320
c0108188:	eb 2e                	jmp    c01081b8 <handle_keywords+0x252>
        else if(scancode == shift_l_make || scancode == shift_r_make)
c010818a:	66 83 7d f6 2a       	cmpw   $0x2a,-0xa(%ebp)
c010818f:	74 07                	je     c0108198 <handle_keywords+0x232>
c0108191:	66 83 7d f6 36       	cmpw   $0x36,-0xa(%ebp)
c0108196:	75 09                	jne    c01081a1 <handle_keywords+0x23b>
            shift_status = 1;
c0108198:	c6 05 21 93 12 c0 01 	movb   $0x1,0xc0129321
c010819f:	eb 17                	jmp    c01081b8 <handle_keywords+0x252>
        else if(scancode == caps_lock_make)
c01081a1:	66 83 7d f6 3a       	cmpw   $0x3a,-0xa(%ebp)
c01081a6:	75 4d                	jne    c01081f5 <handle_keywords+0x28f>
            caps_lock_status = ~caps_lock_status;
c01081a8:	0f b6 05 23 93 12 c0 	movzbl 0xc0129323,%eax
c01081af:	f7 d0                	not    %eax
c01081b1:	a2 23 93 12 c0       	mov    %al,0xc0129323
            (scancode == crtl_r_make)){
c01081b6:	eb 3d                	jmp    c01081f5 <handle_keywords+0x28f>
c01081b8:	eb 3b                	jmp    c01081f5 <handle_keywords+0x28f>
    }else{
        vga_put_char((char)(scancode && 0x00ff));
c01081ba:	66 83 7d f6 00       	cmpw   $0x0,-0xa(%ebp)
c01081bf:	0f 95 c0             	setne  %al
c01081c2:	0f b6 c0             	movzbl %al,%eax
c01081c5:	0f be c0             	movsbl %al,%eax
c01081c8:	83 ec 0c             	sub    $0xc,%esp
c01081cb:	50                   	push   %eax
c01081cc:	e8 4d de ff ff       	call   c010601e <vga_put_char>
c01081d1:	83 c4 10             	add    $0x10,%esp
        io_outb(0x20, 0x20);
c01081d4:	83 ec 08             	sub    $0x8,%esp
c01081d7:	6a 20                	push   $0x20
c01081d9:	6a 20                	push   $0x20
c01081db:	e8 38 fa ff ff       	call   c0107c18 <io_outb>
c01081e0:	83 c4 10             	add    $0x10,%esp
        io_outb(0x20, 0x20);
c01081e3:	83 ec 08             	sub    $0x8,%esp
c01081e6:	6a 20                	push   $0x20
c01081e8:	6a 20                	push   $0x20
c01081ea:	e8 29 fa ff ff       	call   c0107c18 <io_outb>
c01081ef:	83 c4 10             	add    $0x10,%esp
        asm volatile("sti");
c01081f2:	fb                   	sti    
c01081f3:	eb 01                	jmp    c01081f6 <handle_keywords+0x290>
            (scancode == crtl_r_make)){
c01081f5:	90                   	nop
    }
c01081f6:	c9                   	leave  
c01081f7:	c3                   	ret    

c01081f8 <kprintf>:
#include <libs/mstdio.h>
#include <vga/vga.h>
void kprintf (const char *format, ...)
{
c01081f8:	55                   	push   %ebp
c01081f9:	89 e5                	mov    %esp,%ebp
c01081fb:	83 ec 38             	sub    $0x38,%esp
  char **arg = (char **) &format;
c01081fe:	8d 45 08             	lea    0x8(%ebp),%eax
c0108201:	89 45 f4             	mov    %eax,-0xc(%ebp)
  int c;
  char buf[20];

  arg++;
c0108204:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
  while ((c = *format++) != 0)
c0108208:	e9 83 01 00 00       	jmp    c0108390 <kprintf+0x198>
    {
      if (c != '%')
c010820d:	83 7d f0 25          	cmpl   $0x25,-0x10(%ebp)
c0108211:	74 17                	je     c010822a <kprintf+0x32>
        vga_put_char (c);
c0108213:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0108216:	0f be c0             	movsbl %al,%eax
c0108219:	83 ec 0c             	sub    $0xc,%esp
c010821c:	50                   	push   %eax
c010821d:	e8 fc dd ff ff       	call   c010601e <vga_put_char>
c0108222:	83 c4 10             	add    $0x10,%esp
c0108225:	e9 66 01 00 00       	jmp    c0108390 <kprintf+0x198>
      else
        {
          char *p, *p2;
          int pad0 = 0, pad = 0;
c010822a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
c0108231:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
          
          c = *format++;
c0108238:	8b 45 08             	mov    0x8(%ebp),%eax
c010823b:	8d 50 01             	lea    0x1(%eax),%edx
c010823e:	89 55 08             	mov    %edx,0x8(%ebp)
c0108241:	0f b6 00             	movzbl (%eax),%eax
c0108244:	0f be c0             	movsbl %al,%eax
c0108247:	89 45 f0             	mov    %eax,-0x10(%ebp)
          if (c == '0')
c010824a:	83 7d f0 30          	cmpl   $0x30,-0x10(%ebp)
c010824e:	75 19                	jne    c0108269 <kprintf+0x71>
            {
              pad0 = 1;
c0108250:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
              c = *format++;
c0108257:	8b 45 08             	mov    0x8(%ebp),%eax
c010825a:	8d 50 01             	lea    0x1(%eax),%edx
c010825d:	89 55 08             	mov    %edx,0x8(%ebp)
c0108260:	0f b6 00             	movzbl (%eax),%eax
c0108263:	0f be c0             	movsbl %al,%eax
c0108266:	89 45 f0             	mov    %eax,-0x10(%ebp)
            }

          if (c >= '0' && c <= '9')
c0108269:	83 7d f0 2f          	cmpl   $0x2f,-0x10(%ebp)
c010826d:	7e 21                	jle    c0108290 <kprintf+0x98>
c010826f:	83 7d f0 39          	cmpl   $0x39,-0x10(%ebp)
c0108273:	7f 1b                	jg     c0108290 <kprintf+0x98>
            {
              pad = c - '0';
c0108275:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0108278:	83 e8 30             	sub    $0x30,%eax
c010827b:	89 45 e0             	mov    %eax,-0x20(%ebp)
              c = *format++;
c010827e:	8b 45 08             	mov    0x8(%ebp),%eax
c0108281:	8d 50 01             	lea    0x1(%eax),%edx
c0108284:	89 55 08             	mov    %edx,0x8(%ebp)
c0108287:	0f b6 00             	movzbl (%eax),%eax
c010828a:	0f be c0             	movsbl %al,%eax
c010828d:	89 45 f0             	mov    %eax,-0x10(%ebp)
            }

          switch (c)
c0108290:	83 7d f0 78          	cmpl   $0x78,-0x10(%ebp)
c0108294:	74 2b                	je     c01082c1 <kprintf+0xc9>
c0108296:	83 7d f0 78          	cmpl   $0x78,-0x10(%ebp)
c010829a:	0f 8f d5 00 00 00    	jg     c0108375 <kprintf+0x17d>
c01082a0:	83 7d f0 75          	cmpl   $0x75,-0x10(%ebp)
c01082a4:	74 1b                	je     c01082c1 <kprintf+0xc9>
c01082a6:	83 7d f0 75          	cmpl   $0x75,-0x10(%ebp)
c01082aa:	0f 8f c5 00 00 00    	jg     c0108375 <kprintf+0x17d>
c01082b0:	83 7d f0 64          	cmpl   $0x64,-0x10(%ebp)
c01082b4:	74 0b                	je     c01082c1 <kprintf+0xc9>
c01082b6:	83 7d f0 73          	cmpl   $0x73,-0x10(%ebp)
c01082ba:	74 2b                	je     c01082e7 <kprintf+0xef>
c01082bc:	e9 b4 00 00 00       	jmp    c0108375 <kprintf+0x17d>
            {
            case 'd':
            case 'u':
            case 'x':
              itoa (buf, c, *((int *) arg++));
c01082c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01082c4:	8d 50 04             	lea    0x4(%eax),%edx
c01082c7:	89 55 f4             	mov    %edx,-0xc(%ebp)
c01082ca:	8b 00                	mov    (%eax),%eax
c01082cc:	83 ec 04             	sub    $0x4,%esp
c01082cf:	50                   	push   %eax
c01082d0:	ff 75 f0             	push   -0x10(%ebp)
c01082d3:	8d 45 cc             	lea    -0x34(%ebp),%eax
c01082d6:	50                   	push   %eax
c01082d7:	e8 d4 00 00 00       	call   c01083b0 <itoa>
c01082dc:	83 c4 10             	add    $0x10,%esp
              p = buf;
c01082df:	8d 45 cc             	lea    -0x34(%ebp),%eax
c01082e2:	89 45 ec             	mov    %eax,-0x14(%ebp)
              goto string;
c01082e5:	eb 1e                	jmp    c0108305 <kprintf+0x10d>
              break;

            case 's':
              p = *arg++;
c01082e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01082ea:	8d 50 04             	lea    0x4(%eax),%edx
c01082ed:	89 55 f4             	mov    %edx,-0xc(%ebp)
c01082f0:	8b 00                	mov    (%eax),%eax
c01082f2:	89 45 ec             	mov    %eax,-0x14(%ebp)
              if (! p)
c01082f5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c01082f9:	75 09                	jne    c0108304 <kprintf+0x10c>
                p = "(null)";
c01082fb:	c7 45 ec 45 b5 12 c0 	movl   $0xc012b545,-0x14(%ebp)
c0108302:	eb 01                	jmp    c0108305 <kprintf+0x10d>

            string:
c0108304:	90                   	nop
              for (p2 = p; *p2; p2++);
c0108305:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0108308:	89 45 e8             	mov    %eax,-0x18(%ebp)
c010830b:	eb 04                	jmp    c0108311 <kprintf+0x119>
c010830d:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
c0108311:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0108314:	0f b6 00             	movzbl (%eax),%eax
c0108317:	84 c0                	test   %al,%al
c0108319:	75 f2                	jne    c010830d <kprintf+0x115>
              for (; p2 < p + pad; p2++)
c010831b:	eb 22                	jmp    c010833f <kprintf+0x147>
                vga_put_char (pad0 ? '0' : ' ');
c010831d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0108321:	74 07                	je     c010832a <kprintf+0x132>
c0108323:	b8 30 00 00 00       	mov    $0x30,%eax
c0108328:	eb 05                	jmp    c010832f <kprintf+0x137>
c010832a:	b8 20 00 00 00       	mov    $0x20,%eax
c010832f:	83 ec 0c             	sub    $0xc,%esp
c0108332:	50                   	push   %eax
c0108333:	e8 e6 dc ff ff       	call   c010601e <vga_put_char>
c0108338:	83 c4 10             	add    $0x10,%esp
              for (; p2 < p + pad; p2++)
c010833b:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
c010833f:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0108342:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0108345:	01 d0                	add    %edx,%eax
c0108347:	39 45 e8             	cmp    %eax,-0x18(%ebp)
c010834a:	72 d1                	jb     c010831d <kprintf+0x125>
              while (*p)
c010834c:	eb 1b                	jmp    c0108369 <kprintf+0x171>
                vga_put_char (*p++);
c010834e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0108351:	8d 50 01             	lea    0x1(%eax),%edx
c0108354:	89 55 ec             	mov    %edx,-0x14(%ebp)
c0108357:	0f b6 00             	movzbl (%eax),%eax
c010835a:	0f be c0             	movsbl %al,%eax
c010835d:	83 ec 0c             	sub    $0xc,%esp
c0108360:	50                   	push   %eax
c0108361:	e8 b8 dc ff ff       	call   c010601e <vga_put_char>
c0108366:	83 c4 10             	add    $0x10,%esp
              while (*p)
c0108369:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010836c:	0f b6 00             	movzbl (%eax),%eax
c010836f:	84 c0                	test   %al,%al
c0108371:	75 db                	jne    c010834e <kprintf+0x156>
              break;
c0108373:	eb 1b                	jmp    c0108390 <kprintf+0x198>

            default:
              vga_put_char (*((int *) arg++));
c0108375:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108378:	8d 50 04             	lea    0x4(%eax),%edx
c010837b:	89 55 f4             	mov    %edx,-0xc(%ebp)
c010837e:	8b 00                	mov    (%eax),%eax
c0108380:	0f be c0             	movsbl %al,%eax
c0108383:	83 ec 0c             	sub    $0xc,%esp
c0108386:	50                   	push   %eax
c0108387:	e8 92 dc ff ff       	call   c010601e <vga_put_char>
c010838c:	83 c4 10             	add    $0x10,%esp
              break;
c010838f:	90                   	nop
  while ((c = *format++) != 0)
c0108390:	8b 45 08             	mov    0x8(%ebp),%eax
c0108393:	8d 50 01             	lea    0x1(%eax),%edx
c0108396:	89 55 08             	mov    %edx,0x8(%ebp)
c0108399:	0f b6 00             	movzbl (%eax),%eax
c010839c:	0f be c0             	movsbl %al,%eax
c010839f:	89 45 f0             	mov    %eax,-0x10(%ebp)
c01083a2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c01083a6:	0f 85 61 fe ff ff    	jne    c010820d <kprintf+0x15>
            }
        }
    }
}
c01083ac:	90                   	nop
c01083ad:	90                   	nop
c01083ae:	c9                   	leave  
c01083af:	c3                   	ret    

c01083b0 <itoa>:
#include <libs/mstdlib.h>

void
itoa (char *buf, int base, int d)
{
c01083b0:	55                   	push   %ebp
c01083b1:	89 e5                	mov    %esp,%ebp
c01083b3:	83 ec 20             	sub    $0x20,%esp
  char *p = buf;
c01083b6:	8b 45 08             	mov    0x8(%ebp),%eax
c01083b9:	89 45 fc             	mov    %eax,-0x4(%ebp)
  char *p1, *p2;
  unsigned long ud = d;
c01083bc:	8b 45 10             	mov    0x10(%ebp),%eax
c01083bf:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int divisor = 10;
c01083c2:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
  
  /* If %d is specified and D is minus, put ‘-’ in the head. */
  if (base == 'd' && d < 0)
c01083c9:	83 7d 0c 64          	cmpl   $0x64,0xc(%ebp)
c01083cd:	75 20                	jne    c01083ef <itoa+0x3f>
c01083cf:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c01083d3:	79 1a                	jns    c01083ef <itoa+0x3f>
    {
      *p++ = '-';
c01083d5:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01083d8:	8d 50 01             	lea    0x1(%eax),%edx
c01083db:	89 55 fc             	mov    %edx,-0x4(%ebp)
c01083de:	c6 00 2d             	movb   $0x2d,(%eax)
      buf++;
c01083e1:	83 45 08 01          	addl   $0x1,0x8(%ebp)
      ud = -d;
c01083e5:	8b 45 10             	mov    0x10(%ebp),%eax
c01083e8:	f7 d8                	neg    %eax
c01083ea:	89 45 f0             	mov    %eax,-0x10(%ebp)
c01083ed:	eb 0d                	jmp    c01083fc <itoa+0x4c>
    }
  else if (base == 'x')
c01083ef:	83 7d 0c 78          	cmpl   $0x78,0xc(%ebp)
c01083f3:	75 07                	jne    c01083fc <itoa+0x4c>
    divisor = 16;
c01083f5:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)

  /* Divide UD by DIVISOR until UD == 0. */
  do
    {
      int remainder = ud % divisor;
c01083fc:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c01083ff:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0108402:	ba 00 00 00 00       	mov    $0x0,%edx
c0108407:	f7 f1                	div    %ecx
c0108409:	89 d0                	mov    %edx,%eax
c010840b:	89 45 e8             	mov    %eax,-0x18(%ebp)
      
      *p++ = (remainder < 10) ? remainder + '0' : remainder + 'a' - 10;
c010840e:	83 7d e8 09          	cmpl   $0x9,-0x18(%ebp)
c0108412:	7f 0a                	jg     c010841e <itoa+0x6e>
c0108414:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0108417:	83 c0 30             	add    $0x30,%eax
c010841a:	89 c1                	mov    %eax,%ecx
c010841c:	eb 08                	jmp    c0108426 <itoa+0x76>
c010841e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0108421:	83 c0 57             	add    $0x57,%eax
c0108424:	89 c1                	mov    %eax,%ecx
c0108426:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0108429:	8d 50 01             	lea    0x1(%eax),%edx
c010842c:	89 55 fc             	mov    %edx,-0x4(%ebp)
c010842f:	88 08                	mov    %cl,(%eax)
    }
  while (ud /= divisor);
c0108431:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c0108434:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0108437:	ba 00 00 00 00       	mov    $0x0,%edx
c010843c:	f7 f1                	div    %ecx
c010843e:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0108441:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0108445:	75 b5                	jne    c01083fc <itoa+0x4c>

  /* Terminate BUF. */
  *p = 0;
c0108447:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010844a:	c6 00 00             	movb   $0x0,(%eax)
  
  /* Reverse BUF. */
  p1 = buf;
c010844d:	8b 45 08             	mov    0x8(%ebp),%eax
c0108450:	89 45 f8             	mov    %eax,-0x8(%ebp)
  p2 = p - 1;
c0108453:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0108456:	83 e8 01             	sub    $0x1,%eax
c0108459:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (p1 < p2)
c010845c:	eb 25                	jmp    c0108483 <itoa+0xd3>
    {
      char tmp = *p1;
c010845e:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0108461:	0f b6 00             	movzbl (%eax),%eax
c0108464:	88 45 e7             	mov    %al,-0x19(%ebp)
      *p1 = *p2;
c0108467:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010846a:	0f b6 10             	movzbl (%eax),%edx
c010846d:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0108470:	88 10                	mov    %dl,(%eax)
      *p2 = tmp;
c0108472:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108475:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
c0108479:	88 10                	mov    %dl,(%eax)
      p1++;
c010847b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
      p2--;
c010847f:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
  while (p1 < p2)
c0108483:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0108486:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0108489:	72 d3                	jb     c010845e <itoa+0xae>
    }
c010848b:	90                   	nop
c010848c:	90                   	nop
c010848d:	c9                   	leave  
c010848e:	c3                   	ret    

c010848f <memset>:
#include <libs/mstring.h>
#include <stdint.h>

void* memset(void* ptr, int value, size_t num)
{
c010848f:	55                   	push   %ebp
c0108490:	89 e5                	mov    %esp,%ebp
c0108492:	83 ec 10             	sub    $0x10,%esp
    uint8_t* c_ptr = (uint8_t*)ptr;
c0108495:	8b 45 08             	mov    0x8(%ebp),%eax
c0108498:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for (size_t i = 0; i < num; i++) {
c010849b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c01084a2:	eb 11                	jmp    c01084b5 <memset+0x26>
        *(c_ptr + i) = (uint8_t)value;
c01084a4:	8b 55 f8             	mov    -0x8(%ebp),%edx
c01084a7:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01084aa:	01 d0                	add    %edx,%eax
c01084ac:	8b 55 0c             	mov    0xc(%ebp),%edx
c01084af:	88 10                	mov    %dl,(%eax)
    for (size_t i = 0; i < num; i++) {
c01084b1:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c01084b5:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01084b8:	3b 45 10             	cmp    0x10(%ebp),%eax
c01084bb:	72 e7                	jb     c01084a4 <memset+0x15>
    }
    return ptr;
c01084bd:	8b 45 08             	mov    0x8(%ebp),%eax
c01084c0:	c9                   	leave  
c01084c1:	c3                   	ret    
