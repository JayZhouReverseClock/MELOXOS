
build/bin/melox.bin:     file format elf32-i386


Disassembly of section .virk_init_text:

00100000 <start-0xc>:
  100000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
  100006:	00 00                	add    %al,(%eax)
  100008:	fb                   	sti    
  100009:	4f                   	dec    %edi
  10000a:	52                   	push   %edx
  10000b:	e4                   	.byte 0xe4

0010000c <start>:
  10000c:	fa                   	cli    
  10000d:	bc 00 60 10 00       	mov    $0x106000,%esp
  100012:	68 00 10 10 00       	push   $0x101000
  100017:	53                   	push   %ebx
  100018:	e8 64 00 00 00       	call   100081 <save_multiboot_info>
  10001d:	58                   	pop    %eax
  10001e:	58                   	pop    %eax
  10001f:	68 00 a0 00 00       	push   $0xa000
  100024:	68 00 f0 d0 00       	push   $0xd0f000
  100029:	e8 a4 02 00 00       	call   1002d2 <kerner_init>
  10002e:	8b 04 24             	mov    (%esp),%eax
  100031:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  100036:	0f 22 d8             	mov    %eax,%cr3
  100039:	0f 20 c0             	mov    %cr0,%eax
  10003c:	0d 00 00 00 80       	or     $0x80000000,%eax
  100041:	0f 22 c0             	mov    %eax,%cr0
  100044:	58                   	pop    %eax
  100045:	58                   	pop    %eax
  100046:	68 59 8f 10 c0       	push   $0xc0108f59
  10004b:	c3                   	ret    

0010004c <_save_>:
extern uint8_t virkernel_start;
extern uint8_t virkernel_end ;
extern uint8_t __init_phykernel_end;
extern uint8_t _kernel_stack;

uint32_t _save_(uint8_t* destination, uint8_t* base, multiboot_uint32_t size) {
  10004c:	55                   	push   %ebp
  10004d:	89 e5                	mov    %esp,%ebp
  10004f:	83 ec 10             	sub    $0x10,%esp
    multiboot_uint32_t i = 0;
  100052:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    for (; i < size; i++)
  100059:	eb 19                	jmp    100074 <_save_+0x28>
    {
        *(destination + i) = *(base + i);
  10005b:	8b 55 0c             	mov    0xc(%ebp),%edx
  10005e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100061:	01 d0                	add    %edx,%eax
  100063:	8b 4d 08             	mov    0x8(%ebp),%ecx
  100066:	8b 55 fc             	mov    -0x4(%ebp),%edx
  100069:	01 ca                	add    %ecx,%edx
  10006b:	0f b6 00             	movzbl (%eax),%eax
  10006e:	88 02                	mov    %al,(%edx)
    for (; i < size; i++)
  100070:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  100074:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100077:	3b 45 10             	cmp    0x10(%ebp),%eax
  10007a:	72 df                	jb     10005b <_save_+0xf>
    }
    return i;
  10007c:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  10007f:	c9                   	leave  
  100080:	c3                   	ret    

00100081 <save_multiboot_info>:

void save_multiboot_info(multiboot_info_t* mb_info, multiboot_uint8_t* dest)
{
  100081:	55                   	push   %ebp
  100082:	89 e5                	mov    %esp,%ebp
  100084:	53                   	push   %ebx
  100085:	83 ec 10             	sub    $0x10,%esp
    uint32_t current = 0;
  100088:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    uint8_t* info_b = (uint8_t*) mb_info;
  10008f:	8b 45 08             	mov    0x8(%ebp),%eax
  100092:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for (; current < sizeof(multiboot_info_t); current++)
  100095:	eb 19                	jmp    1000b0 <save_multiboot_info+0x2f>
    {
        *(dest + current) = *(info_b + current);
  100097:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10009a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10009d:	01 d0                	add    %edx,%eax
  10009f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1000a2:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1000a5:	01 ca                	add    %ecx,%edx
  1000a7:	0f b6 00             	movzbl (%eax),%eax
  1000aa:	88 02                	mov    %al,(%edx)
    for (; current < sizeof(multiboot_info_t); current++)
  1000ac:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  1000b0:	83 7d f8 77          	cmpl   $0x77,-0x8(%ebp)
  1000b4:	76 e1                	jbe    100097 <save_multiboot_info+0x16>
    }

    ((multiboot_info_t*) dest)->mmap_addr = (uintptr_t)dest + current;
  1000b6:	8b 55 0c             	mov    0xc(%ebp),%edx
  1000b9:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1000bc:	01 c2                	add    %eax,%edx
  1000be:	8b 45 0c             	mov    0xc(%ebp),%eax
  1000c1:	89 50 30             	mov    %edx,0x30(%eax)
    current += _save_(dest + current, (uint8_t*)mb_info->mmap_addr, mb_info->mmap_length);
  1000c4:	8b 45 08             	mov    0x8(%ebp),%eax
  1000c7:	8b 40 2c             	mov    0x2c(%eax),%eax
  1000ca:	8b 55 08             	mov    0x8(%ebp),%edx
  1000cd:	8b 52 30             	mov    0x30(%edx),%edx
  1000d0:	89 d1                	mov    %edx,%ecx
  1000d2:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  1000d5:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1000d8:	01 da                	add    %ebx,%edx
  1000da:	50                   	push   %eax
  1000db:	51                   	push   %ecx
  1000dc:	52                   	push   %edx
  1000dd:	e8 6a ff ff ff       	call   10004c <_save_>
  1000e2:	83 c4 0c             	add    $0xc,%esp
  1000e5:	01 45 f8             	add    %eax,-0x8(%ebp)

    if (present(mb_info->flags, MULTIBOOT_INFO_DRIVE_INFO)) {
  1000e8:	8b 45 08             	mov    0x8(%ebp),%eax
  1000eb:	8b 00                	mov    (%eax),%eax
  1000ed:	25 80 00 00 00       	and    $0x80,%eax
  1000f2:	85 c0                	test   %eax,%eax
  1000f4:	74 32                	je     100128 <save_multiboot_info+0xa7>
        ((multiboot_info_t*) dest)->drives_addr = (uintptr_t)dest + current;
  1000f6:	8b 55 0c             	mov    0xc(%ebp),%edx
  1000f9:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1000fc:	01 c2                	add    %eax,%edx
  1000fe:	8b 45 0c             	mov    0xc(%ebp),%eax
  100101:	89 50 38             	mov    %edx,0x38(%eax)
        current += _save_(dest + current, (uint8_t*)mb_info->drives_addr, mb_info->drives_length);
  100104:	8b 45 08             	mov    0x8(%ebp),%eax
  100107:	8b 40 34             	mov    0x34(%eax),%eax
  10010a:	8b 55 08             	mov    0x8(%ebp),%edx
  10010d:	8b 52 38             	mov    0x38(%edx),%edx
  100110:	89 d1                	mov    %edx,%ecx
  100112:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  100115:	8b 55 f8             	mov    -0x8(%ebp),%edx
  100118:	01 da                	add    %ebx,%edx
  10011a:	50                   	push   %eax
  10011b:	51                   	push   %ecx
  10011c:	52                   	push   %edx
  10011d:	e8 2a ff ff ff       	call   10004c <_save_>
  100122:	83 c4 0c             	add    $0xc,%esp
  100125:	01 45 f8             	add    %eax,-0x8(%ebp)
    }
    multiboot_info_t* test = (multiboot_info_t*) dest;
  100128:	8b 45 0c             	mov    0xc(%ebp),%eax
  10012b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    multiboot_memory_map_t* testmap = (multiboot_memory_map_t*)mb_info->mmap_addr;
  10012e:	8b 45 08             	mov    0x8(%ebp),%eax
  100131:	8b 40 30             	mov    0x30(%eax),%eax
  100134:	89 45 ec             	mov    %eax,-0x14(%ebp)
}
  100137:	90                   	nop
  100138:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10013b:	c9                   	leave  
  10013c:	c3                   	ret    

0010013d <init_page>:

void init_page(ptd_t* pt)
{
  10013d:	55                   	push   %ebp
  10013e:	89 e5                	mov    %esp,%ebp
  100140:	83 ec 30             	sub    $0x30,%esp
    SET_PDE(pt, 0, PDE(PG_PREM_RW, pt + PG_MAX_ENTRIES));
  100143:	8b 45 08             	mov    0x8(%ebp),%eax
  100146:	05 00 10 00 00       	add    $0x1000,%eax
  10014b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  100150:	83 c8 0b             	or     $0xb,%eax
  100153:	89 c2                	mov    %eax,%edx
  100155:	8b 45 08             	mov    0x8(%ebp),%eax
  100158:	89 10                	mov    %edx,(%eax)
    ptd_t * tmp_paged_phy_addr = pt;
  10015a:	8b 45 08             	mov    0x8(%ebp),%eax
  10015d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    ptd_t * tmp_paget_phy_addr = pt + 1024;
  100160:	8b 45 08             	mov    0x8(%ebp),%eax
  100163:	05 00 10 00 00       	add    $0x1000,%eax
  100168:	89 45 e8             	mov    %eax,-0x18(%ebp)
    //identity map 1M memory
    for(uint32_t i = 0; i < 256; i++)
  10016b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  100172:	eb 20                	jmp    100194 <init_page+0x57>
        *(tmp_paget_phy_addr + i) = (((i << 12) & 0xFFFFF000UL) | (PG_PREM_RW & 0xfff));
  100174:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100177:	c1 e0 0c             	shl    $0xc,%eax
  10017a:	89 c2                	mov    %eax,%edx
  10017c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10017f:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
  100186:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100189:	01 c8                	add    %ecx,%eax
  10018b:	83 ca 03             	or     $0x3,%edx
  10018e:	89 10                	mov    %edx,(%eax)
    for(uint32_t i = 0; i < 256; i++)
  100190:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  100194:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%ebp)
  10019b:	76 d7                	jbe    100174 <init_page+0x37>

    //identity map virkernel_init memory
    for(uint32_t i = 0; i < LOADOS_PAGE_COUNT; i++)
  10019d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  1001a4:	eb 29                	jmp    1001cf <init_page+0x92>
        *(tmp_paget_phy_addr + i + 256) = ((((i << 12) + MEM_1M) & 0xFFFFF000UL) | (PG_PREM_RW & 0xfff));
  1001a6:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1001a9:	c1 e0 0c             	shl    $0xc,%eax
  1001ac:	8d 90 00 00 10 00    	lea    0x100000(%eax),%edx
  1001b2:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1001b5:	05 00 01 00 00       	add    $0x100,%eax
  1001ba:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
  1001c1:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1001c4:	01 c8                	add    %ecx,%eax
  1001c6:	83 ca 03             	or     $0x3,%edx
  1001c9:	89 10                	mov    %edx,(%eax)
    for(uint32_t i = 0; i < LOADOS_PAGE_COUNT; i++)
  1001cb:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  1001cf:	b8 00 60 10 00       	mov    $0x106000,%eax
  1001d4:	2d 01 f0 0f 00       	sub    $0xff001,%eax
  1001d9:	c1 e8 0c             	shr    $0xc,%eax
  1001dc:	39 45 f8             	cmp    %eax,-0x8(%ebp)
  1001df:	72 c5                	jb     1001a6 <init_page+0x69>

    //now we map the kernel
    //calculate the virtrue kernrl page index
    uint32_t virk_pde_index = PD_INDEX(sym_val(virkernel_start));
  1001e1:	b8 00 60 10 c0       	mov    $0xc0106000,%eax
  1001e6:	c1 e8 16             	shr    $0x16,%eax
  1001e9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uint32_t virk_pte_index = PT_INDEX(sym_val(virkernel_start));
  1001ec:	b8 00 60 10 c0       	mov    $0xc0106000,%eax
  1001f1:	c1 e8 0c             	shr    $0xc,%eax
  1001f4:	25 ff 03 00 00       	and    $0x3ff,%eax
  1001f9:	89 45 e0             	mov    %eax,-0x20(%ebp)
    uint32_t virk_pg_counts = KERNEL_PAGE_COUNT;
  1001fc:	b8 00 90 d1 c0       	mov    $0xc0d19000,%eax
  100201:	05 00 10 00 00       	add    $0x1000,%eax
  100206:	83 e8 01             	sub    $0x1,%eax
  100209:	ba 00 60 10 c0       	mov    $0xc0106000,%edx
  10020e:	29 d0                	sub    %edx,%eax
  100210:	c1 e8 0c             	shr    $0xc,%eax
  100213:	89 45 dc             	mov    %eax,-0x24(%ebp)

    //regist the vir_kernel page to page direction
    //we give 3 pagetable to virkel, is 3 * 4 = 12 mib size
    for(uint32_t i = 0; i < PG_TABLE_STACK - PG_TABLE_KERNEL; i++)
  100216:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  10021d:	eb 34                	jmp    100253 <init_page+0x116>
    {
        *(pt + virk_pde_index + i) = PDE(PG_PREM_RW, PT_ADDR(pt, PG_TABLE_KERNEL + i));
  10021f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100222:	83 c0 02             	add    $0x2,%eax
  100225:	c1 e0 0c             	shl    $0xc,%eax
  100228:	89 c2                	mov    %eax,%edx
  10022a:	8b 45 08             	mov    0x8(%ebp),%eax
  10022d:	01 d0                	add    %edx,%eax
  10022f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  100234:	89 c2                	mov    %eax,%edx
  100236:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  100239:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10023c:	01 c8                	add    %ecx,%eax
  10023e:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
  100245:	8b 45 08             	mov    0x8(%ebp),%eax
  100248:	01 c8                	add    %ecx,%eax
  10024a:	83 ca 0b             	or     $0xb,%edx
  10024d:	89 10                	mov    %edx,(%eax)
    for(uint32_t i = 0; i < PG_TABLE_STACK - PG_TABLE_KERNEL; i++)
  10024f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  100253:	83 7d f4 06          	cmpl   $0x6,-0xc(%ebp)
  100257:	76 c6                	jbe    10021f <init_page+0xe2>
    }

    //avoid kernel size > prepared page count
    if(virk_pg_counts > (PG_TABLE_STACK - PG_TABLE_KERNEL) * 1024)
  100259:	81 7d dc 00 1c 00 00 	cmpl   $0x1c00,-0x24(%ebp)
  100260:	76 02                	jbe    100264 <init_page+0x127>
    {
        asm ("ud2");
  100262:	0f 0b                	ud2    
    }

    //calcul the phy address
    uint32_t virk_phy_addr = V2P(&virkernel_start);
  100264:	b8 00 60 10 c0       	mov    $0xc0106000,%eax
  100269:	05 00 00 00 40       	add    $0x40000000,%eax
  10026e:	89 45 d8             	mov    %eax,-0x28(%ebp)
    //map virtrue kernel page
    for(uint32_t i = 0; i < virk_pg_counts; i++)
  100271:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  100278:	eb 36                	jmp    1002b0 <init_page+0x173>
    {
        *(tmp_paget_phy_addr + 1024 + virk_pte_index + i) = (((virk_phy_addr + (i << 12)) & 0xFFFFF000UL) | (PG_PREM_RW & 0xfff));
  10027a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10027d:	c1 e0 0c             	shl    $0xc,%eax
  100280:	89 c2                	mov    %eax,%edx
  100282:	8b 45 d8             	mov    -0x28(%ebp),%eax
  100285:	01 d0                	add    %edx,%eax
  100287:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  10028c:	89 c2                	mov    %eax,%edx
  10028e:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  100291:	8b 45 f0             	mov    -0x10(%ebp),%eax
  100294:	01 c8                	add    %ecx,%eax
  100296:	05 00 04 00 00       	add    $0x400,%eax
  10029b:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
  1002a2:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1002a5:	01 c8                	add    %ecx,%eax
  1002a7:	83 ca 03             	or     $0x3,%edx
  1002aa:	89 10                	mov    %edx,(%eax)
    for(uint32_t i = 0; i < virk_pg_counts; i++)
  1002ac:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
  1002b0:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1002b3:	3b 45 dc             	cmp    -0x24(%ebp),%eax
  1002b6:	72 c2                	jb     10027a <init_page+0x13d>
    }

    //self map pd, to give the pd virture address
    SET_PDE(pt, 1023, PDE(T_SELF_REF_PERM, pt));
  1002b8:	8b 45 08             	mov    0x8(%ebp),%eax
  1002bb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  1002c0:	89 c2                	mov    %eax,%edx
  1002c2:	8b 45 08             	mov    0x8(%ebp),%eax
  1002c5:	05 fc 0f 00 00       	add    $0xffc,%eax
  1002ca:	83 ca 1b             	or     $0x1b,%edx
  1002cd:	89 10                	mov    %edx,(%eax)
}
  1002cf:	90                   	nop
  1002d0:	c9                   	leave  
  1002d1:	c3                   	ret    

001002d2 <kerner_init>:

void kerner_init(ptd_t* pt, uint32_t pt_size)
{
  1002d2:	55                   	push   %ebp
  1002d3:	89 e5                	mov    %esp,%ebp
  1002d5:	83 ec 10             	sub    $0x10,%esp
    uint8_t* kpg = (uint8_t*) pt;
  1002d8:	8b 45 08             	mov    0x8(%ebp),%eax
  1002db:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for (uint32_t i = 0; i < pt_size; i++)
  1002de:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1002e5:	eb 0f                	jmp    1002f6 <kerner_init+0x24>
    {
        *(kpg + i) = 0;
  1002e7:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1002ea:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1002ed:	01 d0                	add    %edx,%eax
  1002ef:	c6 00 00             	movb   $0x0,(%eax)
    for (uint32_t i = 0; i < pt_size; i++)
  1002f2:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  1002f6:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1002f9:	3b 45 0c             	cmp    0xc(%ebp),%eax
  1002fc:	72 e9                	jb     1002e7 <kerner_init+0x15>
    }
    init_page(pt);
  1002fe:	ff 75 08             	push   0x8(%ebp)
  100301:	e8 37 fe ff ff       	call   10013d <init_page>
  100306:	83 c4 04             	add    $0x4,%esp
  100309:	90                   	nop
  10030a:	c9                   	leave  
  10030b:	c3                   	ret    

Disassembly of section .text:

c0106000 <init_vga_buffer>:
int XPOS = 0;

vga_attr *video;

void init_vga_buffer()
{
c0106000:	55                   	push   %ebp
c0106001:	89 e5                	mov    %esp,%ebp
    video = (vga_attr *) VIDEO;
c0106003:	c7 05 0c b0 10 c0 00 	movl   $0xb8000,0xc010b00c
c010600a:	80 0b 00 
}
c010600d:	90                   	nop
c010600e:	5d                   	pop    %ebp
c010600f:	c3                   	ret    

c0106010 <set_vga_buffer>:

void set_vga_buffer(void* vga_buf)
{
c0106010:	55                   	push   %ebp
c0106011:	89 e5                	mov    %esp,%ebp
    video = (vga_attr*)vga_buf;
c0106013:	8b 45 08             	mov    0x8(%ebp),%eax
c0106016:	a3 0c b0 10 c0       	mov    %eax,0xc010b00c
}
c010601b:	90                   	nop
c010601c:	5d                   	pop    %ebp
c010601d:	c3                   	ret    

c010601e <vga_put_char>:

void vga_put_char(char c)
{
c010601e:	55                   	push   %ebp
c010601f:	89 e5                	mov    %esp,%ebp
c0106021:	53                   	push   %ebx
c0106022:	83 ec 14             	sub    $0x14,%esp
c0106025:	8b 45 08             	mov    0x8(%ebp),%eax
c0106028:	88 45 f4             	mov    %al,-0xc(%ebp)
    if(c == '\n')
c010602b:	80 7d f4 0a          	cmpb   $0xa,-0xc(%ebp)
c010602f:	75 19                	jne    c010604a <vga_put_char+0x2c>
    {
        YPOS++;
c0106031:	a1 04 b0 10 c0       	mov    0xc010b004,%eax
c0106036:	83 c0 01             	add    $0x1,%eax
c0106039:	a3 04 b0 10 c0       	mov    %eax,0xc010b004
        XPOS = 0;
c010603e:	c7 05 08 b0 10 c0 00 	movl   $0x0,0xc010b008
c0106045:	00 00 00 
c0106048:	eb 54                	jmp    c010609e <vga_put_char+0x80>
    }else if(c == '\r')
c010604a:	80 7d f4 0d          	cmpb   $0xd,-0xc(%ebp)
c010604e:	75 0c                	jne    c010605c <vga_put_char+0x3e>
        XPOS = 0;
c0106050:	c7 05 08 b0 10 c0 00 	movl   $0x0,0xc010b008
c0106057:	00 00 00 
c010605a:	eb 42                	jmp    c010609e <vga_put_char+0x80>
    else{
        *(video + XPOS + YPOS * WIDTH) = (theme_color | c);
c010605c:	66 0f be 55 f4       	movsbw -0xc(%ebp),%dx
c0106061:	0f b7 05 00 b0 10 c0 	movzwl 0xc010b000,%eax
c0106068:	09 c2                	or     %eax,%edx
c010606a:	8b 0d 0c b0 10 c0    	mov    0xc010b00c,%ecx
c0106070:	a1 04 b0 10 c0       	mov    0xc010b004,%eax
c0106075:	89 c3                	mov    %eax,%ebx
c0106077:	89 d8                	mov    %ebx,%eax
c0106079:	c1 e0 02             	shl    $0x2,%eax
c010607c:	01 d8                	add    %ebx,%eax
c010607e:	c1 e0 04             	shl    $0x4,%eax
c0106081:	89 c3                	mov    %eax,%ebx
c0106083:	a1 08 b0 10 c0       	mov    0xc010b008,%eax
c0106088:	01 d8                	add    %ebx,%eax
c010608a:	01 c0                	add    %eax,%eax
c010608c:	01 c8                	add    %ecx,%eax
c010608e:	66 89 10             	mov    %dx,(%eax)
        XPOS++;
c0106091:	a1 08 b0 10 c0       	mov    0xc010b008,%eax
c0106096:	83 c0 01             	add    $0x1,%eax
c0106099:	a3 08 b0 10 c0       	mov    %eax,0xc010b008
    }
    if (XPOS >= WIDTH)
c010609e:	a1 08 b0 10 c0       	mov    0xc010b008,%eax
c01060a3:	83 f8 4f             	cmp    $0x4f,%eax
c01060a6:	7e 17                	jle    c01060bf <vga_put_char+0xa1>
    {
        YPOS++;
c01060a8:	a1 04 b0 10 c0       	mov    0xc010b004,%eax
c01060ad:	83 c0 01             	add    $0x1,%eax
c01060b0:	a3 04 b0 10 c0       	mov    %eax,0xc010b004
        XPOS = 0;
c01060b5:	c7 05 08 b0 10 c0 00 	movl   $0x0,0xc010b008
c01060bc:	00 00 00 
    }
    if(YPOS >= HIGHT)
c01060bf:	a1 04 b0 10 c0       	mov    0xc010b004,%eax
c01060c4:	83 f8 18             	cmp    $0x18,%eax
c01060c7:	7e 05                	jle    c01060ce <vga_put_char+0xb0>
        vga_scrollup();
c01060c9:	e8 be 00 00 00       	call   c010618c <vga_scrollup>
}
c01060ce:	90                   	nop
c01060cf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c01060d2:	c9                   	leave  
c01060d3:	c3                   	ret    

c01060d4 <vga_set_show>:

void vga_set_show(vga_attr flashing, vga_attr backgroud, vga_attr frontcolor)
{
c01060d4:	55                   	push   %ebp
c01060d5:	89 e5                	mov    %esp,%ebp
c01060d7:	83 ec 0c             	sub    $0xc,%esp
c01060da:	8b 4d 08             	mov    0x8(%ebp),%ecx
c01060dd:	8b 55 0c             	mov    0xc(%ebp),%edx
c01060e0:	8b 45 10             	mov    0x10(%ebp),%eax
c01060e3:	66 89 4d fc          	mov    %cx,-0x4(%ebp)
c01060e7:	66 89 55 f8          	mov    %dx,-0x8(%ebp)
c01060eb:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
    theme_color = (flashing << 7 | backgroud << 4 | frontcolor) << 8;
c01060ef:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
c01060f3:	c1 e0 07             	shl    $0x7,%eax
c01060f6:	89 c2                	mov    %eax,%edx
c01060f8:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
c01060fc:	c1 e0 04             	shl    $0x4,%eax
c01060ff:	09 c2                	or     %eax,%edx
c0106101:	0f b7 45 f4          	movzwl -0xc(%ebp),%eax
c0106105:	09 d0                	or     %edx,%eax
c0106107:	c1 e0 08             	shl    $0x8,%eax
c010610a:	66 a3 00 b0 10 c0    	mov    %ax,0xc010b000
}
c0106110:	90                   	nop
c0106111:	c9                   	leave  
c0106112:	c3                   	ret    

c0106113 <vga_put_str>:

void vga_put_str(char* str)
{
c0106113:	55                   	push   %ebp
c0106114:	89 e5                	mov    %esp,%ebp
c0106116:	83 ec 08             	sub    $0x8,%esp
    while (*str != '\0')
c0106119:	eb 19                	jmp    c0106134 <vga_put_str+0x21>
    {
        vga_put_char(*str);
c010611b:	8b 45 08             	mov    0x8(%ebp),%eax
c010611e:	0f b6 00             	movzbl (%eax),%eax
c0106121:	0f be c0             	movsbl %al,%eax
c0106124:	83 ec 0c             	sub    $0xc,%esp
c0106127:	50                   	push   %eax
c0106128:	e8 f1 fe ff ff       	call   c010601e <vga_put_char>
c010612d:	83 c4 10             	add    $0x10,%esp
        str++;
c0106130:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    while (*str != '\0')
c0106134:	8b 45 08             	mov    0x8(%ebp),%eax
c0106137:	0f b6 00             	movzbl (%eax),%eax
c010613a:	84 c0                	test   %al,%al
c010613c:	75 dd                	jne    c010611b <vga_put_str+0x8>
    }
}
c010613e:	90                   	nop
c010613f:	90                   	nop
c0106140:	c9                   	leave  
c0106141:	c3                   	ret    

c0106142 <vga_clear>:

void vga_clear()
{
c0106142:	55                   	push   %ebp
c0106143:	89 e5                	mov    %esp,%ebp
c0106145:	83 ec 10             	sub    $0x10,%esp
  
    for(int i = 0; i < WIDTH * HIGHT; i++)
c0106148:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c010614f:	eb 1b                	jmp    c010616c <vga_clear+0x2a>
        *(video + i) = theme_color;
c0106151:	8b 15 0c b0 10 c0    	mov    0xc010b00c,%edx
c0106157:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010615a:	01 c0                	add    %eax,%eax
c010615c:	01 c2                	add    %eax,%edx
c010615e:	0f b7 05 00 b0 10 c0 	movzwl 0xc010b000,%eax
c0106165:	66 89 02             	mov    %ax,(%edx)
    for(int i = 0; i < WIDTH * HIGHT; i++)
c0106168:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c010616c:	81 7d fc cf 07 00 00 	cmpl   $0x7cf,-0x4(%ebp)
c0106173:	7e dc                	jle    c0106151 <vga_clear+0xf>

    XPOS = 0;
c0106175:	c7 05 08 b0 10 c0 00 	movl   $0x0,0xc010b008
c010617c:	00 00 00 
    YPOS = 0;
c010617f:	c7 05 04 b0 10 c0 00 	movl   $0x0,0xc010b004
c0106186:	00 00 00 
}
c0106189:	90                   	nop
c010618a:	c9                   	leave  
c010618b:	c3                   	ret    

c010618c <vga_scrollup>:

void vga_scrollup()
{
c010618c:	55                   	push   %ebp
c010618d:	89 e5                	mov    %esp,%ebp
c010618f:	83 ec 10             	sub    $0x10,%esp
    unsigned int last_line = WIDTH * (HIGHT - 1);
c0106192:	c7 45 f4 80 07 00 00 	movl   $0x780,-0xc(%ebp)
    for (unsigned int i = 0; i < last_line; i++) {
c0106199:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c01061a0:	eb 27                	jmp    c01061c9 <vga_scrollup+0x3d>
        *(video + i) = *(video + WIDTH + i);
c01061a2:	8b 15 0c b0 10 c0    	mov    0xc010b00c,%edx
c01061a8:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01061ab:	83 c0 50             	add    $0x50,%eax
c01061ae:	01 c0                	add    %eax,%eax
c01061b0:	01 d0                	add    %edx,%eax
c01061b2:	8b 0d 0c b0 10 c0    	mov    0xc010b00c,%ecx
c01061b8:	8b 55 fc             	mov    -0x4(%ebp),%edx
c01061bb:	01 d2                	add    %edx,%edx
c01061bd:	01 ca                	add    %ecx,%edx
c01061bf:	0f b7 00             	movzwl (%eax),%eax
c01061c2:	66 89 02             	mov    %ax,(%edx)
    for (unsigned int i = 0; i < last_line; i++) {
c01061c5:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c01061c9:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01061cc:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c01061cf:	72 d1                	jb     c01061a2 <vga_scrollup+0x16>
    }
    for (unsigned int i = 0; i < WIDTH; i++) {
c01061d1:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c01061d8:	eb 20                	jmp    c01061fa <vga_scrollup+0x6e>
        *(video + i + last_line) = theme_color;
c01061da:	8b 15 0c b0 10 c0    	mov    0xc010b00c,%edx
c01061e0:	8b 4d f8             	mov    -0x8(%ebp),%ecx
c01061e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01061e6:	01 c8                	add    %ecx,%eax
c01061e8:	01 c0                	add    %eax,%eax
c01061ea:	01 c2                	add    %eax,%edx
c01061ec:	0f b7 05 00 b0 10 c0 	movzwl 0xc010b000,%eax
c01061f3:	66 89 02             	mov    %ax,(%edx)
    for (unsigned int i = 0; i < WIDTH; i++) {
c01061f6:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c01061fa:	83 7d f8 4f          	cmpl   $0x4f,-0x8(%ebp)
c01061fe:	76 da                	jbe    c01061da <vga_scrollup+0x4e>
    }
    YPOS = YPOS == 0 ? 0 : HIGHT - 1;
c0106200:	a1 04 b0 10 c0       	mov    0xc010b004,%eax
c0106205:	85 c0                	test   %eax,%eax
c0106207:	75 07                	jne    c0106210 <vga_scrollup+0x84>
c0106209:	b8 00 00 00 00       	mov    $0x0,%eax
c010620e:	eb 05                	jmp    c0106215 <vga_scrollup+0x89>
c0106210:	b8 18 00 00 00       	mov    $0x18,%eax
c0106215:	a3 04 b0 10 c0       	mov    %eax,0xc010b004
c010621a:	90                   	nop
c010621b:	c9                   	leave  
c010621c:	c3                   	ret    

c010621d <cpu_rcr3>:
{
    asm("mov %0, %%cr3" ::"r"(v));
}

static inline reg32 cpu_rcr3()
{
c010621d:	55                   	push   %ebp
c010621e:	89 e5                	mov    %esp,%ebp
c0106220:	83 ec 10             	sub    $0x10,%esp
    uintptr_t val;
    asm volatile("movl %%cr3,%0" : "=r" (val));
c0106223:	0f 20 d8             	mov    %cr3,%eax
c0106226:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return val;
c0106229:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c010622c:	c9                   	leave  
c010622d:	c3                   	ret    

c010622e <cpu_reflags>:

static inline reg32 cpu_reflags()
{
c010622e:	55                   	push   %ebp
c010622f:	89 e5                	mov    %esp,%ebp
c0106231:	83 ec 10             	sub    $0x10,%esp
    uintptr_t val;
    asm volatile(
c0106234:	9c                   	pushf  
c0106235:	58                   	pop    %eax
c0106236:	89 45 fc             	mov    %eax,-0x4(%ebp)
        "pushf\n"
        "popl %0\n"
        :"=r"(val)::);
    return val;
c0106239:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c010623c:	c9                   	leave  
c010623d:	c3                   	ret    

c010623e <_vir_kernel_init>:
/* Forward declarations. */
void _vir_kernel_init (unsigned long addr);
extern void __proc0(); /* proc0.c */

void _vir_kernel_init(unsigned long addr)
{
c010623e:	55                   	push   %ebp
c010623f:	89 e5                	mov    %esp,%ebp
c0106241:	57                   	push   %edi
c0106242:	56                   	push   %esi
c0106243:	53                   	push   %ebx
c0106244:	81 ec bc 00 00 00    	sub    $0xbc,%esp
    multiboot_info_t *mbi;
    mbi = (multiboot_info_t *) addr;
c010624a:	8b 45 08             	mov    0x8(%ebp),%eax
c010624d:	89 45 d8             	mov    %eax,-0x28(%ebp)
    multiboot_memory_map_t* map = (multiboot_memory_map_t*)mbi->mmap_addr;
c0106250:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0106253:	8b 40 30             	mov    0x30(%eax),%eax
c0106256:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    _init_idt();
c0106259:	e8 aa 2b 00 00       	call   c0108e08 <_init_idt>
    pmm_init(MEM_1MB + (mbi->mem_upper << 10));
c010625e:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0106261:	8b 40 08             	mov    0x8(%eax),%eax
c0106264:	c1 e0 0a             	shl    $0xa,%eax
c0106267:	05 00 00 10 00       	add    $0x100000,%eax
c010626c:	83 ec 0c             	sub    $0xc,%esp
c010626f:	50                   	push   %eax
c0106270:	e8 5d 04 00 00       	call   c01066d2 <pmm_init>
c0106275:	83 c4 10             	add    $0x10,%esp
    vmm_init();
c0106278:	e8 42 11 00 00       	call   c01073bf <vmm_init>

    init_vga_buffer();
c010627d:	e8 7e fd ff ff       	call   c0106000 <init_vga_buffer>
    vga_set_show(0,VGA_COLOR_BLACK,VGA_COLOR_LIGHT_WHITE);
c0106282:	83 ec 04             	sub    $0x4,%esp
c0106285:	6a 0f                	push   $0xf
c0106287:	6a 00                	push   $0x0
c0106289:	6a 00                	push   $0x0
c010628b:	e8 44 fe ff ff       	call   c01060d4 <vga_set_show>
c0106290:	83 c4 10             	add    $0x10,%esp
    /* Clear the screen. */
    vga_clear();
c0106293:	e8 aa fe ff ff       	call   c0106142 <vga_clear>

    __kernel_ptd = cpu_rcr3();
c0106298:	e8 80 ff ff ff       	call   c010621d <cpu_rcr3>
c010629d:	a3 20 b0 10 c0       	mov    %eax,0xc010b020

    tmp = (struct m_pcb){ .page_table = __kernel_ptd };
c01062a2:	8b 35 20 b0 10 c0    	mov    0xc010b020,%esi
c01062a8:	bb 40 b0 10 c0       	mov    $0xc010b040,%ebx
c01062ad:	b8 00 00 00 00       	mov    $0x0,%eax
c01062b2:	ba 1b 00 00 00       	mov    $0x1b,%edx
c01062b7:	89 df                	mov    %ebx,%edi
c01062b9:	89 d1                	mov    %edx,%ecx
c01062bb:	f3 ab                	rep stos %eax,%es:(%edi)
c01062bd:	89 35 a4 b0 10 c0    	mov    %esi,0xc010b0a4

    __current = &tmp;
c01062c3:	c7 05 20 cb d0 c0 40 	movl   $0xc010b040,0xc0d0cb20
c01062ca:	b0 10 c0 
    // }

    /* Set MBI to the address of the Multiboot information structure. */

    /* Print out the flags. */
    kprintf("flags = 0x%x\n", (unsigned) mbi->flags);
c01062cd:	8b 45 d8             	mov    -0x28(%ebp),%eax
c01062d0:	8b 00                	mov    (%eax),%eax
c01062d2:	83 ec 08             	sub    $0x8,%esp
c01062d5:	50                   	push   %eax
c01062d6:	68 00 e0 d0 c0       	push   $0xc0d0e000
c01062db:	e8 a1 49 00 00       	call   c010ac81 <kprintf>
c01062e0:	83 c4 10             	add    $0x10,%esp

    /* Are mem_* valid? */
    if (CHECK_FLAG(mbi->flags, 0))
c01062e3:	8b 45 d8             	mov    -0x28(%ebp),%eax
c01062e6:	8b 00                	mov    (%eax),%eax
c01062e8:	83 e0 01             	and    $0x1,%eax
c01062eb:	85 c0                	test   %eax,%eax
c01062ed:	74 1e                	je     c010630d <_vir_kernel_init+0xcf>
        kprintf("mem_lower = %uKB, mem_upper = %uKB\n",(unsigned) mbi->mem_lower, (unsigned) mbi->mem_upper);
c01062ef:	8b 45 d8             	mov    -0x28(%ebp),%eax
c01062f2:	8b 50 08             	mov    0x8(%eax),%edx
c01062f5:	8b 45 d8             	mov    -0x28(%ebp),%eax
c01062f8:	8b 40 04             	mov    0x4(%eax),%eax
c01062fb:	83 ec 04             	sub    $0x4,%esp
c01062fe:	52                   	push   %edx
c01062ff:	50                   	push   %eax
c0106300:	68 10 e0 d0 c0       	push   $0xc0d0e010
c0106305:	e8 77 49 00 00       	call   c010ac81 <kprintf>
c010630a:	83 c4 10             	add    $0x10,%esp
    
    unsigned int map_size = mbi->mmap_length / sizeof(multiboot_memory_map_t);
c010630d:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0106310:	8b 40 2c             	mov    0x2c(%eax),%eax
c0106313:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
c0106318:	f7 e2                	mul    %edx
c010631a:	89 d0                	mov    %edx,%eax
c010631c:	c1 e8 04             	shr    $0x4,%eax
c010631f:	89 45 d0             	mov    %eax,-0x30(%ebp)
    for (unsigned int i = 0; i < map_size; i++) {
c0106322:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
c0106329:	e9 33 01 00 00       	jmp    c0106461 <_vir_kernel_init+0x223>
        multiboot_memory_map_t mmap = map[i];
c010632e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0106331:	89 d0                	mov    %edx,%eax
c0106333:	01 c0                	add    %eax,%eax
c0106335:	01 d0                	add    %edx,%eax
c0106337:	c1 e0 03             	shl    $0x3,%eax
c010633a:	89 c2                	mov    %eax,%edx
c010633c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c010633f:	01 d0                	add    %edx,%eax
c0106341:	8b 10                	mov    (%eax),%edx
c0106343:	89 95 38 ff ff ff    	mov    %edx,-0xc8(%ebp)
c0106349:	8b 50 04             	mov    0x4(%eax),%edx
c010634c:	89 95 3c ff ff ff    	mov    %edx,-0xc4(%ebp)
c0106352:	8b 50 08             	mov    0x8(%eax),%edx
c0106355:	89 95 40 ff ff ff    	mov    %edx,-0xc0(%ebp)
c010635b:	8b 50 0c             	mov    0xc(%eax),%edx
c010635e:	89 95 44 ff ff ff    	mov    %edx,-0xbc(%ebp)
c0106364:	8b 50 10             	mov    0x10(%eax),%edx
c0106367:	89 95 48 ff ff ff    	mov    %edx,-0xb8(%ebp)
c010636d:	8b 40 14             	mov    0x14(%eax),%eax
c0106370:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
        kprintf("[MM] Base: 0x%x, len: %u KiB, type: %u\n",
               map[i].addr_low,
               map[i].len_low >> 10,
               map[i].type);
c0106376:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0106379:	89 d0                	mov    %edx,%eax
c010637b:	01 c0                	add    %eax,%eax
c010637d:	01 d0                	add    %edx,%eax
c010637f:	c1 e0 03             	shl    $0x3,%eax
c0106382:	89 c2                	mov    %eax,%edx
c0106384:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0106387:	01 d0                	add    %edx,%eax
        kprintf("[MM] Base: 0x%x, len: %u KiB, type: %u\n",
c0106389:	8b 50 14             	mov    0x14(%eax),%edx
               map[i].len_low >> 10,
c010638c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c010638f:	89 c8                	mov    %ecx,%eax
c0106391:	01 c0                	add    %eax,%eax
c0106393:	01 c8                	add    %ecx,%eax
c0106395:	c1 e0 03             	shl    $0x3,%eax
c0106398:	89 c1                	mov    %eax,%ecx
c010639a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c010639d:	01 c8                	add    %ecx,%eax
c010639f:	8b 40 0c             	mov    0xc(%eax),%eax
        kprintf("[MM] Base: 0x%x, len: %u KiB, type: %u\n",
c01063a2:	c1 e8 0a             	shr    $0xa,%eax
c01063a5:	89 c3                	mov    %eax,%ebx
               map[i].addr_low,
c01063a7:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c01063aa:	89 c8                	mov    %ecx,%eax
c01063ac:	01 c0                	add    %eax,%eax
c01063ae:	01 c8                	add    %ecx,%eax
c01063b0:	c1 e0 03             	shl    $0x3,%eax
c01063b3:	89 c1                	mov    %eax,%ecx
c01063b5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c01063b8:	01 c8                	add    %ecx,%eax
        kprintf("[MM] Base: 0x%x, len: %u KiB, type: %u\n",
c01063ba:	8b 40 04             	mov    0x4(%eax),%eax
c01063bd:	52                   	push   %edx
c01063be:	53                   	push   %ebx
c01063bf:	50                   	push   %eax
c01063c0:	68 34 e0 d0 c0       	push   $0xc0d0e034
c01063c5:	e8 b7 48 00 00       	call   c010ac81 <kprintf>
c01063ca:	83 c4 10             	add    $0x10,%esp
        if (mmap.type == MULTIBOOT_MEMORY_AVAILABLE) {
c01063cd:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
c01063d3:	83 f8 01             	cmp    $0x1,%eax
c01063d6:	0f 85 81 00 00 00    	jne    c010645d <_vir_kernel_init+0x21f>
            // 整数向上取整除法
            uintptr_t pg = map[i].addr_low + 0x0fffU;
c01063dc:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c01063df:	89 d0                	mov    %edx,%eax
c01063e1:	01 c0                	add    %eax,%eax
c01063e3:	01 d0                	add    %edx,%eax
c01063e5:	c1 e0 03             	shl    $0x3,%eax
c01063e8:	89 c2                	mov    %eax,%edx
c01063ea:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c01063ed:	01 d0                	add    %edx,%eax
c01063ef:	8b 40 04             	mov    0x4(%eax),%eax
c01063f2:	05 ff 0f 00 00       	add    $0xfff,%eax
c01063f7:	89 45 bc             	mov    %eax,-0x44(%ebp)
            pmm_mark_chunk_free(pg >> 12, map[i].len_low >> 12);
c01063fa:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c01063fd:	89 d0                	mov    %edx,%eax
c01063ff:	01 c0                	add    %eax,%eax
c0106401:	01 d0                	add    %edx,%eax
c0106403:	c1 e0 03             	shl    $0x3,%eax
c0106406:	89 c2                	mov    %eax,%edx
c0106408:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c010640b:	01 d0                	add    %edx,%eax
c010640d:	8b 40 0c             	mov    0xc(%eax),%eax
c0106410:	c1 e8 0c             	shr    $0xc,%eax
c0106413:	89 c2                	mov    %eax,%edx
c0106415:	8b 45 bc             	mov    -0x44(%ebp),%eax
c0106418:	c1 e8 0c             	shr    $0xc,%eax
c010641b:	83 ec 08             	sub    $0x8,%esp
c010641e:	52                   	push   %edx
c010641f:	50                   	push   %eax
c0106420:	e8 92 03 00 00       	call   c01067b7 <pmm_mark_chunk_free>
c0106425:	83 c4 10             	add    $0x10,%esp
            kprintf("[MM] Freed %u pages start from 0x%x\n",
c0106428:	8b 45 bc             	mov    -0x44(%ebp),%eax
c010642b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0106430:	89 c1                	mov    %eax,%ecx
                   map[i].len_low >> 12,
c0106432:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0106435:	89 d0                	mov    %edx,%eax
c0106437:	01 c0                	add    %eax,%eax
c0106439:	01 d0                	add    %edx,%eax
c010643b:	c1 e0 03             	shl    $0x3,%eax
c010643e:	89 c2                	mov    %eax,%edx
c0106440:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0106443:	01 d0                	add    %edx,%eax
c0106445:	8b 40 0c             	mov    0xc(%eax),%eax
            kprintf("[MM] Freed %u pages start from 0x%x\n",
c0106448:	c1 e8 0c             	shr    $0xc,%eax
c010644b:	83 ec 04             	sub    $0x4,%esp
c010644e:	51                   	push   %ecx
c010644f:	50                   	push   %eax
c0106450:	68 5c e0 d0 c0       	push   $0xc0d0e05c
c0106455:	e8 27 48 00 00       	call   c010ac81 <kprintf>
c010645a:	83 c4 10             	add    $0x10,%esp
    for (unsigned int i = 0; i < map_size; i++) {
c010645d:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
c0106461:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0106464:	3b 45 d0             	cmp    -0x30(%ebp),%eax
c0106467:	0f 82 c1 fe ff ff    	jb     c010632e <_vir_kernel_init+0xf0>
                   pg & ~0x0fffU);
        }
    }

    // 将内核占据的页设为已占用
    size_t pg_count = (uintptr_t)(&virkernel_end  - &virkernel_start) >> 12;
c010646d:	b8 00 90 d1 c0       	mov    $0xc0d19000,%eax
c0106472:	2d 00 60 10 c0       	sub    $0xc0106000,%eax
c0106477:	c1 e8 0c             	shr    $0xc,%eax
c010647a:	89 45 cc             	mov    %eax,-0x34(%ebp)
    pmm_mark_chunk_occupied(KERNEL_PID, V2P(&virkernel_start) >> 12, pg_count, 0);
c010647d:	b8 00 60 10 c0       	mov    $0xc0106000,%eax
c0106482:	05 00 00 00 40       	add    $0x40000000,%eax
c0106487:	c1 e8 0c             	shr    $0xc,%eax
c010648a:	6a 00                	push   $0x0
c010648c:	ff 75 cc             	push   -0x34(%ebp)
c010648f:	50                   	push   %eax
c0106490:	6a ff                	push   $0xffffffff
c0106492:	e8 63 03 00 00       	call   c01067fa <pmm_mark_chunk_occupied>
c0106497:	83 c4 10             	add    $0x10,%esp
    kprintf("[MM] Allocated %d pages for kernel.\n", pg_count);
c010649a:	83 ec 08             	sub    $0x8,%esp
c010649d:	ff 75 cc             	push   -0x34(%ebp)
c01064a0:	68 84 e0 d0 c0       	push   $0xc0d0e084
c01064a5:	e8 d7 47 00 00       	call   c010ac81 <kprintf>
c01064aa:	83 c4 10             	add    $0x10,%esp

    size_t vga_buf_pgs = VGA_BUFFER_SIZE >> 12;
c01064ad:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
    
    // 首先，标记VGA部分为已占用
    pmm_mark_chunk_occupied(KERNEL_PID, VIDEO >> 12, vga_buf_pgs, 0);
c01064b4:	6a 00                	push   $0x0
c01064b6:	ff 75 c8             	push   -0x38(%ebp)
c01064b9:	68 b8 00 00 00       	push   $0xb8
c01064be:	6a ff                	push   $0xffffffff
c01064c0:	e8 35 03 00 00       	call   c01067fa <pmm_mark_chunk_occupied>
c01064c5:	83 c4 10             	add    $0x10,%esp
    
    // 重映射VGA文本缓冲区（以后会变成显存，i.e., framebuffer）
    for (size_t i = 0; i < vga_buf_pgs; i++)
c01064c8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
c01064cf:	eb 32                	jmp    c0106503 <_vir_kernel_init+0x2c5>
    {
        pt_t* test = vmm_map_page(KERNEL_PID, VGA_BUFFER_VADDR + (i << 12), VIDEO + (i << 12), PG_PREM_RW, PG_PREM_RW);
c01064d1:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01064d4:	c1 e0 0c             	shl    $0xc,%eax
c01064d7:	05 00 80 0b 00       	add    $0xb8000,%eax
c01064dc:	89 c2                	mov    %eax,%edx
c01064de:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01064e1:	c1 e0 0c             	shl    $0xc,%eax
c01064e4:	2d 00 00 00 50       	sub    $0x50000000,%eax
c01064e9:	83 ec 0c             	sub    $0xc,%esp
c01064ec:	6a 03                	push   $0x3
c01064ee:	6a 03                	push   $0x3
c01064f0:	52                   	push   %edx
c01064f1:	50                   	push   %eax
c01064f2:	6a ff                	push   $0xffffffff
c01064f4:	e8 87 10 00 00       	call   c0107580 <vmm_map_page>
c01064f9:	83 c4 20             	add    $0x20,%esp
c01064fc:	89 45 c0             	mov    %eax,-0x40(%ebp)
    for (size_t i = 0; i < vga_buf_pgs; i++)
c01064ff:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
c0106503:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0106506:	3b 45 c8             	cmp    -0x38(%ebp),%eax
c0106509:	72 c6                	jb     c01064d1 <_vir_kernel_init+0x293>
        //kprintf("[MM] vga vaddr %x\n", test);
    }
    set_vga_buffer(VGA_BUFFER_VADDR);
c010650b:	83 ec 0c             	sub    $0xc,%esp
c010650e:	68 00 00 00 b0       	push   $0xb0000000
c0106513:	e8 f8 fa ff ff       	call   c0106010 <set_vga_buffer>
c0106518:	83 c4 10             	add    $0x10,%esp
    kprintf("[MM] Mapped VGA to %x.\n", VGA_BUFFER_VADDR);
c010651b:	83 ec 08             	sub    $0x8,%esp
c010651e:	68 00 00 00 b0       	push   $0xb0000000
c0106523:	68 a9 e0 d0 c0       	push   $0xc0d0e0a9
c0106528:	e8 54 47 00 00       	call   c010ac81 <kprintf>
c010652d:	83 c4 10             	add    $0x10,%esp

    // 为内核创建一个专属栈空间。
    for (size_t i = 0; i < (KSTACK_SIZE >> 12); i++) {
c0106530:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
c0106537:	eb 26                	jmp    c010655f <_vir_kernel_init+0x321>
        pt_t* test = vmm_alloc_page(KERNEL_PID, (void*)KSTACK_START + (i << 12), NULL, PG_PREM_RW, PG_PREM_RW);
c0106539:	8b 45 dc             	mov    -0x24(%ebp),%eax
c010653c:	c1 e0 0c             	shl    $0xc,%eax
c010653f:	2d 00 00 41 00       	sub    $0x410000,%eax
c0106544:	83 ec 0c             	sub    $0xc,%esp
c0106547:	6a 03                	push   $0x3
c0106549:	6a 03                	push   $0x3
c010654b:	6a 00                	push   $0x0
c010654d:	50                   	push   %eax
c010654e:	6a ff                	push   $0xffffffff
c0106550:	e8 d2 11 00 00       	call   c0107727 <vmm_alloc_page>
c0106555:	83 c4 20             	add    $0x20,%esp
c0106558:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    for (size_t i = 0; i < (KSTACK_SIZE >> 12); i++) {
c010655b:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
c010655f:	83 7d dc 0f          	cmpl   $0xf,-0x24(%ebp)
c0106563:	76 d4                	jbe    c0106539 <_vir_kernel_init+0x2fb>
        //kprintf("[MM] kernel paddr %x", test);
    }
    kprintf("[MM] Allocated %d pages for stack start at 0x%x\n", KSTACK_SIZE>>12, KSTACK_START);
c0106565:	83 ec 04             	sub    $0x4,%esp
c0106568:	68 00 00 bf ff       	push   $0xffbf0000
c010656d:	6a 10                	push   $0x10
c010656f:	68 c4 e0 d0 c0       	push   $0xc0d0e0c4
c0106574:	e8 08 47 00 00       	call   c010ac81 <kprintf>
c0106579:	83 c4 10             	add    $0x10,%esp

    //give malloc init
    //mem_init();
    //kprintf("[MM] Malloc Init Success \n");
    kprintf("[KERNEL] === Initialization Done === \n\n");
c010657c:	83 ec 0c             	sub    $0xc,%esp
c010657f:	68 f8 e0 d0 c0       	push   $0xc0d0e0f8
c0106584:	e8 f8 46 00 00       	call   c010ac81 <kprintf>
c0106589:	83 c4 10             	add    $0x10,%esp

    vga_put_str("MELOX OS\n");
c010658c:	83 ec 0c             	sub    $0xc,%esp
c010658f:	68 20 e1 d0 c0       	push   $0xc0d0e120
c0106594:	e8 7a fb ff ff       	call   c0106113 <vga_put_str>
c0106599:	83 c4 10             	add    $0x10,%esp
     //__asm__("int $1");
}
c010659c:	90                   	nop
c010659d:	8d 65 f4             	lea    -0xc(%ebp),%esp
c01065a0:	5b                   	pop    %ebx
c01065a1:	5e                   	pop    %esi
c01065a2:	5f                   	pop    %edi
c01065a3:	5d                   	pop    %ebp
c01065a4:	c3                   	ret    

c01065a5 <_kernel_main>:
//     //kprintf("[KERNEL] === Post Initialization Done === \n\n");
// }

void creat_proc0();
void _kernel_main()
{
c01065a5:	55                   	push   %ebp
c01065a6:	89 e5                	mov    %esp,%ebp
c01065a8:	81 ec 18 01 00 00    	sub    $0x118,%esp
    char* buf[64];
    
    kprintf("We are now running in virtual address space!\n\n");
c01065ae:	83 ec 0c             	sub    $0xc,%esp
c01065b1:	68 2c e1 d0 c0       	push   $0xc0d0e12c
c01065b6:	e8 c6 46 00 00       	call   c010ac81 <kprintf>
c01065bb:	83 c4 10             	add    $0x10,%esp
    
    cpu_get_brand(buf);
c01065be:	83 ec 0c             	sub    $0xc,%esp
c01065c1:	8d 85 f4 fe ff ff    	lea    -0x10c(%ebp),%eax
c01065c7:	50                   	push   %eax
c01065c8:	e8 15 25 00 00       	call   c0108ae2 <cpu_get_brand>
c01065cd:	83 c4 10             	add    $0x10,%esp
    kprintf("CPU: %s\n\n", buf);
c01065d0:	83 ec 08             	sub    $0x8,%esp
c01065d3:	8d 85 f4 fe ff ff    	lea    -0x10c(%ebp),%eax
c01065d9:	50                   	push   %eax
c01065da:	68 5b e1 d0 c0       	push   $0xc0d0e15b
c01065df:	e8 9d 46 00 00       	call   c010ac81 <kprintf>
c01065e4:	83 c4 10             	add    $0x10,%esp

    uintptr_t k_start = vmm_v2p(&virkernel_start);
c01065e7:	83 ec 0c             	sub    $0xc,%esp
c01065ea:	68 00 60 10 c0       	push   $0xc0106000
c01065ef:	e8 78 14 00 00       	call   c0107a6c <vmm_v2p>
c01065f4:	83 c4 10             	add    $0x10,%esp
c01065f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    kprintf("The kernel's base address mapping: %x->%x\n", &virkernel_start, k_start);
c01065fa:	83 ec 04             	sub    $0x4,%esp
c01065fd:	ff 75 f4             	push   -0xc(%ebp)
c0106600:	68 00 60 10 c0       	push   $0xc0106000
c0106605:	68 68 e1 d0 c0       	push   $0xc0d0e168
c010660a:	e8 72 46 00 00       	call   c010ac81 <kprintf>
c010660f:	83 c4 10             	add    $0x10,%esp

    // timer_init();
    // init_keyboard();

    //now we move ourself into proc0, and fork proc1
    if(sched_init())
c0106612:	e8 ef 41 00 00       	call   c010a806 <sched_init>
c0106617:	85 c0                	test   %eax,%eax
c0106619:	74 05                	je     c0106620 <_kernel_main+0x7b>
        //kprintf("process sched init!");

    creat_proc0();
c010661b:	e8 03 00 00 00       	call   c0106623 <creat_proc0>
}
c0106620:	90                   	nop
c0106621:	c9                   	leave  
c0106622:	c3                   	ret    

c0106623 <creat_proc0>:


void creat_proc0()
{
c0106623:	55                   	push   %ebp
c0106624:	89 e5                	mov    %esp,%ebp
c0106626:	57                   	push   %edi
c0106627:	53                   	push   %ebx
c0106628:	81 ec b0 00 00 00    	sub    $0xb0,%esp
    /**
     *      1. 在创建proc0进程前关闭中断
     *
     */

    init_proc(&proc0);
c010662e:	83 ec 0c             	sub    $0xc,%esp
c0106631:	8d 45 8c             	lea    -0x74(%ebp),%eax
c0106634:	50                   	push   %eax
c0106635:	e8 2b 3b 00 00       	call   c010a165 <init_proc>
c010663a:	83 c4 10             	add    $0x10,%esp
    proc0.intr_contxt = (isr_param){ 
                                  .cs = KCODE_SEG,
                                  .eip = (void*)__proc0,
                                  .ss = KDATA_SEG,
                                  .eflags = cpu_reflags() };
c010663d:	e8 ec fb ff ff       	call   c010622e <cpu_reflags>
c0106642:	89 c3                	mov    %eax,%ebx
    proc0.intr_contxt = (isr_param){ 
c0106644:	8d 55 94             	lea    -0x6c(%ebp),%edx
c0106647:	b8 00 00 00 00       	mov    $0x0,%eax
c010664c:	b9 0f 00 00 00       	mov    $0xf,%ecx
c0106651:	89 d7                	mov    %edx,%edi
c0106653:	f3 ab                	rep stos %eax,%es:(%edi)
c0106655:	b8 65 7d 10 c0       	mov    $0xc0107d65,%eax
c010665a:	89 45 bc             	mov    %eax,-0x44(%ebp)
c010665d:	c7 45 c0 08 00 00 00 	movl   $0x8,-0x40(%ebp)
c0106664:	89 5d c4             	mov    %ebx,-0x3c(%ebp)
c0106667:	c7 45 cc 10 00 00 00 	movl   $0x10,-0x34(%ebp)

    // 必须在读取eflags之后禁用。否则当进程被调度时，中断依然是关闭的！
    asm volatile("cli");
c010666e:	fa                   	cli    
    setup_proc_mem(&proc0, PD_REFERENCED);
c010666f:	83 ec 08             	sub    $0x8,%esp
c0106672:	68 00 00 c0 ff       	push   $0xffc00000
c0106677:	8d 45 8c             	lea    -0x74(%ebp),%eax
c010667a:	50                   	push   %eax
c010667b:	e8 97 3c 00 00       	call   c010a317 <setup_proc_mem>
c0106680:	83 c4 10             	add    $0x10,%esp
                 "movl %%esp, %0\n"
                 "movl %%eax, %%cr3\n"
                 "movl %%ebx, %%esp\n"
                 : "=m"(proc0.intr_contxt.registers.esp)// it must have, it give us the correct esp,
                 //so we can soft iret get in to push $0 pos, then we esp + 8 get cs:ip->proc0!
                 : "r"(proc0.page_table),
c0106683:	8b 55 f0             	mov    -0x10(%ebp),%edx
                   "i"(KSATCK_TOP),
                   "i"(KCODE_SEG),
                   "r"(proc0.intr_contxt.eip)
c0106686:	8b 4d bc             	mov    -0x44(%ebp),%ecx
    asm volatile("movl %%cr3, %%eax\n"
c0106689:	0f 20 d8             	mov    %cr3,%eax
c010668c:	89 e3                	mov    %esp,%ebx
c010668e:	0f 22 da             	mov    %edx,%cr3
c0106691:	bc f0 ff bf ff       	mov    $0xffbffff0,%esp
c0106696:	9c                   	pushf  
c0106697:	6a 08                	push   $0x8
c0106699:	51                   	push   %ecx
c010669a:	6a 00                	push   $0x0
c010669c:	6a 00                	push   $0x0
c010669e:	89 65 b0             	mov    %esp,-0x50(%ebp)
c01066a1:	0f 22 d8             	mov    %eax,%cr3
c01066a4:	89 dc                	mov    %ebx,%esp
                 : "%eax", "%ebx", "memory");

    // 向调度器注册进程。
    push_process(&proc0);
c01066a6:	83 ec 0c             	sub    $0xc,%esp
c01066a9:	8d 45 8c             	lea    -0x74(%ebp),%eax
c01066ac:	50                   	push   %eax
c01066ad:	e8 e7 42 00 00       	call   c010a999 <push_process>
c01066b2:	83 c4 10             	add    $0x10,%esp

    // 由于时钟中断未就绪，我们需要手动通知调度器进行第一次调度。这里也会同时隐式地恢复我们的eflags.IF位
    schedule();
c01066b5:	e8 08 42 00 00       	call   c010a8c2 <schedule>

    /* Should not return */
    kprintf("Unexpected Return");
c01066ba:	83 ec 0c             	sub    $0xc,%esp
c01066bd:	68 93 e1 d0 c0       	push   $0xc0d0e193
c01066c2:	e8 ba 45 00 00       	call   c010ac81 <kprintf>
c01066c7:	83 c4 10             	add    $0x10,%esp
c01066ca:	90                   	nop
c01066cb:	8d 65 f8             	lea    -0x8(%ebp),%esp
c01066ce:	5b                   	pop    %ebx
c01066cf:	5f                   	pop    %edi
c01066d0:	5d                   	pop    %ebp
c01066d1:	c3                   	ret    

c01066d2 <pmm_init>:

#ifdef MEMSTRUCT
static struct pp_struct pm_table[PM_STRUCT_MAX_SIZE];

void pmm_init(uintptr_t mem_upper_lim)
{
c01066d2:	55                   	push   %ebp
c01066d3:	89 e5                	mov    %esp,%ebp
c01066d5:	83 ec 10             	sub    $0x10,%esp
    pg_lookup_ptr = LOOKUP_START;
c01066d8:	c7 05 c0 b0 10 c0 01 	movl   $0x1,0xc010b0c0
c01066df:	00 00 00 
    max_pg = (PG_ALIGN(mem_upper_lim) >> 12);
c01066e2:	8b 45 08             	mov    0x8(%ebp),%eax
c01066e5:	c1 e8 0c             	shr    $0xc,%eax
c01066e8:	a3 c4 b0 10 c0       	mov    %eax,0xc010b0c4

    for (size_t i = 0; i < PM_STRUCT_MAX_SIZE; i++) {
c01066ed:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c01066f4:	eb 49                	jmp    c010673f <pmm_init+0x6d>
        pm_table[i] = (struct pp_struct) {
c01066f6:	8b 55 fc             	mov    -0x4(%ebp),%edx
c01066f9:	89 d0                	mov    %edx,%eax
c01066fb:	01 c0                	add    %eax,%eax
c01066fd:	01 d0                	add    %edx,%eax
c01066ff:	c1 e0 02             	shl    $0x2,%eax
c0106702:	05 e0 b0 10 c0       	add    $0xc010b0e0,%eax
c0106707:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c010670d:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0106710:	89 d0                	mov    %edx,%eax
c0106712:	01 c0                	add    %eax,%eax
c0106714:	01 d0                	add    %edx,%eax
c0106716:	c1 e0 02             	shl    $0x2,%eax
c0106719:	05 e4 b0 10 c0       	add    $0xc010b0e4,%eax
c010671e:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
c0106724:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0106727:	89 d0                	mov    %edx,%eax
c0106729:	01 c0                	add    %eax,%eax
c010672b:	01 d0                	add    %edx,%eax
c010672d:	c1 e0 02             	shl    $0x2,%eax
c0106730:	05 e8 b0 10 c0       	add    $0xc010b0e8,%eax
c0106735:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    for (size_t i = 0; i < PM_STRUCT_MAX_SIZE; i++) {
c010673b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c010673f:	81 7d fc ff ff 0f 00 	cmpl   $0xfffff,-0x4(%ebp)
c0106746:	76 ae                	jbe    c01066f6 <pmm_init+0x24>
            .owner = 0,
            .attr = 0,
            .ref_counts = 1
        };
    }
}
c0106748:	90                   	nop
c0106749:	90                   	nop
c010674a:	c9                   	leave  
c010674b:	c3                   	ret    

c010674c <pmm_mark_page_free>:

void pmm_mark_page_free(uintptr_t ppn)
{
c010674c:	55                   	push   %ebp
c010674d:	89 e5                	mov    %esp,%ebp
    pm_table[ppn].ref_counts = 0;
c010674f:	8b 55 08             	mov    0x8(%ebp),%edx
c0106752:	89 d0                	mov    %edx,%eax
c0106754:	01 c0                	add    %eax,%eax
c0106756:	01 d0                	add    %edx,%eax
c0106758:	c1 e0 02             	shl    $0x2,%eax
c010675b:	05 e4 b0 10 c0       	add    $0xc010b0e4,%eax
c0106760:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
c0106766:	90                   	nop
c0106767:	5d                   	pop    %ebp
c0106768:	c3                   	ret    

c0106769 <pmm_mark_page_occupied>:

void pmm_mark_page_occupied(pid_t owner, uintptr_t ppn, pp_attr_t attr)
{
c0106769:	55                   	push   %ebp
c010676a:	89 e5                	mov    %esp,%ebp
c010676c:	83 ec 10             	sub    $0x10,%esp
    pm_table[ppn] = (struct pp_struct) {
c010676f:	8b 55 0c             	mov    0xc(%ebp),%edx
c0106772:	89 d0                	mov    %edx,%eax
c0106774:	01 c0                	add    %eax,%eax
c0106776:	01 d0                	add    %edx,%eax
c0106778:	c1 e0 02             	shl    $0x2,%eax
c010677b:	8d 90 e0 b0 10 c0    	lea    -0x3fef4f20(%eax),%edx
c0106781:	8b 45 08             	mov    0x8(%ebp),%eax
c0106784:	89 02                	mov    %eax,(%edx)
c0106786:	8b 55 0c             	mov    0xc(%ebp),%edx
c0106789:	89 d0                	mov    %edx,%eax
c010678b:	01 c0                	add    %eax,%eax
c010678d:	01 d0                	add    %edx,%eax
c010678f:	c1 e0 02             	shl    $0x2,%eax
c0106792:	05 e4 b0 10 c0       	add    $0xc010b0e4,%eax
c0106797:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
c010679d:	8b 55 0c             	mov    0xc(%ebp),%edx
c01067a0:	89 d0                	mov    %edx,%eax
c01067a2:	01 c0                	add    %eax,%eax
c01067a4:	01 d0                	add    %edx,%eax
c01067a6:	c1 e0 02             	shl    $0x2,%eax
c01067a9:	8d 90 e8 b0 10 c0    	lea    -0x3fef4f18(%eax),%edx
c01067af:	8b 45 10             	mov    0x10(%ebp),%eax
c01067b2:	89 02                	mov    %eax,(%edx)
        .owner = owner,
        .ref_counts = 1,
        .attr = attr
    };
}
c01067b4:	90                   	nop
c01067b5:	c9                   	leave  
c01067b6:	c3                   	ret    

c01067b7 <pmm_mark_chunk_free>:

void pmm_mark_chunk_free(uintptr_t start_ppn, size_t page_count)
{
c01067b7:	55                   	push   %ebp
c01067b8:	89 e5                	mov    %esp,%ebp
c01067ba:	83 ec 10             	sub    $0x10,%esp
    for (size_t i = start_ppn; i < start_ppn + page_count && i < max_pg; i++)
c01067bd:	8b 45 08             	mov    0x8(%ebp),%eax
c01067c0:	89 45 fc             	mov    %eax,-0x4(%ebp)
c01067c3:	eb 1b                	jmp    c01067e0 <pmm_mark_chunk_free+0x29>
    {
        pm_table[i].ref_counts = 0;
c01067c5:	8b 55 fc             	mov    -0x4(%ebp),%edx
c01067c8:	89 d0                	mov    %edx,%eax
c01067ca:	01 c0                	add    %eax,%eax
c01067cc:	01 d0                	add    %edx,%eax
c01067ce:	c1 e0 02             	shl    $0x2,%eax
c01067d1:	05 e4 b0 10 c0       	add    $0xc010b0e4,%eax
c01067d6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    for (size_t i = start_ppn; i < start_ppn + page_count && i < max_pg; i++)
c01067dc:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c01067e0:	8b 55 08             	mov    0x8(%ebp),%edx
c01067e3:	8b 45 0c             	mov    0xc(%ebp),%eax
c01067e6:	01 d0                	add    %edx,%eax
c01067e8:	39 45 fc             	cmp    %eax,-0x4(%ebp)
c01067eb:	73 0a                	jae    c01067f7 <pmm_mark_chunk_free+0x40>
c01067ed:	a1 c4 b0 10 c0       	mov    0xc010b0c4,%eax
c01067f2:	39 45 fc             	cmp    %eax,-0x4(%ebp)
c01067f5:	72 ce                	jb     c01067c5 <pmm_mark_chunk_free+0xe>
    }
}
c01067f7:	90                   	nop
c01067f8:	c9                   	leave  
c01067f9:	c3                   	ret    

c01067fa <pmm_mark_chunk_occupied>:

void pmm_mark_chunk_occupied(pid_t owner, uint32_t start_ppn, size_t page_count, pp_attr_t attr)
{
c01067fa:	55                   	push   %ebp
c01067fb:	89 e5                	mov    %esp,%ebp
c01067fd:	83 ec 10             	sub    $0x10,%esp
    for (size_t i = start_ppn; i < start_ppn + page_count && i < max_pg; i++)
c0106800:	8b 45 0c             	mov    0xc(%ebp),%eax
c0106803:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0106806:	eb 49                	jmp    c0106851 <pmm_mark_chunk_occupied+0x57>
    {
        pm_table[i] = (struct pp_struct) {
c0106808:	8b 55 fc             	mov    -0x4(%ebp),%edx
c010680b:	89 d0                	mov    %edx,%eax
c010680d:	01 c0                	add    %eax,%eax
c010680f:	01 d0                	add    %edx,%eax
c0106811:	c1 e0 02             	shl    $0x2,%eax
c0106814:	8d 90 e0 b0 10 c0    	lea    -0x3fef4f20(%eax),%edx
c010681a:	8b 45 08             	mov    0x8(%ebp),%eax
c010681d:	89 02                	mov    %eax,(%edx)
c010681f:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0106822:	89 d0                	mov    %edx,%eax
c0106824:	01 c0                	add    %eax,%eax
c0106826:	01 d0                	add    %edx,%eax
c0106828:	c1 e0 02             	shl    $0x2,%eax
c010682b:	05 e4 b0 10 c0       	add    $0xc010b0e4,%eax
c0106830:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
c0106836:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0106839:	89 d0                	mov    %edx,%eax
c010683b:	01 c0                	add    %eax,%eax
c010683d:	01 d0                	add    %edx,%eax
c010683f:	c1 e0 02             	shl    $0x2,%eax
c0106842:	8d 90 e8 b0 10 c0    	lea    -0x3fef4f18(%eax),%edx
c0106848:	8b 45 14             	mov    0x14(%ebp),%eax
c010684b:	89 02                	mov    %eax,(%edx)
    for (size_t i = start_ppn; i < start_ppn + page_count && i < max_pg; i++)
c010684d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0106851:	8b 55 0c             	mov    0xc(%ebp),%edx
c0106854:	8b 45 10             	mov    0x10(%ebp),%eax
c0106857:	01 d0                	add    %edx,%eax
c0106859:	39 45 fc             	cmp    %eax,-0x4(%ebp)
c010685c:	73 0a                	jae    c0106868 <pmm_mark_chunk_occupied+0x6e>
c010685e:	a1 c4 b0 10 c0       	mov    0xc010b0c4,%eax
c0106863:	39 45 fc             	cmp    %eax,-0x4(%ebp)
c0106866:	72 a0                	jb     c0106808 <pmm_mark_chunk_occupied+0xe>
            .owner = owner,
            .ref_counts = 1,
            .attr = attr
        };
    }
}
c0106868:	90                   	nop
c0106869:	c9                   	leave  
c010686a:	c3                   	ret    

c010686b <pmm_alloc_page>:

void* pmm_alloc_page(pid_t owner, pp_attr_t attr)
{
c010686b:	55                   	push   %ebp
c010686c:	89 e5                	mov    %esp,%ebp
c010686e:	83 ec 20             	sub    $0x20,%esp
        // Next fit approach. Maximize the throughput!
    uintptr_t good_page_found = NULL;
c0106871:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    size_t old_pg_ptr = pg_lookup_ptr;
c0106878:	a1 c0 b0 10 c0       	mov    0xc010b0c0,%eax
c010687d:	89 45 f8             	mov    %eax,-0x8(%ebp)
    size_t upper_lim = max_pg;
c0106880:	a1 c4 b0 10 c0       	mov    0xc010b0c4,%eax
c0106885:	89 45 f4             	mov    %eax,-0xc(%ebp)
    struct pp_struct* pm;
    while (!good_page_found && pg_lookup_ptr < upper_lim) {
c0106888:	eb 7d                	jmp    c0106907 <pmm_alloc_page+0x9c>
        pm = &pm_table[pg_lookup_ptr];
c010688a:	8b 15 c0 b0 10 c0    	mov    0xc010b0c0,%edx
c0106890:	89 d0                	mov    %edx,%eax
c0106892:	01 c0                	add    %eax,%eax
c0106894:	01 d0                	add    %edx,%eax
c0106896:	c1 e0 02             	shl    $0x2,%eax
c0106899:	05 e0 b0 10 c0       	add    $0xc010b0e0,%eax
c010689e:	89 45 f0             	mov    %eax,-0x10(%ebp)

        // skip the fully occupied chunk, reduce # of iterations
        if (!pm->ref_counts) {
c01068a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01068a4:	8b 40 04             	mov    0x4(%eax),%eax
c01068a7:	85 c0                	test   %eax,%eax
c01068a9:	75 28                	jne    c01068d3 <pmm_alloc_page+0x68>
                *pm = (struct pp_struct) {
c01068ab:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01068ae:	8b 55 08             	mov    0x8(%ebp),%edx
c01068b1:	89 10                	mov    %edx,(%eax)
c01068b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01068b6:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
c01068bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01068c0:	8b 55 0c             	mov    0xc(%ebp),%edx
c01068c3:	89 50 08             	mov    %edx,0x8(%eax)
                .attr = attr,
                .owner = owner,
                .ref_counts = 1
            };
            good_page_found = pg_lookup_ptr << 12;
c01068c6:	a1 c0 b0 10 c0       	mov    0xc010b0c0,%eax
c01068cb:	c1 e0 0c             	shl    $0xc,%eax
c01068ce:	89 45 fc             	mov    %eax,-0x4(%ebp)
c01068d1:	eb 34                	jmp    c0106907 <pmm_alloc_page+0x9c>
        } else {
            pg_lookup_ptr ++;
c01068d3:	a1 c0 b0 10 c0       	mov    0xc010b0c0,%eax
c01068d8:	83 c0 01             	add    $0x1,%eax
c01068db:	a3 c0 b0 10 c0       	mov    %eax,0xc010b0c0

            // We've searched the interval [old_pg_ptr, max_pg) but failed
            //   may be chances in [1, old_pg_ptr) ?
            // Let's find out!
            if (pg_lookup_ptr >= upper_lim && old_pg_ptr != LOOKUP_START) {
c01068e0:	a1 c0 b0 10 c0       	mov    0xc010b0c0,%eax
c01068e5:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c01068e8:	77 1d                	ja     c0106907 <pmm_alloc_page+0x9c>
c01068ea:	83 7d f8 01          	cmpl   $0x1,-0x8(%ebp)
c01068ee:	74 17                	je     c0106907 <pmm_alloc_page+0x9c>
                upper_lim = old_pg_ptr;
c01068f0:	8b 45 f8             	mov    -0x8(%ebp),%eax
c01068f3:	89 45 f4             	mov    %eax,-0xc(%ebp)
                pg_lookup_ptr = LOOKUP_START;
c01068f6:	c7 05 c0 b0 10 c0 01 	movl   $0x1,0xc010b0c0
c01068fd:	00 00 00 
                old_pg_ptr = LOOKUP_START;
c0106900:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
    while (!good_page_found && pg_lookup_ptr < upper_lim) {
c0106907:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c010690b:	75 0e                	jne    c010691b <pmm_alloc_page+0xb0>
c010690d:	a1 c0 b0 10 c0       	mov    0xc010b0c0,%eax
c0106912:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0106915:	0f 87 6f ff ff ff    	ja     c010688a <pmm_alloc_page+0x1f>
            }
        }
    }
    if (!good_page_found) {
c010691b:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c010691f:	75 0c                	jne    c010692d <pmm_alloc_page+0xc2>
        __current->k_status = MXOUTOFMEM;
c0106921:	a1 20 cb d0 c0       	mov    0xc0d0cb20,%eax
c0106926:	c7 40 68 fd ff ff ff 	movl   $0xfffffffd,0x68(%eax)
    }
    return (void*)good_page_found;
c010692d:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0106930:	c9                   	leave  
c0106931:	c3                   	ret    

c0106932 <pmm_alloc_cpage>:

void* pmm_alloc_cpage(pid_t owner, size_t num_pages, pp_attr_t attr) {
c0106932:	55                   	push   %ebp
c0106933:	89 e5                	mov    %esp,%ebp
c0106935:	83 ec 10             	sub    $0x10,%esp
    size_t p1 = 0;
c0106938:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    size_t p2 = 0;
c010693f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

    while (p2 < max_pg && p2 - p1 < num_pages)
c0106946:	eb 28                	jmp    c0106970 <pmm_alloc_cpage+0x3e>
    {
        (!(&pm_table[p2])->ref_counts) ? (p2++) : (p1 = p2);
c0106948:	8b 55 f8             	mov    -0x8(%ebp),%edx
c010694b:	89 d0                	mov    %edx,%eax
c010694d:	01 c0                	add    %eax,%eax
c010694f:	01 d0                	add    %edx,%eax
c0106951:	c1 e0 02             	shl    $0x2,%eax
c0106954:	05 e4 b0 10 c0       	add    $0xc010b0e4,%eax
c0106959:	8b 00                	mov    (%eax),%eax
c010695b:	85 c0                	test   %eax,%eax
c010695d:	75 0b                	jne    c010696a <pmm_alloc_cpage+0x38>
c010695f:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0106962:	83 c0 01             	add    $0x1,%eax
c0106965:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0106968:	eb 06                	jmp    c0106970 <pmm_alloc_cpage+0x3e>
c010696a:	8b 45 f8             	mov    -0x8(%ebp),%eax
c010696d:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while (p2 < max_pg && p2 - p1 < num_pages)
c0106970:	a1 c4 b0 10 c0       	mov    0xc010b0c4,%eax
c0106975:	39 45 f8             	cmp    %eax,-0x8(%ebp)
c0106978:	73 0b                	jae    c0106985 <pmm_alloc_cpage+0x53>
c010697a:	8b 45 f8             	mov    -0x8(%ebp),%eax
c010697d:	2b 45 fc             	sub    -0x4(%ebp),%eax
c0106980:	39 45 0c             	cmp    %eax,0xc(%ebp)
c0106983:	77 c3                	ja     c0106948 <pmm_alloc_cpage+0x16>
    }

    if (p2 < max_pg) {
c0106985:	a1 c4 b0 10 c0       	mov    0xc010b0c4,%eax
c010698a:	39 45 f8             	cmp    %eax,-0x8(%ebp)
c010698d:	73 07                	jae    c0106996 <pmm_alloc_cpage+0x64>
        return NULL;
c010698f:	b8 00 00 00 00       	mov    $0x0,%eax
c0106994:	eb 1a                	jmp    c01069b0 <pmm_alloc_cpage+0x7e>
    }

    pmm_mark_chunk_occupied(owner, p1, num_pages, attr);
c0106996:	ff 75 10             	push   0x10(%ebp)
c0106999:	ff 75 0c             	push   0xc(%ebp)
c010699c:	ff 75 fc             	push   -0x4(%ebp)
c010699f:	ff 75 08             	push   0x8(%ebp)
c01069a2:	e8 53 fe ff ff       	call   c01067fa <pmm_mark_chunk_occupied>
c01069a7:	83 c4 10             	add    $0x10,%esp

    return p1 << 12;
c01069aa:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01069ad:	c1 e0 0c             	shl    $0xc,%eax
}
c01069b0:	c9                   	leave  
c01069b1:	c3                   	ret    

c01069b2 <pmm_free_page>:

int pmm_free_page(pid_t owner, void* page)
{
c01069b2:	55                   	push   %ebp
c01069b3:	89 e5                	mov    %esp,%ebp
c01069b5:	83 ec 10             	sub    $0x10,%esp
    struct pp_struct* pm = &pm_table[(intptr_t)page >> 12];
c01069b8:	8b 45 0c             	mov    0xc(%ebp),%eax
c01069bb:	c1 f8 0c             	sar    $0xc,%eax
c01069be:	89 c2                	mov    %eax,%edx
c01069c0:	89 d0                	mov    %edx,%eax
c01069c2:	01 c0                	add    %eax,%eax
c01069c4:	01 d0                	add    %edx,%eax
c01069c6:	c1 e0 02             	shl    $0x2,%eax
c01069c9:	05 e0 b0 10 c0       	add    $0xc010b0e0,%eax
c01069ce:	89 45 fc             	mov    %eax,-0x4(%ebp)
    //     pm->ref_counts--;
    //     return 1;
    // }

        // Is this a MMIO mapping or double free?
    if (((intptr_t)page >> 12) >= max_pg || !(pm->ref_counts)) {
c01069d1:	8b 45 0c             	mov    0xc(%ebp),%eax
c01069d4:	c1 f8 0c             	sar    $0xc,%eax
c01069d7:	89 c2                	mov    %eax,%edx
c01069d9:	a1 c4 b0 10 c0       	mov    0xc010b0c4,%eax
c01069de:	39 c2                	cmp    %eax,%edx
c01069e0:	73 0a                	jae    c01069ec <pmm_free_page+0x3a>
c01069e2:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01069e5:	8b 40 04             	mov    0x4(%eax),%eax
c01069e8:	85 c0                	test   %eax,%eax
c01069ea:	75 07                	jne    c01069f3 <pmm_free_page+0x41>
        return 0;
c01069ec:	b8 00 00 00 00       	mov    $0x0,%eax
c01069f1:	eb 14                	jmp    c0106a07 <pmm_free_page+0x55>
    }

    // TODO: 检查权限，保证：1) 只有正在使用该页（包括被分享者）的进程可以释放； 2) 内核可释放所有页。
    pm->ref_counts--;
c01069f3:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01069f6:	8b 40 04             	mov    0x4(%eax),%eax
c01069f9:	8d 50 ff             	lea    -0x1(%eax),%edx
c01069fc:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01069ff:	89 50 04             	mov    %edx,0x4(%eax)
    return 1;
c0106a02:	b8 01 00 00 00       	mov    $0x1,%eax
    //return 0;
    
}
c0106a07:	c9                   	leave  
c0106a08:	c3                   	ret    

c0106a09 <pmm_query>:

struct pp_struct* pmm_query(void* pa) {
c0106a09:	55                   	push   %ebp
c0106a0a:	89 e5                	mov    %esp,%ebp
c0106a0c:	83 ec 10             	sub    $0x10,%esp
    uint32_t ppn = (uintptr_t)pa >> 12;
c0106a0f:	8b 45 08             	mov    0x8(%ebp),%eax
c0106a12:	c1 e8 0c             	shr    $0xc,%eax
c0106a15:	89 45 fc             	mov    %eax,-0x4(%ebp)
    
    if (ppn >= PM_STRUCT_MAX_SIZE) {
c0106a18:	81 7d fc ff ff 0f 00 	cmpl   $0xfffff,-0x4(%ebp)
c0106a1f:	76 07                	jbe    c0106a28 <pmm_query+0x1f>
        return NULL;
c0106a21:	b8 00 00 00 00       	mov    $0x0,%eax
c0106a26:	eb 11                	jmp    c0106a39 <pmm_query+0x30>
    }

    return &pm_table[ppn];
c0106a28:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0106a2b:	89 d0                	mov    %edx,%eax
c0106a2d:	01 c0                	add    %eax,%eax
c0106a2f:	01 d0                	add    %edx,%eax
c0106a31:	c1 e0 02             	shl    $0x2,%eax
c0106a34:	05 e0 b0 10 c0       	add    $0xc010b0e0,%eax
}
c0106a39:	c9                   	leave  
c0106a3a:	c3                   	ret    

c0106a3b <pmm_ref_page>:

int pmm_ref_page(pid_t owner, void* page) {
c0106a3b:	55                   	push   %ebp
c0106a3c:	89 e5                	mov    %esp,%ebp
c0106a3e:	83 ec 10             	sub    $0x10,%esp
    //(void*) owner;      // TODO: do smth with owner
    
    uint32_t ppn = (uintptr_t)page >> 12;
c0106a41:	8b 45 0c             	mov    0xc(%ebp),%eax
c0106a44:	c1 e8 0c             	shr    $0xc,%eax
c0106a47:	89 45 fc             	mov    %eax,-0x4(%ebp)
    
    if (ppn >= PM_STRUCT_MAX_SIZE) {
c0106a4a:	81 7d fc ff ff 0f 00 	cmpl   $0xfffff,-0x4(%ebp)
c0106a51:	76 07                	jbe    c0106a5a <pmm_ref_page+0x1f>
        return 0;
c0106a53:	b8 00 00 00 00       	mov    $0x0,%eax
c0106a58:	eb 43                	jmp    c0106a9d <pmm_ref_page+0x62>
    }

    struct pp_struct* pm = &pm_table[ppn];
c0106a5a:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0106a5d:	89 d0                	mov    %edx,%eax
c0106a5f:	01 c0                	add    %eax,%eax
c0106a61:	01 d0                	add    %edx,%eax
c0106a63:	c1 e0 02             	shl    $0x2,%eax
c0106a66:	05 e0 b0 10 c0       	add    $0xc010b0e0,%eax
c0106a6b:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if (ppn >= max_pg || !pm->ref_counts) {
c0106a6e:	a1 c4 b0 10 c0       	mov    0xc010b0c4,%eax
c0106a73:	39 45 fc             	cmp    %eax,-0x4(%ebp)
c0106a76:	73 0a                	jae    c0106a82 <pmm_ref_page+0x47>
c0106a78:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0106a7b:	8b 40 04             	mov    0x4(%eax),%eax
c0106a7e:	85 c0                	test   %eax,%eax
c0106a80:	75 07                	jne    c0106a89 <pmm_ref_page+0x4e>
        return 0;
c0106a82:	b8 00 00 00 00       	mov    $0x0,%eax
c0106a87:	eb 14                	jmp    c0106a9d <pmm_ref_page+0x62>
    }

    pm->ref_counts++;
c0106a89:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0106a8c:	8b 40 04             	mov    0x4(%eax),%eax
c0106a8f:	8d 50 01             	lea    0x1(%eax),%edx
c0106a92:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0106a95:	89 50 04             	mov    %edx,0x4(%eax)
    return 1;
c0106a98:	b8 01 00 00 00       	mov    $0x1,%eax
}
c0106a9d:	c9                   	leave  
c0106a9e:	c3                   	ret    

c0106a9f <extend_heap>:
 * @brief extend heap
 * 
 * @param extend size
 */
static void* extend_heap(size_t words)
{
c0106a9f:	55                   	push   %ebp
c0106aa0:	89 e5                	mov    %esp,%ebp
c0106aa2:	83 ec 18             	sub    $0x18,%esp
    char* bp = mem_brk;
c0106aa5:	a1 e8 b0 d0 c0       	mov    0xc0d0b0e8,%eax
c0106aaa:	89 45 f4             	mov    %eax,-0xc(%ebp)
    size_t size;
    //align
    size = (words % 2) ? words * WSIZE : (words + 1) * WSIZE;
c0106aad:	8b 45 08             	mov    0x8(%ebp),%eax
c0106ab0:	83 e0 01             	and    $0x1,%eax
c0106ab3:	85 c0                	test   %eax,%eax
c0106ab5:	74 08                	je     c0106abf <extend_heap+0x20>
c0106ab7:	8b 45 08             	mov    0x8(%ebp),%eax
c0106aba:	c1 e0 02             	shl    $0x2,%eax
c0106abd:	eb 09                	jmp    c0106ac8 <extend_heap+0x29>
c0106abf:	8b 45 08             	mov    0x8(%ebp),%eax
c0106ac2:	83 c0 01             	add    $0x1,%eax
c0106ac5:	c1 e0 02             	shl    $0x2,%eax
c0106ac8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    mem_sbrk(size + WSIZE);
c0106acb:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106ace:	83 c0 04             	add    $0x4,%eax
c0106ad1:	83 ec 0c             	sub    $0xc,%esp
c0106ad4:	50                   	push   %eax
c0106ad5:	e8 64 03 00 00       	call   c0106e3e <mem_sbrk>
c0106ada:	83 c4 10             	add    $0x10,%esp

    //initialize free block header/footer and the epilogue header
    PUT(HDRP(bp), PACK(size, 0)); // free block header
c0106add:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106ae0:	8d 50 fc             	lea    -0x4(%eax),%edx
c0106ae3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106ae6:	89 02                	mov    %eax,(%edx)
    PUT(FTRP(bp), PACK(size, 0)); // free block foot //TODO CRUSH HERE, ADD ONE PAGE OUT OF RANGE, WE ONLY GIVE ONE PAGE, MEYBE PAGE FAULT
c0106ae8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106aeb:	83 e8 04             	sub    $0x4,%eax
c0106aee:	8b 00                	mov    (%eax),%eax
c0106af0:	83 e0 f8             	and    $0xfffffff8,%eax
c0106af3:	8d 50 f8             	lea    -0x8(%eax),%edx
c0106af6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106af9:	01 c2                	add    %eax,%edx
c0106afb:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106afe:	89 02                	mov    %eax,(%edx)
    PUT(HDRP(NEXT_BLKP(bp)), PACK(0, 1)); //NEW Epilogue header
c0106b00:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106b03:	83 e8 04             	sub    $0x4,%eax
c0106b06:	8b 00                	mov    (%eax),%eax
c0106b08:	83 e0 f8             	and    $0xfffffff8,%eax
c0106b0b:	8d 50 fc             	lea    -0x4(%eax),%edx
c0106b0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106b11:	01 d0                	add    %edx,%eax
c0106b13:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

    //Coalesce if previous block is free
    return coalesce(bp);
c0106b19:	83 ec 0c             	sub    $0xc,%esp
c0106b1c:	ff 75 f4             	push   -0xc(%ebp)
c0106b1f:	e8 05 00 00 00       	call   c0106b29 <coalesce>
c0106b24:	83 c4 10             	add    $0x10,%esp
}
c0106b27:	c9                   	leave  
c0106b28:	c3                   	ret    

c0106b29 <coalesce>:
 * @brief Coalesce free blk
 * 
 * @param Coalesce bp pointer
 */
static void* coalesce(void* bp)
{
c0106b29:	55                   	push   %ebp
c0106b2a:	89 e5                	mov    %esp,%ebp
c0106b2c:	83 ec 10             	sub    $0x10,%esp
    size_t prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));
c0106b2f:	8b 45 08             	mov    0x8(%ebp),%eax
c0106b32:	83 e8 04             	sub    $0x4,%eax
c0106b35:	8b 00                	mov    (%eax),%eax
c0106b37:	83 e0 f8             	and    $0xfffffff8,%eax
c0106b3a:	8d 50 f8             	lea    -0x8(%eax),%edx
c0106b3d:	8b 45 08             	mov    0x8(%ebp),%eax
c0106b40:	01 d0                	add    %edx,%eax
c0106b42:	8b 00                	mov    (%eax),%eax
c0106b44:	83 e0 01             	and    $0x1,%eax
c0106b47:	89 45 fc             	mov    %eax,-0x4(%ebp)
    size_t next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));
c0106b4a:	8b 45 08             	mov    0x8(%ebp),%eax
c0106b4d:	83 e8 04             	sub    $0x4,%eax
c0106b50:	8b 00                	mov    (%eax),%eax
c0106b52:	83 e0 f8             	and    $0xfffffff8,%eax
c0106b55:	8d 50 fc             	lea    -0x4(%eax),%edx
c0106b58:	8b 45 08             	mov    0x8(%ebp),%eax
c0106b5b:	01 d0                	add    %edx,%eax
c0106b5d:	8b 00                	mov    (%eax),%eax
c0106b5f:	83 e0 01             	and    $0x1,%eax
c0106b62:	89 45 f8             	mov    %eax,-0x8(%ebp)
    size_t size = GET_SIZE(HDRP(bp));
c0106b65:	8b 45 08             	mov    0x8(%ebp),%eax
c0106b68:	83 e8 04             	sub    $0x4,%eax
c0106b6b:	8b 00                	mov    (%eax),%eax
c0106b6d:	83 e0 f8             	and    $0xfffffff8,%eax
c0106b70:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(prev_alloc && next_alloc)
c0106b73:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0106b77:	74 0e                	je     c0106b87 <coalesce+0x5e>
c0106b79:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0106b7d:	74 08                	je     c0106b87 <coalesce+0x5e>
        return bp;
c0106b7f:	8b 45 08             	mov    0x8(%ebp),%eax
c0106b82:	e9 3e 01 00 00       	jmp    c0106cc5 <coalesce+0x19c>

    else if(prev_alloc && !next_alloc)
c0106b87:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0106b8b:	74 49                	je     c0106bd6 <coalesce+0xad>
c0106b8d:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0106b91:	75 43                	jne    c0106bd6 <coalesce+0xad>
    {
        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));
c0106b93:	8b 45 08             	mov    0x8(%ebp),%eax
c0106b96:	83 e8 04             	sub    $0x4,%eax
c0106b99:	8b 00                	mov    (%eax),%eax
c0106b9b:	83 e0 f8             	and    $0xfffffff8,%eax
c0106b9e:	8d 50 fc             	lea    -0x4(%eax),%edx
c0106ba1:	8b 45 08             	mov    0x8(%ebp),%eax
c0106ba4:	01 d0                	add    %edx,%eax
c0106ba6:	8b 00                	mov    (%eax),%eax
c0106ba8:	83 e0 f8             	and    $0xfffffff8,%eax
c0106bab:	01 45 f4             	add    %eax,-0xc(%ebp)
        PUT(HDRP(bp), PACK(size, 0));
c0106bae:	8b 45 08             	mov    0x8(%ebp),%eax
c0106bb1:	8d 50 fc             	lea    -0x4(%eax),%edx
c0106bb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106bb7:	89 02                	mov    %eax,(%edx)
        PUT(FTRP(bp), PACK(size, 0));
c0106bb9:	8b 45 08             	mov    0x8(%ebp),%eax
c0106bbc:	83 e8 04             	sub    $0x4,%eax
c0106bbf:	8b 00                	mov    (%eax),%eax
c0106bc1:	83 e0 f8             	and    $0xfffffff8,%eax
c0106bc4:	8d 50 f8             	lea    -0x8(%eax),%edx
c0106bc7:	8b 45 08             	mov    0x8(%ebp),%eax
c0106bca:	01 c2                	add    %eax,%edx
c0106bcc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106bcf:	89 02                	mov    %eax,(%edx)
c0106bd1:	e9 ec 00 00 00       	jmp    c0106cc2 <coalesce+0x199>
    }

    else if(!prev_alloc && next_alloc)
c0106bd6:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0106bda:	75 6b                	jne    c0106c47 <coalesce+0x11e>
c0106bdc:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0106be0:	74 65                	je     c0106c47 <coalesce+0x11e>
    {
        size += GET_SIZE(HDRP(PREV_BLKP(bp)));//TO DO ,THERE IS PEOBLEM, CRUSH HERE
c0106be2:	8b 45 08             	mov    0x8(%ebp),%eax
c0106be5:	83 e8 08             	sub    $0x8,%eax
c0106be8:	8b 00                	mov    (%eax),%eax
c0106bea:	83 e0 f8             	and    $0xfffffff8,%eax
c0106bed:	ba fc ff ff ff       	mov    $0xfffffffc,%edx
c0106bf2:	29 c2                	sub    %eax,%edx
c0106bf4:	8b 45 08             	mov    0x8(%ebp),%eax
c0106bf7:	01 d0                	add    %edx,%eax
c0106bf9:	8b 00                	mov    (%eax),%eax
c0106bfb:	83 e0 f8             	and    $0xfffffff8,%eax
c0106bfe:	01 45 f4             	add    %eax,-0xc(%ebp)
        PUT(FTRP(bp), PACK(size, 0));
c0106c01:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c04:	83 e8 04             	sub    $0x4,%eax
c0106c07:	8b 00                	mov    (%eax),%eax
c0106c09:	83 e0 f8             	and    $0xfffffff8,%eax
c0106c0c:	8d 50 f8             	lea    -0x8(%eax),%edx
c0106c0f:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c12:	01 c2                	add    %eax,%edx
c0106c14:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106c17:	89 02                	mov    %eax,(%edx)
        PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0));
c0106c19:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c1c:	83 e8 08             	sub    $0x8,%eax
c0106c1f:	8b 00                	mov    (%eax),%eax
c0106c21:	83 e0 f8             	and    $0xfffffff8,%eax
c0106c24:	ba fc ff ff ff       	mov    $0xfffffffc,%edx
c0106c29:	29 c2                	sub    %eax,%edx
c0106c2b:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c2e:	01 c2                	add    %eax,%edx
c0106c30:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106c33:	89 02                	mov    %eax,(%edx)
        bp = PREV_BLKP(bp);
c0106c35:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c38:	83 e8 08             	sub    $0x8,%eax
c0106c3b:	8b 00                	mov    (%eax),%eax
c0106c3d:	83 e0 f8             	and    $0xfffffff8,%eax
c0106c40:	f7 d8                	neg    %eax
c0106c42:	01 45 08             	add    %eax,0x8(%ebp)
c0106c45:	eb 7b                	jmp    c0106cc2 <coalesce+0x199>
    }

    else{
        size += GET_SIZE(HDRP(PREV_BLKP(bp))) + GET_SIZE(FTRP(NEXT_BLKP(bp)));
c0106c47:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c4a:	83 e8 08             	sub    $0x8,%eax
c0106c4d:	8b 00                	mov    (%eax),%eax
c0106c4f:	83 e0 f8             	and    $0xfffffff8,%eax
c0106c52:	ba fc ff ff ff       	mov    $0xfffffffc,%edx
c0106c57:	29 c2                	sub    %eax,%edx
c0106c59:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c5c:	01 d0                	add    %edx,%eax
c0106c5e:	8b 00                	mov    (%eax),%eax
c0106c60:	83 e0 f8             	and    $0xfffffff8,%eax
c0106c63:	89 c2                	mov    %eax,%edx
c0106c65:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c68:	83 e8 04             	sub    $0x4,%eax
c0106c6b:	8b 00                	mov    (%eax),%eax
c0106c6d:	83 e0 f8             	and    $0xfffffff8,%eax
c0106c70:	8d 48 f8             	lea    -0x8(%eax),%ecx
c0106c73:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c76:	01 c8                	add    %ecx,%eax
c0106c78:	8b 00                	mov    (%eax),%eax
c0106c7a:	83 e0 f8             	and    $0xfffffff8,%eax
c0106c7d:	01 d0                	add    %edx,%eax
c0106c7f:	01 45 f4             	add    %eax,-0xc(%ebp)
        PUT(FTRP(PREV_BLKP(bp)), PACK(size, 0));
c0106c82:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c85:	83 e8 04             	sub    $0x4,%eax
c0106c88:	8b 00                	mov    (%eax),%eax
c0106c8a:	83 e0 f8             	and    $0xfffffff8,%eax
c0106c8d:	8d 50 f8             	lea    -0x8(%eax),%edx
c0106c90:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c93:	01 c2                	add    %eax,%edx
c0106c95:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106c98:	89 02                	mov    %eax,(%edx)
        PUT(HDRP(NEXT_BLKP(bp)), PACK(size, 0));
c0106c9a:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c9d:	83 e8 04             	sub    $0x4,%eax
c0106ca0:	8b 00                	mov    (%eax),%eax
c0106ca2:	83 e0 f8             	and    $0xfffffff8,%eax
c0106ca5:	8d 50 fc             	lea    -0x4(%eax),%edx
c0106ca8:	8b 45 08             	mov    0x8(%ebp),%eax
c0106cab:	01 c2                	add    %eax,%edx
c0106cad:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106cb0:	89 02                	mov    %eax,(%edx)
        bp = PREV_BLKP(bp);
c0106cb2:	8b 45 08             	mov    0x8(%ebp),%eax
c0106cb5:	83 e8 08             	sub    $0x8,%eax
c0106cb8:	8b 00                	mov    (%eax),%eax
c0106cba:	83 e0 f8             	and    $0xfffffff8,%eax
c0106cbd:	f7 d8                	neg    %eax
c0106cbf:	01 45 08             	add    %eax,0x8(%ebp)
    }
    return bp;
c0106cc2:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0106cc5:	c9                   	leave  
c0106cc6:	c3                   	ret    

c0106cc7 <find_fit>:
 * @brief find free blk
 * 
 * @param find size
 */
static void* find_fit(size_t asize)// we just traverse heap
{
c0106cc7:	55                   	push   %ebp
c0106cc8:	89 e5                	mov    %esp,%ebp
c0106cca:	83 ec 10             	sub    $0x10,%esp
    void* bp = heap_listp;
c0106ccd:	a1 e0 b0 d0 c0       	mov    0xc0d0b0e0,%eax
c0106cd2:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while(GET_ALLOC(HDRP(bp)) || (GET_SIZE(HDRP(bp)) < asize))
c0106cd5:	eb 2f                	jmp    c0106d06 <find_fit+0x3f>
    {
        if(GET_SIZE(bp) != 0 && GET_ALLOC(bp) != 1)
c0106cd7:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106cda:	8b 00                	mov    (%eax),%eax
c0106cdc:	83 e0 f8             	and    $0xfffffff8,%eax
c0106cdf:	85 c0                	test   %eax,%eax
c0106ce1:	74 1c                	je     c0106cff <find_fit+0x38>
c0106ce3:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106ce6:	8b 00                	mov    (%eax),%eax
c0106ce8:	83 e0 01             	and    $0x1,%eax
c0106ceb:	85 c0                	test   %eax,%eax
c0106ced:	75 10                	jne    c0106cff <find_fit+0x38>
            bp = NEXT_BLKP(bp);
c0106cef:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106cf2:	83 e8 04             	sub    $0x4,%eax
c0106cf5:	8b 00                	mov    (%eax),%eax
c0106cf7:	83 e0 f8             	and    $0xfffffff8,%eax
c0106cfa:	01 45 fc             	add    %eax,-0x4(%ebp)
c0106cfd:	eb 07                	jmp    c0106d06 <find_fit+0x3f>
        else
            return NULL;
c0106cff:	b8 00 00 00 00       	mov    $0x0,%eax
c0106d04:	eb 22                	jmp    c0106d28 <find_fit+0x61>
    while(GET_ALLOC(HDRP(bp)) || (GET_SIZE(HDRP(bp)) < asize))
c0106d06:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106d09:	83 e8 04             	sub    $0x4,%eax
c0106d0c:	8b 00                	mov    (%eax),%eax
c0106d0e:	83 e0 01             	and    $0x1,%eax
c0106d11:	85 c0                	test   %eax,%eax
c0106d13:	75 c2                	jne    c0106cd7 <find_fit+0x10>
c0106d15:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106d18:	83 e8 04             	sub    $0x4,%eax
c0106d1b:	8b 00                	mov    (%eax),%eax
c0106d1d:	83 e0 f8             	and    $0xfffffff8,%eax
c0106d20:	39 45 08             	cmp    %eax,0x8(%ebp)
c0106d23:	77 b2                	ja     c0106cd7 <find_fit+0x10>
    }
    return bp;
c0106d25:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0106d28:	c9                   	leave  
c0106d29:	c3                   	ret    

c0106d2a <place>:
 * @brief place the blk
 * 
 * @param blk,size
 */
static void place(void* bp, size_t asize)
{
c0106d2a:	55                   	push   %ebp
c0106d2b:	89 e5                	mov    %esp,%ebp
c0106d2d:	83 ec 10             	sub    $0x10,%esp
    size_t bp_allsize = GET_SIZE(HDRP(bp));
c0106d30:	8b 45 08             	mov    0x8(%ebp),%eax
c0106d33:	83 e8 04             	sub    $0x4,%eax
c0106d36:	8b 00                	mov    (%eax),%eax
c0106d38:	83 e0 f8             	and    $0xfffffff8,%eax
c0106d3b:	89 45 fc             	mov    %eax,-0x4(%ebp)
    size_t remain_size = bp_allsize - asize;
c0106d3e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106d41:	2b 45 0c             	sub    0xc(%ebp),%eax
c0106d44:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if(remain_size >= 2*DSIZE)
c0106d47:	83 7d f8 0f          	cmpl   $0xf,-0x8(%ebp)
c0106d4b:	76 5b                	jbe    c0106da8 <place+0x7e>
    {
        PUT(HDRP(bp), PACK(asize, 1));
c0106d4d:	8b 45 08             	mov    0x8(%ebp),%eax
c0106d50:	83 e8 04             	sub    $0x4,%eax
c0106d53:	8b 55 0c             	mov    0xc(%ebp),%edx
c0106d56:	83 ca 01             	or     $0x1,%edx
c0106d59:	89 10                	mov    %edx,(%eax)
        PUT(FTRP(bp), PACK(asize, 1));
c0106d5b:	8b 45 08             	mov    0x8(%ebp),%eax
c0106d5e:	83 e8 04             	sub    $0x4,%eax
c0106d61:	8b 00                	mov    (%eax),%eax
c0106d63:	83 e0 f8             	and    $0xfffffff8,%eax
c0106d66:	8d 50 f8             	lea    -0x8(%eax),%edx
c0106d69:	8b 45 08             	mov    0x8(%ebp),%eax
c0106d6c:	01 d0                	add    %edx,%eax
c0106d6e:	8b 55 0c             	mov    0xc(%ebp),%edx
c0106d71:	83 ca 01             	or     $0x1,%edx
c0106d74:	89 10                	mov    %edx,(%eax)
        PUT(HDRP(NEXT_BLKP(bp)), PACK(remain_size, 0));
c0106d76:	8b 45 08             	mov    0x8(%ebp),%eax
c0106d79:	83 e8 04             	sub    $0x4,%eax
c0106d7c:	8b 00                	mov    (%eax),%eax
c0106d7e:	83 e0 f8             	and    $0xfffffff8,%eax
c0106d81:	8d 50 fc             	lea    -0x4(%eax),%edx
c0106d84:	8b 45 08             	mov    0x8(%ebp),%eax
c0106d87:	01 c2                	add    %eax,%edx
c0106d89:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0106d8c:	89 02                	mov    %eax,(%edx)
        PUT(FTRP(NEXT_BLKP(bp)), PACK(remain_size, 0));
c0106d8e:	8b 45 08             	mov    0x8(%ebp),%eax
c0106d91:	83 e8 04             	sub    $0x4,%eax
c0106d94:	8b 00                	mov    (%eax),%eax
c0106d96:	83 e0 f8             	and    $0xfffffff8,%eax
c0106d99:	8d 50 f8             	lea    -0x8(%eax),%edx
c0106d9c:	8b 45 08             	mov    0x8(%ebp),%eax
c0106d9f:	01 c2                	add    %eax,%edx
c0106da1:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0106da4:	89 02                	mov    %eax,(%edx)
    }else{
        PUT(HDRP(bp), PACK(bp_allsize, 1));
        PUT(FTRP(bp), PACK(bp_allsize, 1));
    }
}
c0106da6:	eb 29                	jmp    c0106dd1 <place+0xa7>
        PUT(HDRP(bp), PACK(bp_allsize, 1));
c0106da8:	8b 45 08             	mov    0x8(%ebp),%eax
c0106dab:	83 e8 04             	sub    $0x4,%eax
c0106dae:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0106db1:	83 ca 01             	or     $0x1,%edx
c0106db4:	89 10                	mov    %edx,(%eax)
        PUT(FTRP(bp), PACK(bp_allsize, 1));
c0106db6:	8b 45 08             	mov    0x8(%ebp),%eax
c0106db9:	83 e8 04             	sub    $0x4,%eax
c0106dbc:	8b 00                	mov    (%eax),%eax
c0106dbe:	83 e0 f8             	and    $0xfffffff8,%eax
c0106dc1:	8d 50 f8             	lea    -0x8(%eax),%edx
c0106dc4:	8b 45 08             	mov    0x8(%ebp),%eax
c0106dc7:	01 d0                	add    %edx,%eax
c0106dc9:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0106dcc:	83 ca 01             	or     $0x1,%edx
c0106dcf:	89 10                	mov    %edx,(%eax)
}
c0106dd1:	90                   	nop
c0106dd2:	c9                   	leave  
c0106dd3:	c3                   	ret    

c0106dd4 <mem_init>:

//following is head file function

void mem_init()
{
c0106dd4:	55                   	push   %ebp
c0106dd5:	89 e5                	mov    %esp,%ebp
c0106dd7:	83 ec 18             	sub    $0x18,%esp
    mem_heap = &__heap_start;
c0106dda:	c7 05 e4 b0 d0 c0 00 	movl   $0xc1119000,0xc0d0b0e4
c0106de1:	90 11 c1 
    //mem_heap = (char*)Malloc(MAX_HEAP);
    mem_brk = mem_heap;
c0106de4:	a1 e4 b0 d0 c0       	mov    0xc0d0b0e4,%eax
c0106de9:	a3 e8 b0 d0 c0       	mov    %eax,0xc0d0b0e8
    //mem_max_addr = (char*)(mem_heap + MAX_HEAP);
    mem_max_addr = (char*)KSTACK_START;
c0106dee:	c7 05 ec b0 d0 c0 00 	movl   $0xffbf0000,0xc0d0b0ec
c0106df5:	00 bf ff 
    uint8_t* pgaddr = 0;
c0106df8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    if((pgaddr = vmm_alloc_page(KERNEL_PID, mem_brk, NULL, PG_PREM_RW, PG_PREM_RW)) == NULL)
c0106dff:	a1 e8 b0 d0 c0       	mov    0xc0d0b0e8,%eax
c0106e04:	83 ec 0c             	sub    $0xc,%esp
c0106e07:	6a 03                	push   $0x3
c0106e09:	6a 03                	push   $0x3
c0106e0b:	6a 00                	push   $0x0
c0106e0d:	50                   	push   %eax
c0106e0e:	6a ff                	push   $0xffffffff
c0106e10:	e8 12 09 00 00       	call   c0107727 <vmm_alloc_page>
c0106e15:	83 c4 20             	add    $0x20,%esp
c0106e18:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0106e1b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0106e1f:	74 1a                	je     c0106e3b <mem_init+0x67>
        return;
    kprintf("malloc init phy address is 0x%x\n", pgaddr);
c0106e21:	83 ec 08             	sub    $0x8,%esp
c0106e24:	ff 75 f4             	push   -0xc(%ebp)
c0106e27:	68 a8 e1 d0 c0       	push   $0xc0d0e1a8
c0106e2c:	e8 50 3e 00 00       	call   c010ac81 <kprintf>
c0106e31:	83 c4 10             	add    $0x10,%esp
    malloc_init();
c0106e34:	e8 bb 00 00 00       	call   c0106ef4 <malloc_init>
c0106e39:	eb 01                	jmp    c0106e3c <mem_init+0x68>
        return;
c0106e3b:	90                   	nop
}
c0106e3c:	c9                   	leave  
c0106e3d:	c3                   	ret    

c0106e3e <mem_sbrk>:

void* mem_sbrk(int incr)
{
c0106e3e:	55                   	push   %ebp
c0106e3f:	89 e5                	mov    %esp,%ebp
c0106e41:	83 ec 18             	sub    $0x18,%esp
    char* old = mem_brk;
c0106e44:	a1 e8 b0 d0 c0       	mov    0xc0d0b0e8,%eax
c0106e49:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if((incr < 0) || ((mem_brk + incr) > mem_max_addr))
c0106e4c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0106e50:	78 14                	js     c0106e66 <mem_sbrk+0x28>
c0106e52:	8b 15 e8 b0 d0 c0    	mov    0xc0d0b0e8,%edx
c0106e58:	8b 45 08             	mov    0x8(%ebp),%eax
c0106e5b:	01 c2                	add    %eax,%edx
c0106e5d:	a1 ec b0 d0 c0       	mov    0xc0d0b0ec,%eax
c0106e62:	39 c2                	cmp    %eax,%edx
c0106e64:	76 0a                	jbe    c0106e70 <mem_sbrk+0x32>
    {
        return (void*)-1;
c0106e66:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0106e6b:	e9 82 00 00 00       	jmp    c0106ef2 <mem_sbrk+0xb4>
    }
    char* new = mem_brk + incr;
c0106e70:	8b 15 e8 b0 d0 c0    	mov    0xc0d0b0e8,%edx
c0106e76:	8b 45 08             	mov    0x8(%ebp),%eax
c0106e79:	01 d0                	add    %edx,%eax
c0106e7b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    unsigned int diff = PG_ALIGN(new) - PG_ALIGN(old);
c0106e7e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106e81:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0106e86:	89 c2                	mov    %eax,%edx
c0106e88:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106e8b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0106e90:	89 c1                	mov    %eax,%ecx
c0106e92:	89 d0                	mov    %edx,%eax
c0106e94:	29 c8                	sub    %ecx,%eax
c0106e96:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(diff)
c0106e99:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0106e9d:	74 40                	je     c0106edf <mem_sbrk+0xa1>
    {
        uint8_t* pgaddr = -1;
c0106e9f:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,-0x18(%ebp)
        if(!(pgaddr = vmm_alloc_page(KERNEL_PID, new, NULL, PG_PREM_RW,PG_PREM_RW)))
c0106ea6:	83 ec 0c             	sub    $0xc,%esp
c0106ea9:	6a 03                	push   $0x3
c0106eab:	6a 03                	push   $0x3
c0106ead:	6a 00                	push   $0x0
c0106eaf:	ff 75 f0             	push   -0x10(%ebp)
c0106eb2:	6a ff                	push   $0xffffffff
c0106eb4:	e8 6e 08 00 00       	call   c0107727 <vmm_alloc_page>
c0106eb9:	83 c4 20             	add    $0x20,%esp
c0106ebc:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0106ebf:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0106ec3:	75 07                	jne    c0106ecc <mem_sbrk+0x8e>
        {
            return NULL;
c0106ec5:	b8 00 00 00 00       	mov    $0x0,%eax
c0106eca:	eb 26                	jmp    c0106ef2 <mem_sbrk+0xb4>
        }
        kprintf("head new page is 0x%x\n", pgaddr);
c0106ecc:	83 ec 08             	sub    $0x8,%esp
c0106ecf:	ff 75 e8             	push   -0x18(%ebp)
c0106ed2:	68 c9 e1 d0 c0       	push   $0xc0d0e1c9
c0106ed7:	e8 a5 3d 00 00       	call   c010ac81 <kprintf>
c0106edc:	83 c4 10             	add    $0x10,%esp
    }
    mem_brk += incr;
c0106edf:	8b 15 e8 b0 d0 c0    	mov    0xc0d0b0e8,%edx
c0106ee5:	8b 45 08             	mov    0x8(%ebp),%eax
c0106ee8:	01 d0                	add    %edx,%eax
c0106eea:	a3 e8 b0 d0 c0       	mov    %eax,0xc0d0b0e8
    return (void*)old;
c0106eef:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0106ef2:	c9                   	leave  
c0106ef3:	c3                   	ret    

c0106ef4 <malloc_init>:

int malloc_init()
{
c0106ef4:	55                   	push   %ebp
c0106ef5:	89 e5                	mov    %esp,%ebp
c0106ef7:	83 ec 08             	sub    $0x8,%esp
    if((heap_listp = mem_sbrk(4 * WSIZE)) == (void*) - 1)
c0106efa:	83 ec 0c             	sub    $0xc,%esp
c0106efd:	6a 10                	push   $0x10
c0106eff:	e8 3a ff ff ff       	call   c0106e3e <mem_sbrk>
c0106f04:	83 c4 10             	add    $0x10,%esp
c0106f07:	a3 e0 b0 d0 c0       	mov    %eax,0xc0d0b0e0
c0106f0c:	a1 e0 b0 d0 c0       	mov    0xc0d0b0e0,%eax
c0106f11:	83 f8 ff             	cmp    $0xffffffff,%eax
c0106f14:	75 07                	jne    c0106f1d <malloc_init+0x29>
        return -1;
c0106f16:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0106f1b:	eb 62                	jmp    c0106f7f <malloc_init+0x8b>
    PUT(heap_listp, 0);
c0106f1d:	a1 e0 b0 d0 c0       	mov    0xc0d0b0e0,%eax
c0106f22:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    PUT(heap_listp + (1*WSIZE), PACK(DSIZE, 1));
c0106f28:	a1 e0 b0 d0 c0       	mov    0xc0d0b0e0,%eax
c0106f2d:	83 c0 04             	add    $0x4,%eax
c0106f30:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
    PUT(heap_listp + (2*WSIZE), PACK(DSIZE, 1));
c0106f36:	a1 e0 b0 d0 c0       	mov    0xc0d0b0e0,%eax
c0106f3b:	83 c0 08             	add    $0x8,%eax
c0106f3e:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
    PUT(heap_listp + (3*WSIZE), PACK(0, 1));
c0106f44:	a1 e0 b0 d0 c0       	mov    0xc0d0b0e0,%eax
c0106f49:	83 c0 0c             	add    $0xc,%eax
c0106f4c:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    heap_listp += (2*WSIZE);
c0106f52:	a1 e0 b0 d0 c0       	mov    0xc0d0b0e0,%eax
c0106f57:	83 c0 08             	add    $0x8,%eax
c0106f5a:	a3 e0 b0 d0 c0       	mov    %eax,0xc0d0b0e0

    //extend free heap with free blk og CHUNKSIZE size
    //mem_sbrk((CHUNKSIZE - WSIZE));
    if(extend_heap((CHUNKSIZE - WSIZE)  / WSIZE) == NULL)
c0106f5f:	83 ec 0c             	sub    $0xc,%esp
c0106f62:	68 ff 03 00 00       	push   $0x3ff
c0106f67:	e8 33 fb ff ff       	call   c0106a9f <extend_heap>
c0106f6c:	83 c4 10             	add    $0x10,%esp
c0106f6f:	85 c0                	test   %eax,%eax
c0106f71:	75 07                	jne    c0106f7a <malloc_init+0x86>
        return -1;
c0106f73:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0106f78:	eb 05                	jmp    c0106f7f <malloc_init+0x8b>
    return 0;
c0106f7a:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0106f7f:	c9                   	leave  
c0106f80:	c3                   	ret    

c0106f81 <malloc_free>:

void malloc_free(void* bp)
{
c0106f81:	55                   	push   %ebp
c0106f82:	89 e5                	mov    %esp,%ebp
c0106f84:	83 ec 10             	sub    $0x10,%esp
    size_t size = GET_SIZE(HDRP(bp));
c0106f87:	8b 45 08             	mov    0x8(%ebp),%eax
c0106f8a:	83 e8 04             	sub    $0x4,%eax
c0106f8d:	8b 00                	mov    (%eax),%eax
c0106f8f:	83 e0 f8             	and    $0xfffffff8,%eax
c0106f92:	89 45 fc             	mov    %eax,-0x4(%ebp)

    PUT(HDRP(bp), PACK(size, 0));
c0106f95:	8b 45 08             	mov    0x8(%ebp),%eax
c0106f98:	8d 50 fc             	lea    -0x4(%eax),%edx
c0106f9b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106f9e:	89 02                	mov    %eax,(%edx)
    PUT(FTRP(bp), PACK(size, 0));
c0106fa0:	8b 45 08             	mov    0x8(%ebp),%eax
c0106fa3:	83 e8 04             	sub    $0x4,%eax
c0106fa6:	8b 00                	mov    (%eax),%eax
c0106fa8:	83 e0 f8             	and    $0xfffffff8,%eax
c0106fab:	8d 50 f8             	lea    -0x8(%eax),%edx
c0106fae:	8b 45 08             	mov    0x8(%ebp),%eax
c0106fb1:	01 c2                	add    %eax,%edx
c0106fb3:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106fb6:	89 02                	mov    %eax,(%edx)
    coalesce(bp);
c0106fb8:	ff 75 08             	push   0x8(%ebp)
c0106fbb:	e8 69 fb ff ff       	call   c0106b29 <coalesce>
c0106fc0:	83 c4 04             	add    $0x4,%esp
}
c0106fc3:	90                   	nop
c0106fc4:	c9                   	leave  
c0106fc5:	c3                   	ret    

c0106fc6 <k_malloc>:

void* k_malloc(size_t size)
{
c0106fc6:	55                   	push   %ebp
c0106fc7:	89 e5                	mov    %esp,%ebp
c0106fc9:	83 ec 18             	sub    $0x18,%esp
    size_t asize;
    size_t extendsize;
    char* bp;

    if(size == 0)
c0106fcc:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0106fd0:	75 0a                	jne    c0106fdc <k_malloc+0x16>
        return NULL;
c0106fd2:	b8 00 00 00 00       	mov    $0x0,%eax
c0106fd7:	e9 8a 00 00 00       	jmp    c0107066 <k_malloc+0xa0>
    
    //THE MIN blk is 2*DSIZE, ONE DSIZE means head and foot, one is align
    if(size <= DSIZE)
c0106fdc:	83 7d 08 08          	cmpl   $0x8,0x8(%ebp)
c0106fe0:	77 09                	ja     c0106feb <k_malloc+0x25>
        asize = 2 * DSIZE;
c0106fe2:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
c0106fe9:	eb 0e                	jmp    c0106ff9 <k_malloc+0x33>
    else
        asize = DSIZE * ((size + DSIZE) + (DSIZE - 1)) / DSIZE; // Round up 
c0106feb:	8b 45 08             	mov    0x8(%ebp),%eax
c0106fee:	83 c0 0f             	add    $0xf,%eax
c0106ff1:	25 ff ff ff 1f       	and    $0x1fffffff,%eax
c0106ff6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    //search the free list of fit
    if((bp = find_fit(asize)) != NULL)
c0106ff9:	ff 75 f4             	push   -0xc(%ebp)
c0106ffc:	e8 c6 fc ff ff       	call   c0106cc7 <find_fit>
c0107001:	83 c4 04             	add    $0x4,%esp
c0107004:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0107007:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c010700b:	74 13                	je     c0107020 <k_malloc+0x5a>
    {
        place(bp, asize);
c010700d:	ff 75 f4             	push   -0xc(%ebp)
c0107010:	ff 75 f0             	push   -0x10(%ebp)
c0107013:	e8 12 fd ff ff       	call   c0106d2a <place>
c0107018:	83 c4 08             	add    $0x8,%esp
        return bp;
c010701b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010701e:	eb 46                	jmp    c0107066 <k_malloc+0xa0>
    }

    //no fit found try to extend head mem
    extendsize = MAX(asize, CHUNKSIZE);
c0107020:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107023:	ba 00 10 00 00       	mov    $0x1000,%edx
c0107028:	39 d0                	cmp    %edx,%eax
c010702a:	0f 42 c2             	cmovb  %edx,%eax
c010702d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if((bp = extend_heap(extendsize / WSIZE)) == NULL)
c0107030:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0107033:	c1 e8 02             	shr    $0x2,%eax
c0107036:	83 ec 0c             	sub    $0xc,%esp
c0107039:	50                   	push   %eax
c010703a:	e8 60 fa ff ff       	call   c0106a9f <extend_heap>
c010703f:	83 c4 10             	add    $0x10,%esp
c0107042:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0107045:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0107049:	75 07                	jne    c0107052 <k_malloc+0x8c>
        return NULL;
c010704b:	b8 00 00 00 00       	mov    $0x0,%eax
c0107050:	eb 14                	jmp    c0107066 <k_malloc+0xa0>
    place(bp, asize);
c0107052:	83 ec 08             	sub    $0x8,%esp
c0107055:	ff 75 f4             	push   -0xc(%ebp)
c0107058:	ff 75 f0             	push   -0x10(%ebp)
c010705b:	e8 ca fc ff ff       	call   c0106d2a <place>
c0107060:	83 c4 10             	add    $0x10,%esp
    return bp;
c0107063:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107066:	c9                   	leave  
c0107067:	c3                   	ret    

c0107068 <cpu_rcr2>:
{
c0107068:	55                   	push   %ebp
c0107069:	89 e5                	mov    %esp,%ebp
c010706b:	83 ec 10             	sub    $0x10,%esp
    asm volatile("movl %%cr2,%0" : "=r" (val));
c010706e:	0f 20 d0             	mov    %cr2,%eax
c0107071:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return val;
c0107074:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0107077:	c9                   	leave  
c0107078:	c3                   	ret    

c0107079 <cpu_invplg>:

reg32 cpu_r_cr3();


static inline void cpu_invplg(void* va)
{
c0107079:	55                   	push   %ebp
c010707a:	89 e5                	mov    %esp,%ebp
    asm volatile("invlpg (%0)" ::"r"((unsigned int)va) : "memory");
c010707c:	8b 45 08             	mov    0x8(%ebp),%eax
c010707f:	0f 01 38             	invlpg (%eax)
};
c0107082:	90                   	nop
c0107083:	5d                   	pop    %ebp
c0107084:	c3                   	ret    

c0107085 <do_page_fault>:
#include <kernel/memory/phy_mem.h>
#include <libs/mstdio.h>
#include <status.h>

void do_page_fault(unsigned long err_code, unsigned long address)
{
c0107085:	55                   	push   %ebp
c0107086:	89 e5                	mov    %esp,%ebp
c0107088:	83 ec 28             	sub    $0x28,%esp
    uintptr_t ptr = cpu_rcr2();
c010708b:	e8 d8 ff ff ff       	call   c0107068 <cpu_rcr2>
c0107090:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (!ptr) {
c0107093:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0107097:	0f 84 ea 00 00 00    	je     c0107187 <do_page_fault+0x102>
        goto segv_term;
    }

    struct mm_region* hit_region = region_get(__current, ptr);
c010709d:	a1 20 cb d0 c0       	mov    0xc0d0cb20,%eax
c01070a2:	83 ec 08             	sub    $0x8,%esp
c01070a5:	ff 75 f4             	push   -0xc(%ebp)
c01070a8:	50                   	push   %eax
c01070a9:	e8 8a 02 00 00       	call   c0107338 <region_get>
c01070ae:	83 c4 10             	add    $0x10,%esp
c01070b1:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (!hit_region) {
c01070b4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c01070b8:	0f 84 cc 00 00 00    	je     c010718a <do_page_fault+0x105>
        // Into the void...
        goto segv_term;
    }

    ptd_t* pte = PTE_MOUNTED(PD_REFERENCED, ptr >> 12);
c01070be:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01070c1:	c1 e8 0c             	shr    $0xc,%eax
c01070c4:	25 ff 03 00 00       	and    $0x3ff,%eax
c01070c9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c01070d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01070d3:	c1 e8 0c             	shr    $0xc,%eax
c01070d6:	c1 e0 02             	shl    $0x2,%eax
c01070d9:	25 00 f0 3f 00       	and    $0x3ff000,%eax
c01070de:	0d 00 00 c0 ff       	or     $0xffc00000,%eax
c01070e3:	01 d0                	add    %edx,%eax
c01070e5:	8b 00                	mov    (%eax),%eax
c01070e7:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (*pte & PG_PRESENT) {
c01070ea:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01070ed:	8b 00                	mov    (%eax),%eax
c01070ef:	83 e0 01             	and    $0x1,%eax
c01070f2:	85 c0                	test   %eax,%eax
c01070f4:	0f 85 93 00 00 00    	jne    c010718d <do_page_fault+0x108>
        }
        // impossible cases or accessing privileged page
        goto segv_term;
    }

    if (!(*pte)) {
c01070fa:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01070fd:	8b 00                	mov    (%eax),%eax
c01070ff:	85 c0                	test   %eax,%eax
c0107101:	0f 84 89 00 00 00    	je     c0107190 <do_page_fault+0x10b>
        // Invalid location
        goto segv_term;
    }
    uintptr_t loc = *pte & ~0xfff;
c0107107:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010710a:	8b 00                	mov    (%eax),%eax
c010710c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0107111:	89 45 e8             	mov    %eax,-0x18(%ebp)
    // a writable page, not present, pte attr is not null
    //   and no indication of cached page -> a new page need to be alloc
    if ((hit_region->attr & REGION_WRITE) && (*pte & 0xfff) && !loc) {
c0107114:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107117:	8b 40 10             	mov    0x10(%eax),%eax
c010711a:	83 e0 08             	and    $0x8,%eax
c010711d:	85 c0                	test   %eax,%eax
c010711f:	74 4e                	je     c010716f <do_page_fault+0xea>
c0107121:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0107124:	8b 00                	mov    (%eax),%eax
c0107126:	25 ff 0f 00 00       	and    $0xfff,%eax
c010712b:	85 c0                	test   %eax,%eax
c010712d:	74 40                	je     c010716f <do_page_fault+0xea>
c010712f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0107133:	75 3a                	jne    c010716f <do_page_fault+0xea>
        cpu_invplg(pte);
c0107135:	83 ec 0c             	sub    $0xc,%esp
c0107138:	ff 75 ec             	push   -0x14(%ebp)
c010713b:	e8 39 ff ff ff       	call   c0107079 <cpu_invplg>
c0107140:	83 c4 10             	add    $0x10,%esp
        uintptr_t pa = pmm_alloc_page(__current->pid, 0);
c0107143:	a1 20 cb d0 c0       	mov    0xc0d0cb20,%eax
c0107148:	8b 00                	mov    (%eax),%eax
c010714a:	83 ec 08             	sub    $0x8,%esp
c010714d:	6a 00                	push   $0x0
c010714f:	50                   	push   %eax
c0107150:	e8 16 f7 ff ff       	call   c010686b <pmm_alloc_page>
c0107155:	83 c4 10             	add    $0x10,%esp
c0107158:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        *pte = *pte | pa | PG_PRESENT;
c010715b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010715e:	8b 00                	mov    (%eax),%eax
c0107160:	0b 45 e4             	or     -0x1c(%ebp),%eax
c0107163:	83 c8 01             	or     $0x1,%eax
c0107166:	89 c2                	mov    %eax,%edx
c0107168:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010716b:	89 10                	mov    %edx,(%eax)
        return;
c010716d:	eb 4c                	jmp    c01071bb <do_page_fault+0x136>
    }
    // page not present, bring it from disk or somewhere else
    kprintf("WIP page fault route,errcode = 0x%x,wrong address = 0x%x, pageaddress is 0x%x",err_code, address, ptr);
c010716f:	ff 75 f4             	push   -0xc(%ebp)
c0107172:	ff 75 0c             	push   0xc(%ebp)
c0107175:	ff 75 08             	push   0x8(%ebp)
c0107178:	68 e0 e1 d0 c0       	push   $0xc0d0e1e0
c010717d:	e8 ff 3a 00 00       	call   c010ac81 <kprintf>
c0107182:	83 c4 10             	add    $0x10,%esp
    while (1)
c0107185:	eb fe                	jmp    c0107185 <do_page_fault+0x100>
        goto segv_term;
c0107187:	90                   	nop
c0107188:	eb 07                	jmp    c0107191 <do_page_fault+0x10c>
        goto segv_term;
c010718a:	90                   	nop
c010718b:	eb 04                	jmp    c0107191 <do_page_fault+0x10c>
        goto segv_term;
c010718d:	90                   	nop
c010718e:	eb 01                	jmp    c0107191 <do_page_fault+0x10c>
        goto segv_term;
c0107190:	90                   	nop
        ;

segv_term:
    kprintf("[KERROR] (pid: %d) Segmentation fault on %x (%x)\n",
            __current->pid,
c0107191:	a1 20 cb d0 c0       	mov    0xc0d0cb20,%eax
c0107196:	8b 00                	mov    (%eax),%eax
    kprintf("[KERROR] (pid: %d) Segmentation fault on %x (%x)\n",
c0107198:	ff 75 0c             	push   0xc(%ebp)
c010719b:	ff 75 f4             	push   -0xc(%ebp)
c010719e:	50                   	push   %eax
c010719f:	68 30 e2 d0 c0       	push   $0xc0d0e230
c01071a4:	e8 d8 3a 00 00       	call   c010ac81 <kprintf>
c01071a9:	83 c4 10             	add    $0x10,%esp
            ptr,
            address);
    terminate_proc(MXSEGFAULT);
c01071ac:	83 ec 0c             	sub    $0xc,%esp
c01071af:	6a fb                	push   $0xfffffffb
c01071b1:	e8 b2 38 00 00       	call   c010aa68 <terminate_proc>
c01071b6:	83 c4 10             	add    $0x10,%esp
    while(1);
c01071b9:	eb fe                	jmp    c01071b9 <do_page_fault+0x134>
    // should not reach
c01071bb:	c9                   	leave  
c01071bc:	c3                   	ret    

c01071bd <page_fault>:
c01071bd:	87 04 24             	xchg   %eax,(%esp)
c01071c0:	51                   	push   %ecx
c01071c1:	52                   	push   %edx
c01071c2:	1e                   	push   %ds
c01071c3:	06                   	push   %es
c01071c4:	0f a0                	push   %fs
c01071c6:	ba 10 00 00 00       	mov    $0x10,%edx
c01071cb:	8e da                	mov    %edx,%ds
c01071cd:	8e c2                	mov    %edx,%es
c01071cf:	8e e2                	mov    %edx,%fs
c01071d1:	8d 54 24 18          	lea    0x18(%esp),%edx
c01071d5:	52                   	push   %edx
c01071d6:	50                   	push   %eax
c01071d7:	e8 a9 fe ff ff       	call   c0107085 <do_page_fault>
c01071dc:	0f a1                	pop    %fs
c01071de:	07                   	pop    %es
c01071df:	1f                   	pop    %ds
c01071e0:	5a                   	pop    %edx
c01071e1:	59                   	pop    %ecx
c01071e2:	58                   	pop    %eax
c01071e3:	cf                   	iret   

c01071e4 <__llist_add>:
};

static inline void __llist_add(struct llist_header* elem,
            struct llist_header* prev,
            struct llist_header* next)
{
c01071e4:	55                   	push   %ebp
c01071e5:	89 e5                	mov    %esp,%ebp
    next->prev = elem;
c01071e7:	8b 45 10             	mov    0x10(%ebp),%eax
c01071ea:	8b 55 08             	mov    0x8(%ebp),%edx
c01071ed:	89 10                	mov    %edx,(%eax)
    elem->next = next;
c01071ef:	8b 45 08             	mov    0x8(%ebp),%eax
c01071f2:	8b 55 10             	mov    0x10(%ebp),%edx
c01071f5:	89 50 04             	mov    %edx,0x4(%eax)
    elem->prev = prev;
c01071f8:	8b 45 08             	mov    0x8(%ebp),%eax
c01071fb:	8b 55 0c             	mov    0xc(%ebp),%edx
c01071fe:	89 10                	mov    %edx,(%eax)
    prev->next = elem;
c0107200:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107203:	8b 55 08             	mov    0x8(%ebp),%edx
c0107206:	89 50 04             	mov    %edx,0x4(%eax)
}
c0107209:	90                   	nop
c010720a:	5d                   	pop    %ebp
c010720b:	c3                   	ret    

c010720c <llist_init_head>:

static inline void llist_init_head(struct llist_header* head) {
c010720c:	55                   	push   %ebp
c010720d:	89 e5                	mov    %esp,%ebp
    head->next = head;
c010720f:	8b 45 08             	mov    0x8(%ebp),%eax
c0107212:	8b 55 08             	mov    0x8(%ebp),%edx
c0107215:	89 50 04             	mov    %edx,0x4(%eax)
    head->prev = head;
c0107218:	8b 45 08             	mov    0x8(%ebp),%eax
c010721b:	8b 55 08             	mov    0x8(%ebp),%edx
c010721e:	89 10                	mov    %edx,(%eax)
}
c0107220:	90                   	nop
c0107221:	5d                   	pop    %ebp
c0107222:	c3                   	ret    

c0107223 <llist_append>:

static inline void llist_append(struct llist_header* head, struct llist_header* elem)
{
c0107223:	55                   	push   %ebp
c0107224:	89 e5                	mov    %esp,%ebp
    __llist_add(elem, head, head->next);
c0107226:	8b 45 08             	mov    0x8(%ebp),%eax
c0107229:	8b 40 04             	mov    0x4(%eax),%eax
c010722c:	50                   	push   %eax
c010722d:	ff 75 08             	push   0x8(%ebp)
c0107230:	ff 75 0c             	push   0xc(%ebp)
c0107233:	e8 ac ff ff ff       	call   c01071e4 <__llist_add>
c0107238:	83 c4 0c             	add    $0xc,%esp
}
c010723b:	90                   	nop
c010723c:	c9                   	leave  
c010723d:	c3                   	ret    

c010723e <region_add>:
#include <kernel/memory/region.h>
#include <kernel/memory/malloc.h>
#include <libs/list.h>
void region_add(struct m_pcb* proc,unsigned long start, unsigned long end, unsigned int attr) {
c010723e:	55                   	push   %ebp
c010723f:	89 e5                	mov    %esp,%ebp
c0107241:	83 ec 28             	sub    $0x28,%esp
    struct mm_region* region = k_malloc(sizeof(struct mm_region));
c0107244:	83 ec 0c             	sub    $0xc,%esp
c0107247:	6a 14                	push   $0x14
c0107249:	e8 78 fd ff ff       	call   c0106fc6 <k_malloc>
c010724e:	83 c4 10             	add    $0x10,%esp
c0107251:	89 45 f4             	mov    %eax,-0xc(%ebp)

    *region = (struct mm_region) {
c0107254:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107257:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c010725d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
c0107264:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
c010726b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
c0107272:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
c0107279:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010727c:	8b 55 0c             	mov    0xc(%ebp),%edx
c010727f:	89 50 08             	mov    %edx,0x8(%eax)
c0107282:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107285:	8b 55 10             	mov    0x10(%ebp),%edx
c0107288:	89 50 0c             	mov    %edx,0xc(%eax)
c010728b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010728e:	8b 55 14             	mov    0x14(%ebp),%edx
c0107291:	89 50 10             	mov    %edx,0x10(%eax)
        .attr = attr,
        .end = end,
        .start = start
    };
    if (!proc->process_mm) {
c0107294:	8b 45 08             	mov    0x8(%ebp),%eax
c0107297:	8b 40 58             	mov    0x58(%eax),%eax
c010729a:	85 c0                	test   %eax,%eax
c010729c:	75 1a                	jne    c01072b8 <region_add+0x7a>
        llist_init_head(&region->head);
c010729e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01072a1:	83 ec 0c             	sub    $0xc,%esp
c01072a4:	50                   	push   %eax
c01072a5:	e8 62 ff ff ff       	call   c010720c <llist_init_head>
c01072aa:	83 c4 10             	add    $0x10,%esp
        proc->process_mm = region;
c01072ad:	8b 45 08             	mov    0x8(%ebp),%eax
c01072b0:	8b 55 f4             	mov    -0xc(%ebp),%edx
c01072b3:	89 50 58             	mov    %edx,0x58(%eax)
    }
    else {
        llist_append(&proc->process_mm->head, &region->head);
    }
}
c01072b6:	eb 16                	jmp    c01072ce <region_add+0x90>
        llist_append(&proc->process_mm->head, &region->head);
c01072b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01072bb:	8b 55 08             	mov    0x8(%ebp),%edx
c01072be:	8b 52 58             	mov    0x58(%edx),%edx
c01072c1:	83 ec 08             	sub    $0x8,%esp
c01072c4:	50                   	push   %eax
c01072c5:	52                   	push   %edx
c01072c6:	e8 58 ff ff ff       	call   c0107223 <llist_append>
c01072cb:	83 c4 10             	add    $0x10,%esp
}
c01072ce:	90                   	nop
c01072cf:	c9                   	leave  
c01072d0:	c3                   	ret    

c01072d1 <region_release_all>:

void region_release_all(struct m_pcb* proc) {
c01072d1:	55                   	push   %ebp
c01072d2:	89 e5                	mov    %esp,%ebp
c01072d4:	83 ec 28             	sub    $0x28,%esp
    struct mm_region* head = proc->process_mm;
c01072d7:	8b 45 08             	mov    0x8(%ebp),%eax
c01072da:	8b 40 58             	mov    0x58(%eax),%eax
c01072dd:	89 45 ec             	mov    %eax,-0x14(%ebp)
    struct mm_region *pos, *n;

    llist_for_each(pos, n, &head->head, head) {
c01072e0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01072e3:	8b 40 04             	mov    0x4(%eax),%eax
c01072e6:	89 45 e8             	mov    %eax,-0x18(%ebp)
c01072e9:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01072ec:	89 45 f4             	mov    %eax,-0xc(%ebp)
c01072ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01072f2:	8b 40 04             	mov    0x4(%eax),%eax
c01072f5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c01072f8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01072fb:	89 45 f0             	mov    %eax,-0x10(%ebp)
c01072fe:	eb 23                	jmp    c0107323 <region_release_all+0x52>
        malloc_free(pos);
c0107300:	83 ec 0c             	sub    $0xc,%esp
c0107303:	ff 75 f4             	push   -0xc(%ebp)
c0107306:	e8 76 fc ff ff       	call   c0106f81 <malloc_free>
c010730b:	83 c4 10             	add    $0x10,%esp
    llist_for_each(pos, n, &head->head, head) {
c010730e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107311:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0107314:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107317:	8b 40 04             	mov    0x4(%eax),%eax
c010731a:	89 45 e0             	mov    %eax,-0x20(%ebp)
c010731d:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0107320:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0107323:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107326:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0107329:	75 d5                	jne    c0107300 <region_release_all+0x2f>
    }

    proc->process_mm = NULL;
c010732b:	8b 45 08             	mov    0x8(%ebp),%eax
c010732e:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
}
c0107335:	90                   	nop
c0107336:	c9                   	leave  
c0107337:	c3                   	ret    

c0107338 <region_get>:

struct mm_region* region_get(struct m_pcb* proc, unsigned long vaddr) {
c0107338:	55                   	push   %ebp
c0107339:	89 e5                	mov    %esp,%ebp
c010733b:	83 ec 20             	sub    $0x20,%esp
    struct mm_region* head = proc->process_mm;
c010733e:	8b 45 08             	mov    0x8(%ebp),%eax
c0107341:	8b 40 58             	mov    0x58(%eax),%eax
c0107344:	89 45 f4             	mov    %eax,-0xc(%ebp)
    
    if (!head) {
c0107347:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c010734b:	75 07                	jne    c0107354 <region_get+0x1c>
        return NULL;
c010734d:	b8 00 00 00 00       	mov    $0x0,%eax
c0107352:	eb 5d                	jmp    c01073b1 <region_get+0x79>
    }

    struct mm_region *pos, *n;

    llist_for_each(pos, n, &head->head, head) {
c0107354:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107357:	8b 40 04             	mov    0x4(%eax),%eax
c010735a:	89 45 f0             	mov    %eax,-0x10(%ebp)
c010735d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107360:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0107363:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0107366:	8b 40 04             	mov    0x4(%eax),%eax
c0107369:	89 45 ec             	mov    %eax,-0x14(%ebp)
c010736c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010736f:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0107372:	eb 30                	jmp    c01073a4 <region_get+0x6c>
        if (vaddr >= pos->start && vaddr < pos->end) {
c0107374:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0107377:	8b 40 08             	mov    0x8(%eax),%eax
c010737a:	39 45 0c             	cmp    %eax,0xc(%ebp)
c010737d:	72 10                	jb     c010738f <region_get+0x57>
c010737f:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0107382:	8b 40 0c             	mov    0xc(%eax),%eax
c0107385:	39 45 0c             	cmp    %eax,0xc(%ebp)
c0107388:	73 05                	jae    c010738f <region_get+0x57>
            return pos;
c010738a:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010738d:	eb 22                	jmp    c01073b1 <region_get+0x79>
    llist_for_each(pos, n, &head->head, head) {
c010738f:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0107392:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0107395:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0107398:	8b 40 04             	mov    0x4(%eax),%eax
c010739b:	89 45 e8             	mov    %eax,-0x18(%ebp)
c010739e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01073a1:	89 45 f8             	mov    %eax,-0x8(%ebp)
c01073a4:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01073a7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c01073aa:	75 c8                	jne    c0107374 <region_get+0x3c>
        }
    }
    return NULL;
c01073ac:	b8 00 00 00 00       	mov    $0x0,%eax
c01073b1:	c9                   	leave  
c01073b2:	c3                   	ret    

c01073b3 <cpu_invplg>:
{
c01073b3:	55                   	push   %ebp
c01073b4:	89 e5                	mov    %esp,%ebp
    asm volatile("invlpg (%0)" ::"r"((unsigned int)va) : "memory");
c01073b6:	8b 45 08             	mov    0x8(%ebp),%eax
c01073b9:	0f 01 38             	invlpg (%eax)
};
c01073bc:	90                   	nop
c01073bd:	5d                   	pop    %ebp
c01073be:	c3                   	ret    

c01073bf <vmm_init>:
#include <kernel/memory/vir_mem.h>
#include <libs/mstring.h>
#include <libs/mstdio.h>

void vmm_init() {
c01073bf:	55                   	push   %ebp
c01073c0:	89 e5                	mov    %esp,%ebp
    // TODO: something here?
}
c01073c2:	90                   	nop
c01073c3:	5d                   	pop    %ebp
c01073c4:	c3                   	ret    

c01073c5 <get_pd>:

// TODO: Move these nasty inline asm stuff into hal
//      These should be arch dependent
ptd_t* get_pd() {
c01073c5:	55                   	push   %ebp
c01073c6:	89 e5                	mov    %esp,%ebp
c01073c8:	83 ec 10             	sub    $0x10,%esp
    ptd_t* pd;
    #ifdef __ARCH_IA32
    __asm__(
c01073cb:	0f 20 d8             	mov    %cr3,%eax
c01073ce:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c01073d3:	89 45 fc             	mov    %eax,-0x4(%ebp)
        "movl %%cr3, %0\n"
        "andl $0xfffff000, %0"
        : "=r"(pd)
    );
    #endif
    return P2V(pd);
c01073d6:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01073d9:	2d 00 00 00 40       	sub    $0x40000000,%eax
}
c01073de:	c9                   	leave  
c01073df:	c3                   	ret    

c01073e0 <set_pd>:

void set_pd(ptd_t* pd) {
c01073e0:	55                   	push   %ebp
c01073e1:	89 e5                	mov    %esp,%ebp
    #ifdef __ARCH_IA32
    __asm__(
c01073e3:	8b 45 08             	mov    0x8(%ebp),%eax
c01073e6:	89 c0                	mov    %eax,%eax
c01073e8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c01073ed:	0f 22 d8             	mov    %eax,%cr3
        "movl %%eax, %%cr3\n"
        :
        : "r" (pd)
    );
    #endif
}
c01073f0:	90                   	nop
c01073f1:	5d                   	pop    %ebp
c01073f2:	c3                   	ret    

c01073f3 <vmm_init_pd>:

ptd_t* vmm_init_pd() {
c01073f3:	55                   	push   %ebp
c01073f4:	89 e5                	mov    %esp,%ebp
c01073f6:	83 ec 18             	sub    $0x18,%esp
    ptd_t* dir = pmm_alloc_page(KERNEL_PID, PP_FGPERSIST);
c01073f9:	83 ec 08             	sub    $0x8,%esp
c01073fc:	6a 01                	push   $0x1
c01073fe:	6a ff                	push   $0xffffffff
c0107400:	e8 66 f4 ff ff       	call   c010686b <pmm_alloc_page>
c0107405:	83 c4 10             	add    $0x10,%esp
c0107408:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for (size_t i = 0; i < 1024; i++)
c010740b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0107412:	eb 19                	jmp    c010742d <vmm_init_pd+0x3a>
    {
        dir[i] = 0;
c0107414:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107417:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010741e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107421:	01 d0                	add    %edx,%eax
c0107423:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    for (size_t i = 0; i < 1024; i++)
c0107429:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010742d:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
c0107434:	76 de                	jbe    c0107414 <vmm_init_pd+0x21>
    }
    
    // 自己映射自己，方便我们在软件层面进行查表地址转换
    dir[1023] = PDE(T_SELF_REF_PERM, dir);
c0107436:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107439:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010743e:	89 c2                	mov    %eax,%edx
c0107440:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107443:	05 fc 0f 00 00       	add    $0xffc,%eax
c0107448:	83 ca 1b             	or     $0x1b,%edx
c010744b:	89 10                	mov    %edx,(%eax)

    return dir;
c010744d:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0107450:	c9                   	leave  
c0107451:	c3                   	ret    

c0107452 <__vmm_map_alloc>:
                   uint32_t l1_inx,
                   uint32_t l2_inx,
                   uintptr_t pa,
                   pt_attr attr,
                   int forced)
{
c0107452:	55                   	push   %ebp
c0107453:	89 e5                	mov    %esp,%ebp
c0107455:	53                   	push   %ebx
c0107456:	83 ec 14             	sub    $0x14,%esp
    ptd_t* ptd = (ptd_t*)PTD_BASE_VADDR;
c0107459:	c7 45 f4 00 f0 ff ff 	movl   $0xfffff000,-0xc(%ebp)
    pt_t* pt = (uintptr_t)PT_VADDR(l1_inx);
c0107460:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107463:	c1 e0 0c             	shl    $0xc,%eax
c0107466:	0d 00 00 c0 ff       	or     $0xffc00000,%eax
c010746b:	89 45 f0             	mov    %eax,-0x10(%ebp)


    // See if attr make sense
    if(attr > 128)
c010746e:	81 7d 18 80 00 00 00 	cmpl   $0x80,0x18(%ebp)
c0107475:	76 1a                	jbe    c0107491 <__vmm_map_alloc+0x3f>
    {
        kprintf("__vmm_map_alloc false, attr > 128!");
c0107477:	83 ec 0c             	sub    $0xc,%esp
c010747a:	68 64 e2 d0 c0       	push   $0xc0d0e264
c010747f:	e8 fd 37 00 00       	call   c010ac81 <kprintf>
c0107484:	83 c4 10             	add    $0x10,%esp
        return 0;
c0107487:	b8 00 00 00 00       	mov    $0x0,%eax
c010748c:	e9 ea 00 00 00       	jmp    c010757b <__vmm_map_alloc+0x129>
    }

    if (!ptd[l1_inx]) {
c0107491:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107494:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010749b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010749e:	01 d0                	add    %edx,%eax
c01074a0:	8b 00                	mov    (%eax),%eax
c01074a2:	85 c0                	test   %eax,%eax
c01074a4:	75 6b                	jne    c0107511 <__vmm_map_alloc+0xbf>
        uint8_t* new_pt_pa = pmm_alloc_page(pid, PP_FGPERSIST);
c01074a6:	83 ec 08             	sub    $0x8,%esp
c01074a9:	6a 01                	push   $0x1
c01074ab:	ff 75 08             	push   0x8(%ebp)
c01074ae:	e8 b8 f3 ff ff       	call   c010686b <pmm_alloc_page>
c01074b3:	83 c4 10             	add    $0x10,%esp
c01074b6:	89 45 ec             	mov    %eax,-0x14(%ebp)

        // 物理内存已满！
        if (!new_pt_pa) {
c01074b9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c01074bd:	75 0a                	jne    c01074c9 <__vmm_map_alloc+0x77>
            return 0;
c01074bf:	b8 00 00 00 00       	mov    $0x0,%eax
c01074c4:	e9 b2 00 00 00       	jmp    c010757b <__vmm_map_alloc+0x129>
        }

        // This must be writable
        ptd[l1_inx] = PDE(attr | PG_WRITE, new_pt_pa);
c01074c9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01074cc:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c01074d1:	89 c1                	mov    %eax,%ecx
c01074d3:	8b 45 18             	mov    0x18(%ebp),%eax
c01074d6:	83 c8 0a             	or     $0xa,%eax
c01074d9:	25 ff 0f 00 00       	and    $0xfff,%eax
c01074de:	89 c2                	mov    %eax,%edx
c01074e0:	8b 45 0c             	mov    0xc(%ebp),%eax
c01074e3:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
c01074ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01074ed:	01 d8                	add    %ebx,%eax
c01074ef:	09 ca                	or     %ecx,%edx
c01074f1:	89 10                	mov    %edx,(%eax)
        memset((void*)PT_VADDR(l1_inx), 0, PM_PAGE_SIZE);
c01074f3:	8b 45 0c             	mov    0xc(%ebp),%eax
c01074f6:	c1 e0 0c             	shl    $0xc,%eax
c01074f9:	0d 00 00 c0 ff       	or     $0xffc00000,%eax
c01074fe:	83 ec 04             	sub    $0x4,%esp
c0107501:	68 00 10 00 00       	push   $0x1000
c0107506:	6a 00                	push   $0x0
c0107508:	50                   	push   %eax
c0107509:	e8 0a 3a 00 00       	call   c010af18 <memset>
c010750e:	83 c4 10             	add    $0x10,%esp
    }

    if (pt[l2_inx]) {
c0107511:	8b 45 10             	mov    0x10(%ebp),%eax
c0107514:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010751b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010751e:	01 d0                	add    %edx,%eax
c0107520:	8b 00                	mov    (%eax),%eax
c0107522:	85 c0                	test   %eax,%eax
c0107524:	74 0d                	je     c0107533 <__vmm_map_alloc+0xe1>
        if (!forced) {
c0107526:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
c010752a:	75 07                	jne    c0107533 <__vmm_map_alloc+0xe1>
            return 0;
c010752c:	b8 00 00 00 00       	mov    $0x0,%eax
c0107531:	eb 48                	jmp    c010757b <__vmm_map_alloc+0x129>
        }
    }

    if ((HAS_FLAGS(attr, PG_PRESENT))) {
c0107533:	8b 45 18             	mov    0x18(%ebp),%eax
c0107536:	83 e0 01             	and    $0x1,%eax
c0107539:	85 c0                	test   %eax,%eax
c010753b:	74 12                	je     c010754f <__vmm_map_alloc+0xfd>
        // add one on reference count, regardless of existence.
        pmm_ref_page(pid, pa);
c010753d:	8b 45 14             	mov    0x14(%ebp),%eax
c0107540:	83 ec 08             	sub    $0x8,%esp
c0107543:	50                   	push   %eax
c0107544:	ff 75 08             	push   0x8(%ebp)
c0107547:	e8 ef f4 ff ff       	call   c0106a3b <pmm_ref_page>
c010754c:	83 c4 10             	add    $0x10,%esp
    }

    pt[l2_inx] = PTE(attr, pa);
c010754f:	8b 45 14             	mov    0x14(%ebp),%eax
c0107552:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0107557:	89 c1                	mov    %eax,%ecx
c0107559:	8b 45 18             	mov    0x18(%ebp),%eax
c010755c:	25 ff 0f 00 00       	and    $0xfff,%eax
c0107561:	89 c2                	mov    %eax,%edx
c0107563:	8b 45 10             	mov    0x10(%ebp),%eax
c0107566:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
c010756d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107570:	01 d8                	add    %ebx,%eax
c0107572:	09 ca                	or     %ecx,%edx
c0107574:	89 10                	mov    %edx,(%eax)

    return 1;
c0107576:	b8 01 00 00 00       	mov    $0x1,%eax
}
c010757b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010757e:	c9                   	leave  
c010757f:	c3                   	ret    

c0107580 <vmm_map_page>:

void* vmm_map_page(pid_t pid, void* va, void* pa, pt_attr dattr, pt_attr tattr) {
c0107580:	55                   	push   %ebp
c0107581:	89 e5                	mov    %esp,%ebp
c0107583:	83 ec 28             	sub    $0x28,%esp
    // 显然，对空指针进行映射没有意义。
    if (!pa || !va) {
c0107586:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c010758a:	74 06                	je     c0107592 <vmm_map_page+0x12>
c010758c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0107590:	75 0a                	jne    c010759c <vmm_map_page+0x1c>
        return NULL;
c0107592:	b8 00 00 00 00       	mov    $0x0,%eax
c0107597:	e9 1e 01 00 00       	jmp    c01076ba <vmm_map_page+0x13a>
    }

    uintptr_t pd_offset = PD_INDEX(va);
c010759c:	8b 45 0c             	mov    0xc(%ebp),%eax
c010759f:	c1 e8 16             	shr    $0x16,%eax
c01075a2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uintptr_t pt_offset = PT_INDEX(va);
c01075a5:	8b 45 0c             	mov    0xc(%ebp),%eax
c01075a8:	c1 e8 0c             	shr    $0xc,%eax
c01075ab:	25 ff 03 00 00       	and    $0x3ff,%eax
c01075b0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    ptd_t* ptd = (ptd_t*)PTD_BASE_VADDR;
c01075b3:	c7 45 e8 00 f0 ff ff 	movl   $0xfffff000,-0x18(%ebp)

    // 在页表与页目录中找到一个可用的空位进行映射（位于va或其附近）
    ptd_t* pde = ptd[pd_offset];
c01075ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01075bd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c01075c4:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01075c7:	01 d0                	add    %edx,%eax
c01075c9:	8b 00                	mov    (%eax),%eax
c01075cb:	89 45 ec             	mov    %eax,-0x14(%ebp)
    pt_t* pt = (uintptr_t)PT_VADDR(pd_offset);
c01075ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01075d1:	c1 e0 0c             	shl    $0xc,%eax
c01075d4:	0d 00 00 c0 ff       	or     $0xffc00000,%eax
c01075d9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    while (pde && pd_offset < 1024) {
c01075dc:	eb 77                	jmp    c0107655 <vmm_map_page+0xd5>
        if (pt_offset == 1024) {
c01075de:	81 7d f0 00 04 00 00 	cmpl   $0x400,-0x10(%ebp)
c01075e5:	75 2d                	jne    c0107614 <vmm_map_page+0x94>
            pd_offset++;
c01075e7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
            pt_offset = 0;
c01075eb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            pde = ptd[pd_offset];
c01075f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01075f5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c01075fc:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01075ff:	01 d0                	add    %edx,%eax
c0107601:	8b 00                	mov    (%eax),%eax
c0107603:	89 45 ec             	mov    %eax,-0x14(%ebp)
            pt = (pt_t*)PT_VADDR(pd_offset);
c0107606:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107609:	c1 e0 0c             	shl    $0xc,%eax
c010760c:	0d 00 00 c0 ff       	or     $0xffc00000,%eax
c0107611:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        }
        // 页表有空位，只需要开辟一个新的 PTE
        if (__vmm_map_alloc(pid, pd_offset, pt_offset, pa, dattr, false)) {
c0107614:	8b 45 10             	mov    0x10(%ebp),%eax
c0107617:	83 ec 08             	sub    $0x8,%esp
c010761a:	6a 00                	push   $0x0
c010761c:	ff 75 14             	push   0x14(%ebp)
c010761f:	50                   	push   %eax
c0107620:	ff 75 f0             	push   -0x10(%ebp)
c0107623:	ff 75 f4             	push   -0xc(%ebp)
c0107626:	ff 75 08             	push   0x8(%ebp)
c0107629:	e8 24 fe ff ff       	call   c0107452 <__vmm_map_alloc>
c010762e:	83 c4 20             	add    $0x20,%esp
c0107631:	85 c0                	test   %eax,%eax
c0107633:	74 1c                	je     c0107651 <vmm_map_page+0xd1>
            return (void*)V_ADDR(pd_offset, pt_offset, PG_OFFSET(va));
c0107635:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107638:	c1 e0 16             	shl    $0x16,%eax
c010763b:	89 c2                	mov    %eax,%edx
c010763d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107640:	c1 e0 0c             	shl    $0xc,%eax
c0107643:	09 c2                	or     %eax,%edx
c0107645:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107648:	25 ff 0f 00 00       	and    $0xfff,%eax
c010764d:	09 d0                	or     %edx,%eax
c010764f:	eb 69                	jmp    c01076ba <vmm_map_page+0x13a>
        }
        pt_offset++;
c0107651:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    while (pde && pd_offset < 1024) {
c0107655:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0107659:	74 0d                	je     c0107668 <vmm_map_page+0xe8>
c010765b:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
c0107662:	0f 86 76 ff ff ff    	jbe    c01075de <vmm_map_page+0x5e>
    }
    
    // 页目录与所有页表已满！
    if (pd_offset > 1024) {
c0107668:	81 7d f4 00 04 00 00 	cmpl   $0x400,-0xc(%ebp)
c010766f:	76 07                	jbe    c0107678 <vmm_map_page+0xf8>
        return NULL;
c0107671:	b8 00 00 00 00       	mov    $0x0,%eax
c0107676:	eb 42                	jmp    c01076ba <vmm_map_page+0x13a>
    }

    if (!__vmm_map_alloc(pid, pd_offset, pt_offset, (uintptr_t)pa, dattr, false))
c0107678:	8b 45 10             	mov    0x10(%ebp),%eax
c010767b:	83 ec 08             	sub    $0x8,%esp
c010767e:	6a 00                	push   $0x0
c0107680:	ff 75 14             	push   0x14(%ebp)
c0107683:	50                   	push   %eax
c0107684:	ff 75 f0             	push   -0x10(%ebp)
c0107687:	ff 75 f4             	push   -0xc(%ebp)
c010768a:	ff 75 08             	push   0x8(%ebp)
c010768d:	e8 c0 fd ff ff       	call   c0107452 <__vmm_map_alloc>
c0107692:	83 c4 20             	add    $0x20,%esp
c0107695:	85 c0                	test   %eax,%eax
c0107697:	75 07                	jne    c01076a0 <vmm_map_page+0x120>
        return NULL;
c0107699:	b8 00 00 00 00       	mov    $0x0,%eax
c010769e:	eb 1a                	jmp    c01076ba <vmm_map_page+0x13a>
    //     // add one on reference count, regardless of existence.
    //     pmm_ref_page(pid, pa);
    // }
    // pt[pt_offset] = PTE(tattr, pa);

    return (void*)V_ADDR(pd_offset, pt_offset, PG_OFFSET(va));
c01076a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01076a3:	c1 e0 16             	shl    $0x16,%eax
c01076a6:	89 c2                	mov    %eax,%edx
c01076a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01076ab:	c1 e0 0c             	shl    $0xc,%eax
c01076ae:	09 c2                	or     %eax,%edx
c01076b0:	8b 45 0c             	mov    0xc(%ebp),%eax
c01076b3:	25 ff 0f 00 00       	and    $0xfff,%eax
c01076b8:	09 d0                	or     %edx,%eax
}
c01076ba:	c9                   	leave  
c01076bb:	c3                   	ret    

c01076bc <vmm_cover_map_page>:

void* vmm_cover_map_page(pid_t pid, void* va, void* pa, pt_attr dattr, pt_attr tattr)
{
c01076bc:	55                   	push   %ebp
c01076bd:	89 e5                	mov    %esp,%ebp
c01076bf:	83 ec 18             	sub    $0x18,%esp
        // 显然，对空指针进行映射没有意义。
    if (!pa || !va) {
c01076c2:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c01076c6:	74 06                	je     c01076ce <vmm_cover_map_page+0x12>
c01076c8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c01076cc:	75 07                	jne    c01076d5 <vmm_cover_map_page+0x19>
        return NULL;
c01076ce:	b8 00 00 00 00       	mov    $0x0,%eax
c01076d3:	eb 50                	jmp    c0107725 <vmm_cover_map_page+0x69>
    }

    uintptr_t pd_offset = PD_INDEX(va);
c01076d5:	8b 45 0c             	mov    0xc(%ebp),%eax
c01076d8:	c1 e8 16             	shr    $0x16,%eax
c01076db:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uintptr_t pt_offset = PT_INDEX(va);
c01076de:	8b 45 0c             	mov    0xc(%ebp),%eax
c01076e1:	c1 e8 0c             	shr    $0xc,%eax
c01076e4:	25 ff 03 00 00       	and    $0x3ff,%eax
c01076e9:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if(!__vmm_map_alloc(pid, pd_offset, pt_offset, (uintptr_t)pa, dattr, true)) return NULL;
c01076ec:	8b 45 10             	mov    0x10(%ebp),%eax
c01076ef:	83 ec 08             	sub    $0x8,%esp
c01076f2:	6a 01                	push   $0x1
c01076f4:	ff 75 14             	push   0x14(%ebp)
c01076f7:	50                   	push   %eax
c01076f8:	ff 75 f0             	push   -0x10(%ebp)
c01076fb:	ff 75 f4             	push   -0xc(%ebp)
c01076fe:	ff 75 08             	push   0x8(%ebp)
c0107701:	e8 4c fd ff ff       	call   c0107452 <__vmm_map_alloc>
c0107706:	83 c4 20             	add    $0x20,%esp
c0107709:	85 c0                	test   %eax,%eax
c010770b:	75 07                	jne    c0107714 <vmm_cover_map_page+0x58>
c010770d:	b8 00 00 00 00       	mov    $0x0,%eax
c0107712:	eb 11                	jmp    c0107725 <vmm_cover_map_page+0x69>
    //     // add one on reference count, regardless of existence.
    //     pmm_ref_page(pid, pa);
    // }
    // pt[pt_offset] = PTE(tattr, pa);

    cpu_invplg(va);
c0107714:	83 ec 0c             	sub    $0xc,%esp
c0107717:	ff 75 0c             	push   0xc(%ebp)
c010771a:	e8 94 fc ff ff       	call   c01073b3 <cpu_invplg>
c010771f:	83 c4 10             	add    $0x10,%esp

    return va;
c0107722:	8b 45 0c             	mov    0xc(%ebp),%eax
}
c0107725:	c9                   	leave  
c0107726:	c3                   	ret    

c0107727 <vmm_alloc_page>:

void* vmm_alloc_page(pid_t pid, void* vpn, void** pa, pt_attr dattr, pt_attr tattr)
{
c0107727:	55                   	push   %ebp
c0107728:	89 e5                	mov    %esp,%ebp
c010772a:	83 ec 18             	sub    $0x18,%esp
    void* pp = pmm_alloc_page(pid, tattr);
c010772d:	83 ec 08             	sub    $0x8,%esp
c0107730:	ff 75 18             	push   0x18(%ebp)
c0107733:	ff 75 08             	push   0x8(%ebp)
c0107736:	e8 30 f1 ff ff       	call   c010686b <pmm_alloc_page>
c010773b:	83 c4 10             	add    $0x10,%esp
c010773e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    void* result = vmm_map_page(pid, vpn, pp, dattr, tattr);
c0107741:	83 ec 0c             	sub    $0xc,%esp
c0107744:	ff 75 18             	push   0x18(%ebp)
c0107747:	ff 75 14             	push   0x14(%ebp)
c010774a:	ff 75 f4             	push   -0xc(%ebp)
c010774d:	ff 75 0c             	push   0xc(%ebp)
c0107750:	ff 75 08             	push   0x8(%ebp)
c0107753:	e8 28 fe ff ff       	call   c0107580 <vmm_map_page>
c0107758:	83 c4 20             	add    $0x20,%esp
c010775b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (!result) {
c010775e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0107762:	75 11                	jne    c0107775 <vmm_alloc_page+0x4e>
        pmm_free_page(pid, pp);
c0107764:	83 ec 08             	sub    $0x8,%esp
c0107767:	ff 75 f4             	push   -0xc(%ebp)
c010776a:	ff 75 08             	push   0x8(%ebp)
c010776d:	e8 40 f2 ff ff       	call   c01069b2 <pmm_free_page>
c0107772:	83 c4 10             	add    $0x10,%esp
    }
    pa ? (*pa = pp) : 0;
c0107775:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0107779:	74 08                	je     c0107783 <vmm_alloc_page+0x5c>
c010777b:	8b 45 10             	mov    0x10(%ebp),%eax
c010777e:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0107781:	89 10                	mov    %edx,(%eax)
    return result;
c0107783:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0107786:	c9                   	leave  
c0107787:	c3                   	ret    

c0107788 <vmm_alloc_pages>:

int vmm_alloc_pages(pid_t pid, void* va, size_t sz, pt_attr tattr, pp_attr_t pattr)
{
c0107788:	55                   	push   %ebp
c0107789:	89 e5                	mov    %esp,%ebp
c010778b:	83 ec 28             	sub    $0x28,%esp
    //assert((uintptr_t)va % PG_SIZE == 0) assert(sz % PG_SIZE == 0);

    void* va_ = va;
c010778e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107791:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for (size_t i = 0; i < (sz >> PG_SIZE_BITS); i++, va_ += PG_SIZE) {
c0107794:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c010779b:	e9 97 00 00 00       	jmp    c0107837 <vmm_alloc_pages+0xaf>
        void* pp = pmm_alloc_page(pid, pattr);
c01077a0:	83 ec 08             	sub    $0x8,%esp
c01077a3:	ff 75 18             	push   0x18(%ebp)
c01077a6:	ff 75 08             	push   0x8(%ebp)
c01077a9:	e8 bd f0 ff ff       	call   c010686b <pmm_alloc_page>
c01077ae:	83 c4 10             	add    $0x10,%esp
c01077b1:	89 45 e8             	mov    %eax,-0x18(%ebp)
        uint32_t l1_index = PD_INDEX(va_);
c01077b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01077b7:	c1 e8 16             	shr    $0x16,%eax
c01077ba:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        uint32_t l2_index = PT_INDEX(va_);
c01077bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01077c0:	c1 e8 0c             	shr    $0xc,%eax
c01077c3:	25 ff 03 00 00       	and    $0x3ff,%eax
c01077c8:	89 45 e0             	mov    %eax,-0x20(%ebp)
        if (!pp || !__vmm_map_alloc(
c01077cb:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c01077cf:	74 21                	je     c01077f2 <vmm_alloc_pages+0x6a>
c01077d1:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01077d4:	83 ec 08             	sub    $0x8,%esp
c01077d7:	6a 00                	push   $0x0
c01077d9:	ff 75 14             	push   0x14(%ebp)
c01077dc:	50                   	push   %eax
c01077dd:	ff 75 e0             	push   -0x20(%ebp)
c01077e0:	ff 75 e4             	push   -0x1c(%ebp)
c01077e3:	ff 75 08             	push   0x8(%ebp)
c01077e6:	e8 67 fc ff ff       	call   c0107452 <__vmm_map_alloc>
c01077eb:	83 c4 20             	add    $0x20,%esp
c01077ee:	85 c0                	test   %eax,%eax
c01077f0:	75 3a                	jne    c010782c <vmm_alloc_pages+0xa4>
                     pid,
                     l1_index, l2_index, (uintptr_t)pp, tattr, false)) {
            // if one failed, release previous allocated pages.
            va_ = va;
c01077f2:	8b 45 0c             	mov    0xc(%ebp),%eax
c01077f5:	89 45 f4             	mov    %eax,-0xc(%ebp)
            for (size_t j = 0; j < i; j++, va_ += PG_SIZE) {
c01077f8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c01077ff:	eb 1c                	jmp    c010781d <vmm_alloc_pages+0x95>
                vmm_unmap_page(pid, va_);
c0107801:	83 ec 08             	sub    $0x8,%esp
c0107804:	ff 75 f4             	push   -0xc(%ebp)
c0107807:	ff 75 08             	push   0x8(%ebp)
c010780a:	e8 41 01 00 00       	call   c0107950 <vmm_unmap_page>
c010780f:	83 c4 10             	add    $0x10,%esp
            for (size_t j = 0; j < i; j++, va_ += PG_SIZE) {
c0107812:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0107816:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
c010781d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0107820:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0107823:	72 dc                	jb     c0107801 <vmm_alloc_pages+0x79>
            }

            return false;
c0107825:	b8 00 00 00 00       	mov    $0x0,%eax
c010782a:	eb 1f                	jmp    c010784b <vmm_alloc_pages+0xc3>
    for (size_t i = 0; i < (sz >> PG_SIZE_BITS); i++, va_ += PG_SIZE) {
c010782c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0107830:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
c0107837:	8b 45 10             	mov    0x10(%ebp),%eax
c010783a:	c1 e8 0c             	shr    $0xc,%eax
c010783d:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c0107840:	0f 82 5a ff ff ff    	jb     c01077a0 <vmm_alloc_pages+0x18>
        }
    }

    return true;
c0107846:	b8 01 00 00 00       	mov    $0x1,%eax
}
c010784b:	c9                   	leave  
c010784c:	c3                   	ret    

c010784d <vmm_set_mapping>:

int vmm_set_mapping(pid_t pid, void* va, void* pa, pt_attr attr)
{
c010784d:	55                   	push   %ebp
c010784e:	89 e5                	mov    %esp,%ebp
c0107850:	83 ec 18             	sub    $0x18,%esp
    //assert(((uintptr_t)va & 0xFFFU) == 0);

    uint32_t l1_index = PD_INDEX(va);
c0107853:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107856:	c1 e8 16             	shr    $0x16,%eax
c0107859:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t l2_index = PT_INDEX(va);
c010785c:	8b 45 0c             	mov    0xc(%ebp),%eax
c010785f:	c1 e8 0c             	shr    $0xc,%eax
c0107862:	25 ff 03 00 00       	and    $0x3ff,%eax
c0107867:	89 45 f0             	mov    %eax,-0x10(%ebp)

    // prevent map of recursive mapping region
    if (l1_index == 1023) {
c010786a:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
c0107871:	75 07                	jne    c010787a <vmm_set_mapping+0x2d>
        return 0;
c0107873:	b8 00 00 00 00       	mov    $0x0,%eax
c0107878:	eb 22                	jmp    c010789c <vmm_set_mapping+0x4f>
    }
    
    __vmm_map_alloc(pid, l1_index, l2_index, (uintptr_t)pa, attr, false);
c010787a:	8b 45 10             	mov    0x10(%ebp),%eax
c010787d:	83 ec 08             	sub    $0x8,%esp
c0107880:	6a 00                	push   $0x0
c0107882:	ff 75 14             	push   0x14(%ebp)
c0107885:	50                   	push   %eax
c0107886:	ff 75 f0             	push   -0x10(%ebp)
c0107889:	ff 75 f4             	push   -0xc(%ebp)
c010788c:	ff 75 08             	push   0x8(%ebp)
c010788f:	e8 be fb ff ff       	call   c0107452 <__vmm_map_alloc>
c0107894:	83 c4 20             	add    $0x20,%esp
    return 1;
c0107897:	b8 01 00 00 00       	mov    $0x1,%eax
}
c010789c:	c9                   	leave  
c010789d:	c3                   	ret    

c010789e <__vmm_unmap_unalloc>:

void __vmm_unmap_unalloc(pid_t pid, void* va, int free_ppage)
{
c010789e:	55                   	push   %ebp
c010789f:	89 e5                	mov    %esp,%ebp
c01078a1:	83 ec 28             	sub    $0x28,%esp
    //assert(((uintptr_t)va & 0xFFFU) == 0);

    uint32_t l1_index = PD_INDEX(va);
c01078a4:	8b 45 0c             	mov    0xc(%ebp),%eax
c01078a7:	c1 e8 16             	shr    $0x16,%eax
c01078aa:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t l2_index = PT_INDEX(va);
c01078ad:	8b 45 0c             	mov    0xc(%ebp),%eax
c01078b0:	c1 e8 0c             	shr    $0xc,%eax
c01078b3:	25 ff 03 00 00       	and    $0x3ff,%eax
c01078b8:	89 45 f0             	mov    %eax,-0x10(%ebp)

    // prevent unmap of recursive mapping region
    if (l1_index == 1023) {
c01078bb:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
c01078c2:	0f 84 85 00 00 00    	je     c010794d <__vmm_unmap_unalloc+0xaf>
        return;
    }

    ptd_t* ptd = (ptd_t*)PTD_BASE_VADDR;
c01078c8:	c7 45 ec 00 f0 ff ff 	movl   $0xfffff000,-0x14(%ebp)

    if (ptd[l1_index]) {
c01078cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01078d2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c01078d9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01078dc:	01 d0                	add    %edx,%eax
c01078de:	8b 00                	mov    (%eax),%eax
c01078e0:	85 c0                	test   %eax,%eax
c01078e2:	74 6a                	je     c010794e <__vmm_unmap_unalloc+0xb0>
        pt_t* pt = (uintptr_t)PT_VADDR(l1_index);
c01078e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01078e7:	c1 e0 0c             	shl    $0xc,%eax
c01078ea:	0d 00 00 c0 ff       	or     $0xffc00000,%eax
c01078ef:	89 45 e8             	mov    %eax,-0x18(%ebp)
        pt_t pte = pt[l2_index];
c01078f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01078f5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c01078fc:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01078ff:	01 d0                	add    %edx,%eax
c0107901:	8b 00                	mov    (%eax),%eax
c0107903:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if (IS_PRESENT(pte) && free_ppage) {
c0107906:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0107909:	83 e0 01             	and    $0x1,%eax
c010790c:	85 c0                	test   %eax,%eax
c010790e:	74 18                	je     c0107928 <__vmm_unmap_unalloc+0x8a>
c0107910:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0107914:	74 12                	je     c0107928 <__vmm_unmap_unalloc+0x8a>
            pmm_free_page(pid, (void*)pte);
c0107916:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0107919:	83 ec 08             	sub    $0x8,%esp
c010791c:	50                   	push   %eax
c010791d:	ff 75 08             	push   0x8(%ebp)
c0107920:	e8 8d f0 ff ff       	call   c01069b2 <pmm_free_page>
c0107925:	83 c4 10             	add    $0x10,%esp
        }
        cpu_invplg(va);
c0107928:	83 ec 0c             	sub    $0xc,%esp
c010792b:	ff 75 0c             	push   0xc(%ebp)
c010792e:	e8 80 fa ff ff       	call   c01073b3 <cpu_invplg>
c0107933:	83 c4 10             	add    $0x10,%esp
        //kprintf("%d ", l2_index);
        pt[l2_index] = NULL;
c0107936:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107939:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0107940:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0107943:	01 d0                	add    %edx,%eax
c0107945:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c010794b:	eb 01                	jmp    c010794e <__vmm_unmap_unalloc+0xb0>
        return;
c010794d:	90                   	nop
    }
}
c010794e:	c9                   	leave  
c010794f:	c3                   	ret    

c0107950 <vmm_unmap_page>:

void vmm_unmap_page(pid_t pid, void* va)
{
c0107950:	55                   	push   %ebp
c0107951:	89 e5                	mov    %esp,%ebp
c0107953:	83 ec 08             	sub    $0x8,%esp
    __vmm_unmap_unalloc(pid, va, true);
c0107956:	83 ec 04             	sub    $0x4,%esp
c0107959:	6a 01                	push   $0x1
c010795b:	ff 75 0c             	push   0xc(%ebp)
c010795e:	ff 75 08             	push   0x8(%ebp)
c0107961:	e8 38 ff ff ff       	call   c010789e <__vmm_unmap_unalloc>
c0107966:	83 c4 10             	add    $0x10,%esp
}
c0107969:	90                   	nop
c010796a:	c9                   	leave  
c010796b:	c3                   	ret    

c010796c <vmm_unset_mapping>:

void vmm_unset_mapping(void* va)
{
c010796c:	55                   	push   %ebp
c010796d:	89 e5                	mov    %esp,%ebp
c010796f:	83 ec 08             	sub    $0x8,%esp
    __vmm_unmap_unalloc(0, va, false);
c0107972:	83 ec 04             	sub    $0x4,%esp
c0107975:	6a 00                	push   $0x0
c0107977:	ff 75 08             	push   0x8(%ebp)
c010797a:	6a 00                	push   $0x0
c010797c:	e8 1d ff ff ff       	call   c010789e <__vmm_unmap_unalloc>
c0107981:	83 c4 10             	add    $0x10,%esp
}
c0107984:	90                   	nop
c0107985:	c9                   	leave  
c0107986:	c3                   	ret    

c0107987 <vmm_lookup>:

v_mapping vmm_lookup(void* va)
{
c0107987:	55                   	push   %ebp
c0107988:	89 e5                	mov    %esp,%ebp
c010798a:	83 ec 28             	sub    $0x28,%esp
    assert(((uintptr_t)va & 0xFFFU) == 0);
c010798d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107990:	25 ff 0f 00 00       	and    $0xfff,%eax
c0107995:	85 c0                	test   %eax,%eax
c0107997:	74 1a                	je     c01079b3 <vmm_lookup+0x2c>
c0107999:	83 ec 04             	sub    $0x4,%esp
c010799c:	68 87 01 00 00       	push   $0x187
c01079a1:	68 87 e2 d0 c0       	push   $0xc0d0e287
c01079a6:	68 a0 e2 d0 c0       	push   $0xc0d0e2a0
c01079ab:	e8 18 27 00 00       	call   c010a0c8 <__assert_fail>
c01079b0:	83 c4 10             	add    $0x10,%esp

    uint32_t l1_index = PD_INDEX(va);
c01079b3:	8b 45 0c             	mov    0xc(%ebp),%eax
c01079b6:	c1 e8 16             	shr    $0x16,%eax
c01079b9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t l2_index = PT_INDEX(va);
c01079bc:	8b 45 0c             	mov    0xc(%ebp),%eax
c01079bf:	c1 e8 0c             	shr    $0xc,%eax
c01079c2:	25 ff 03 00 00       	and    $0x3ff,%eax
c01079c7:	89 45 f0             	mov    %eax,-0x10(%ebp)

    ptd_t* ptd = (ptd_t*)PTD_BASE_VADDR;
c01079ca:	c7 45 ec 00 f0 ff ff 	movl   $0xfffff000,-0x14(%ebp)

    v_mapping mapping = { .flags = 0, .pa = 0, .pn = 0 };
c01079d1:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
c01079d8:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
c01079df:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
c01079e6:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    if (ptd[l1_index]) {
c01079ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01079f0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c01079f7:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01079fa:	01 d0                	add    %edx,%eax
c01079fc:	8b 00                	mov    (%eax),%eax
c01079fe:	85 c0                	test   %eax,%eax
c0107a00:	74 49                	je     c0107a4b <vmm_lookup+0xc4>
        //pt_t* pt = (uintptr_t)PT_VADDR(l1_index);
        pt_t* l2pte = &(((pt_t*)PT_VADDR(l1_index))[l2_index]);
c0107a02:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107a05:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0107a0c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107a0f:	c1 e0 0c             	shl    $0xc,%eax
c0107a12:	0d 00 00 c0 ff       	or     $0xffc00000,%eax
c0107a17:	01 d0                	add    %edx,%eax
c0107a19:	89 45 e8             	mov    %eax,-0x18(%ebp)
        //pt_t* l2pte = &pt[l2_index];
        if (l2pte) {
c0107a1c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0107a20:	74 29                	je     c0107a4b <vmm_lookup+0xc4>
            mapping.flags = PG_ENTRY_FLAGS(*l2pte);
c0107a22:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0107a25:	8b 00                	mov    (%eax),%eax
c0107a27:	66 25 ff 0f          	and    $0xfff,%ax
c0107a2b:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
            mapping.pa = PG_ENTRY_ADDR(*l2pte);
c0107a2f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0107a32:	8b 00                	mov    (%eax),%eax
c0107a34:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0107a39:	89 45 dc             	mov    %eax,-0x24(%ebp)
            mapping.pn = mapping.pa >> PG_SIZE_BITS;
c0107a3c:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0107a3f:	c1 e8 0c             	shr    $0xc,%eax
c0107a42:	89 45 d8             	mov    %eax,-0x28(%ebp)
            mapping.pte = l2pte;
c0107a45:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0107a48:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        }
    }

    return mapping;
c0107a4b:	8b 45 08             	mov    0x8(%ebp),%eax
c0107a4e:	8b 55 d8             	mov    -0x28(%ebp),%edx
c0107a51:	89 10                	mov    %edx,(%eax)
c0107a53:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0107a56:	89 50 04             	mov    %edx,0x4(%eax)
c0107a59:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0107a5c:	89 50 08             	mov    %edx,0x8(%eax)
c0107a5f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0107a62:	89 50 0c             	mov    %edx,0xc(%eax)
}
c0107a65:	8b 45 08             	mov    0x8(%ebp),%eax
c0107a68:	c9                   	leave  
c0107a69:	c2 04 00             	ret    $0x4

c0107a6c <vmm_v2p>:

void* vmm_v2p(void* va)
{
c0107a6c:	55                   	push   %ebp
c0107a6d:	89 e5                	mov    %esp,%ebp
c0107a6f:	83 ec 18             	sub    $0x18,%esp
    return (void*)vmm_lookup(va).pa;
c0107a72:	8d 45 e8             	lea    -0x18(%ebp),%eax
c0107a75:	83 ec 08             	sub    $0x8,%esp
c0107a78:	ff 75 08             	push   0x8(%ebp)
c0107a7b:	50                   	push   %eax
c0107a7c:	e8 06 ff ff ff       	call   c0107987 <vmm_lookup>
c0107a81:	83 c4 0c             	add    $0xc,%esp
c0107a84:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
c0107a87:	c9                   	leave  
c0107a88:	c3                   	ret    

c0107a89 <vmm_dup_page>:

void* vmm_dup_page(pid_t pid, void* pa)
{
c0107a89:	55                   	push   %ebp
c0107a8a:	89 e5                	mov    %esp,%ebp
c0107a8c:	57                   	push   %edi
c0107a8d:	56                   	push   %esi
c0107a8e:	53                   	push   %ebx
c0107a8f:	83 ec 1c             	sub    $0x1c,%esp
    void* new_ppg = pmm_alloc_page(pid, 0);
c0107a92:	83 ec 08             	sub    $0x8,%esp
c0107a95:	6a 00                	push   $0x0
c0107a97:	ff 75 08             	push   0x8(%ebp)
c0107a9a:	e8 cc ed ff ff       	call   c010686b <pmm_alloc_page>
c0107a9f:	83 c4 10             	add    $0x10,%esp
c0107aa2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    vmm_cover_map_page(pid, PG_MOUNT_3, new_ppg, PG_PREM_RW,PG_PREM_RW);
c0107aa5:	83 ec 0c             	sub    $0xc,%esp
c0107aa8:	6a 03                	push   $0x3
c0107aaa:	6a 03                	push   $0x3
c0107aac:	ff 75 e4             	push   -0x1c(%ebp)
c0107aaf:	68 00 d0 7f af       	push   $0xaf7fd000
c0107ab4:	ff 75 08             	push   0x8(%ebp)
c0107ab7:	e8 00 fc ff ff       	call   c01076bc <vmm_cover_map_page>
c0107abc:	83 c4 20             	add    $0x20,%esp
    vmm_cover_map_page(pid, PG_MOUNT_4, pa, PG_PREM_RW,PG_PREM_RW);
c0107abf:	83 ec 0c             	sub    $0xc,%esp
c0107ac2:	6a 03                	push   $0x3
c0107ac4:	6a 03                	push   $0x3
c0107ac6:	ff 75 0c             	push   0xc(%ebp)
c0107ac9:	68 00 c0 7f af       	push   $0xaf7fc000
c0107ace:	ff 75 08             	push   0x8(%ebp)
c0107ad1:	e8 e6 fb ff ff       	call   c01076bc <vmm_cover_map_page>
c0107ad6:	83 c4 20             	add    $0x20,%esp

    asm volatile (
c0107ad9:	b8 00 04 00 00       	mov    $0x400,%eax
c0107ade:	ba 00 d0 7f af       	mov    $0xaf7fd000,%edx
c0107ae3:	bb 00 c0 7f af       	mov    $0xaf7fc000,%ebx
c0107ae8:	89 c1                	mov    %eax,%ecx
c0107aea:	89 d7                	mov    %edx,%edi
c0107aec:	89 de                	mov    %ebx,%esi
c0107aee:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
        "movl %2, %%esi\n"
        "rep movsl\n"
        :: "c"(1024), "r"(PG_MOUNT_3), "r"(PG_MOUNT_4)
        : "memory", "%edi", "%esi");

    vmm_unset_mapping(PG_MOUNT_3);
c0107af0:	83 ec 0c             	sub    $0xc,%esp
c0107af3:	68 00 d0 7f af       	push   $0xaf7fd000
c0107af8:	e8 6f fe ff ff       	call   c010796c <vmm_unset_mapping>
c0107afd:	83 c4 10             	add    $0x10,%esp
    vmm_unset_mapping(PG_MOUNT_4);
c0107b00:	83 ec 0c             	sub    $0xc,%esp
c0107b03:	68 00 c0 7f af       	push   $0xaf7fc000
c0107b08:	e8 5f fe ff ff       	call   c010796c <vmm_unset_mapping>
c0107b0d:	83 c4 10             	add    $0x10,%esp

    return new_ppg;
c0107b10:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
c0107b13:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0107b16:	5b                   	pop    %ebx
c0107b17:	5e                   	pop    %esi
c0107b18:	5f                   	pop    %edi
c0107b19:	5d                   	pop    %ebp
c0107b1a:	c3                   	ret    

c0107b1b <vmm_mount_pd>:

void* vmm_mount_pd(uintptr_t mnt, void* pde)
{
c0107b1b:	55                   	push   %ebp
c0107b1c:	89 e5                	mov    %esp,%ebp
c0107b1e:	83 ec 10             	sub    $0x10,%esp
    ptd_t* l1pt = (ptd_t*)PTD_BASE_VADDR;
c0107b21:	c7 45 fc 00 f0 ff ff 	movl   $0xfffff000,-0x4(%ebp)
    l1pt[(mnt >> 22)] = PDE(T_SELF_REF_PERM, pde);
c0107b28:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107b2b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0107b30:	89 c2                	mov    %eax,%edx
c0107b32:	8b 45 08             	mov    0x8(%ebp),%eax
c0107b35:	c1 e8 16             	shr    $0x16,%eax
c0107b38:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
c0107b3f:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0107b42:	01 c8                	add    %ecx,%eax
c0107b44:	83 ca 1b             	or     $0x1b,%edx
c0107b47:	89 10                	mov    %edx,(%eax)
    cpu_invplg(mnt);
c0107b49:	8b 45 08             	mov    0x8(%ebp),%eax
c0107b4c:	50                   	push   %eax
c0107b4d:	e8 61 f8 ff ff       	call   c01073b3 <cpu_invplg>
c0107b52:	83 c4 04             	add    $0x4,%esp
    return mnt;
c0107b55:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0107b58:	c9                   	leave  
c0107b59:	c3                   	ret    

c0107b5a <vmm_unmount_pd>:

void* vmm_unmount_pd(uintptr_t mnt)
{
c0107b5a:	55                   	push   %ebp
c0107b5b:	89 e5                	mov    %esp,%ebp
c0107b5d:	83 ec 10             	sub    $0x10,%esp
    ptd_t* l1pt = (ptd_t*)PTD_BASE_VADDR;
c0107b60:	c7 45 fc 00 f0 ff ff 	movl   $0xfffff000,-0x4(%ebp)
    l1pt[(mnt >> 22)] = 0;
c0107b67:	8b 45 08             	mov    0x8(%ebp),%eax
c0107b6a:	c1 e8 16             	shr    $0x16,%eax
c0107b6d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0107b74:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0107b77:	01 d0                	add    %edx,%eax
c0107b79:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    cpu_invplg(mnt);
c0107b7f:	8b 45 08             	mov    0x8(%ebp),%eax
c0107b82:	50                   	push   %eax
c0107b83:	e8 2b f8 ff ff       	call   c01073b3 <cpu_invplg>
c0107b88:	83 c4 04             	add    $0x4,%esp
}
c0107b8b:	90                   	nop
c0107b8c:	c9                   	leave  
c0107b8d:	c3                   	ret    

c0107b8e <io_inb>:

#include <stdint.h>

static inline uint8_t
io_inb(int port)
{
c0107b8e:	55                   	push   %ebp
c0107b8f:	89 e5                	mov    %esp,%ebp
c0107b91:	83 ec 10             	sub    $0x10,%esp
    uint8_t data;
    asm volatile("inb %w1,%0" : "=a"(data) : "d"(port));
c0107b94:	8b 45 08             	mov    0x8(%ebp),%eax
c0107b97:	89 c2                	mov    %eax,%edx
c0107b99:	ec                   	in     (%dx),%al
c0107b9a:	88 45 ff             	mov    %al,-0x1(%ebp)
    return data;
c0107b9d:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c0107ba1:	c9                   	leave  
c0107ba2:	c3                   	ret    

c0107ba3 <io_outb>:
                 : "memory", "cc");
}

static inline void
io_outb(int port, uint8_t data)
{
c0107ba3:	55                   	push   %ebp
c0107ba4:	89 e5                	mov    %esp,%ebp
c0107ba6:	83 ec 04             	sub    $0x4,%esp
c0107ba9:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107bac:	88 45 fc             	mov    %al,-0x4(%ebp)
    asm volatile("outb %0, %w1" : : "a"(data), "d"(port));
c0107baf:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0107bb3:	8b 55 08             	mov    0x8(%ebp),%edx
c0107bb6:	ee                   	out    %al,(%dx)
}
c0107bb7:	90                   	nop
c0107bb8:	c9                   	leave  
c0107bb9:	c3                   	ret    

c0107bba <frequence_set>:
uint32_t sched_ticks;
void do_intr_time_handler(isr_param int_param);

static void frequence_set(uint8_t counter_port, uint8_t counter_no, 
                         uint8_t rwl, uint8_t counter_mode, uint16_t counter_value)
{
c0107bba:	55                   	push   %ebp
c0107bbb:	89 e5                	mov    %esp,%ebp
c0107bbd:	57                   	push   %edi
c0107bbe:	56                   	push   %esi
c0107bbf:	53                   	push   %ebx
c0107bc0:	83 ec 14             	sub    $0x14,%esp
c0107bc3:	8b 75 08             	mov    0x8(%ebp),%esi
c0107bc6:	8b 5d 0c             	mov    0xc(%ebp),%ebx
c0107bc9:	8b 4d 10             	mov    0x10(%ebp),%ecx
c0107bcc:	8b 55 14             	mov    0x14(%ebp),%edx
c0107bcf:	8b 7d 18             	mov    0x18(%ebp),%edi
c0107bd2:	89 f0                	mov    %esi,%eax
c0107bd4:	88 45 f0             	mov    %al,-0x10(%ebp)
c0107bd7:	88 5d ec             	mov    %bl,-0x14(%ebp)
c0107bda:	88 4d e8             	mov    %cl,-0x18(%ebp)
c0107bdd:	88 55 e4             	mov    %dl,-0x1c(%ebp)
c0107be0:	89 f8                	mov    %edi,%eax
c0107be2:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
    io_outb(PIT_CONTROL_PORT, (uint8_t)(counter_no << 6 | rwl << 4 | counter_mode << 1));
c0107be6:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0107bea:	c1 e0 06             	shl    $0x6,%eax
c0107bed:	89 c2                	mov    %eax,%edx
c0107bef:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c0107bf3:	c1 e0 04             	shl    $0x4,%eax
c0107bf6:	09 c2                	or     %eax,%edx
c0107bf8:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0107bfc:	01 c0                	add    %eax,%eax
c0107bfe:	09 d0                	or     %edx,%eax
c0107c00:	0f b6 c0             	movzbl %al,%eax
c0107c03:	50                   	push   %eax
c0107c04:	6a 43                	push   $0x43
c0107c06:	e8 98 ff ff ff       	call   c0107ba3 <io_outb>
c0107c0b:	83 c4 08             	add    $0x8,%esp
    io_outb(counter_port, (uint8_t)counter_value);
c0107c0e:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
c0107c12:	0f b6 d0             	movzbl %al,%edx
c0107c15:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
c0107c19:	52                   	push   %edx
c0107c1a:	50                   	push   %eax
c0107c1b:	e8 83 ff ff ff       	call   c0107ba3 <io_outb>
c0107c20:	83 c4 08             	add    $0x8,%esp
    io_outb(counter_port, (uint8_t)(counter_value >> 8));
c0107c23:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
c0107c27:	66 c1 e8 08          	shr    $0x8,%ax
c0107c2b:	0f b6 d0             	movzbl %al,%edx
c0107c2e:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
c0107c32:	52                   	push   %edx
c0107c33:	50                   	push   %eax
c0107c34:	e8 6a ff ff ff       	call   c0107ba3 <io_outb>
c0107c39:	83 c4 08             	add    $0x8,%esp
}
c0107c3c:	90                   	nop
c0107c3d:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0107c40:	5b                   	pop    %ebx
c0107c41:	5e                   	pop    %esi
c0107c42:	5f                   	pop    %edi
c0107c43:	5d                   	pop    %ebp
c0107c44:	c3                   	ret    

c0107c45 <timer_init>:

void timer_init(){
c0107c45:	55                   	push   %ebp
c0107c46:	89 e5                	mov    %esp,%ebp
c0107c48:	83 ec 18             	sub    $0x18,%esp
    ticks = 0;
c0107c4b:	c7 05 f0 b0 d0 c0 00 	movl   $0x0,0xc0d0b0f0
c0107c52:	00 00 00 
    sched_ticks = 10;
c0107c55:	c7 05 f4 b0 d0 c0 0a 	movl   $0xa,0xc0d0b0f4
c0107c5c:	00 00 00 
    //kprintf("timer intr start\n");
    frequence_set(CURRENTR0_PORT, CURRENTR0_NO, READ_WRITE_LATCH, CURRENTR_MODE, CURRENTR0_VALUE);
c0107c5f:	68 9b 2e 00 00       	push   $0x2e9b
c0107c64:	6a 02                	push   $0x2
c0107c66:	6a 03                	push   $0x3
c0107c68:	6a 00                	push   $0x0
c0107c6a:	6a 40                	push   $0x40
c0107c6c:	e8 49 ff ff ff       	call   c0107bba <frequence_set>
c0107c71:	83 c4 14             	add    $0x14,%esp
    _set_idt_entry(HARDWARE_TIME_INT, 0x08, &intr_time_handler, 0);
c0107c74:	6a 00                	push   $0x0
c0107c76:	68 b2 81 10 c0       	push   $0xc01081b2
c0107c7b:	6a 08                	push   $0x8
c0107c7d:	6a 20                	push   $0x20
c0107c7f:	e8 bb 10 00 00       	call   c0108d3f <_set_idt_entry>
c0107c84:	83 c4 10             	add    $0x10,%esp
    intr_subscribe(HARDWARE_TIME_INT, do_intr_time_handler);
c0107c87:	83 ec 08             	sub    $0x8,%esp
c0107c8a:	68 bc 7c 10 c0       	push   $0xc0107cbc
c0107c8f:	6a 20                	push   $0x20
c0107c91:	e8 e7 01 00 00       	call   c0107e7d <intr_subscribe>
c0107c96:	83 c4 10             	add    $0x10,%esp
    uint8_t result = io_inb(0x21);
c0107c99:	83 ec 0c             	sub    $0xc,%esp
c0107c9c:	6a 21                	push   $0x21
c0107c9e:	e8 eb fe ff ff       	call   c0107b8e <io_inb>
c0107ca3:	83 c4 10             	add    $0x10,%esp
c0107ca6:	88 45 f7             	mov    %al,-0x9(%ebp)
    //io_outb(0x21, result & 0xfe);
    kprintf("timer init down\n");
c0107ca9:	83 ec 0c             	sub    $0xc,%esp
c0107cac:	68 be e2 d0 c0       	push   $0xc0d0e2be
c0107cb1:	e8 cb 2f 00 00       	call   c010ac81 <kprintf>
c0107cb6:	83 c4 10             	add    $0x10,%esp
    //asm("cli");
}
c0107cb9:	90                   	nop
c0107cba:	c9                   	leave  
c0107cbb:	c3                   	ret    

c0107cbc <do_intr_time_handler>:

void do_intr_time_handler(isr_param int_param)
{
c0107cbc:	55                   	push   %ebp
c0107cbd:	89 e5                	mov    %esp,%ebp
c0107cbf:	83 ec 08             	sub    $0x8,%esp
    ticks++;
c0107cc2:	a1 f0 b0 d0 c0       	mov    0xc0d0b0f0,%eax
c0107cc7:	83 c0 01             	add    $0x1,%eax
c0107cca:	a3 f0 b0 d0 c0       	mov    %eax,0xc0d0b0f0
    //__current->intr_contxt = int_param;
    if(sched_ticks == 0)
c0107ccf:	a1 f4 b0 d0 c0       	mov    0xc0d0b0f4,%eax
c0107cd4:	85 c0                	test   %eax,%eax
c0107cd6:	75 11                	jne    c0107ce9 <do_intr_time_handler+0x2d>
    {
        sched_ticks = 10;
c0107cd8:	c7 05 f4 b0 d0 c0 0a 	movl   $0xa,0xc0d0b0f4
c0107cdf:	00 00 00 
        schedule();
c0107ce2:	e8 db 2b 00 00       	call   c010a8c2 <schedule>
    }
    else
        sched_ticks--;
c0107ce7:	eb 0d                	jmp    c0107cf6 <do_intr_time_handler+0x3a>
        sched_ticks--;
c0107ce9:	a1 f4 b0 d0 c0       	mov    0xc0d0b0f4,%eax
c0107cee:	83 e8 01             	sub    $0x1,%eax
c0107cf1:	a3 f4 b0 d0 c0       	mov    %eax,0xc0d0b0f4
c0107cf6:	90                   	nop
c0107cf7:	c9                   	leave  
c0107cf8:	c3                   	ret    

c0107cf9 <syscall>:
void
syscall_install();

static void*
syscall(unsigned int callcode)
{
c0107cf9:	55                   	push   %ebp
c0107cfa:	89 e5                	mov    %esp,%ebp
c0107cfc:	57                   	push   %edi
    asm volatile("int %0" ::"i"(0x80), "D"(callcode) : "eax");
c0107cfd:	8b 55 08             	mov    0x8(%ebp),%edx
c0107d00:	89 d7                	mov    %edx,%edi
c0107d02:	cd 80                	int    $0x80
}
c0107d04:	90                   	nop
c0107d05:	8b 7d fc             	mov    -0x4(%ebp),%edi
c0107d08:	c9                   	leave  
c0107d09:	c3                   	ret    

c0107d0a <fork>:
#include <syscall/syscall.h>
#include <stdint.h>

typedef int32_t pid_t;

__MXSYSCALL(pid_t, fork)
c0107d0a:	55                   	push   %ebp
c0107d0b:	89 e5                	mov    %esp,%ebp
c0107d0d:	83 ec 10             	sub    $0x10,%esp
c0107d10:	b8 01 00 00 00       	mov    $0x1,%eax
c0107d15:	cd 80                	int    $0x80
c0107d17:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0107d1a:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0107d1d:	c9                   	leave  
c0107d1e:	c3                   	ret    

c0107d1f <getpid>:

// __MXSYSCALL1(int, sbrk, void*, addr)

// __MXSYSCALL1(void*, brk, unsigned long, size)

__MXSYSCALL(pid_t, getpid)
c0107d1f:	55                   	push   %ebp
c0107d20:	89 e5                	mov    %esp,%ebp
c0107d22:	83 ec 10             	sub    $0x10,%esp
c0107d25:	b8 02 00 00 00       	mov    $0x2,%eax
c0107d2a:	cd 80                	int    $0x80
c0107d2c:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0107d2f:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0107d32:	c9                   	leave  
c0107d33:	c3                   	ret    

c0107d34 <getppid>:

__MXSYSCALL(pid_t, getppid)
c0107d34:	55                   	push   %ebp
c0107d35:	89 e5                	mov    %esp,%ebp
c0107d37:	83 ec 10             	sub    $0x10,%esp
c0107d3a:	b8 03 00 00 00       	mov    $0x3,%eax
c0107d3f:	cd 80                	int    $0x80
c0107d41:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0107d44:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0107d47:	c9                   	leave  
c0107d48:	c3                   	ret    

c0107d49 <_exit>:

__MXSYSCALL1(void, _exit, int, status)
c0107d49:	55                   	push   %ebp
c0107d4a:	89 e5                	mov    %esp,%ebp
c0107d4c:	53                   	push   %ebx
c0107d4d:	83 ec 10             	sub    $0x10,%esp
c0107d50:	8b 45 08             	mov    0x8(%ebp),%eax
c0107d53:	89 c3                	mov    %eax,%ebx
c0107d55:	b8 04 00 00 00       	mov    $0x4,%eax
c0107d5a:	cd 80                	int    $0x80
c0107d5c:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0107d5f:	90                   	nop
c0107d60:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0107d63:	c9                   	leave  
c0107d64:	c3                   	ret    

c0107d65 <__proc0>:
#include <blk_drive/ata_dev.h>
extern void __init_phykernel_end;
void init_platform();
extern void _mxinit_main(); /* mxinit.c */
void __proc0()
{
c0107d65:	55                   	push   %ebp
c0107d66:	89 e5                	mov    %esp,%ebp
c0107d68:	83 ec 08             	sub    $0x8,%esp
    init_platform();
c0107d6b:	e8 23 00 00 00       	call   c0107d93 <init_platform>
    //kprintf("This is proc0!\n");
    if (!fork()) {
c0107d70:	e8 95 ff ff ff       	call   c0107d0a <fork>
c0107d75:	85 c0                	test   %eax,%eax
c0107d77:	75 05                	jne    c0107d7e <__proc0+0x19>
        //schedule();
        //kprintf("fork sucess!\n");
        asm("jmp _mxinit_main");
c0107d79:	e9 ad 00 00 00       	jmp    c0107e2b <_mxinit_main>
    }
    kprintf("proc 0");
c0107d7e:	83 ec 0c             	sub    $0xc,%esp
c0107d81:	68 cf e2 d0 c0       	push   $0xc0d0e2cf
c0107d86:	e8 f6 2e 00 00       	call   c010ac81 <kprintf>
c0107d8b:	83 c4 10             	add    $0x10,%esp
    //io_outb(0x20, 0x20);
    //io_outb(0xa0, 0x20);//EOI end the int
    asm("1: jmp 1b");
c0107d8e:	eb fe                	jmp    c0107d8e <__proc0+0x29>
}
c0107d90:	90                   	nop
c0107d91:	c9                   	leave  
c0107d92:	c3                   	ret    

c0107d93 <init_platform>:

void init_platform()
{
c0107d93:	55                   	push   %ebp
c0107d94:	89 e5                	mov    %esp,%ebp
c0107d96:	83 ec 08             	sub    $0x8,%esp
    //size_t virk_init_pg_count = ((uintptr_t)(&__init_phykernel_end)) >> 12;
    //init malloc
    mem_init();
c0107d99:	e8 36 f0 ff ff       	call   c0106dd4 <mem_init>
    init_keyboard();
c0107d9e:	e8 23 15 00 00       	call   c01092c6 <init_keyboard>
    timer_init();
c0107da3:	e8 9d fe ff ff       	call   c0107c45 <timer_init>
    pci_init();
c0107da8:	e8 7a 0b 00 00       	call   c0108927 <pci_init>
    pci_print_device();
c0107dad:	e8 e0 07 00 00       	call   c0108592 <pci_print_device>
    ide_init();
c0107db2:	e8 f5 20 00 00       	call   c0109eac <ide_init>
    syscall_install();
c0107db7:	e8 b2 22 00 00       	call   c010a06e <syscall_install>
    // for (size_t i = 0; i < virk_init_pg_count; i++) {

    //     vmm_unmap_page(KERNEL_PID, (i << 12));
    // }
    // kprintf("[MM] Releaseing %d pages from 0x0.\n", virk_init_pg_count);
c0107dbc:	90                   	nop
c0107dbd:	c9                   	leave  
c0107dbe:	c3                   	ret    

c0107dbf <syscall>:
{
c0107dbf:	55                   	push   %ebp
c0107dc0:	89 e5                	mov    %esp,%ebp
c0107dc2:	57                   	push   %edi
    asm volatile("int %0" ::"i"(0x80), "D"(callcode) : "eax");
c0107dc3:	8b 55 08             	mov    0x8(%ebp),%edx
c0107dc6:	89 d7                	mov    %edx,%edi
c0107dc8:	cd 80                	int    $0x80
}
c0107dca:	90                   	nop
c0107dcb:	8b 7d fc             	mov    -0x4(%ebp),%edi
c0107dce:	c9                   	leave  
c0107dcf:	c3                   	ret    

c0107dd0 <fork>:
__MXSYSCALL(pid_t, fork)
c0107dd0:	55                   	push   %ebp
c0107dd1:	89 e5                	mov    %esp,%ebp
c0107dd3:	83 ec 10             	sub    $0x10,%esp
c0107dd6:	b8 01 00 00 00       	mov    $0x1,%eax
c0107ddb:	cd 80                	int    $0x80
c0107ddd:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0107de0:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0107de3:	c9                   	leave  
c0107de4:	c3                   	ret    

c0107de5 <getpid>:
__MXSYSCALL(pid_t, getpid)
c0107de5:	55                   	push   %ebp
c0107de6:	89 e5                	mov    %esp,%ebp
c0107de8:	83 ec 10             	sub    $0x10,%esp
c0107deb:	b8 02 00 00 00       	mov    $0x2,%eax
c0107df0:	cd 80                	int    $0x80
c0107df2:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0107df5:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0107df8:	c9                   	leave  
c0107df9:	c3                   	ret    

c0107dfa <getppid>:
__MXSYSCALL(pid_t, getppid)
c0107dfa:	55                   	push   %ebp
c0107dfb:	89 e5                	mov    %esp,%ebp
c0107dfd:	83 ec 10             	sub    $0x10,%esp
c0107e00:	b8 03 00 00 00       	mov    $0x3,%eax
c0107e05:	cd 80                	int    $0x80
c0107e07:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0107e0a:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0107e0d:	c9                   	leave  
c0107e0e:	c3                   	ret    

c0107e0f <_exit>:
__MXSYSCALL1(void, _exit, int, status)
c0107e0f:	55                   	push   %ebp
c0107e10:	89 e5                	mov    %esp,%ebp
c0107e12:	53                   	push   %ebx
c0107e13:	83 ec 10             	sub    $0x10,%esp
c0107e16:	8b 45 08             	mov    0x8(%ebp),%eax
c0107e19:	89 c3                	mov    %eax,%ebx
c0107e1b:	b8 04 00 00 00       	mov    $0x4,%eax
c0107e20:	cd 80                	int    $0x80
c0107e22:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0107e25:	90                   	nop
c0107e26:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0107e29:	c9                   	leave  
c0107e2a:	c3                   	ret    

c0107e2b <_mxinit_main>:
#include <syscall/meloxstd.h>
#include <syscall/syscall.h>
#include <kernel/cpu/io.h>
//#define FORK_BOMB_DEMO
void _mxinit_main()
{
c0107e2b:	55                   	push   %ebp
c0107e2c:	89 e5                	mov    %esp,%ebp
c0107e2e:	83 ec 08             	sub    $0x8,%esp
    //     kprintf("Forked %d\n", pid);
    // }

    // char buf[64];
    //asm("sti");
    kprintf("proc 1!");
c0107e31:	83 ec 0c             	sub    $0xc,%esp
c0107e34:	68 d6 e2 d0 c0       	push   $0xc0d0e2d6
c0107e39:	e8 43 2e 00 00       	call   c010ac81 <kprintf>
c0107e3e:	83 c4 10             	add    $0x10,%esp
    asm("int $0x20");
c0107e41:	cd 20                	int    $0x20
    //fork();
    //io_outb(0x20, 0x20);
    //io_outb(0xa0, 0x20);//EOI end the int
    while(1);
c0107e43:	eb fe                	jmp    c0107e43 <_mxinit_main+0x18>

c0107e45 <io_outb>:
{
c0107e45:	55                   	push   %ebp
c0107e46:	89 e5                	mov    %esp,%ebp
c0107e48:	83 ec 04             	sub    $0x4,%esp
c0107e4b:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107e4e:	88 45 fc             	mov    %al,-0x4(%ebp)
    asm volatile("outb %0, %w1" : : "a"(data), "d"(port));
c0107e51:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0107e55:	8b 55 08             	mov    0x8(%ebp),%edx
c0107e58:	ee                   	out    %al,(%dx)
}
c0107e59:	90                   	nop
c0107e5a:	c9                   	leave  
c0107e5b:	c3                   	ret    

c0107e5c <pic_end_eoi>:

static inline void cpu_delay(){
    for(int i = 0; i < 3; i++);
}

static inline void pic_end_eoi(){
c0107e5c:	55                   	push   %ebp
c0107e5d:	89 e5                	mov    %esp,%ebp
    io_outb(0x20, 0x20);
c0107e5f:	6a 20                	push   $0x20
c0107e61:	6a 20                	push   $0x20
c0107e63:	e8 dd ff ff ff       	call   c0107e45 <io_outb>
c0107e68:	83 c4 08             	add    $0x8,%esp
    io_outb(0xa0, 0x20);//EOI end the int
c0107e6b:	6a 20                	push   $0x20
c0107e6d:	68 a0 00 00 00       	push   $0xa0
c0107e72:	e8 ce ff ff ff       	call   c0107e45 <io_outb>
c0107e77:	83 c4 08             	add    $0x8,%esp
}
c0107e7a:	90                   	nop
c0107e7b:	c9                   	leave  
c0107e7c:	c3                   	ret    

c0107e7d <intr_subscribe>:
#include <kernel/process/peocess.h>
#include <kernel/cpu/io.h>

static int_subscriber subscribers[256];

void intr_subscribe(const uint8_t vector, int_subscriber subscriber) {
c0107e7d:	55                   	push   %ebp
c0107e7e:	89 e5                	mov    %esp,%ebp
c0107e80:	83 ec 04             	sub    $0x4,%esp
c0107e83:	8b 45 08             	mov    0x8(%ebp),%eax
c0107e86:	88 45 fc             	mov    %al,-0x4(%ebp)
    subscribers[vector] = subscriber;
c0107e89:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0107e8d:	8b 55 0c             	mov    0xc(%ebp),%edx
c0107e90:	89 14 85 00 b1 d0 c0 	mov    %edx,-0x3f2f4f00(,%eax,4)
}
c0107e97:	90                   	nop
c0107e98:	c9                   	leave  
c0107e99:	c3                   	ret    

c0107e9a <intr_unsubscribe>:

void intr_unsubscribe(const uint8_t vector, int_subscriber subscriber) {
c0107e9a:	55                   	push   %ebp
c0107e9b:	89 e5                	mov    %esp,%ebp
c0107e9d:	83 ec 04             	sub    $0x4,%esp
c0107ea0:	8b 45 08             	mov    0x8(%ebp),%eax
c0107ea3:	88 45 fc             	mov    %al,-0x4(%ebp)
    if (subscribers[vector] == subscriber) {
c0107ea6:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0107eaa:	8b 04 85 00 b1 d0 c0 	mov    -0x3f2f4f00(,%eax,4),%eax
c0107eb1:	39 45 0c             	cmp    %eax,0xc(%ebp)
c0107eb4:	75 0f                	jne    c0107ec5 <intr_unsubscribe+0x2b>
        subscribers[vector] = (int_subscriber) 0;
c0107eb6:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0107eba:	c7 04 85 00 b1 d0 c0 	movl   $0x0,-0x3f2f4f00(,%eax,4)
c0107ec1:	00 00 00 00 
    }
}
c0107ec5:	90                   	nop
c0107ec6:	c9                   	leave  
c0107ec7:	c3                   	ret    

c0107ec8 <intr_handler>:

void intr_handler(isr_param* param)
{
c0107ec8:	55                   	push   %ebp
c0107ec9:	89 e5                	mov    %esp,%ebp
c0107ecb:	53                   	push   %ebx
c0107ecc:	83 ec 14             	sub    $0x14,%esp
	__current->intr_contxt = *param;
c0107ecf:	a1 20 cb d0 c0       	mov    0xc0d0cb20,%eax
c0107ed4:	8b 55 08             	mov    0x8(%ebp),%edx
c0107ed7:	8b 0a                	mov    (%edx),%ecx
c0107ed9:	89 48 08             	mov    %ecx,0x8(%eax)
c0107edc:	8b 4a 04             	mov    0x4(%edx),%ecx
c0107edf:	89 48 0c             	mov    %ecx,0xc(%eax)
c0107ee2:	8b 4a 08             	mov    0x8(%edx),%ecx
c0107ee5:	89 48 10             	mov    %ecx,0x10(%eax)
c0107ee8:	8b 4a 0c             	mov    0xc(%edx),%ecx
c0107eeb:	89 48 14             	mov    %ecx,0x14(%eax)
c0107eee:	8b 4a 10             	mov    0x10(%edx),%ecx
c0107ef1:	89 48 18             	mov    %ecx,0x18(%eax)
c0107ef4:	8b 4a 14             	mov    0x14(%edx),%ecx
c0107ef7:	89 48 1c             	mov    %ecx,0x1c(%eax)
c0107efa:	8b 4a 18             	mov    0x18(%edx),%ecx
c0107efd:	89 48 20             	mov    %ecx,0x20(%eax)
c0107f00:	8b 4a 1c             	mov    0x1c(%edx),%ecx
c0107f03:	89 48 24             	mov    %ecx,0x24(%eax)
c0107f06:	8b 4a 20             	mov    0x20(%edx),%ecx
c0107f09:	89 48 28             	mov    %ecx,0x28(%eax)
c0107f0c:	8b 4a 24             	mov    0x24(%edx),%ecx
c0107f0f:	89 48 2c             	mov    %ecx,0x2c(%eax)
c0107f12:	8b 4a 28             	mov    0x28(%edx),%ecx
c0107f15:	89 48 30             	mov    %ecx,0x30(%eax)
c0107f18:	8b 4a 2c             	mov    0x2c(%edx),%ecx
c0107f1b:	89 48 34             	mov    %ecx,0x34(%eax)
c0107f1e:	8b 4a 30             	mov    0x30(%edx),%ecx
c0107f21:	89 48 38             	mov    %ecx,0x38(%eax)
c0107f24:	8b 4a 34             	mov    0x34(%edx),%ecx
c0107f27:	89 48 3c             	mov    %ecx,0x3c(%eax)
c0107f2a:	8b 52 38             	mov    0x38(%edx),%edx
c0107f2d:	89 50 40             	mov    %edx,0x40(%eax)
    cpu_lcr3(__kernel_ptd);

    vmm_mount_pd(PD_MOUNT_1, __current->page_table);
#endif

    isr_param *lparam = &__current->intr_contxt;
c0107f30:	a1 20 cb d0 c0       	mov    0xc0d0cb20,%eax
c0107f35:	83 c0 08             	add    $0x8,%eax
c0107f38:	89 45 f4             	mov    %eax,-0xc(%ebp)
    
    if (lparam->vector <= 255) {
c0107f3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107f3e:	8b 40 20             	mov    0x20(%eax),%eax
c0107f41:	3d ff 00 00 00       	cmp    $0xff,%eax
c0107f46:	77 26                	ja     c0107f6e <intr_handler+0xa6>
        int_subscriber subscriber = subscribers[lparam->vector];
c0107f48:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107f4b:	8b 40 20             	mov    0x20(%eax),%eax
c0107f4e:	8b 04 85 00 b1 d0 c0 	mov    -0x3f2f4f00(,%eax,4),%eax
c0107f55:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if (subscriber) {
c0107f58:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0107f5c:	74 10                	je     c0107f6e <intr_handler+0xa6>
            subscriber(param);
c0107f5e:	83 ec 0c             	sub    $0xc,%esp
c0107f61:	ff 75 08             	push   0x8(%ebp)
c0107f64:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107f67:	ff d0                	call   *%eax
c0107f69:	83 c4 10             	add    $0x10,%esp
            goto done;
c0107f6c:	eb 2c                	jmp    c0107f9a <intr_handler+0xd2>
    // if (fallback) {
    //     fallback(lparam);
    //     goto done;
    // }
    
    kprintf("INT %x: (%x) [%x: %x] Unknown",
c0107f6e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107f71:	8b 58 28             	mov    0x28(%eax),%ebx
c0107f74:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107f77:	8b 48 2c             	mov    0x2c(%eax),%ecx
c0107f7a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107f7d:	8b 50 24             	mov    0x24(%eax),%edx
c0107f80:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107f83:	8b 40 20             	mov    0x20(%eax),%eax
c0107f86:	83 ec 0c             	sub    $0xc,%esp
c0107f89:	53                   	push   %ebx
c0107f8a:	51                   	push   %ecx
c0107f8b:	52                   	push   %edx
c0107f8c:	50                   	push   %eax
c0107f8d:	68 e0 e2 d0 c0       	push   $0xc0d0e2e0
c0107f92:	e8 ea 2c 00 00       	call   c010ac81 <kprintf>
c0107f97:	83 c4 20             	add    $0x20,%esp
            lparam->cs,
            lparam->eip);

done:
    // for all external interrupts except the spurious interrupt
    if (lparam->vector >= EXTERN_INTER) {
c0107f9a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107f9d:	8b 40 20             	mov    0x20(%eax),%eax
c0107fa0:	83 f8 1f             	cmp    $0x1f,%eax
c0107fa3:	76 06                	jbe    c0107fab <intr_handler+0xe3>
        pic_end_eoi();
c0107fa5:	e8 b2 fe ff ff       	call   c0107e5c <pic_end_eoi>
	}

#ifdef USE_KERNEL_PT
    cpu_lcr3(__current->page_table);
#endif
    return;
c0107faa:	90                   	nop
c0107fab:	90                   	nop
}
c0107fac:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0107faf:	c9                   	leave  
c0107fb0:	c3                   	ret    

c0107fb1 <_divide_err>:

void _divide_err(unsigned long addr, int err_code)
{
c0107fb1:	55                   	push   %ebp
c0107fb2:	89 e5                	mov    %esp,%ebp
c0107fb4:	83 ec 08             	sub    $0x8,%esp
    vga_set_show(1,VGA_COLOR_BLACK,VGA_COLOR_BLUE);
c0107fb7:	83 ec 04             	sub    $0x4,%esp
c0107fba:	6a 01                	push   $0x1
c0107fbc:	6a 00                	push   $0x0
c0107fbe:	6a 01                	push   $0x1
c0107fc0:	e8 0f e1 ff ff       	call   c01060d4 <vga_set_show>
c0107fc5:	83 c4 10             	add    $0x10,%esp
    kprintf("divide err addr = 0x%x,err code = %d\n", addr,err_code);
c0107fc8:	83 ec 04             	sub    $0x4,%esp
c0107fcb:	ff 75 0c             	push   0xc(%ebp)
c0107fce:	ff 75 08             	push   0x8(%ebp)
c0107fd1:	68 00 e3 d0 c0       	push   $0xc0d0e300
c0107fd6:	e8 a6 2c 00 00       	call   c010ac81 <kprintf>
c0107fdb:	83 c4 10             	add    $0x10,%esp
}
c0107fde:	90                   	nop
c0107fdf:	c9                   	leave  
c0107fe0:	c3                   	ret    

c0107fe1 <do_double_fault>:

void do_double_fault(unsigned long addr, int err_code)
{
c0107fe1:	55                   	push   %ebp
c0107fe2:	89 e5                	mov    %esp,%ebp
c0107fe4:	83 ec 08             	sub    $0x8,%esp
	kprintf("double_fault addr = 0x%x,err code = %d\n", addr,err_code);
c0107fe7:	83 ec 04             	sub    $0x4,%esp
c0107fea:	ff 75 0c             	push   0xc(%ebp)
c0107fed:	ff 75 08             	push   0x8(%ebp)
c0107ff0:	68 28 e3 d0 c0       	push   $0xc0d0e328
c0107ff5:	e8 87 2c 00 00       	call   c010ac81 <kprintf>
c0107ffa:	83 c4 10             	add    $0x10,%esp
}
c0107ffd:	90                   	nop
c0107ffe:	c9                   	leave  
c0107fff:	c3                   	ret    

c0108000 <do_general_protection>:

void do_general_protection(unsigned long addr, int err_code)
{
c0108000:	55                   	push   %ebp
c0108001:	89 e5                	mov    %esp,%ebp
c0108003:	83 ec 08             	sub    $0x8,%esp
	kprintf("general_protection addr = 0x%x,err code = %d\n", addr,err_code);
c0108006:	83 ec 04             	sub    $0x4,%esp
c0108009:	ff 75 0c             	push   0xc(%ebp)
c010800c:	ff 75 08             	push   0x8(%ebp)
c010800f:	68 50 e3 d0 c0       	push   $0xc0d0e350
c0108014:	e8 68 2c 00 00       	call   c010ac81 <kprintf>
c0108019:	83 c4 10             	add    $0x10,%esp
}
c010801c:	90                   	nop
c010801d:	c9                   	leave  
c010801e:	c3                   	ret    

c010801f <do_int3>:


void do_int3(unsigned long addr, int err_code)
{
c010801f:	55                   	push   %ebp
c0108020:	89 e5                	mov    %esp,%ebp
c0108022:	83 ec 08             	sub    $0x8,%esp
    kprintf("int3 addr = 0x%x,err code = %d\n", addr,err_code);
c0108025:	83 ec 04             	sub    $0x4,%esp
c0108028:	ff 75 0c             	push   0xc(%ebp)
c010802b:	ff 75 08             	push   0x8(%ebp)
c010802e:	68 80 e3 d0 c0       	push   $0xc0d0e380
c0108033:	e8 49 2c 00 00       	call   c010ac81 <kprintf>
c0108038:	83 c4 10             	add    $0x10,%esp
}
c010803b:	90                   	nop
c010803c:	c9                   	leave  
c010803d:	c3                   	ret    

c010803e <do_nmi>:

void do_nmi(unsigned long addr, int err_code)
{
c010803e:	55                   	push   %ebp
c010803f:	89 e5                	mov    %esp,%ebp
c0108041:	83 ec 08             	sub    $0x8,%esp
	kprintf("nmi addr = 0x%x,err code = %d\n", addr,err_code);
c0108044:	83 ec 04             	sub    $0x4,%esp
c0108047:	ff 75 0c             	push   0xc(%ebp)
c010804a:	ff 75 08             	push   0x8(%ebp)
c010804d:	68 a0 e3 d0 c0       	push   $0xc0d0e3a0
c0108052:	e8 2a 2c 00 00       	call   c010ac81 <kprintf>
c0108057:	83 c4 10             	add    $0x10,%esp
}
c010805a:	90                   	nop
c010805b:	c9                   	leave  
c010805c:	c3                   	ret    

c010805d <do_debug>:

void do_debug(unsigned long addr, int err_code)
{
c010805d:	55                   	push   %ebp
c010805e:	89 e5                	mov    %esp,%ebp
c0108060:	83 ec 08             	sub    $0x8,%esp
	kprintf("debug addr = 0x%x,err code = %d\n", addr,err_code);
c0108063:	83 ec 04             	sub    $0x4,%esp
c0108066:	ff 75 0c             	push   0xc(%ebp)
c0108069:	ff 75 08             	push   0x8(%ebp)
c010806c:	68 c0 e3 d0 c0       	push   $0xc0d0e3c0
c0108071:	e8 0b 2c 00 00       	call   c010ac81 <kprintf>
c0108076:	83 c4 10             	add    $0x10,%esp
}
c0108079:	90                   	nop
c010807a:	c9                   	leave  
c010807b:	c3                   	ret    

c010807c <do_overflow>:

void do_overflow(unsigned long addr, int err_code)
{
c010807c:	55                   	push   %ebp
c010807d:	89 e5                	mov    %esp,%ebp
c010807f:	83 ec 08             	sub    $0x8,%esp
	kprintf("overflow addr = 0x%x,err code = %d\n", addr,err_code);
c0108082:	83 ec 04             	sub    $0x4,%esp
c0108085:	ff 75 0c             	push   0xc(%ebp)
c0108088:	ff 75 08             	push   0x8(%ebp)
c010808b:	68 e4 e3 d0 c0       	push   $0xc0d0e3e4
c0108090:	e8 ec 2b 00 00       	call   c010ac81 <kprintf>
c0108095:	83 c4 10             	add    $0x10,%esp
}
c0108098:	90                   	nop
c0108099:	c9                   	leave  
c010809a:	c3                   	ret    

c010809b <do_bounds>:

void do_bounds(unsigned long addr, int err_code)
{
c010809b:	55                   	push   %ebp
c010809c:	89 e5                	mov    %esp,%ebp
c010809e:	83 ec 08             	sub    $0x8,%esp
	kprintf("bounds addr = 0x%x,err code = %d\n", addr,err_code);
c01080a1:	83 ec 04             	sub    $0x4,%esp
c01080a4:	ff 75 0c             	push   0xc(%ebp)
c01080a7:	ff 75 08             	push   0x8(%ebp)
c01080aa:	68 08 e4 d0 c0       	push   $0xc0d0e408
c01080af:	e8 cd 2b 00 00       	call   c010ac81 <kprintf>
c01080b4:	83 c4 10             	add    $0x10,%esp
}
c01080b7:	90                   	nop
c01080b8:	c9                   	leave  
c01080b9:	c3                   	ret    

c01080ba <do_invalid_op>:

void do_invalid_op(unsigned long addr, int err_code)
{
c01080ba:	55                   	push   %ebp
c01080bb:	89 e5                	mov    %esp,%ebp
c01080bd:	83 ec 08             	sub    $0x8,%esp
	kprintf("invalid_op addr = 0x%x,err code = %d\n", addr,err_code);
c01080c0:	83 ec 04             	sub    $0x4,%esp
c01080c3:	ff 75 0c             	push   0xc(%ebp)
c01080c6:	ff 75 08             	push   0x8(%ebp)
c01080c9:	68 2c e4 d0 c0       	push   $0xc0d0e42c
c01080ce:	e8 ae 2b 00 00       	call   c010ac81 <kprintf>
c01080d3:	83 c4 10             	add    $0x10,%esp
}
c01080d6:	90                   	nop
c01080d7:	c9                   	leave  
c01080d8:	c3                   	ret    

c01080d9 <do_device_not_available>:

void do_device_not_available(unsigned long addr, int err_code)
{
c01080d9:	55                   	push   %ebp
c01080da:	89 e5                	mov    %esp,%ebp
c01080dc:	83 ec 08             	sub    $0x8,%esp
	kprintf("device_not_availabel addr = 0x%x,err code = %d\n", addr,err_code);
c01080df:	83 ec 04             	sub    $0x4,%esp
c01080e2:	ff 75 0c             	push   0xc(%ebp)
c01080e5:	ff 75 08             	push   0x8(%ebp)
c01080e8:	68 54 e4 d0 c0       	push   $0xc0d0e454
c01080ed:	e8 8f 2b 00 00       	call   c010ac81 <kprintf>
c01080f2:	83 c4 10             	add    $0x10,%esp
}
c01080f5:	90                   	nop
c01080f6:	c9                   	leave  
c01080f7:	c3                   	ret    

c01080f8 <do_coprocessor_segment_overrun>:

void do_coprocessor_segment_overrun(unsigned long addr, int err_code)
{
c01080f8:	55                   	push   %ebp
c01080f9:	89 e5                	mov    %esp,%ebp
c01080fb:	83 ec 08             	sub    $0x8,%esp
	kprintf("coprprocessor_segment_overrun addr = 0x%x,err code = %d\n", addr,err_code);
c01080fe:	83 ec 04             	sub    $0x4,%esp
c0108101:	ff 75 0c             	push   0xc(%ebp)
c0108104:	ff 75 08             	push   0x8(%ebp)
c0108107:	68 84 e4 d0 c0       	push   $0xc0d0e484
c010810c:	e8 70 2b 00 00       	call   c010ac81 <kprintf>
c0108111:	83 c4 10             	add    $0x10,%esp
}
c0108114:	90                   	nop
c0108115:	c9                   	leave  
c0108116:	c3                   	ret    

c0108117 <do_invalid_TSS>:

void do_invalid_TSS(unsigned long addr, int err_code)
{
c0108117:	55                   	push   %ebp
c0108118:	89 e5                	mov    %esp,%ebp
c010811a:	83 ec 08             	sub    $0x8,%esp
	kprintf("invalid_TSS addr = 0x%x,err code = %d\n", addr,err_code);
c010811d:	83 ec 04             	sub    $0x4,%esp
c0108120:	ff 75 0c             	push   0xc(%ebp)
c0108123:	ff 75 08             	push   0x8(%ebp)
c0108126:	68 c0 e4 d0 c0       	push   $0xc0d0e4c0
c010812b:	e8 51 2b 00 00       	call   c010ac81 <kprintf>
c0108130:	83 c4 10             	add    $0x10,%esp
}
c0108133:	90                   	nop
c0108134:	c9                   	leave  
c0108135:	c3                   	ret    

c0108136 <do_segment_not_present>:

void do_segment_not_present(unsigned long addr, int err_code)
{
c0108136:	55                   	push   %ebp
c0108137:	89 e5                	mov    %esp,%ebp
c0108139:	83 ec 08             	sub    $0x8,%esp
	kprintf("segment not present addr = 0x%x,err code = %d\n", addr,err_code);
c010813c:	83 ec 04             	sub    $0x4,%esp
c010813f:	ff 75 0c             	push   0xc(%ebp)
c0108142:	ff 75 08             	push   0x8(%ebp)
c0108145:	68 e8 e4 d0 c0       	push   $0xc0d0e4e8
c010814a:	e8 32 2b 00 00       	call   c010ac81 <kprintf>
c010814f:	83 c4 10             	add    $0x10,%esp
}
c0108152:	90                   	nop
c0108153:	c9                   	leave  
c0108154:	c3                   	ret    

c0108155 <do_stack_segment>:

void do_stack_segment(unsigned long addr, int err_code)
{
c0108155:	55                   	push   %ebp
c0108156:	89 e5                	mov    %esp,%ebp
c0108158:	83 ec 08             	sub    $0x8,%esp
	kprintf("stack_segment addr = 0x%x,err code = %d\n", addr,err_code);
c010815b:	83 ec 04             	sub    $0x4,%esp
c010815e:	ff 75 0c             	push   0xc(%ebp)
c0108161:	ff 75 08             	push   0x8(%ebp)
c0108164:	68 18 e5 d0 c0       	push   $0xc0d0e518
c0108169:	e8 13 2b 00 00       	call   c010ac81 <kprintf>
c010816e:	83 c4 10             	add    $0x10,%esp
}
c0108171:	90                   	nop
c0108172:	c9                   	leave  
c0108173:	c3                   	ret    

c0108174 <do_coprocessor_error>:

void do_coprocessor_error(unsigned long addr, int err_code)
{
c0108174:	55                   	push   %ebp
c0108175:	89 e5                	mov    %esp,%ebp
c0108177:	83 ec 08             	sub    $0x8,%esp
    kprintf("coprocessor_err addr = 0x%x,err code = %d\n", addr,err_code);
c010817a:	83 ec 04             	sub    $0x4,%esp
c010817d:	ff 75 0c             	push   0xc(%ebp)
c0108180:	ff 75 08             	push   0x8(%ebp)
c0108183:	68 44 e5 d0 c0       	push   $0xc0d0e544
c0108188:	e8 f4 2a 00 00       	call   c010ac81 <kprintf>
c010818d:	83 c4 10             	add    $0x10,%esp
}
c0108190:	90                   	nop
c0108191:	c9                   	leave  
c0108192:	c3                   	ret    

c0108193 <do_reserved>:

void do_reserved(unsigned long addr, int err_code)
{
c0108193:	55                   	push   %ebp
c0108194:	89 e5                	mov    %esp,%ebp
c0108196:	83 ec 08             	sub    $0x8,%esp
	kprintf("reserved addr = 0x%x,err code = %d\n", addr,err_code);
c0108199:	83 ec 04             	sub    $0x4,%esp
c010819c:	ff 75 0c             	push   0xc(%ebp)
c010819f:	ff 75 08             	push   0x8(%ebp)
c01081a2:	68 70 e5 d0 c0       	push   $0xc0d0e570
c01081a7:	e8 d5 2a 00 00       	call   c010ac81 <kprintf>
c01081ac:	83 c4 10             	add    $0x10,%esp
}
c01081af:	90                   	nop
c01081b0:	c9                   	leave  
c01081b1:	c3                   	ret    

c01081b2 <intr_time_handler>:
c01081b2:	6a 00                	push   $0x0
c01081b4:	6a 20                	push   $0x20
c01081b6:	eb 15                	jmp    c01081cd <interrupt_wrapper>

c01081b8 <intr_syscall_handler>:
c01081b8:	6a 00                	push   $0x0
c01081ba:	68 80 00 00 00       	push   $0x80
c01081bf:	eb 0c                	jmp    c01081cd <interrupt_wrapper>

c01081c1 <intr_hd_handler1>:
c01081c1:	6a 00                	push   $0x0
c01081c3:	6a 2e                	push   $0x2e
c01081c5:	eb 06                	jmp    c01081cd <interrupt_wrapper>

c01081c7 <intr_hd_handler2>:
c01081c7:	6a 00                	push   $0x0
c01081c9:	6a 2f                	push   $0x2f
c01081cb:	eb 00                	jmp    c01081cd <interrupt_wrapper>

c01081cd <interrupt_wrapper>:
c01081cd:	54                   	push   %esp
c01081ce:	56                   	push   %esi
c01081cf:	55                   	push   %ebp
c01081d0:	57                   	push   %edi
c01081d1:	52                   	push   %edx
c01081d2:	51                   	push   %ecx
c01081d3:	53                   	push   %ebx
c01081d4:	50                   	push   %eax
c01081d5:	89 e0                	mov    %esp,%eax
c01081d7:	83 e4 f0             	and    $0xfffffff0,%esp
c01081da:	83 ec 10             	sub    $0x10,%esp
c01081dd:	89 04 24             	mov    %eax,(%esp)
c01081e0:	e8 e3 fc ff ff       	call   c0107ec8 <intr_handler>

c01081e5 <soft_iret>:
c01081e5:	5c                   	pop    %esp
c01081e6:	58                   	pop    %eax
c01081e7:	5b                   	pop    %ebx
c01081e8:	59                   	pop    %ecx
c01081e9:	5a                   	pop    %edx
c01081ea:	5f                   	pop    %edi
c01081eb:	5d                   	pop    %ebp
c01081ec:	5e                   	pop    %esi
c01081ed:	5c                   	pop    %esp
c01081ee:	83 c4 08             	add    $0x8,%esp
c01081f1:	cf                   	iret   

c01081f2 <_no_err_code>:
c01081f2:	87 04 24             	xchg   %eax,(%esp)
c01081f5:	53                   	push   %ebx
c01081f6:	51                   	push   %ecx
c01081f7:	52                   	push   %edx
c01081f8:	57                   	push   %edi
c01081f9:	56                   	push   %esi
c01081fa:	55                   	push   %ebp
c01081fb:	1e                   	push   %ds
c01081fc:	06                   	push   %es
c01081fd:	0f a0                	push   %fs
c01081ff:	6a 00                	push   $0x0
c0108201:	8d 54 24 2c          	lea    0x2c(%esp),%edx
c0108205:	52                   	push   %edx
c0108206:	ba 10 00 00 00       	mov    $0x10,%edx
c010820b:	8e da                	mov    %edx,%ds
c010820d:	8e c2                	mov    %edx,%es
c010820f:	8e e2                	mov    %edx,%fs
c0108211:	ff d0                	call   *%eax
c0108213:	83 c4 08             	add    $0x8,%esp
c0108216:	0f a1                	pop    %fs
c0108218:	07                   	pop    %es
c0108219:	1f                   	pop    %ds
c010821a:	5d                   	pop    %ebp
c010821b:	5e                   	pop    %esi
c010821c:	5f                   	pop    %edi
c010821d:	5a                   	pop    %edx
c010821e:	59                   	pop    %ecx
c010821f:	5b                   	pop    %ebx
c0108220:	58                   	pop    %eax
c0108221:	cf                   	iret   

c0108222 <_err_code>:
c0108222:	87 44 24 04          	xchg   %eax,0x4(%esp)
c0108226:	87 1c 24             	xchg   %ebx,(%esp)
c0108229:	51                   	push   %ecx
c010822a:	52                   	push   %edx
c010822b:	57                   	push   %edi
c010822c:	56                   	push   %esi
c010822d:	55                   	push   %ebp
c010822e:	1e                   	push   %ds
c010822f:	06                   	push   %es
c0108230:	0f a0                	push   %fs
c0108232:	50                   	push   %eax
c0108233:	8d 44 24 2c          	lea    0x2c(%esp),%eax
c0108237:	50                   	push   %eax
c0108238:	b8 10 00 00 00       	mov    $0x10,%eax
c010823d:	8e d8                	mov    %eax,%ds
c010823f:	8e c0                	mov    %eax,%es
c0108241:	8e e0                	mov    %eax,%fs
c0108243:	ff d3                	call   *%ebx
c0108245:	83 c4 08             	add    $0x8,%esp
c0108248:	0f a1                	pop    %fs
c010824a:	07                   	pop    %es
c010824b:	1f                   	pop    %ds
c010824c:	5d                   	pop    %ebp
c010824d:	5e                   	pop    %esi
c010824e:	5f                   	pop    %edi
c010824f:	5a                   	pop    %edx
c0108250:	59                   	pop    %ecx
c0108251:	5b                   	pop    %ebx
c0108252:	58                   	pop    %eax
c0108253:	cf                   	iret   

c0108254 <divide_error>:
c0108254:	68 b1 7f 10 c0       	push   $0xc0107fb1
c0108259:	eb 97                	jmp    c01081f2 <_no_err_code>

c010825b <debug>:
c010825b:	68 1f 80 10 c0       	push   $0xc010801f
c0108260:	eb 90                	jmp    c01081f2 <_no_err_code>

c0108262 <nmi>:
c0108262:	68 3e 80 10 c0       	push   $0xc010803e
c0108267:	eb 89                	jmp    c01081f2 <_no_err_code>

c0108269 <int3>:
c0108269:	68 1f 80 10 c0       	push   $0xc010801f
c010826e:	eb 82                	jmp    c01081f2 <_no_err_code>

c0108270 <overflow>:
c0108270:	68 7c 80 10 c0       	push   $0xc010807c
c0108275:	e9 78 ff ff ff       	jmp    c01081f2 <_no_err_code>

c010827a <bounds>:
c010827a:	68 9b 80 10 c0       	push   $0xc010809b
c010827f:	e9 6e ff ff ff       	jmp    c01081f2 <_no_err_code>

c0108284 <invalid_op>:
c0108284:	68 ba 80 10 c0       	push   $0xc01080ba
c0108289:	e9 64 ff ff ff       	jmp    c01081f2 <_no_err_code>

c010828e <coprocessor_segment_overrun>:
c010828e:	68 f8 80 10 c0       	push   $0xc01080f8
c0108293:	e9 5a ff ff ff       	jmp    c01081f2 <_no_err_code>

c0108298 <reserved>:
c0108298:	68 93 81 10 c0       	push   $0xc0108193
c010829d:	e9 50 ff ff ff       	jmp    c01081f2 <_no_err_code>

c01082a2 <invalid_TSS>:
c01082a2:	68 17 81 10 c0       	push   $0xc0108117
c01082a7:	e9 76 ff ff ff       	jmp    c0108222 <_err_code>

c01082ac <segment_not_present>:
c01082ac:	68 36 81 10 c0       	push   $0xc0108136
c01082b1:	e9 6c ff ff ff       	jmp    c0108222 <_err_code>

c01082b6 <stack_segment>:
c01082b6:	68 55 81 10 c0       	push   $0xc0108155
c01082bb:	e9 62 ff ff ff       	jmp    c0108222 <_err_code>

c01082c0 <general_protection>:
c01082c0:	68 00 80 10 c0       	push   $0xc0108000
c01082c5:	e9 58 ff ff ff       	jmp    c0108222 <_err_code>

c01082ca <io_inl>:
{
c01082ca:	55                   	push   %ebp
c01082cb:	89 e5                	mov    %esp,%ebp
c01082cd:	83 ec 10             	sub    $0x10,%esp
    asm volatile("inl %w1,%0" : "=a"(data) : "d"(port));
c01082d0:	8b 45 08             	mov    0x8(%ebp),%eax
c01082d3:	89 c2                	mov    %eax,%edx
c01082d5:	ed                   	in     (%dx),%eax
c01082d6:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return data;
c01082d9:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c01082dc:	c9                   	leave  
c01082dd:	c3                   	ret    

c01082de <io_outl>:
{
c01082de:	55                   	push   %ebp
c01082df:	89 e5                	mov    %esp,%ebp
    asm volatile("outl %0,%w1" : : "a"(data), "d"(port));
c01082e1:	8b 45 0c             	mov    0xc(%ebp),%eax
c01082e4:	8b 55 08             	mov    0x8(%ebp),%edx
c01082e7:	ef                   	out    %eax,(%dx)
}
c01082e8:	90                   	nop
c01082e9:	5d                   	pop    %ebp
c01082ea:	c3                   	ret    

c01082eb <__llist_add>:
{
c01082eb:	55                   	push   %ebp
c01082ec:	89 e5                	mov    %esp,%ebp
    next->prev = elem;
c01082ee:	8b 45 10             	mov    0x10(%ebp),%eax
c01082f1:	8b 55 08             	mov    0x8(%ebp),%edx
c01082f4:	89 10                	mov    %edx,(%eax)
    elem->next = next;
c01082f6:	8b 45 08             	mov    0x8(%ebp),%eax
c01082f9:	8b 55 10             	mov    0x10(%ebp),%edx
c01082fc:	89 50 04             	mov    %edx,0x4(%eax)
    elem->prev = prev;
c01082ff:	8b 45 08             	mov    0x8(%ebp),%eax
c0108302:	8b 55 0c             	mov    0xc(%ebp),%edx
c0108305:	89 10                	mov    %edx,(%eax)
    prev->next = elem;
c0108307:	8b 45 0c             	mov    0xc(%ebp),%eax
c010830a:	8b 55 08             	mov    0x8(%ebp),%edx
c010830d:	89 50 04             	mov    %edx,0x4(%eax)
}
c0108310:	90                   	nop
c0108311:	5d                   	pop    %ebp
c0108312:	c3                   	ret    

c0108313 <llist_init_head>:
static inline void llist_init_head(struct llist_header* head) {
c0108313:	55                   	push   %ebp
c0108314:	89 e5                	mov    %esp,%ebp
    head->next = head;
c0108316:	8b 45 08             	mov    0x8(%ebp),%eax
c0108319:	8b 55 08             	mov    0x8(%ebp),%edx
c010831c:	89 50 04             	mov    %edx,0x4(%eax)
    head->prev = head;
c010831f:	8b 45 08             	mov    0x8(%ebp),%eax
c0108322:	8b 55 08             	mov    0x8(%ebp),%edx
c0108325:	89 10                	mov    %edx,(%eax)
}
c0108327:	90                   	nop
c0108328:	5d                   	pop    %ebp
c0108329:	c3                   	ret    

c010832a <llist_append>:
{
c010832a:	55                   	push   %ebp
c010832b:	89 e5                	mov    %esp,%ebp
    __llist_add(elem, head, head->next);
c010832d:	8b 45 08             	mov    0x8(%ebp),%eax
c0108330:	8b 40 04             	mov    0x4(%eax),%eax
c0108333:	50                   	push   %eax
c0108334:	ff 75 08             	push   0x8(%ebp)
c0108337:	ff 75 0c             	push   0xc(%ebp)
c010833a:	e8 ac ff ff ff       	call   c01082eb <__llist_add>
c010833f:	83 c4 0c             	add    $0xc,%esp
}
c0108342:	90                   	nop
c0108343:	c9                   	leave  
c0108344:	c3                   	ret    

c0108345 <pci_probe_device>:
static struct llist_header pci_devices;

void pci_probe_msi_info(struct pci_device* device);

void pci_probe_device(int bus, int dev, int funct)
{
c0108345:	55                   	push   %ebp
c0108346:	89 e5                	mov    %esp,%ebp
c0108348:	56                   	push   %esi
c0108349:	53                   	push   %ebx
c010834a:	83 ec 40             	sub    $0x40,%esp
    uint32_t base = PCI_ADDRESS(bus, dev, funct);
c010834d:	8b 45 08             	mov    0x8(%ebp),%eax
c0108350:	c1 e0 10             	shl    $0x10,%eax
c0108353:	25 00 00 ff 00       	and    $0xff0000,%eax
c0108358:	89 c2                	mov    %eax,%edx
c010835a:	8b 45 0c             	mov    0xc(%ebp),%eax
c010835d:	c1 e0 0b             	shl    $0xb,%eax
c0108360:	25 00 f8 07 00       	and    $0x7f800,%eax
c0108365:	09 c2                	or     %eax,%edx
c0108367:	8b 45 10             	mov    0x10(%ebp),%eax
c010836a:	c1 e0 08             	shl    $0x8,%eax
c010836d:	0f b7 c0             	movzwl %ax,%eax
c0108370:	09 d0                	or     %edx,%eax
c0108372:	0d 00 00 00 80       	or     $0x80000000,%eax
c0108377:	89 45 ec             	mov    %eax,-0x14(%ebp)
    pci_reg_t reg1 = pci_read_cspace(base, 0);
c010837a:	83 ec 08             	sub    $0x8,%esp
c010837d:	6a 00                	push   $0x0
c010837f:	ff 75 ec             	push   -0x14(%ebp)
c0108382:	e8 bb 05 00 00       	call   c0108942 <pci_read_cspace>
c0108387:	83 c4 10             	add    $0x10,%esp
c010838a:	89 45 e8             	mov    %eax,-0x18(%ebp)

    // Vendor=0xffff则表示设备不存在
    if (PCI_DEV_VENDOR(reg1) == PCI_VENDOR_INVLD) {
c010838d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0108390:	0f b7 c0             	movzwl %ax,%eax
c0108393:	3d ff ff 00 00       	cmp    $0xffff,%eax
c0108398:	0f 84 0d 01 00 00    	je     c01084ab <pci_probe_device+0x166>
        return;
    }

    pci_reg_t hdr_type = pci_read_cspace(base, 0xc);
c010839e:	83 ec 08             	sub    $0x8,%esp
c01083a1:	6a 0c                	push   $0xc
c01083a3:	ff 75 ec             	push   -0x14(%ebp)
c01083a6:	e8 97 05 00 00       	call   c0108942 <pci_read_cspace>
c01083ab:	83 c4 10             	add    $0x10,%esp
c01083ae:	89 45 f4             	mov    %eax,-0xc(%ebp)
    hdr_type = (hdr_type >> 16) & 0xff;
c01083b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01083b4:	c1 e8 10             	shr    $0x10,%eax
c01083b7:	25 ff 00 00 00       	and    $0xff,%eax
c01083bc:	89 45 f4             	mov    %eax,-0xc(%ebp)

    // 防止堆栈溢出
    // QEMU的ICH9/Q35实现似乎有点问题，对于多功能设备的每一个功能的header type
    //  都将第七位置位。而virtualbox 就没有这个毛病。
    if ((hdr_type & 0x80) && funct == 0) {
c01083bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01083c2:	25 80 00 00 00       	and    $0x80,%eax
c01083c7:	85 c0                	test   %eax,%eax
c01083c9:	74 34                	je     c01083ff <pci_probe_device+0xba>
c01083cb:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c01083cf:	75 2e                	jne    c01083ff <pci_probe_device+0xba>
        hdr_type = hdr_type & ~0x80;
c01083d1:	81 65 f4 7f ff ff ff 	andl   $0xffffff7f,-0xc(%ebp)
        // 探测多用途设备（multi-function device）
        for (int i = 1; i < 7; i++) {
c01083d8:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
c01083df:	eb 18                	jmp    c01083f9 <pci_probe_device+0xb4>
            pci_probe_device(bus, dev, i);
c01083e1:	83 ec 04             	sub    $0x4,%esp
c01083e4:	ff 75 f0             	push   -0x10(%ebp)
c01083e7:	ff 75 0c             	push   0xc(%ebp)
c01083ea:	ff 75 08             	push   0x8(%ebp)
c01083ed:	e8 53 ff ff ff       	call   c0108345 <pci_probe_device>
c01083f2:	83 c4 10             	add    $0x10,%esp
        for (int i = 1; i < 7; i++) {
c01083f5:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c01083f9:	83 7d f0 06          	cmpl   $0x6,-0x10(%ebp)
c01083fd:	7e e2                	jle    c01083e1 <pci_probe_device+0x9c>
        }
    }

    if (hdr_type != PCI_TDEV) {
c01083ff:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0108403:	0f 85 a5 00 00 00    	jne    c01084ae <pci_probe_device+0x169>
        // XXX: 目前忽略所有桥接设备，比如PCI-PCI桥接器，或者是CardBus桥接器
        return;
    }

    pci_reg_t intr = pci_read_cspace(base, 0x3c);
c0108409:	83 ec 08             	sub    $0x8,%esp
c010840c:	6a 3c                	push   $0x3c
c010840e:	ff 75 ec             	push   -0x14(%ebp)
c0108411:	e8 2c 05 00 00       	call   c0108942 <pci_read_cspace>
c0108416:	83 c4 10             	add    $0x10,%esp
c0108419:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    pci_reg_t mclass = pci_read_cspace(base, 0x8);
c010841c:	83 ec 08             	sub    $0x8,%esp
c010841f:	6a 08                	push   $0x8
c0108421:	ff 75 ec             	push   -0x14(%ebp)
c0108424:	e8 19 05 00 00       	call   c0108942 <pci_read_cspace>
c0108429:	83 c4 10             	add    $0x10,%esp
c010842c:	89 45 e0             	mov    %eax,-0x20(%ebp)

    struct pci_device* device = k_malloc(sizeof(struct pci_device));
c010842f:	83 ec 0c             	sub    $0xc,%esp
c0108432:	6a 1c                	push   $0x1c
c0108434:	e8 8d eb ff ff       	call   c0106fc6 <k_malloc>
c0108439:	83 c4 10             	add    $0x10,%esp
c010843c:	89 45 dc             	mov    %eax,-0x24(%ebp)
    *device = (struct pci_device){ .device_info = reg1,
c010843f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0108442:	89 c3                	mov    %eax,%ebx
c0108444:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0108447:	be 00 00 00 00       	mov    $0x0,%esi
c010844c:	b8 1c 00 00 00       	mov    $0x1c,%eax
c0108451:	83 e0 fc             	and    $0xfffffffc,%eax
c0108454:	89 c1                	mov    %eax,%ecx
c0108456:	b8 00 00 00 00       	mov    $0x0,%eax
c010845b:	89 34 02             	mov    %esi,(%edx,%eax,1)
c010845e:	83 c0 04             	add    $0x4,%eax
c0108461:	39 c8                	cmp    %ecx,%eax
c0108463:	72 f6                	jb     c010845b <pci_probe_device+0x116>
c0108465:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0108468:	8b 55 e8             	mov    -0x18(%ebp),%edx
c010846b:	89 50 08             	mov    %edx,0x8(%eax)
c010846e:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0108471:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0108474:	89 50 0c             	mov    %edx,0xc(%eax)
c0108477:	8b 45 dc             	mov    -0x24(%ebp),%eax
c010847a:	8b 55 ec             	mov    -0x14(%ebp),%edx
c010847d:	89 50 10             	mov    %edx,0x10(%eax)
c0108480:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0108483:	66 89 58 18          	mov    %bx,0x18(%eax)
                                   .class_info = mclass,
                                   .cspace_base = base,
                                   .intr_info = intr };

    pci_probe_msi_info(device);
c0108487:	83 ec 0c             	sub    $0xc,%esp
c010848a:	ff 75 dc             	push   -0x24(%ebp)
c010848d:	e8 67 00 00 00       	call   c01084f9 <pci_probe_msi_info>
c0108492:	83 c4 10             	add    $0x10,%esp

    llist_append(&pci_devices, &device->dev_chain);
c0108495:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0108498:	83 ec 08             	sub    $0x8,%esp
c010849b:	50                   	push   %eax
c010849c:	68 00 b5 d0 c0       	push   $0xc0d0b500
c01084a1:	e8 84 fe ff ff       	call   c010832a <llist_append>
c01084a6:	83 c4 10             	add    $0x10,%esp
c01084a9:	eb 04                	jmp    c01084af <pci_probe_device+0x16a>
        return;
c01084ab:	90                   	nop
c01084ac:	eb 01                	jmp    c01084af <pci_probe_device+0x16a>
        return;
c01084ae:	90                   	nop
}
c01084af:	8d 65 f8             	lea    -0x8(%ebp),%esp
c01084b2:	5b                   	pop    %ebx
c01084b3:	5e                   	pop    %esi
c01084b4:	5d                   	pop    %ebp
c01084b5:	c3                   	ret    

c01084b6 <pci_probe>:

void pci_probe()
{
c01084b6:	55                   	push   %ebp
c01084b7:	89 e5                	mov    %esp,%ebp
c01084b9:	83 ec 18             	sub    $0x18,%esp
    // 暴力扫描所有PCI设备
    // XXX: 尽管最多会有256条PCI总线，但就目前而言，只考虑bus #0就足够了
    for (int bus = 0; bus < 1; bus++) {
c01084bc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c01084c3:	eb 2a                	jmp    c01084ef <pci_probe+0x39>
        for (int dev = 0; dev < 32; dev++) {
c01084c5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c01084cc:	eb 17                	jmp    c01084e5 <pci_probe+0x2f>
            pci_probe_device(bus, dev, 0);
c01084ce:	83 ec 04             	sub    $0x4,%esp
c01084d1:	6a 00                	push   $0x0
c01084d3:	ff 75 f0             	push   -0x10(%ebp)
c01084d6:	ff 75 f4             	push   -0xc(%ebp)
c01084d9:	e8 67 fe ff ff       	call   c0108345 <pci_probe_device>
c01084de:	83 c4 10             	add    $0x10,%esp
        for (int dev = 0; dev < 32; dev++) {
c01084e1:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c01084e5:	83 7d f0 1f          	cmpl   $0x1f,-0x10(%ebp)
c01084e9:	7e e3                	jle    c01084ce <pci_probe+0x18>
    for (int bus = 0; bus < 1; bus++) {
c01084eb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c01084ef:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c01084f3:	7e d0                	jle    c01084c5 <pci_probe+0xf>
        }
    }
}
c01084f5:	90                   	nop
c01084f6:	90                   	nop
c01084f7:	c9                   	leave  
c01084f8:	c3                   	ret    

c01084f9 <pci_probe_msi_info>:

void pci_probe_msi_info(struct pci_device* device)
{
c01084f9:	55                   	push   %ebp
c01084fa:	89 e5                	mov    %esp,%ebp
c01084fc:	83 ec 18             	sub    $0x18,%esp
    // Note that Virtualbox have to use ICH9 chipset for MSI support.
    // Qemu seems ok with default PIIX3, Bochs is pending to test...
    //    See https://www.virtualbox.org/manual/ch03.html (section 3.5.1)
    pci_reg_t status =
      pci_read_cspace(device->cspace_base, PCI_REG_STATUS_CMD) >> 16;
c01084ff:	8b 45 08             	mov    0x8(%ebp),%eax
c0108502:	8b 40 10             	mov    0x10(%eax),%eax
c0108505:	83 ec 08             	sub    $0x8,%esp
c0108508:	6a 04                	push   $0x4
c010850a:	50                   	push   %eax
c010850b:	e8 32 04 00 00       	call   c0108942 <pci_read_cspace>
c0108510:	83 c4 10             	add    $0x10,%esp
    pci_reg_t status =
c0108513:	c1 e8 10             	shr    $0x10,%eax
c0108516:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if (!(status & 0x10)) {
c0108519:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010851c:	83 e0 10             	and    $0x10,%eax
c010851f:	85 c0                	test   %eax,%eax
c0108521:	75 0c                	jne    c010852f <pci_probe_msi_info+0x36>
        device->msi_loc = 0;
c0108523:	8b 45 08             	mov    0x8(%ebp),%eax
c0108526:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
        return;
c010852d:	eb 61                	jmp    c0108590 <pci_probe_msi_info+0x97>
    }

    pci_reg_t cap_ptr = pci_read_cspace(device->cspace_base, 0x34) & 0xff;
c010852f:	8b 45 08             	mov    0x8(%ebp),%eax
c0108532:	8b 40 10             	mov    0x10(%eax),%eax
c0108535:	83 ec 08             	sub    $0x8,%esp
c0108538:	6a 34                	push   $0x34
c010853a:	50                   	push   %eax
c010853b:	e8 02 04 00 00       	call   c0108942 <pci_read_cspace>
c0108540:	83 c4 10             	add    $0x10,%esp
c0108543:	25 ff 00 00 00       	and    $0xff,%eax
c0108548:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t cap_hdr;

    while (cap_ptr) {
c010854b:	eb 3d                	jmp    c010858a <pci_probe_msi_info+0x91>
        cap_hdr = pci_read_cspace(device->cspace_base, cap_ptr);
c010854d:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0108550:	8b 45 08             	mov    0x8(%ebp),%eax
c0108553:	8b 40 10             	mov    0x10(%eax),%eax
c0108556:	83 ec 08             	sub    $0x8,%esp
c0108559:	52                   	push   %edx
c010855a:	50                   	push   %eax
c010855b:	e8 e2 03 00 00       	call   c0108942 <pci_read_cspace>
c0108560:	83 c4 10             	add    $0x10,%esp
c0108563:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if ((cap_hdr & 0xff) == 0x5) {
c0108566:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0108569:	0f b6 c0             	movzbl %al,%eax
c010856c:	83 f8 05             	cmp    $0x5,%eax
c010856f:	75 0b                	jne    c010857c <pci_probe_msi_info+0x83>
            // MSI
            device->msi_loc = cap_ptr;
c0108571:	8b 45 08             	mov    0x8(%ebp),%eax
c0108574:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0108577:	89 50 14             	mov    %edx,0x14(%eax)
            return;
c010857a:	eb 14                	jmp    c0108590 <pci_probe_msi_info+0x97>
        }
        cap_ptr = (cap_hdr >> 8) & 0xff;
c010857c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010857f:	c1 e8 08             	shr    $0x8,%eax
c0108582:	25 ff 00 00 00       	and    $0xff,%eax
c0108587:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while (cap_ptr) {
c010858a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c010858e:	75 bd                	jne    c010854d <pci_probe_msi_info+0x54>
    }
}
c0108590:	c9                   	leave  
c0108591:	c3                   	ret    

c0108592 <pci_print_device>:

#define PCI_PRINT_BAR_LISTING

void pci_print_device()
{
c0108592:	55                   	push   %ebp
c0108593:	89 e5                	mov    %esp,%ebp
c0108595:	57                   	push   %edi
c0108596:	56                   	push   %esi
c0108597:	53                   	push   %ebx
c0108598:	83 ec 2c             	sub    $0x2c,%esp
    struct pci_device *pos, *n;
    llist_for_each(pos, n, &pci_devices, dev_chain)
c010859b:	a1 04 b5 d0 c0       	mov    0xc0d0b504,%eax
c01085a0:	89 45 d8             	mov    %eax,-0x28(%ebp)
c01085a3:	8b 45 d8             	mov    -0x28(%ebp),%eax
c01085a6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c01085a9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01085ac:	8b 40 04             	mov    0x4(%eax),%eax
c01085af:	89 45 d4             	mov    %eax,-0x2c(%ebp)
c01085b2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c01085b5:	89 45 e0             	mov    %eax,-0x20(%ebp)
c01085b8:	e9 35 01 00 00       	jmp    c01086f2 <pci_print_device+0x160>
                PCI_BUS_NUM(pos->cspace_base),
                PCI_SLOT_NUM(pos->cspace_base),
                PCI_FUNCT_NUM(pos->cspace_base),
                PCI_DEV_VENDOR(pos->device_info),
                PCI_DEV_DEVID(pos->device_info),
                PCI_DEV_CLASS(pos->class_info));
c01085bd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01085c0:	8b 40 0c             	mov    0xc(%eax),%eax
        kprintf("(B%xh:D%xh:F%xh) Dev %x:%x, Class 0x%x\n",
c01085c3:	c1 e8 08             	shr    $0x8,%eax
c01085c6:	89 c7                	mov    %eax,%edi
                PCI_DEV_DEVID(pos->device_info),
c01085c8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01085cb:	8b 40 08             	mov    0x8(%eax),%eax
        kprintf("(B%xh:D%xh:F%xh) Dev %x:%x, Class 0x%x\n",
c01085ce:	c1 e8 10             	shr    $0x10,%eax
c01085d1:	89 c6                	mov    %eax,%esi
                PCI_DEV_VENDOR(pos->device_info),
c01085d3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01085d6:	8b 40 08             	mov    0x8(%eax),%eax
        kprintf("(B%xh:D%xh:F%xh) Dev %x:%x, Class 0x%x\n",
c01085d9:	0f b7 d0             	movzwl %ax,%edx
                PCI_FUNCT_NUM(pos->cspace_base),
c01085dc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01085df:	8b 40 10             	mov    0x10(%eax),%eax
c01085e2:	c1 e8 08             	shr    $0x8,%eax
        kprintf("(B%xh:D%xh:F%xh) Dev %x:%x, Class 0x%x\n",
c01085e5:	83 e0 07             	and    $0x7,%eax
c01085e8:	89 c3                	mov    %eax,%ebx
                PCI_SLOT_NUM(pos->cspace_base),
c01085ea:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01085ed:	8b 40 10             	mov    0x10(%eax),%eax
c01085f0:	c1 e8 0b             	shr    $0xb,%eax
        kprintf("(B%xh:D%xh:F%xh) Dev %x:%x, Class 0x%x\n",
c01085f3:	83 e0 1f             	and    $0x1f,%eax
c01085f6:	89 c1                	mov    %eax,%ecx
                PCI_BUS_NUM(pos->cspace_base),
c01085f8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01085fb:	8b 40 10             	mov    0x10(%eax),%eax
c01085fe:	c1 e8 10             	shr    $0x10,%eax
        kprintf("(B%xh:D%xh:F%xh) Dev %x:%x, Class 0x%x\n",
c0108601:	0f b6 c0             	movzbl %al,%eax
c0108604:	83 ec 04             	sub    $0x4,%esp
c0108607:	57                   	push   %edi
c0108608:	56                   	push   %esi
c0108609:	52                   	push   %edx
c010860a:	53                   	push   %ebx
c010860b:	51                   	push   %ecx
c010860c:	50                   	push   %eax
c010860d:	68 94 e5 d0 c0       	push   $0xc0d0e594
c0108612:	e8 6a 26 00 00       	call   c010ac81 <kprintf>
c0108617:	83 c4 20             	add    $0x20,%esp

        kprintf("\t IRQ: %d, INT#x: %d\n",
                PCI_INTR_IRQ(pos->intr_info),
                PCI_INTR_PIN(pos->intr_info));
c010861a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010861d:	0f b7 40 18          	movzwl 0x18(%eax),%eax
c0108621:	66 c1 e8 08          	shr    $0x8,%ax
        kprintf("\t IRQ: %d, INT#x: %d\n",
c0108625:	0f b7 d0             	movzwl %ax,%edx
                PCI_INTR_IRQ(pos->intr_info),
c0108628:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010862b:	0f b7 40 18          	movzwl 0x18(%eax),%eax
        kprintf("\t IRQ: %d, INT#x: %d\n",
c010862f:	0f b7 c0             	movzwl %ax,%eax
c0108632:	0f b6 c0             	movzbl %al,%eax
c0108635:	83 ec 04             	sub    $0x4,%esp
c0108638:	52                   	push   %edx
c0108639:	50                   	push   %eax
c010863a:	68 bc e5 d0 c0       	push   $0xc0d0e5bc
c010863f:	e8 3d 26 00 00       	call   c010ac81 <kprintf>
c0108644:	83 c4 10             	add    $0x10,%esp
#ifdef PCI_PRINT_BAR_LISTING
        pci_reg_t bar;
        for (size_t i = 1; i <= 6; i++) {
c0108647:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
c010864e:	eb 66                	jmp    c01086b6 <pci_print_device+0x124>
            size_t size = pci_bar_sizing(pos, &bar, i);
c0108650:	83 ec 04             	sub    $0x4,%esp
c0108653:	ff 75 dc             	push   -0x24(%ebp)
c0108656:	8d 45 c8             	lea    -0x38(%ebp),%eax
c0108659:	50                   	push   %eax
c010865a:	ff 75 e4             	push   -0x1c(%ebp)
c010865d:	e8 a8 00 00 00       	call   c010870a <pci_bar_sizing>
c0108662:	83 c4 10             	add    $0x10,%esp
c0108665:	89 45 cc             	mov    %eax,-0x34(%ebp)
            if (!bar)
c0108668:	8b 45 c8             	mov    -0x38(%ebp),%eax
c010866b:	85 c0                	test   %eax,%eax
c010866d:	74 42                	je     c01086b1 <pci_print_device+0x11f>
                continue;
            if (PCI_BAR_MMIO(bar)) {
c010866f:	8b 45 c8             	mov    -0x38(%ebp),%eax
c0108672:	83 e0 01             	and    $0x1,%eax
c0108675:	85 c0                	test   %eax,%eax
c0108677:	75 1c                	jne    c0108695 <pci_print_device+0x103>
                kprintf("\t BAR#%d (MMIO) %p [%d]\n",
c0108679:	8b 45 c8             	mov    -0x38(%ebp),%eax
c010867c:	83 e0 f0             	and    $0xfffffff0,%eax
c010867f:	ff 75 cc             	push   -0x34(%ebp)
c0108682:	50                   	push   %eax
c0108683:	ff 75 dc             	push   -0x24(%ebp)
c0108686:	68 d2 e5 d0 c0       	push   $0xc0d0e5d2
c010868b:	e8 f1 25 00 00       	call   c010ac81 <kprintf>
c0108690:	83 c4 10             	add    $0x10,%esp
c0108693:	eb 1d                	jmp    c01086b2 <pci_print_device+0x120>
                        i,
                        PCI_BAR_ADDR_MM(bar),
                        size);
            } else {
                kprintf("\t BAR#%d (I/O) %p [%d]\n",
c0108695:	8b 45 c8             	mov    -0x38(%ebp),%eax
c0108698:	83 e0 fc             	and    $0xfffffffc,%eax
c010869b:	ff 75 cc             	push   -0x34(%ebp)
c010869e:	50                   	push   %eax
c010869f:	ff 75 dc             	push   -0x24(%ebp)
c01086a2:	68 eb e5 d0 c0       	push   $0xc0d0e5eb
c01086a7:	e8 d5 25 00 00       	call   c010ac81 <kprintf>
c01086ac:	83 c4 10             	add    $0x10,%esp
c01086af:	eb 01                	jmp    c01086b2 <pci_print_device+0x120>
                continue;
c01086b1:	90                   	nop
        for (size_t i = 1; i <= 6; i++) {
c01086b2:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
c01086b6:	83 7d dc 06          	cmpl   $0x6,-0x24(%ebp)
c01086ba:	76 94                	jbe    c0108650 <pci_print_device+0xbe>
                        PCI_BAR_ADDR_IO(bar),
                        size);
            }
        }
#endif
        if (pos->msi_loc) {
c01086bc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01086bf:	8b 40 14             	mov    0x14(%eax),%eax
c01086c2:	85 c0                	test   %eax,%eax
c01086c4:	74 17                	je     c01086dd <pci_print_device+0x14b>
            kprintf("\t MSI supported (@%xh)\n", pos->msi_loc);
c01086c6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01086c9:	8b 40 14             	mov    0x14(%eax),%eax
c01086cc:	83 ec 08             	sub    $0x8,%esp
c01086cf:	50                   	push   %eax
c01086d0:	68 03 e6 d0 c0       	push   $0xc0d0e603
c01086d5:	e8 a7 25 00 00       	call   c010ac81 <kprintf>
c01086da:	83 c4 10             	add    $0x10,%esp
    llist_for_each(pos, n, &pci_devices, dev_chain)
c01086dd:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01086e0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c01086e3:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01086e6:	8b 40 04             	mov    0x4(%eax),%eax
c01086e9:	89 45 d0             	mov    %eax,-0x30(%ebp)
c01086ec:	8b 45 d0             	mov    -0x30(%ebp),%eax
c01086ef:	89 45 e0             	mov    %eax,-0x20(%ebp)
c01086f2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01086f5:	3d 00 b5 d0 c0       	cmp    $0xc0d0b500,%eax
c01086fa:	0f 85 bd fe ff ff    	jne    c01085bd <pci_print_device+0x2b>
        }
    }
}
c0108700:	90                   	nop
c0108701:	90                   	nop
c0108702:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0108705:	5b                   	pop    %ebx
c0108706:	5e                   	pop    %esi
c0108707:	5f                   	pop    %edi
c0108708:	5d                   	pop    %ebp
c0108709:	c3                   	ret    

c010870a <pci_bar_sizing>:

size_t pci_bar_sizing(struct pci_device* dev, uint32_t* bar_out, uint32_t bar_num)
{
c010870a:	55                   	push   %ebp
c010870b:	89 e5                	mov    %esp,%ebp
c010870d:	83 ec 18             	sub    $0x18,%esp
    pci_reg_t bar = pci_read_cspace(dev->cspace_base, PCI_REG_BAR(bar_num));
c0108710:	8b 45 10             	mov    0x10(%ebp),%eax
c0108713:	83 c0 03             	add    $0x3,%eax
c0108716:	c1 e0 02             	shl    $0x2,%eax
c0108719:	89 c2                	mov    %eax,%edx
c010871b:	8b 45 08             	mov    0x8(%ebp),%eax
c010871e:	8b 40 10             	mov    0x10(%eax),%eax
c0108721:	83 ec 08             	sub    $0x8,%esp
c0108724:	52                   	push   %edx
c0108725:	50                   	push   %eax
c0108726:	e8 17 02 00 00       	call   c0108942 <pci_read_cspace>
c010872b:	83 c4 10             	add    $0x10,%esp
c010872e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (!bar) {
c0108731:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0108735:	75 10                	jne    c0108747 <pci_bar_sizing+0x3d>
        *bar_out = 0;
c0108737:	8b 45 0c             	mov    0xc(%ebp),%eax
c010873a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        return 0;
c0108740:	b8 00 00 00 00       	mov    $0x0,%eax
c0108745:	eb 5f                	jmp    c01087a6 <pci_bar_sizing+0x9c>
    }

    pci_write_cspace(dev->cspace_base, PCI_REG_BAR(bar_num), 0xffffffff);
c0108747:	8b 45 10             	mov    0x10(%ebp),%eax
c010874a:	83 c0 03             	add    $0x3,%eax
c010874d:	c1 e0 02             	shl    $0x2,%eax
c0108750:	89 c2                	mov    %eax,%edx
c0108752:	8b 45 08             	mov    0x8(%ebp),%eax
c0108755:	8b 40 10             	mov    0x10(%eax),%eax
c0108758:	83 ec 04             	sub    $0x4,%esp
c010875b:	6a ff                	push   $0xffffffff
c010875d:	52                   	push   %edx
c010875e:	50                   	push   %eax
c010875f:	e8 07 02 00 00       	call   c010896b <pci_write_cspace>
c0108764:	83 c4 10             	add    $0x10,%esp
    pci_reg_t sized =
      pci_read_cspace(dev->cspace_base, PCI_REG_BAR(bar_num)) & ~0x1;
c0108767:	8b 45 10             	mov    0x10(%ebp),%eax
c010876a:	83 c0 03             	add    $0x3,%eax
c010876d:	c1 e0 02             	shl    $0x2,%eax
c0108770:	89 c2                	mov    %eax,%edx
c0108772:	8b 45 08             	mov    0x8(%ebp),%eax
c0108775:	8b 40 10             	mov    0x10(%eax),%eax
c0108778:	83 ec 08             	sub    $0x8,%esp
c010877b:	52                   	push   %edx
c010877c:	50                   	push   %eax
c010877d:	e8 c0 01 00 00       	call   c0108942 <pci_read_cspace>
c0108782:	83 c4 10             	add    $0x10,%esp
    pci_reg_t sized =
c0108785:	83 e0 fe             	and    $0xfffffffe,%eax
c0108788:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (PCI_BAR_MMIO(bar)) {
c010878b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010878e:	83 e0 01             	and    $0x1,%eax
c0108791:	85 c0                	test   %eax,%eax
c0108793:	75 04                	jne    c0108799 <pci_bar_sizing+0x8f>
        sized = PCI_BAR_ADDR_MM(sized);
c0108795:	83 65 f4 f0          	andl   $0xfffffff0,-0xc(%ebp)
    }
    *bar_out = bar;
c0108799:	8b 45 0c             	mov    0xc(%ebp),%eax
c010879c:	8b 55 f0             	mov    -0x10(%ebp),%edx
c010879f:	89 10                	mov    %edx,(%eax)
    return ~sized + 1;
c01087a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01087a4:	f7 d8                	neg    %eax
}
c01087a6:	c9                   	leave  
c01087a7:	c3                   	ret    

c01087a8 <pci_setup_msi>:

void pci_setup_msi(struct pci_device* device, int vector)
{
c01087a8:	55                   	push   %ebp
c01087a9:	89 e5                	mov    %esp,%ebp
c01087ab:	83 ec 18             	sub    $0x18,%esp
    // Dest: APIC#0, Physical Destination, No redirection
    uint32_t msi_addr = (__APIC_BASE_PADDR | 0x8);
c01087ae:	c7 45 f4 08 00 e0 fe 	movl   $0xfee00008,-0xc(%ebp)

    // Edge trigger, Fixed delivery
    uint32_t msi_data = vector;
c01087b5:	8b 45 0c             	mov    0xc(%ebp),%eax
c01087b8:	89 45 f0             	mov    %eax,-0x10(%ebp)

    pci_write_cspace(
      device->cspace_base, PCI_MSI_ADDR(device->msi_loc), msi_addr);
c01087bb:	8b 45 08             	mov    0x8(%ebp),%eax
c01087be:	8b 40 14             	mov    0x14(%eax),%eax
c01087c1:	83 c0 04             	add    $0x4,%eax
    pci_write_cspace(
c01087c4:	89 c2                	mov    %eax,%edx
c01087c6:	8b 45 08             	mov    0x8(%ebp),%eax
c01087c9:	8b 40 10             	mov    0x10(%eax),%eax
c01087cc:	83 ec 04             	sub    $0x4,%esp
c01087cf:	ff 75 f4             	push   -0xc(%ebp)
c01087d2:	52                   	push   %edx
c01087d3:	50                   	push   %eax
c01087d4:	e8 92 01 00 00       	call   c010896b <pci_write_cspace>
c01087d9:	83 c4 10             	add    $0x10,%esp
    pci_write_cspace(
c01087dc:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01087df:	0f b7 d0             	movzwl %ax,%edx
      device->cspace_base, PCI_MSI_DATA(device->msi_loc), msi_data & 0xffff);
c01087e2:	8b 45 08             	mov    0x8(%ebp),%eax
c01087e5:	8b 40 14             	mov    0x14(%eax),%eax
c01087e8:	83 c0 08             	add    $0x8,%eax
    pci_write_cspace(
c01087eb:	89 c1                	mov    %eax,%ecx
c01087ed:	8b 45 08             	mov    0x8(%ebp),%eax
c01087f0:	8b 40 10             	mov    0x10(%eax),%eax
c01087f3:	83 ec 04             	sub    $0x4,%esp
c01087f6:	52                   	push   %edx
c01087f7:	51                   	push   %ecx
c01087f8:	50                   	push   %eax
c01087f9:	e8 6d 01 00 00       	call   c010896b <pci_write_cspace>
c01087fe:	83 c4 10             	add    $0x10,%esp

    pci_reg_t reg1 = pci_read_cspace(device->cspace_base, device->msi_loc);
c0108801:	8b 45 08             	mov    0x8(%ebp),%eax
c0108804:	8b 40 14             	mov    0x14(%eax),%eax
c0108807:	89 c2                	mov    %eax,%edx
c0108809:	8b 45 08             	mov    0x8(%ebp),%eax
c010880c:	8b 40 10             	mov    0x10(%eax),%eax
c010880f:	83 ec 08             	sub    $0x8,%esp
c0108812:	52                   	push   %edx
c0108813:	50                   	push   %eax
c0108814:	e8 29 01 00 00       	call   c0108942 <pci_read_cspace>
c0108819:	83 c4 10             	add    $0x10,%esp
c010881c:	89 45 ec             	mov    %eax,-0x14(%ebp)

    // manipulate the MSI_CTRL to allow device using MSI to request service.
    reg1 = ((((reg1 >> 16) & ~0x70) | 0x1) << 16) | (reg1 & 0xffff);
c010881f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0108822:	25 ff ff 8e ff       	and    $0xff8effff,%eax
c0108827:	0d 00 00 01 00       	or     $0x10000,%eax
c010882c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    pci_write_cspace(device->cspace_base, device->msi_loc, reg1);
c010882f:	8b 45 08             	mov    0x8(%ebp),%eax
c0108832:	8b 40 14             	mov    0x14(%eax),%eax
c0108835:	89 c2                	mov    %eax,%edx
c0108837:	8b 45 08             	mov    0x8(%ebp),%eax
c010883a:	8b 40 10             	mov    0x10(%eax),%eax
c010883d:	83 ec 04             	sub    $0x4,%esp
c0108840:	ff 75 ec             	push   -0x14(%ebp)
c0108843:	52                   	push   %edx
c0108844:	50                   	push   %eax
c0108845:	e8 21 01 00 00       	call   c010896b <pci_write_cspace>
c010884a:	83 c4 10             	add    $0x10,%esp
}
c010884d:	90                   	nop
c010884e:	c9                   	leave  
c010884f:	c3                   	ret    

c0108850 <pci_get_device_by_id>:

struct pci_device* pci_get_device_by_id(uint16_t vendorId, uint16_t deviceId)
{
c0108850:	55                   	push   %ebp
c0108851:	89 e5                	mov    %esp,%ebp
c0108853:	83 ec 28             	sub    $0x28,%esp
c0108856:	8b 55 08             	mov    0x8(%ebp),%edx
c0108859:	8b 45 0c             	mov    0xc(%ebp),%eax
c010885c:	66 89 55 dc          	mov    %dx,-0x24(%ebp)
c0108860:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
    uint32_t dev_info = vendorId | (deviceId << 16);
c0108864:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
c0108868:	0f b7 45 d8          	movzwl -0x28(%ebp),%eax
c010886c:	c1 e0 10             	shl    $0x10,%eax
c010886f:	09 d0                	or     %edx,%eax
c0108871:	89 45 f4             	mov    %eax,-0xc(%ebp)
    struct pci_device *pos, *n;
    llist_for_each(pos, n, &pci_devices, dev_chain)
c0108874:	a1 04 b5 d0 c0       	mov    0xc0d0b504,%eax
c0108879:	89 45 f0             	mov    %eax,-0x10(%ebp)
c010887c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010887f:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0108882:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0108885:	8b 40 04             	mov    0x4(%eax),%eax
c0108888:	89 45 ec             	mov    %eax,-0x14(%ebp)
c010888b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010888e:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0108891:	eb 25                	jmp    c01088b8 <pci_get_device_by_id+0x68>
    {
        if (pos->device_info == dev_info) {
c0108893:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0108896:	8b 40 08             	mov    0x8(%eax),%eax
c0108899:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c010889c:	75 05                	jne    c01088a3 <pci_get_device_by_id+0x53>
            return pos;
c010889e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01088a1:	eb 24                	jmp    c01088c7 <pci_get_device_by_id+0x77>
    llist_for_each(pos, n, &pci_devices, dev_chain)
c01088a3:	8b 45 f8             	mov    -0x8(%ebp),%eax
c01088a6:	89 45 fc             	mov    %eax,-0x4(%ebp)
c01088a9:	8b 45 f8             	mov    -0x8(%ebp),%eax
c01088ac:	8b 40 04             	mov    0x4(%eax),%eax
c01088af:	89 45 e8             	mov    %eax,-0x18(%ebp)
c01088b2:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01088b5:	89 45 f8             	mov    %eax,-0x8(%ebp)
c01088b8:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01088bb:	3d 00 b5 d0 c0       	cmp    $0xc0d0b500,%eax
c01088c0:	75 d1                	jne    c0108893 <pci_get_device_by_id+0x43>
        }
    }

    return NULL;
c01088c2:	b8 00 00 00 00       	mov    $0x0,%eax
}
c01088c7:	c9                   	leave  
c01088c8:	c3                   	ret    

c01088c9 <pci_get_device_by_class>:

struct pci_device* pci_get_device_by_class(uint32_t mclass)
{
c01088c9:	55                   	push   %ebp
c01088ca:	89 e5                	mov    %esp,%ebp
c01088cc:	83 ec 20             	sub    $0x20,%esp
    struct pci_device *pos, *n;
    llist_for_each(pos, n, &pci_devices, dev_chain)
c01088cf:	a1 04 b5 d0 c0       	mov    0xc0d0b504,%eax
c01088d4:	89 45 f4             	mov    %eax,-0xc(%ebp)
c01088d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01088da:	89 45 fc             	mov    %eax,-0x4(%ebp)
c01088dd:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01088e0:	8b 40 04             	mov    0x4(%eax),%eax
c01088e3:	89 45 f0             	mov    %eax,-0x10(%ebp)
c01088e6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01088e9:	89 45 f8             	mov    %eax,-0x8(%ebp)
c01088ec:	eb 28                	jmp    c0108916 <pci_get_device_by_class+0x4d>
    {
        if (PCI_DEV_CLASS(pos->class_info) == mclass) {
c01088ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01088f1:	8b 40 0c             	mov    0xc(%eax),%eax
c01088f4:	c1 e8 08             	shr    $0x8,%eax
c01088f7:	39 45 08             	cmp    %eax,0x8(%ebp)
c01088fa:	75 05                	jne    c0108901 <pci_get_device_by_class+0x38>
            return pos;
c01088fc:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01088ff:	eb 24                	jmp    c0108925 <pci_get_device_by_class+0x5c>
    llist_for_each(pos, n, &pci_devices, dev_chain)
c0108901:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0108904:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0108907:	8b 45 f8             	mov    -0x8(%ebp),%eax
c010890a:	8b 40 04             	mov    0x4(%eax),%eax
c010890d:	89 45 ec             	mov    %eax,-0x14(%ebp)
c0108910:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0108913:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0108916:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0108919:	3d 00 b5 d0 c0       	cmp    $0xc0d0b500,%eax
c010891e:	75 ce                	jne    c01088ee <pci_get_device_by_class+0x25>
        }
    }

    return NULL;
c0108920:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0108925:	c9                   	leave  
c0108926:	c3                   	ret    

c0108927 <pci_init>:

void pci_init()
{
c0108927:	55                   	push   %ebp
c0108928:	89 e5                	mov    %esp,%ebp
c010892a:	83 ec 08             	sub    $0x8,%esp
    llist_init_head(&pci_devices);
c010892d:	68 00 b5 d0 c0       	push   $0xc0d0b500
c0108932:	e8 dc f9 ff ff       	call   c0108313 <llist_init_head>
c0108937:	83 c4 04             	add    $0x4,%esp
    // Otherwise, fallback to use legacy PCI 3.0 method.
    pci_probe();
c010893a:	e8 77 fb ff ff       	call   c01084b6 <pci_probe>
}
c010893f:	90                   	nop
c0108940:	c9                   	leave  
c0108941:	c3                   	ret    

c0108942 <pci_read_cspace>:

pci_reg_t pci_read_cspace(uint32_t base, int offset)
{
c0108942:	55                   	push   %ebp
c0108943:	89 e5                	mov    %esp,%ebp
    io_outl(PCI_CONFIG_ADDR, base | (offset & ~0x3));
c0108945:	8b 45 0c             	mov    0xc(%ebp),%eax
c0108948:	83 e0 fc             	and    $0xfffffffc,%eax
c010894b:	0b 45 08             	or     0x8(%ebp),%eax
c010894e:	50                   	push   %eax
c010894f:	68 f8 0c 00 00       	push   $0xcf8
c0108954:	e8 85 f9 ff ff       	call   c01082de <io_outl>
c0108959:	83 c4 08             	add    $0x8,%esp
    return io_inl(PCI_CONFIG_DATA);
c010895c:	68 fc 0c 00 00       	push   $0xcfc
c0108961:	e8 64 f9 ff ff       	call   c01082ca <io_inl>
c0108966:	83 c4 04             	add    $0x4,%esp
}
c0108969:	c9                   	leave  
c010896a:	c3                   	ret    

c010896b <pci_write_cspace>:

void pci_write_cspace(uint32_t base, int offset, pci_reg_t data)
{
c010896b:	55                   	push   %ebp
c010896c:	89 e5                	mov    %esp,%ebp
    io_outl(PCI_CONFIG_ADDR, base | (offset & ~0x3));
c010896e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0108971:	83 e0 fc             	and    $0xfffffffc,%eax
c0108974:	0b 45 08             	or     0x8(%ebp),%eax
c0108977:	50                   	push   %eax
c0108978:	68 f8 0c 00 00       	push   $0xcf8
c010897d:	e8 5c f9 ff ff       	call   c01082de <io_outl>
c0108982:	83 c4 08             	add    $0x8,%esp
    io_outl(PCI_CONFIG_DATA, data);
c0108985:	ff 75 10             	push   0x10(%ebp)
c0108988:	68 fc 0c 00 00       	push   $0xcfc
c010898d:	e8 4c f9 ff ff       	call   c01082de <io_outl>
c0108992:	83 c4 08             	add    $0x8,%esp
c0108995:	90                   	nop
c0108996:	c9                   	leave  
c0108997:	c3                   	ret    

c0108998 <__get_cpuid_max>:
   pointer is non-null, then first four bytes of the signature
   (as found in ebx register) are returned in location pointed by sig.  */

static __inline unsigned int
__get_cpuid_max (unsigned int __ext, unsigned int *__sig)
{
c0108998:	55                   	push   %ebp
c0108999:	89 e5                	mov    %esp,%ebp
c010899b:	53                   	push   %ebx
c010899c:	83 ec 10             	sub    $0x10,%esp
  unsigned int __eax, __ebx, __ecx, __edx;

#ifndef __x86_64__
  /* See if we can use cpuid.  On AMD64 we always can.  */
#if __GNUC__ >= 3
  __asm__ ("pushf{l|d}\n\t"
c010899f:	9c                   	pushf  
c01089a0:	9c                   	pushf  
c01089a1:	5a                   	pop    %edx
c01089a2:	89 d0                	mov    %edx,%eax
c01089a4:	81 f2 00 00 20 00    	xor    $0x200000,%edx
c01089aa:	52                   	push   %edx
c01089ab:	9d                   	popf   
c01089ac:	9c                   	pushf  
c01089ad:	5a                   	pop    %edx
c01089ae:	9d                   	popf   
c01089af:	89 55 f8             	mov    %edx,-0x8(%ebp)
c01089b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	   "popfl\n\t"
	   : "=&r" (__eax), "=&r" (__ebx)
	   : "i" (0x00200000));
#endif

  if (!((__eax ^ __ebx) & 0x00200000))
c01089b5:	8b 45 f8             	mov    -0x8(%ebp),%eax
c01089b8:	33 45 f4             	xor    -0xc(%ebp),%eax
c01089bb:	25 00 00 20 00       	and    $0x200000,%eax
c01089c0:	85 c0                	test   %eax,%eax
c01089c2:	75 07                	jne    c01089cb <__get_cpuid_max+0x33>
    return 0;
c01089c4:	b8 00 00 00 00       	mov    $0x0,%eax
c01089c9:	eb 30                	jmp    c01089fb <__get_cpuid_max+0x63>
#endif

  /* Host supports cpuid.  Return highest supported cpuid input value.  */
  __cpuid (__ext, __eax, __ebx, __ecx, __edx);
c01089cb:	8b 45 08             	mov    0x8(%ebp),%eax
c01089ce:	b9 00 00 00 00       	mov    $0x0,%ecx
c01089d3:	ba 00 00 00 00       	mov    $0x0,%edx
c01089d8:	89 cb                	mov    %ecx,%ebx
c01089da:	89 d1                	mov    %edx,%ecx
c01089dc:	0f a2                	cpuid  
c01089de:	89 45 f8             	mov    %eax,-0x8(%ebp)
c01089e1:	89 5d f4             	mov    %ebx,-0xc(%ebp)
c01089e4:	89 4d f0             	mov    %ecx,-0x10(%ebp)
c01089e7:	89 55 ec             	mov    %edx,-0x14(%ebp)

  if (__sig)
c01089ea:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c01089ee:	74 08                	je     c01089f8 <__get_cpuid_max+0x60>
    *__sig = __ebx;
c01089f0:	8b 45 0c             	mov    0xc(%ebp),%eax
c01089f3:	8b 55 f4             	mov    -0xc(%ebp),%edx
c01089f6:	89 10                	mov    %edx,(%eax)

  return __eax;
c01089f8:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
c01089fb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c01089fe:	c9                   	leave  
c01089ff:	c3                   	ret    

c0108a00 <__get_cpuid>:

static __inline int
__get_cpuid (unsigned int __leaf,
	     unsigned int *__eax, unsigned int *__ebx,
	     unsigned int *__ecx, unsigned int *__edx)
{
c0108a00:	55                   	push   %ebp
c0108a01:	89 e5                	mov    %esp,%ebp
c0108a03:	56                   	push   %esi
c0108a04:	53                   	push   %ebx
c0108a05:	83 ec 10             	sub    $0x10,%esp
  unsigned int __ext = __leaf & 0x80000000;
c0108a08:	8b 45 08             	mov    0x8(%ebp),%eax
c0108a0b:	25 00 00 00 80       	and    $0x80000000,%eax
c0108a10:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned int __maxlevel = __get_cpuid_max (__ext, 0);
c0108a13:	6a 00                	push   $0x0
c0108a15:	ff 75 f4             	push   -0xc(%ebp)
c0108a18:	e8 7b ff ff ff       	call   c0108998 <__get_cpuid_max>
c0108a1d:	83 c4 08             	add    $0x8,%esp
c0108a20:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if (__maxlevel == 0 || __maxlevel < __leaf)
c0108a23:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0108a27:	74 08                	je     c0108a31 <__get_cpuid+0x31>
c0108a29:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0108a2c:	3b 45 08             	cmp    0x8(%ebp),%eax
c0108a2f:	73 07                	jae    c0108a38 <__get_cpuid+0x38>
    return 0;
c0108a31:	b8 00 00 00 00       	mov    $0x0,%eax
c0108a36:	eb 2c                	jmp    c0108a64 <__get_cpuid+0x64>

  __cpuid (__leaf, *__eax, *__ebx, *__ecx, *__edx);
c0108a38:	8b 45 08             	mov    0x8(%ebp),%eax
c0108a3b:	b9 00 00 00 00       	mov    $0x0,%ecx
c0108a40:	ba 00 00 00 00       	mov    $0x0,%edx
c0108a45:	89 cb                	mov    %ecx,%ebx
c0108a47:	89 d1                	mov    %edx,%ecx
c0108a49:	0f a2                	cpuid  
c0108a4b:	8b 75 0c             	mov    0xc(%ebp),%esi
c0108a4e:	89 06                	mov    %eax,(%esi)
c0108a50:	8b 45 10             	mov    0x10(%ebp),%eax
c0108a53:	89 18                	mov    %ebx,(%eax)
c0108a55:	8b 45 14             	mov    0x14(%ebp),%eax
c0108a58:	89 08                	mov    %ecx,(%eax)
c0108a5a:	8b 45 18             	mov    0x18(%ebp),%eax
c0108a5d:	89 10                	mov    %edx,(%eax)
  return 1;
c0108a5f:	b8 01 00 00 00       	mov    $0x1,%eax
}
c0108a64:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0108a67:	5b                   	pop    %ebx
c0108a68:	5e                   	pop    %esi
c0108a69:	5d                   	pop    %ebp
c0108a6a:	c3                   	ret    

c0108a6b <cpu_get_model>:
#include <kernel/cpu/cpu.h>
#include <stdint.h>
#include <cpuid.h>

void cpu_get_model(char* model_out) {
c0108a6b:	55                   	push   %ebp
c0108a6c:	89 e5                	mov    %esp,%ebp
c0108a6e:	83 ec 20             	sub    $0x20,%esp
    uint32_t* out = (uint32_t*)model_out;
c0108a71:	8b 45 08             	mov    0x8(%ebp),%eax
c0108a74:	89 45 fc             	mov    %eax,-0x4(%ebp)
    reg32 eax, ebx, edx, ecx;
    
    __get_cpuid(0, &eax, &ebx, &ecx, &edx);
c0108a77:	8d 45 f0             	lea    -0x10(%ebp),%eax
c0108a7a:	50                   	push   %eax
c0108a7b:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0108a7e:	50                   	push   %eax
c0108a7f:	8d 45 f4             	lea    -0xc(%ebp),%eax
c0108a82:	50                   	push   %eax
c0108a83:	8d 45 f8             	lea    -0x8(%ebp),%eax
c0108a86:	50                   	push   %eax
c0108a87:	6a 00                	push   $0x0
c0108a89:	e8 72 ff ff ff       	call   c0108a00 <__get_cpuid>
c0108a8e:	83 c4 14             	add    $0x14,%esp

    out[0] = ebx;
c0108a91:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0108a94:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0108a97:	89 10                	mov    %edx,(%eax)
    out[1] = edx;
c0108a99:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0108a9c:	8d 50 04             	lea    0x4(%eax),%edx
c0108a9f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0108aa2:	89 02                	mov    %eax,(%edx)
    out[2] = ecx;
c0108aa4:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0108aa7:	8d 50 08             	lea    0x8(%eax),%edx
c0108aaa:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0108aad:	89 02                	mov    %eax,(%edx)
    model_out[12] = '\0';
c0108aaf:	8b 45 08             	mov    0x8(%ebp),%eax
c0108ab2:	83 c0 0c             	add    $0xc,%eax
c0108ab5:	c6 00 00             	movb   $0x0,(%eax)
}
c0108ab8:	90                   	nop
c0108ab9:	c9                   	leave  
c0108aba:	c3                   	ret    

c0108abb <cpu_brand_string_supported>:

#define BRAND_LEAF 0x80000000UL

int cpu_brand_string_supported() {
c0108abb:	55                   	push   %ebp
c0108abc:	89 e5                	mov    %esp,%ebp
c0108abe:	83 ec 10             	sub    $0x10,%esp
    reg32 supported = __get_cpuid_max(BRAND_LEAF, 0);
c0108ac1:	6a 00                	push   $0x0
c0108ac3:	68 00 00 00 80       	push   $0x80000000
c0108ac8:	e8 cb fe ff ff       	call   c0108998 <__get_cpuid_max>
c0108acd:	83 c4 08             	add    $0x8,%esp
c0108ad0:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return (supported >= 0x80000004UL);
c0108ad3:	81 7d fc 03 00 00 80 	cmpl   $0x80000003,-0x4(%ebp)
c0108ada:	0f 97 c0             	seta   %al
c0108add:	0f b6 c0             	movzbl %al,%eax
}
c0108ae0:	c9                   	leave  
c0108ae1:	c3                   	ret    

c0108ae2 <cpu_get_brand>:

void cpu_get_brand(char* brand_out) {
c0108ae2:	55                   	push   %ebp
c0108ae3:	89 e5                	mov    %esp,%ebp
c0108ae5:	83 ec 20             	sub    $0x20,%esp
    if(!cpu_brand_string_supported()) {
c0108ae8:	e8 ce ff ff ff       	call   c0108abb <cpu_brand_string_supported>
c0108aed:	85 c0                	test   %eax,%eax
c0108aef:	75 0f                	jne    c0108b00 <cpu_get_brand+0x1e>
        brand_out[0] = '?';
c0108af1:	8b 45 08             	mov    0x8(%ebp),%eax
c0108af4:	c6 00 3f             	movb   $0x3f,(%eax)
        brand_out[1] = '\0';
c0108af7:	8b 45 08             	mov    0x8(%ebp),%eax
c0108afa:	83 c0 01             	add    $0x1,%eax
c0108afd:	c6 00 00             	movb   $0x0,(%eax)
    }
    uint32_t* out = (uint32_t*) brand_out;
c0108b00:	8b 45 08             	mov    0x8(%ebp),%eax
c0108b03:	89 45 f4             	mov    %eax,-0xc(%ebp)
    reg32 eax, ebx, edx, ecx;
    for (uint32_t i = 2, j = 0; i < 5; i++)
c0108b06:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
c0108b0d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c0108b14:	e9 83 00 00 00       	jmp    c0108b9c <cpu_get_brand+0xba>
    {
        __get_cpuid(BRAND_LEAF + i, &eax, &ebx, &ecx, &edx);
c0108b19:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0108b1c:	8d 90 00 00 00 80    	lea    -0x80000000(%eax),%edx
c0108b22:	8d 45 e8             	lea    -0x18(%ebp),%eax
c0108b25:	50                   	push   %eax
c0108b26:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0108b29:	50                   	push   %eax
c0108b2a:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0108b2d:	50                   	push   %eax
c0108b2e:	8d 45 f0             	lea    -0x10(%ebp),%eax
c0108b31:	50                   	push   %eax
c0108b32:	52                   	push   %edx
c0108b33:	e8 c8 fe ff ff       	call   c0108a00 <__get_cpuid>
c0108b38:	83 c4 14             	add    $0x14,%esp
        out[j] = eax;
c0108b3b:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0108b3e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0108b45:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108b48:	01 c2                	add    %eax,%edx
c0108b4a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0108b4d:	89 02                	mov    %eax,(%edx)
        out[j + 1] = ebx;
c0108b4f:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0108b52:	83 c0 01             	add    $0x1,%eax
c0108b55:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0108b5c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108b5f:	01 c2                	add    %eax,%edx
c0108b61:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0108b64:	89 02                	mov    %eax,(%edx)
        out[j + 2] = ecx;
c0108b66:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0108b69:	83 c0 02             	add    $0x2,%eax
c0108b6c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0108b73:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108b76:	01 c2                	add    %eax,%edx
c0108b78:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0108b7b:	89 02                	mov    %eax,(%edx)
        out[j + 3] = edx;
c0108b7d:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0108b80:	83 c0 03             	add    $0x3,%eax
c0108b83:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0108b8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108b8d:	01 c2                	add    %eax,%edx
c0108b8f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0108b92:	89 02                	mov    %eax,(%edx)
        j+=4;
c0108b94:	83 45 f8 04          	addl   $0x4,-0x8(%ebp)
    for (uint32_t i = 2, j = 0; i < 5; i++)
c0108b98:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0108b9c:	83 7d fc 04          	cmpl   $0x4,-0x4(%ebp)
c0108ba0:	0f 86 73 ff ff ff    	jbe    c0108b19 <cpu_get_brand+0x37>
    }
    brand_out[48] = '\0';
c0108ba6:	8b 45 08             	mov    0x8(%ebp),%eax
c0108ba9:	83 c0 30             	add    $0x30,%eax
c0108bac:	c6 00 00             	movb   $0x0,(%eax)
}
c0108baf:	90                   	nop
c0108bb0:	c9                   	leave  
c0108bb1:	c3                   	ret    

c0108bb2 <cpu_r_cr0>:

reg32 cpu_r_cr0() {
c0108bb2:	55                   	push   %ebp
c0108bb3:	89 e5                	mov    %esp,%ebp
    asm volatile ("mov %cr0, %eax");
c0108bb5:	0f 20 c0             	mov    %cr0,%eax
}
c0108bb8:	90                   	nop
c0108bb9:	5d                   	pop    %ebp
c0108bba:	c3                   	ret    

c0108bbb <cpu_r_cr2>:

reg32 cpu_r_cr2() {
c0108bbb:	55                   	push   %ebp
c0108bbc:	89 e5                	mov    %esp,%ebp
    asm volatile ("mov %cr2, %eax");
c0108bbe:	0f 20 d0             	mov    %cr2,%eax
}
c0108bc1:	90                   	nop
c0108bc2:	5d                   	pop    %ebp
c0108bc3:	c3                   	ret    

c0108bc4 <cpu_r_cr3>:

reg32 cpu_r_cr3() {
c0108bc4:	55                   	push   %ebp
c0108bc5:	89 e5                	mov    %esp,%ebp
    asm volatile ("mov %cr3, %eax");
c0108bc7:	0f 20 d8             	mov    %cr3,%eax
}
c0108bca:	90                   	nop
c0108bcb:	5d                   	pop    %ebp
c0108bcc:	c3                   	ret    

c0108bcd <cpu_w_cr0>:

void cpu_w_cr0(reg32 v) {
c0108bcd:	55                   	push   %ebp
c0108bce:	89 e5                	mov    %esp,%ebp
    asm volatile (
c0108bd0:	8b 45 08             	mov    0x8(%ebp),%eax
c0108bd3:	0f 22 c0             	mov    %eax,%cr0
        "mov %0, %%cr0"
        :: "r"(v)
    );
}
c0108bd6:	90                   	nop
c0108bd7:	5d                   	pop    %ebp
c0108bd8:	c3                   	ret    

c0108bd9 <cpu_w_cr2>:

void cpu_w_cr2(reg32 v) {
c0108bd9:	55                   	push   %ebp
c0108bda:	89 e5                	mov    %esp,%ebp
    asm volatile (
c0108bdc:	8b 45 08             	mov    0x8(%ebp),%eax
c0108bdf:	0f 22 d0             	mov    %eax,%cr2
        "mov %0, %%cr2"
        :: "r"(v)
    );
}
c0108be2:	90                   	nop
c0108be3:	5d                   	pop    %ebp
c0108be4:	c3                   	ret    

c0108be5 <cpu_w_cr3>:

void cpu_w_cr3(reg32 v) {
c0108be5:	55                   	push   %ebp
c0108be6:	89 e5                	mov    %esp,%ebp
    asm volatile (
c0108be8:	8b 45 08             	mov    0x8(%ebp),%eax
c0108beb:	0f 22 d8             	mov    %eax,%cr3
        "mov %0, %%cr3"
        :: "r"(v)
    );
}
c0108bee:	90                   	nop
c0108bef:	5d                   	pop    %ebp
c0108bf0:	c3                   	ret    

c0108bf1 <_set_gdt_entry>:
uint64_t _gdt[GDT_ENTRY];
uint16_t _gdt_limit = sizeof(_gdt) - 1;

extern struct x86_tss _tss;

void _set_gdt_entry(uint32_t index, uint32_t base, uint32_t limit, uint32_t flags) {
c0108bf1:	55                   	push   %ebp
c0108bf2:	89 e5                	mov    %esp,%ebp
c0108bf4:	57                   	push   %edi
c0108bf5:	56                   	push   %esi
c0108bf6:	53                   	push   %ebx
c0108bf7:	83 ec 0c             	sub    $0xc,%esp
    _gdt[index] = SEG_BASE_H(base) | flags | SEG_LIM_H(limit) | SEG_BASE_M(base);
c0108bfa:	8b 45 0c             	mov    0xc(%ebp),%eax
c0108bfd:	25 00 00 00 ff       	and    $0xff000000,%eax
c0108c02:	0b 45 14             	or     0x14(%ebp),%eax
c0108c05:	89 c2                	mov    %eax,%edx
c0108c07:	8b 45 10             	mov    0x10(%ebp),%eax
c0108c0a:	25 00 00 0f 00       	and    $0xf0000,%eax
c0108c0f:	09 c2                	or     %eax,%edx
c0108c11:	8b 45 0c             	mov    0xc(%ebp),%eax
c0108c14:	c1 e8 10             	shr    $0x10,%eax
c0108c17:	0f b6 c0             	movzbl %al,%eax
c0108c1a:	09 d0                	or     %edx,%eax
c0108c1c:	ba 00 00 00 00       	mov    $0x0,%edx
c0108c21:	8b 75 08             	mov    0x8(%ebp),%esi
c0108c24:	89 04 f5 20 b5 d0 c0 	mov    %eax,-0x3f2f4ae0(,%esi,8)
c0108c2b:	89 14 f5 24 b5 d0 c0 	mov    %edx,-0x3f2f4adc(,%esi,8)
    _gdt[index] <<= 32;
c0108c32:	8b 45 08             	mov    0x8(%ebp),%eax
c0108c35:	8b 14 c5 24 b5 d0 c0 	mov    -0x3f2f4adc(,%eax,8),%edx
c0108c3c:	8b 04 c5 20 b5 d0 c0 	mov    -0x3f2f4ae0(,%eax,8),%eax
c0108c43:	89 c2                	mov    %eax,%edx
c0108c45:	b8 00 00 00 00       	mov    $0x0,%eax
c0108c4a:	8b 75 08             	mov    0x8(%ebp),%esi
c0108c4d:	89 04 f5 20 b5 d0 c0 	mov    %eax,-0x3f2f4ae0(,%esi,8)
c0108c54:	89 14 f5 24 b5 d0 c0 	mov    %edx,-0x3f2f4adc(,%esi,8)
    _gdt[index] |= SEG_BASE_L(base) | SEG_LIM_L(limit);
c0108c5b:	8b 45 08             	mov    0x8(%ebp),%eax
c0108c5e:	8b 14 c5 24 b5 d0 c0 	mov    -0x3f2f4adc(,%eax,8),%edx
c0108c65:	8b 04 c5 20 b5 d0 c0 	mov    -0x3f2f4ae0(,%eax,8),%eax
c0108c6c:	8b 75 0c             	mov    0xc(%ebp),%esi
c0108c6f:	89 f7                	mov    %esi,%edi
c0108c71:	c1 e7 10             	shl    $0x10,%edi
c0108c74:	8b 75 10             	mov    0x10(%ebp),%esi
c0108c77:	0f b7 f6             	movzwl %si,%esi
c0108c7a:	09 fe                	or     %edi,%esi
c0108c7c:	bf 00 00 00 00       	mov    $0x0,%edi
c0108c81:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0108c84:	89 55 ec             	mov    %edx,-0x14(%ebp)
c0108c87:	09 f0                	or     %esi,%eax
c0108c89:	89 c1                	mov    %eax,%ecx
c0108c8b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0108c8e:	09 f8                	or     %edi,%eax
c0108c90:	89 c3                	mov    %eax,%ebx
c0108c92:	8b 45 08             	mov    0x8(%ebp),%eax
c0108c95:	89 0c c5 20 b5 d0 c0 	mov    %ecx,-0x3f2f4ae0(,%eax,8)
c0108c9c:	89 1c c5 24 b5 d0 c0 	mov    %ebx,-0x3f2f4adc(,%eax,8)
}
c0108ca3:	90                   	nop
c0108ca4:	83 c4 0c             	add    $0xc,%esp
c0108ca7:	5b                   	pop    %ebx
c0108ca8:	5e                   	pop    %esi
c0108ca9:	5f                   	pop    %edi
c0108caa:	5d                   	pop    %ebp
c0108cab:	c3                   	ret    

c0108cac <_init_gdt>:
// 
void
_init_gdt() {
c0108cac:	55                   	push   %ebp
c0108cad:	89 e5                	mov    %esp,%ebp
    _set_gdt_entry(0, 0, 0, 0);
c0108caf:	6a 00                	push   $0x0
c0108cb1:	6a 00                	push   $0x0
c0108cb3:	6a 00                	push   $0x0
c0108cb5:	6a 00                	push   $0x0
c0108cb7:	e8 35 ff ff ff       	call   c0108bf1 <_set_gdt_entry>
c0108cbc:	83 c4 10             	add    $0x10,%esp
    _set_gdt_entry(1, 0, 0xfffff, SEG_R0_CODE);
c0108cbf:	68 00 9a c0 00       	push   $0xc09a00
c0108cc4:	68 ff ff 0f 00       	push   $0xfffff
c0108cc9:	6a 00                	push   $0x0
c0108ccb:	6a 01                	push   $0x1
c0108ccd:	e8 1f ff ff ff       	call   c0108bf1 <_set_gdt_entry>
c0108cd2:	83 c4 10             	add    $0x10,%esp
    _set_gdt_entry(2, 0, 0xfffff, SEG_R0_DATA);
c0108cd5:	68 00 92 c0 00       	push   $0xc09200
c0108cda:	68 ff ff 0f 00       	push   $0xfffff
c0108cdf:	6a 00                	push   $0x0
c0108ce1:	6a 02                	push   $0x2
c0108ce3:	e8 09 ff ff ff       	call   c0108bf1 <_set_gdt_entry>
c0108ce8:	83 c4 10             	add    $0x10,%esp
    _set_gdt_entry(3, 0, 0xfffff, SEG_R3_CODE);
c0108ceb:	68 00 fa c0 00       	push   $0xc0fa00
c0108cf0:	68 ff ff 0f 00       	push   $0xfffff
c0108cf5:	6a 00                	push   $0x0
c0108cf7:	6a 03                	push   $0x3
c0108cf9:	e8 f3 fe ff ff       	call   c0108bf1 <_set_gdt_entry>
c0108cfe:	83 c4 10             	add    $0x10,%esp
    _set_gdt_entry(4, 0, 0xfffff, SEG_R3_DATA);
c0108d01:	68 00 f2 c0 00       	push   $0xc0f200
c0108d06:	68 ff ff 0f 00       	push   $0xfffff
c0108d0b:	6a 00                	push   $0x0
c0108d0d:	6a 04                	push   $0x4
c0108d0f:	e8 dd fe ff ff       	call   c0108bf1 <_set_gdt_entry>
c0108d14:	83 c4 10             	add    $0x10,%esp
    _set_gdt_entry(5, &_tss, sizeof(struct x86_tss) - 1, SEG_TSS);
c0108d17:	b8 20 d0 d0 c0       	mov    $0xc0d0d020,%eax
c0108d1c:	68 00 89 00 00       	push   $0x8900
c0108d21:	6a 67                	push   $0x67
c0108d23:	50                   	push   %eax
c0108d24:	6a 05                	push   $0x5
c0108d26:	e8 c6 fe ff ff       	call   c0108bf1 <_set_gdt_entry>
c0108d2b:	83 c4 10             	add    $0x10,%esp
c0108d2e:	90                   	nop
c0108d2f:	c9                   	leave  
c0108d30:	c3                   	ret    

c0108d31 <tss_update_esp>:
    .esp0 = KSTACK_START,
    .ss0  = KDATA_SEG,
    .__padding = {0}
};

void tss_update_esp(uint32_t esp0) {
c0108d31:	55                   	push   %ebp
c0108d32:	89 e5                	mov    %esp,%ebp
    _tss.esp0 = esp0;
c0108d34:	8b 45 08             	mov    0x8(%ebp),%eax
c0108d37:	a3 24 d0 d0 c0       	mov    %eax,0xc0d0d024
c0108d3c:	90                   	nop
c0108d3d:	5d                   	pop    %ebp
c0108d3e:	c3                   	ret    

c0108d3f <_set_idt_entry>:
#define IDT_ENTRY 256

uint64_t _idt[IDT_ENTRY];
uint16_t _idt_limit = sizeof(_idt) - 1;

void _set_idt_entry(uint32_t vector, uint16_t seg_selector, void (*isr)(), uint8_t dpl) {
c0108d3f:	55                   	push   %ebp
c0108d40:	89 e5                	mov    %esp,%ebp
c0108d42:	57                   	push   %edi
c0108d43:	56                   	push   %esi
c0108d44:	53                   	push   %ebx
c0108d45:	83 ec 24             	sub    $0x24,%esp
c0108d48:	8b 45 0c             	mov    0xc(%ebp),%eax
c0108d4b:	8b 55 14             	mov    0x14(%ebp),%edx
c0108d4e:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
c0108d52:	89 d0                	mov    %edx,%eax
c0108d54:	88 45 d8             	mov    %al,-0x28(%ebp)
    uintptr_t offset = (uintptr_t)isr;
c0108d57:	8b 45 10             	mov    0x10(%ebp),%eax
c0108d5a:	89 45 ec             	mov    %eax,-0x14(%ebp)
    _idt[vector] = (offset & 0xffff0000) | IDT_ATTR(dpl);
c0108d5d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0108d60:	66 b8 00 00          	mov    $0x0,%ax
c0108d64:	89 c2                	mov    %eax,%edx
c0108d66:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
c0108d6a:	c1 e0 0d             	shl    $0xd,%eax
c0108d6d:	25 00 60 00 00       	and    $0x6000,%eax
c0108d72:	09 d0                	or     %edx,%eax
c0108d74:	80 cc 8e             	or     $0x8e,%ah
c0108d77:	ba 00 00 00 00       	mov    $0x0,%edx
c0108d7c:	8b 75 08             	mov    0x8(%ebp),%esi
c0108d7f:	89 04 f5 60 b5 d0 c0 	mov    %eax,-0x3f2f4aa0(,%esi,8)
c0108d86:	89 14 f5 64 b5 d0 c0 	mov    %edx,-0x3f2f4a9c(,%esi,8)
    _idt[vector] <<= 32;
c0108d8d:	8b 45 08             	mov    0x8(%ebp),%eax
c0108d90:	8b 14 c5 64 b5 d0 c0 	mov    -0x3f2f4a9c(,%eax,8),%edx
c0108d97:	8b 04 c5 60 b5 d0 c0 	mov    -0x3f2f4aa0(,%eax,8),%eax
c0108d9e:	89 c2                	mov    %eax,%edx
c0108da0:	b8 00 00 00 00       	mov    $0x0,%eax
c0108da5:	8b 75 08             	mov    0x8(%ebp),%esi
c0108da8:	89 04 f5 60 b5 d0 c0 	mov    %eax,-0x3f2f4aa0(,%esi,8)
c0108daf:	89 14 f5 64 b5 d0 c0 	mov    %edx,-0x3f2f4a9c(,%esi,8)
    _idt[vector] |= (seg_selector << 16) | (offset & 0x0000ffff);
c0108db6:	8b 45 08             	mov    0x8(%ebp),%eax
c0108db9:	8b 14 c5 64 b5 d0 c0 	mov    -0x3f2f4a9c(,%eax,8),%edx
c0108dc0:	8b 04 c5 60 b5 d0 c0 	mov    -0x3f2f4aa0(,%eax,8),%eax
c0108dc7:	0f b7 75 dc          	movzwl -0x24(%ebp),%esi
c0108dcb:	c1 e6 10             	shl    $0x10,%esi
c0108dce:	89 f7                	mov    %esi,%edi
c0108dd0:	8b 75 ec             	mov    -0x14(%ebp),%esi
c0108dd3:	0f b7 f6             	movzwl %si,%esi
c0108dd6:	09 fe                	or     %edi,%esi
c0108dd8:	bf 00 00 00 00       	mov    $0x0,%edi
c0108ddd:	89 45 d0             	mov    %eax,-0x30(%ebp)
c0108de0:	89 55 d4             	mov    %edx,-0x2c(%ebp)
c0108de3:	09 f0                	or     %esi,%eax
c0108de5:	89 c1                	mov    %eax,%ecx
c0108de7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0108dea:	09 f8                	or     %edi,%eax
c0108dec:	89 c3                	mov    %eax,%ebx
c0108dee:	8b 45 08             	mov    0x8(%ebp),%eax
c0108df1:	89 0c c5 60 b5 d0 c0 	mov    %ecx,-0x3f2f4aa0(,%eax,8)
c0108df8:	89 1c c5 64 b5 d0 c0 	mov    %ebx,-0x3f2f4a9c(,%eax,8)
}
c0108dff:	90                   	nop
c0108e00:	83 c4 24             	add    $0x24,%esp
c0108e03:	5b                   	pop    %ebx
c0108e04:	5e                   	pop    %esi
c0108e05:	5f                   	pop    %edi
c0108e06:	5d                   	pop    %ebp
c0108e07:	c3                   	ret    

c0108e08 <_init_idt>:

void _init_idt()
{
c0108e08:	55                   	push   %ebp
c0108e09:	89 e5                	mov    %esp,%ebp
c0108e0b:	83 ec 10             	sub    $0x10,%esp
    _set_idt_entry(FAULT_DIVISION_ERROR, 0x08, &divide_error, 0);
c0108e0e:	6a 00                	push   $0x0
c0108e10:	68 54 82 10 c0       	push   $0xc0108254
c0108e15:	6a 08                	push   $0x8
c0108e17:	6a 00                	push   $0x0
c0108e19:	e8 21 ff ff ff       	call   c0108d3f <_set_idt_entry>
c0108e1e:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(FAULT_TRAP_DEBUG_EXCEPTION, 0x08, &debug, 0);
c0108e21:	6a 00                	push   $0x0
c0108e23:	68 5b 82 10 c0       	push   $0xc010825b
c0108e28:	6a 08                	push   $0x8
c0108e2a:	6a 01                	push   $0x1
c0108e2c:	e8 0e ff ff ff       	call   c0108d3f <_set_idt_entry>
c0108e31:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(INT_NMI, 0x08, &nmi, 0);
c0108e34:	6a 00                	push   $0x0
c0108e36:	68 62 82 10 c0       	push   $0xc0108262
c0108e3b:	6a 08                	push   $0x8
c0108e3d:	6a 02                	push   $0x2
c0108e3f:	e8 fb fe ff ff       	call   c0108d3f <_set_idt_entry>
c0108e44:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(TRAP_BREAKPOINT, 0x08, &int3, 0);
c0108e47:	6a 00                	push   $0x0
c0108e49:	68 69 82 10 c0       	push   $0xc0108269
c0108e4e:	6a 08                	push   $0x8
c0108e50:	6a 03                	push   $0x3
c0108e52:	e8 e8 fe ff ff       	call   c0108d3f <_set_idt_entry>
c0108e57:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(TRAP_OVERFLOW, 0x08, &overflow, 0);
c0108e5a:	6a 00                	push   $0x0
c0108e5c:	68 70 82 10 c0       	push   $0xc0108270
c0108e61:	6a 08                	push   $0x8
c0108e63:	6a 04                	push   $0x4
c0108e65:	e8 d5 fe ff ff       	call   c0108d3f <_set_idt_entry>
c0108e6a:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(FAULT_BOUND_EXCEED, 0x08, &bounds, 0);
c0108e6d:	6a 00                	push   $0x0
c0108e6f:	68 7a 82 10 c0       	push   $0xc010827a
c0108e74:	6a 08                	push   $0x8
c0108e76:	6a 05                	push   $0x5
c0108e78:	e8 c2 fe ff ff       	call   c0108d3f <_set_idt_entry>
c0108e7d:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(FAULT_INVALID_OPCODE, 0x08, &invalid_op, 0);
c0108e80:	6a 00                	push   $0x0
c0108e82:	68 84 82 10 c0       	push   $0xc0108284
c0108e87:	6a 08                	push   $0x8
c0108e89:	6a 06                	push   $0x6
c0108e8b:	e8 af fe ff ff       	call   c0108d3f <_set_idt_entry>
c0108e90:	83 c4 10             	add    $0x10,%esp
    //_set_idt_entry(FAULT_NO_MATH_PROCESSOR, 0x08, &device_not_available, 0);
    //_set_idt_entry(ABORT_DOUBLE_FAULT, 0x08, &double_fault, 0);
    _set_idt_entry(FAULT_RESERVED_0, 0x08, &coprocessor_segment_overrun, 0);
c0108e93:	6a 00                	push   $0x0
c0108e95:	68 8e 82 10 c0       	push   $0xc010828e
c0108e9a:	6a 08                	push   $0x8
c0108e9c:	6a 09                	push   $0x9
c0108e9e:	e8 9c fe ff ff       	call   c0108d3f <_set_idt_entry>
c0108ea3:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(FAULT_INVALID_TSS, 0x08, &invalid_TSS, 0);
c0108ea6:	6a 00                	push   $0x0
c0108ea8:	68 a2 82 10 c0       	push   $0xc01082a2
c0108ead:	6a 08                	push   $0x8
c0108eaf:	6a 0a                	push   $0xa
c0108eb1:	e8 89 fe ff ff       	call   c0108d3f <_set_idt_entry>
c0108eb6:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(FAULT_SEG_NOT_PRESENT, 0x08, &segment_not_present, 0);
c0108eb9:	6a 00                	push   $0x0
c0108ebb:	68 ac 82 10 c0       	push   $0xc01082ac
c0108ec0:	6a 08                	push   $0x8
c0108ec2:	6a 0b                	push   $0xb
c0108ec4:	e8 76 fe ff ff       	call   c0108d3f <_set_idt_entry>
c0108ec9:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(FAULT_STACK_SEG_FAULT, 0x08, &stack_segment, 0);
c0108ecc:	6a 00                	push   $0x0
c0108ece:	68 b6 82 10 c0       	push   $0xc01082b6
c0108ed3:	6a 08                	push   $0x8
c0108ed5:	6a 0c                	push   $0xc
c0108ed7:	e8 63 fe ff ff       	call   c0108d3f <_set_idt_entry>
c0108edc:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(FAULT_GENERAL_PROTECTION, 0x08, &general_protection, 0);
c0108edf:	6a 00                	push   $0x0
c0108ee1:	68 c0 82 10 c0       	push   $0xc01082c0
c0108ee6:	6a 08                	push   $0x8
c0108ee8:	6a 0d                	push   $0xd
c0108eea:	e8 50 fe ff ff       	call   c0108d3f <_set_idt_entry>
c0108eef:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(FAULT_PAGE_FAULT, 0x08, &page_fault, 0);
c0108ef2:	6a 00                	push   $0x0
c0108ef4:	68 bd 71 10 c0       	push   $0xc01071bd
c0108ef9:	6a 08                	push   $0x8
c0108efb:	6a 0e                	push   $0xe
c0108efd:	e8 3d fe ff ff       	call   c0108d3f <_set_idt_entry>
c0108f02:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(FAULT_RESERVED_1, 0x08, &reserved, 0);
c0108f05:	6a 00                	push   $0x0
c0108f07:	68 98 82 10 c0       	push   $0xc0108298
c0108f0c:	6a 08                	push   $0x8
c0108f0e:	6a 0f                	push   $0xf
c0108f10:	e8 2a fe ff ff       	call   c0108d3f <_set_idt_entry>
c0108f15:	83 c4 10             	add    $0x10,%esp
    //_set_idt_entry(FAULT_X87_FAULT, 0x08, coprocessor_error, 0);
    for (int i=17;i < 48;i++)
c0108f18:	c7 45 fc 11 00 00 00 	movl   $0x11,-0x4(%ebp)
c0108f1f:	eb 19                	jmp    c0108f3a <_init_idt+0x132>
		  _set_idt_entry(i, 0x08, &reserved, 0);
c0108f21:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0108f24:	6a 00                	push   $0x0
c0108f26:	68 98 82 10 c0       	push   $0xc0108298
c0108f2b:	6a 08                	push   $0x8
c0108f2d:	50                   	push   %eax
c0108f2e:	e8 0c fe ff ff       	call   c0108d3f <_set_idt_entry>
c0108f33:	83 c4 10             	add    $0x10,%esp
    for (int i=17;i < 48;i++)
c0108f36:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0108f3a:	83 7d fc 2f          	cmpl   $0x2f,-0x4(%ebp)
c0108f3e:	7e e1                	jle    c0108f21 <_init_idt+0x119>
    //_set_idt_entry(45, 0x08, irq13, 0);
    _set_idt_entry(MELOX_SYS_CALL, 0x08, &intr_syscall_handler, 3);
c0108f40:	6a 03                	push   $0x3
c0108f42:	68 b8 81 10 c0       	push   $0xc01081b8
c0108f47:	6a 08                	push   $0x8
c0108f49:	68 80 00 00 00       	push   $0x80
c0108f4e:	e8 ec fd ff ff       	call   c0108d3f <_set_idt_entry>
c0108f53:	83 c4 10             	add    $0x10,%esp
c0108f56:	90                   	nop
c0108f57:	c9                   	leave  
c0108f58:	c3                   	ret    

c0108f59 <_kernel_start>:
c0108f59:	e8 4e fd ff ff       	call   c0108cac <_init_gdt>
c0108f5e:	68 20 b5 d0 c0       	push   $0xc0d0b520
c0108f63:	66 ff 35 00 d0 d0 c0 	pushw  0xc0d0d000
c0108f6a:	0f 01 14 24          	lgdtl  (%esp)
c0108f6e:	66 b9 10 00          	mov    $0x10,%cx
c0108f72:	8e c1                	mov    %ecx,%es
c0108f74:	8e d9                	mov    %ecx,%ds
c0108f76:	8e e1                	mov    %ecx,%fs
c0108f78:	8e e9                	mov    %ecx,%gs
c0108f7a:	8e d1                	mov    %ecx,%ss
c0108f7c:	66 6a 08             	pushw  $0x8
c0108f7f:	68 85 8f 10 c0       	push   $0xc0108f85
c0108f84:	cb                   	lret   

c0108f85 <_after_gdt>:
c0108f85:	c7 04 24 00 10 10 00 	movl   $0x101000,(%esp)
c0108f8c:	e8 ad d2 ff ff       	call   c010623e <_vir_kernel_init>
c0108f91:	83 ec 06             	sub    $0x6,%esp
c0108f94:	c7 44 24 02 60 b5 d0 	movl   $0xc0d0b560,0x2(%esp)
c0108f9b:	c0 
c0108f9c:	66 a1 88 d0 d0 c0    	mov    0xc0d0d088,%ax
c0108fa2:	66 89 04 24          	mov    %ax,(%esp)
c0108fa6:	0f 01 1c 24          	lidtl  (%esp)
c0108faa:	66 b8 28 00          	mov    $0x28,%ax
c0108fae:	0f 00 d8             	ltr    %ax
c0108fb1:	83 c4 06             	add    $0x6,%esp
c0108fb4:	e8 ec d5 ff ff       	call   c01065a5 <_kernel_main>

c0108fb9 <j_>:
c0108fb9:	f4                   	hlt    
c0108fba:	eb fd                	jmp    c0108fb9 <j_>

c0108fbc <io_inb>:
{
c0108fbc:	55                   	push   %ebp
c0108fbd:	89 e5                	mov    %esp,%ebp
c0108fbf:	83 ec 10             	sub    $0x10,%esp
    asm volatile("inb %w1,%0" : "=a"(data) : "d"(port));
c0108fc2:	8b 45 08             	mov    0x8(%ebp),%eax
c0108fc5:	89 c2                	mov    %eax,%edx
c0108fc7:	ec                   	in     (%dx),%al
c0108fc8:	88 45 ff             	mov    %al,-0x1(%ebp)
    return data;
c0108fcb:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c0108fcf:	c9                   	leave  
c0108fd0:	c3                   	ret    

c0108fd1 <io_outb>:
{
c0108fd1:	55                   	push   %ebp
c0108fd2:	89 e5                	mov    %esp,%ebp
c0108fd4:	83 ec 04             	sub    $0x4,%esp
c0108fd7:	8b 45 0c             	mov    0xc(%ebp),%eax
c0108fda:	88 45 fc             	mov    %al,-0x4(%ebp)
    asm volatile("outb %0, %w1" : : "a"(data), "d"(port));
c0108fdd:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0108fe1:	8b 55 08             	mov    0x8(%ebp),%edx
c0108fe4:	ee                   	out    %al,(%dx)
}
c0108fe5:	90                   	nop
c0108fe6:	c9                   	leave  
c0108fe7:	c3                   	ret    

c0108fe8 <cpu_delay>:
static inline void cpu_delay(){
c0108fe8:	55                   	push   %ebp
c0108fe9:	89 e5                	mov    %esp,%ebp
c0108feb:	83 ec 10             	sub    $0x10,%esp
    for(int i = 0; i < 3; i++);
c0108fee:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0108ff5:	eb 04                	jmp    c0108ffb <cpu_delay+0x13>
c0108ff7:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0108ffb:	83 7d fc 02          	cmpl   $0x2,-0x4(%ebp)
c0108fff:	7e f6                	jle    c0108ff7 <cpu_delay+0xf>
}
c0109001:	90                   	nop
c0109002:	90                   	nop
c0109003:	c9                   	leave  
c0109004:	c3                   	ret    

c0109005 <init_8259>:
//other keys tmp do not hand
};
#endif

void init_8259()
{
c0109005:	55                   	push   %ebp
c0109006:	89 e5                	mov    %esp,%ebp
    asm volatile("cli");
c0109008:	fa                   	cli    

    //ICW1
    io_outb(0x20, 0x11);
c0109009:	6a 11                	push   $0x11
c010900b:	6a 20                	push   $0x20
c010900d:	e8 bf ff ff ff       	call   c0108fd1 <io_outb>
c0109012:	83 c4 08             	add    $0x8,%esp
    cpu_delay();
c0109015:	e8 ce ff ff ff       	call   c0108fe8 <cpu_delay>
    io_outb(0xa0, 0x11);
c010901a:	6a 11                	push   $0x11
c010901c:	68 a0 00 00 00       	push   $0xa0
c0109021:	e8 ab ff ff ff       	call   c0108fd1 <io_outb>
c0109026:	83 c4 08             	add    $0x8,%esp
    cpu_delay();
c0109029:	e8 ba ff ff ff       	call   c0108fe8 <cpu_delay>

    //ICW2
    io_outb(0x21, 0x20);
c010902e:	6a 20                	push   $0x20
c0109030:	6a 21                	push   $0x21
c0109032:	e8 9a ff ff ff       	call   c0108fd1 <io_outb>
c0109037:	83 c4 08             	add    $0x8,%esp
    cpu_delay();
c010903a:	e8 a9 ff ff ff       	call   c0108fe8 <cpu_delay>
    io_outb(0xa1, 0x28);
c010903f:	6a 28                	push   $0x28
c0109041:	68 a1 00 00 00       	push   $0xa1
c0109046:	e8 86 ff ff ff       	call   c0108fd1 <io_outb>
c010904b:	83 c4 08             	add    $0x8,%esp
    cpu_delay();
c010904e:	e8 95 ff ff ff       	call   c0108fe8 <cpu_delay>

    //ICW3
    io_outb(0x21, 0x04);
c0109053:	6a 04                	push   $0x4
c0109055:	6a 21                	push   $0x21
c0109057:	e8 75 ff ff ff       	call   c0108fd1 <io_outb>
c010905c:	83 c4 08             	add    $0x8,%esp
    cpu_delay();
c010905f:	e8 84 ff ff ff       	call   c0108fe8 <cpu_delay>
    io_outb(0xa1, 0x02);
c0109064:	6a 02                	push   $0x2
c0109066:	68 a1 00 00 00       	push   $0xa1
c010906b:	e8 61 ff ff ff       	call   c0108fd1 <io_outb>
c0109070:	83 c4 08             	add    $0x8,%esp
    cpu_delay();
c0109073:	e8 70 ff ff ff       	call   c0108fe8 <cpu_delay>

    //ICW4
    io_outb(0x21, 0x01);
c0109078:	6a 01                	push   $0x1
c010907a:	6a 21                	push   $0x21
c010907c:	e8 50 ff ff ff       	call   c0108fd1 <io_outb>
c0109081:	83 c4 08             	add    $0x8,%esp
    cpu_delay();
c0109084:	e8 5f ff ff ff       	call   c0108fe8 <cpu_delay>
    io_outb(0xa1, 0x01);
c0109089:	6a 01                	push   $0x1
c010908b:	68 a1 00 00 00       	push   $0xa1
c0109090:	e8 3c ff ff ff       	call   c0108fd1 <io_outb>
c0109095:	83 c4 08             	add    $0x8,%esp
    cpu_delay();
c0109098:	e8 4b ff ff ff       	call   c0108fe8 <cpu_delay>

    //OCW1
    io_outb(0x21, 0xff);
c010909d:	68 ff 00 00 00       	push   $0xff
c01090a2:	6a 21                	push   $0x21
c01090a4:	e8 28 ff ff ff       	call   c0108fd1 <io_outb>
c01090a9:	83 c4 08             	add    $0x8,%esp
    cpu_delay();
c01090ac:	e8 37 ff ff ff       	call   c0108fe8 <cpu_delay>
    io_outb(0xa1, 0xff);
c01090b1:	68 ff 00 00 00       	push   $0xff
c01090b6:	68 a1 00 00 00       	push   $0xa1
c01090bb:	e8 11 ff ff ff       	call   c0108fd1 <io_outb>
c01090c0:	83 c4 08             	add    $0x8,%esp

    asm volatile("sti");
c01090c3:	fb                   	sti    
}
c01090c4:	90                   	nop
c01090c5:	c9                   	leave  
c01090c6:	c3                   	ret    

c01090c7 <ps2_post_cmd>:


static void ps2_post_cmd(uint8_t port, char cmd, uint16_t arg) {
c01090c7:	55                   	push   %ebp
c01090c8:	89 e5                	mov    %esp,%ebp
c01090ca:	83 ec 1c             	sub    $0x1c,%esp
c01090cd:	8b 4d 08             	mov    0x8(%ebp),%ecx
c01090d0:	8b 55 0c             	mov    0xc(%ebp),%edx
c01090d3:	8b 45 10             	mov    0x10(%ebp),%eax
c01090d6:	88 4d ec             	mov    %cl,-0x14(%ebp)
c01090d9:	88 55 e8             	mov    %dl,-0x18(%ebp)
c01090dc:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    char result;
    // 等待PS/2输入缓冲区清空，这样我们才可以写入命令
    while((result = io_inb(PS2_PORT_CTRL_STATUS)) & PS2_STATUS_IFULL);
c01090e0:	90                   	nop
c01090e1:	6a 64                	push   $0x64
c01090e3:	e8 d4 fe ff ff       	call   c0108fbc <io_inb>
c01090e8:	83 c4 04             	add    $0x4,%esp
c01090eb:	88 45 ff             	mov    %al,-0x1(%ebp)
c01090ee:	0f be 45 ff          	movsbl -0x1(%ebp),%eax
c01090f2:	83 e0 02             	and    $0x2,%eax
c01090f5:	85 c0                	test   %eax,%eax
c01090f7:	75 e8                	jne    c01090e1 <ps2_post_cmd+0x1a>

    io_outb(port, cmd);
c01090f9:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c01090fd:	0f b6 d0             	movzbl %al,%edx
c0109100:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0109104:	52                   	push   %edx
c0109105:	50                   	push   %eax
c0109106:	e8 c6 fe ff ff       	call   c0108fd1 <io_outb>
c010910b:	83 c4 08             	add    $0x8,%esp
    if (!(arg & PS2_NO_ARG)) {
c010910e:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
c0109112:	25 00 ff 00 00       	and    $0xff00,%eax
c0109117:	85 c0                	test   %eax,%eax
c0109119:	75 12                	jne    c010912d <ps2_post_cmd+0x66>
        // 所有参数一律通过0x60传入。
        io_outb(PS2_PORT_ENC_CMDREG, (uint8_t)(arg & 0x00ff));
c010911b:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
c010911f:	0f b6 c0             	movzbl %al,%eax
c0109122:	50                   	push   %eax
c0109123:	6a 60                	push   $0x60
c0109125:	e8 a7 fe ff ff       	call   c0108fd1 <io_outb>
c010912a:	83 c4 08             	add    $0x8,%esp
    }
}
c010912d:	90                   	nop
c010912e:	c9                   	leave  
c010912f:	c3                   	ret    

c0109130 <ps2_issue_cmd>:

static uint8_t ps2_issue_cmd(char cmd, uint16_t arg) {
c0109130:	55                   	push   %ebp
c0109131:	89 e5                	mov    %esp,%ebp
c0109133:	83 ec 18             	sub    $0x18,%esp
c0109136:	8b 55 08             	mov    0x8(%ebp),%edx
c0109139:	8b 45 0c             	mov    0xc(%ebp),%eax
c010913c:	88 55 ec             	mov    %dl,-0x14(%ebp)
c010913f:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
    ps2_post_cmd(PS2_PORT_CTRL_CMDREG, cmd, arg);
c0109143:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
c0109147:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
c010914b:	52                   	push   %edx
c010914c:	50                   	push   %eax
c010914d:	6a 64                	push   $0x64
c010914f:	e8 73 ff ff ff       	call   c01090c7 <ps2_post_cmd>
c0109154:	83 c4 0c             	add    $0xc,%esp

    char result;
    
    // 等待PS/2控制器返回。通过轮询（polling）状态寄存器的 bit 0
    // 如置位，则表明返回代码此时就在 0x60 IO口上等待读取。
    while(!((result = io_inb(PS2_PORT_CTRL_STATUS)) & PS2_STATUS_OFULL));
c0109157:	90                   	nop
c0109158:	6a 64                	push   $0x64
c010915a:	e8 5d fe ff ff       	call   c0108fbc <io_inb>
c010915f:	83 c4 04             	add    $0x4,%esp
c0109162:	88 45 ff             	mov    %al,-0x1(%ebp)
c0109165:	0f be 45 ff          	movsbl -0x1(%ebp),%eax
c0109169:	83 e0 01             	and    $0x1,%eax
c010916c:	85 c0                	test   %eax,%eax
c010916e:	74 e8                	je     c0109158 <ps2_issue_cmd+0x28>

    return io_inb(PS2_PORT_ENC_CMDREG);
c0109170:	6a 60                	push   $0x60
c0109172:	e8 45 fe ff ff       	call   c0108fbc <io_inb>
c0109177:	83 c4 04             	add    $0x4,%esp
}
c010917a:	c9                   	leave  
c010917b:	c3                   	ret    

c010917c <ps2_issue_dev_cmd>:

static uint8_t ps2_issue_dev_cmd(char cmd, uint16_t arg) {
c010917c:	55                   	push   %ebp
c010917d:	89 e5                	mov    %esp,%ebp
c010917f:	83 ec 18             	sub    $0x18,%esp
c0109182:	8b 55 08             	mov    0x8(%ebp),%edx
c0109185:	8b 45 0c             	mov    0xc(%ebp),%eax
c0109188:	88 55 ec             	mov    %dl,-0x14(%ebp)
c010918b:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
    ps2_post_cmd(PS2_PORT_ENC_CMDREG, cmd, arg);
c010918f:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
c0109193:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
c0109197:	52                   	push   %edx
c0109198:	50                   	push   %eax
c0109199:	6a 60                	push   $0x60
c010919b:	e8 27 ff ff ff       	call   c01090c7 <ps2_post_cmd>
c01091a0:	83 c4 0c             	add    $0xc,%esp

    char result;
    
    // 等待PS/2控制器返回。通过轮询（polling）状态寄存器的 bit 0
    // 如置位，则表明返回代码此时就在 0x60 IO口上等待读取。
    while(!((result = io_inb(PS2_PORT_CTRL_STATUS)) & PS2_STATUS_OFULL));
c01091a3:	90                   	nop
c01091a4:	6a 64                	push   $0x64
c01091a6:	e8 11 fe ff ff       	call   c0108fbc <io_inb>
c01091ab:	83 c4 04             	add    $0x4,%esp
c01091ae:	88 45 ff             	mov    %al,-0x1(%ebp)
c01091b1:	0f be 45 ff          	movsbl -0x1(%ebp),%eax
c01091b5:	83 e0 01             	and    $0x1,%eax
c01091b8:	85 c0                	test   %eax,%eax
c01091ba:	74 e8                	je     c01091a4 <ps2_issue_dev_cmd+0x28>

    return io_inb(PS2_PORT_ENC_CMDREG);
c01091bc:	6a 60                	push   $0x60
c01091be:	e8 f9 fd ff ff       	call   c0108fbc <io_inb>
c01091c3:	83 c4 04             	add    $0x4,%esp
}
c01091c6:	c9                   	leave  
c01091c7:	c3                   	ret    

c01091c8 <init_ps2k>:

void init_ps2k()
{
c01091c8:	55                   	push   %ebp
c01091c9:	89 e5                	mov    %esp,%ebp
c01091cb:	83 ec 18             	sub    $0x18,%esp
    asm volatile("cli");
c01091ce:	fa                   	cli    

     // 1、禁用任何的PS/2设备
    ps2_post_cmd(PS2_PORT_CTRL_CMDREG, PS2_CMD_PORT1_DISABLE, PS2_NO_ARG);
c01091cf:	68 00 ff 00 00       	push   $0xff00
c01091d4:	6a ad                	push   $0xffffffad
c01091d6:	6a 64                	push   $0x64
c01091d8:	e8 ea fe ff ff       	call   c01090c7 <ps2_post_cmd>
c01091dd:	83 c4 0c             	add    $0xc,%esp
    ps2_post_cmd(PS2_PORT_CTRL_CMDREG, PS2_CMD_PORT2_DISABLE, PS2_NO_ARG);
c01091e0:	68 00 ff 00 00       	push   $0xff00
c01091e5:	6a a7                	push   $0xffffffa7
c01091e7:	6a 64                	push   $0x64
c01091e9:	e8 d9 fe ff ff       	call   c01090c7 <ps2_post_cmd>
c01091ee:	83 c4 0c             	add    $0xc,%esp
    
    // 2、清空控制器缓冲区
    io_inb(PS2_PORT_ENC_DATA);
c01091f1:	6a 60                	push   $0x60
c01091f3:	e8 c4 fd ff ff       	call   c0108fbc <io_inb>
c01091f8:	83 c4 04             	add    $0x4,%esp

    char result;

    // 3、屏蔽所有PS/2设备（端口1&2）IRQ，并且禁用键盘键码转换功能
    result = ps2_issue_cmd(PS2_CMD_READ_CFG, PS2_NO_ARG);
c01091fb:	68 00 ff 00 00       	push   $0xff00
c0109200:	6a 20                	push   $0x20
c0109202:	e8 29 ff ff ff       	call   c0109130 <ps2_issue_cmd>
c0109207:	83 c4 08             	add    $0x8,%esp
c010920a:	88 45 f7             	mov    %al,-0x9(%ebp)
    result = result & ~(PS2_CFG_P1INT | PS2_CFG_P2INT | PS2_CFG_TRANSLATION);
c010920d:	80 65 f7 bc          	andb   $0xbc,-0x9(%ebp)
    ps2_post_cmd(PS2_PORT_CTRL_CMDREG, PS2_CMD_WRITE_CFG, result);
c0109211:	66 0f be 45 f7       	movsbw -0x9(%ebp),%ax
c0109216:	0f b7 c0             	movzwl %ax,%eax
c0109219:	50                   	push   %eax
c010921a:	6a 60                	push   $0x60
c010921c:	6a 64                	push   $0x64
c010921e:	e8 a4 fe ff ff       	call   c01090c7 <ps2_post_cmd>
c0109223:	83 c4 0c             	add    $0xc,%esp

    // 4、控制器自检
    result = ps2_issue_cmd(PS2_CMD_SELFTEST, PS2_NO_ARG);
c0109226:	68 00 ff 00 00       	push   $0xff00
c010922b:	6a aa                	push   $0xffffffaa
c010922d:	e8 fe fe ff ff       	call   c0109130 <ps2_issue_cmd>
c0109232:	83 c4 08             	add    $0x8,%esp
c0109235:	88 45 f7             	mov    %al,-0x9(%ebp)
    if (result != PS2_RESULT_TEST_OK) {
c0109238:	80 7d f7 55          	cmpb   $0x55,-0x9(%ebp)
c010923c:	74 12                	je     c0109250 <init_ps2k+0x88>
        kprintf("Controller self-test failed.");
c010923e:	83 ec 0c             	sub    $0xc,%esp
c0109241:	68 1c e6 d0 c0       	push   $0xc0d0e61c
c0109246:	e8 36 1a 00 00       	call   c010ac81 <kprintf>
c010924b:	83 c4 10             	add    $0x10,%esp
        goto done;
c010924e:	eb 72                	jmp    c01092c2 <init_ps2k+0xfa>
    }

    // 5、设备自检（端口1自检，通常是我们的键盘）
    result = ps2_issue_cmd(PS2_CMD_SELFTEST_PORT1, PS2_NO_ARG);
c0109250:	83 ec 08             	sub    $0x8,%esp
c0109253:	68 00 ff 00 00       	push   $0xff00
c0109258:	6a ab                	push   $0xffffffab
c010925a:	e8 d1 fe ff ff       	call   c0109130 <ps2_issue_cmd>
c010925f:	83 c4 10             	add    $0x10,%esp
c0109262:	88 45 f7             	mov    %al,-0x9(%ebp)
    if (result != 0) {
c0109265:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
c0109269:	74 12                	je     c010927d <init_ps2k+0xb5>
        kprintf("Interface test on port 1 failed.");
c010926b:	83 ec 0c             	sub    $0xc,%esp
c010926e:	68 3c e6 d0 c0       	push   $0xc0d0e63c
c0109273:	e8 09 1a 00 00       	call   c010ac81 <kprintf>
c0109278:	83 c4 10             	add    $0x10,%esp
        goto done;
c010927b:	eb 45                	jmp    c01092c2 <init_ps2k+0xfa>
    }

    // 6、开启位于端口1的 IRQ，并启用端口1。不用理会端口2，那儿一般是鼠标。
    ps2_post_cmd(PS2_PORT_CTRL_CMDREG, PS2_CMD_PORT1_ENABLE, PS2_NO_ARG);
c010927d:	83 ec 04             	sub    $0x4,%esp
c0109280:	68 00 ff 00 00       	push   $0xff00
c0109285:	6a ae                	push   $0xffffffae
c0109287:	6a 64                	push   $0x64
c0109289:	e8 39 fe ff ff       	call   c01090c7 <ps2_post_cmd>
c010928e:	83 c4 10             	add    $0x10,%esp
    result = ps2_issue_cmd(PS2_CMD_READ_CFG, PS2_NO_ARG);
c0109291:	83 ec 08             	sub    $0x8,%esp
c0109294:	68 00 ff 00 00       	push   $0xff00
c0109299:	6a 20                	push   $0x20
c010929b:	e8 90 fe ff ff       	call   c0109130 <ps2_issue_cmd>
c01092a0:	83 c4 10             	add    $0x10,%esp
c01092a3:	88 45 f7             	mov    %al,-0x9(%ebp)
    result = result | PS2_CFG_P1INT;
c01092a6:	80 4d f7 01          	orb    $0x1,-0x9(%ebp)
    ps2_post_cmd(PS2_PORT_CTRL_CMDREG, PS2_CMD_WRITE_CFG, result);
c01092aa:	66 0f be 45 f7       	movsbw -0x9(%ebp),%ax
c01092af:	0f b7 c0             	movzwl %ax,%eax
c01092b2:	83 ec 04             	sub    $0x4,%esp
c01092b5:	50                   	push   %eax
c01092b6:	6a 60                	push   $0x60
c01092b8:	6a 64                	push   $0x64
c01092ba:	e8 08 fe ff ff       	call   c01090c7 <ps2_post_cmd>
c01092bf:	83 c4 10             	add    $0x10,%esp

    // 至此，PS/2控制器和设备已完成初始化，可以正常使用。

done:
    asm volatile("sti");
c01092c2:	fb                   	sti    
}
c01092c3:	90                   	nop
c01092c4:	c9                   	leave  
c01092c5:	c3                   	ret    

c01092c6 <init_keyboard>:



void init_keyboard()
{
c01092c6:	55                   	push   %ebp
c01092c7:	89 e5                	mov    %esp,%ebp
c01092c9:	83 ec 18             	sub    $0x18,%esp
    asm("cli");
c01092cc:	fa                   	cli    
    init_8259();
c01092cd:	e8 33 fd ff ff       	call   c0109005 <init_8259>

    uint8_t result = io_inb(0x21);
c01092d2:	6a 21                	push   $0x21
c01092d4:	e8 e3 fc ff ff       	call   c0108fbc <io_inb>
c01092d9:	83 c4 04             	add    $0x4,%esp
c01092dc:	88 45 f7             	mov    %al,-0x9(%ebp)
    io_outb(0x21, result & 0xfd);
c01092df:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c01092e3:	25 fd 00 00 00       	and    $0xfd,%eax
c01092e8:	50                   	push   %eax
c01092e9:	6a 21                	push   $0x21
c01092eb:	e8 e1 fc ff ff       	call   c0108fd1 <io_outb>
c01092f0:	83 c4 08             	add    $0x8,%esp
    cpu_delay();
c01092f3:	e8 f0 fc ff ff       	call   c0108fe8 <cpu_delay>
    result = io_inb(0x21);
c01092f8:	6a 21                	push   $0x21
c01092fa:	e8 bd fc ff ff       	call   c0108fbc <io_inb>
c01092ff:	83 c4 04             	add    $0x4,%esp
c0109302:	88 45 f7             	mov    %al,-0x9(%ebp)

    init_ps2k();
c0109305:	e8 be fe ff ff       	call   c01091c8 <init_ps2k>
    
    _set_idt_entry(0x21, 0x08, &handle_keywords, 0);
c010930a:	6a 00                	push   $0x0
c010930c:	68 21 93 10 c0       	push   $0xc0109321
c0109311:	6a 08                	push   $0x8
c0109313:	6a 21                	push   $0x21
c0109315:	e8 25 fa ff ff       	call   c0108d3f <_set_idt_entry>
c010931a:	83 c4 10             	add    $0x10,%esp
    asm("sti");
c010931d:	fb                   	sti    
}
c010931e:	90                   	nop
c010931f:	c9                   	leave  
c0109320:	c3                   	ret    

c0109321 <handle_keywords>:

static void handle_keywords()
{
c0109321:	55                   	push   %ebp
c0109322:	89 e5                	mov    %esp,%ebp
c0109324:	83 ec 18             	sub    $0x18,%esp
    crtl_status, shift_status, alt_status, caps_lock_status, ext_scancode = 0;
c0109327:	c6 05 64 bd d0 c0 00 	movb   $0x0,0xc0d0bd64
    asm volatile("cli");
c010932e:	fa                   	cli    
    io_outb(0x61, 0x20);
c010932f:	6a 20                	push   $0x20
c0109331:	6a 61                	push   $0x61
c0109333:	e8 99 fc ff ff       	call   c0108fd1 <io_outb>
c0109338:	83 c4 08             	add    $0x8,%esp
    uint8_t ctrl_down_last = crtl_status;
c010933b:	0f b6 05 60 bd d0 c0 	movzbl 0xc0d0bd60,%eax
c0109342:	88 45 f4             	mov    %al,-0xc(%ebp)
    uint8_t shift_down_last = shift_status;
c0109345:	0f b6 05 61 bd d0 c0 	movzbl 0xc0d0bd61,%eax
c010934c:	88 45 f3             	mov    %al,-0xd(%ebp)
    uint8_t caps_lock_last = caps_lock_status;
c010934f:	0f b6 05 63 bd d0 c0 	movzbl 0xc0d0bd63,%eax
c0109356:	88 45 f2             	mov    %al,-0xe(%ebp)

    uint8_t break_code;
    uint16_t scancode = io_inb(0x60);
c0109359:	6a 60                	push   $0x60
c010935b:	e8 5c fc ff ff       	call   c0108fbc <io_inb>
c0109360:	83 c4 04             	add    $0x4,%esp
c0109363:	0f b6 c0             	movzbl %al,%eax
c0109366:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
    
    if(scancode == 0xe0){
c010936a:	66 81 7d f6 e0 00    	cmpw   $0xe0,-0xa(%ebp)
c0109370:	75 25                	jne    c0109397 <handle_keywords+0x76>
        ext_scancode = 1;
c0109372:	c6 05 64 bd d0 c0 01 	movb   $0x1,0xc0d0bd64
        io_outb(0x20, 0x20);
c0109379:	6a 20                	push   $0x20
c010937b:	6a 20                	push   $0x20
c010937d:	e8 4f fc ff ff       	call   c0108fd1 <io_outb>
c0109382:	83 c4 08             	add    $0x8,%esp
        io_outb(0x20, 0x20);
c0109385:	6a 20                	push   $0x20
c0109387:	6a 20                	push   $0x20
c0109389:	e8 43 fc ff ff       	call   c0108fd1 <io_outb>
c010938e:	83 c4 08             	add    $0x8,%esp
        asm volatile("sti");
c0109391:	fb                   	sti    
        return;
c0109392:	e9 1a 02 00 00       	jmp    c01095b1 <handle_keywords+0x290>
    }
    if(ext_scancode){
c0109397:	0f b6 05 64 bd d0 c0 	movzbl 0xc0d0bd64,%eax
c010939e:	84 c0                	test   %al,%al
c01093a0:	74 0d                	je     c01093af <handle_keywords+0x8e>
        scancode = ((0xe000) | scancode);
c01093a2:	66 81 4d f6 00 e0    	orw    $0xe000,-0xa(%ebp)
        ext_scancode = 0;
c01093a8:	c6 05 64 bd d0 c0 00 	movb   $0x0,0xc0d0bd64
    }

    break_code = ((0x0080 & scancode) != 0);
c01093af:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c01093b3:	66 25 80 00          	and    $0x80,%ax
c01093b7:	66 85 c0             	test   %ax,%ax
c01093ba:	0f 95 c0             	setne  %al
c01093bd:	88 45 f1             	mov    %al,-0xf(%ebp)

    if(break_code)//tan qi ma
c01093c0:	80 7d f1 00          	cmpb   $0x0,-0xf(%ebp)
c01093c4:	74 6d                	je     c0109433 <handle_keywords+0x112>
    {
        uint16_t make_code = (scancode & 0xff7f);
c01093c6:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c01093ca:	24 7f                	and    $0x7f,%al
c01093cc:	66 89 45 ec          	mov    %ax,-0x14(%ebp)

        if(make_code == crtl_l_make || make_code == crtl_r_make)
c01093d0:	66 83 7d ec 1d       	cmpw   $0x1d,-0x14(%ebp)
c01093d5:	74 08                	je     c01093df <handle_keywords+0xbe>
c01093d7:	66 81 7d ec 1d e0    	cmpw   $0xe01d,-0x14(%ebp)
c01093dd:	75 09                	jne    c01093e8 <handle_keywords+0xc7>
        {
            crtl_status = 0;
c01093df:	c6 05 60 bd d0 c0 00 	movb   $0x0,0xc0d0bd60
c01093e6:	eb 2d                	jmp    c0109415 <handle_keywords+0xf4>
        }else if(make_code == shift_l_make || make_code == shift_r_make){
c01093e8:	66 83 7d ec 2a       	cmpw   $0x2a,-0x14(%ebp)
c01093ed:	74 07                	je     c01093f6 <handle_keywords+0xd5>
c01093ef:	66 83 7d ec 36       	cmpw   $0x36,-0x14(%ebp)
c01093f4:	75 09                	jne    c01093ff <handle_keywords+0xde>
            shift_status = 0;
c01093f6:	c6 05 61 bd d0 c0 00 	movb   $0x0,0xc0d0bd61
c01093fd:	eb 16                	jmp    c0109415 <handle_keywords+0xf4>
        }else if(make_code == alt_l_make || make_code == alt_r_make){
c01093ff:	66 83 7d ec 38       	cmpw   $0x38,-0x14(%ebp)
c0109404:	74 08                	je     c010940e <handle_keywords+0xed>
c0109406:	66 81 7d ec 38 e0    	cmpw   $0xe038,-0x14(%ebp)
c010940c:	75 07                	jne    c0109415 <handle_keywords+0xf4>
            alt_status = 0;
c010940e:	c6 05 62 bd d0 c0 00 	movb   $0x0,0xc0d0bd62
        }
        io_outb(0x20, 0x20);
c0109415:	6a 20                	push   $0x20
c0109417:	6a 20                	push   $0x20
c0109419:	e8 b3 fb ff ff       	call   c0108fd1 <io_outb>
c010941e:	83 c4 08             	add    $0x8,%esp
        io_outb(0x20, 0x20);
c0109421:	6a 20                	push   $0x20
c0109423:	6a 20                	push   $0x20
c0109425:	e8 a7 fb ff ff       	call   c0108fd1 <io_outb>
c010942a:	83 c4 08             	add    $0x8,%esp
        asm volatile("sti");
c010942d:	fb                   	sti    
        return;
c010942e:	e9 7e 01 00 00       	jmp    c01095b1 <handle_keywords+0x290>
    }//if is common word, hand
    else if((scancode > 0x00 && scancode < 0x3b) ||\
c0109433:	66 83 7d f6 00       	cmpw   $0x0,-0xa(%ebp)
c0109438:	74 07                	je     c0109441 <handle_keywords+0x120>
c010943a:	66 83 7d f6 3a       	cmpw   $0x3a,-0xa(%ebp)
c010943f:	76 14                	jbe    c0109455 <handle_keywords+0x134>
c0109441:	66 81 7d f6 38 e0    	cmpw   $0xe038,-0xa(%ebp)
c0109447:	74 0c                	je     c0109455 <handle_keywords+0x134>
            (scancode == alt_r_make) || \
c0109449:	66 81 7d f6 1d e0    	cmpw   $0xe01d,-0xa(%ebp)
c010944f:	0f 85 20 01 00 00    	jne    c0109575 <handle_keywords+0x254>
            (scancode == crtl_r_make)){
        uint8_t shift = 0;
c0109455:	c6 45 f5 00          	movb   $0x0,-0xb(%ebp)
        if((scancode < 0x0e) || (scancode == 0x29) || \
c0109459:	66 83 7d f6 0d       	cmpw   $0xd,-0xa(%ebp)
c010945e:	76 3f                	jbe    c010949f <handle_keywords+0x17e>
c0109460:	66 83 7d f6 29       	cmpw   $0x29,-0xa(%ebp)
c0109465:	74 38                	je     c010949f <handle_keywords+0x17e>
c0109467:	66 83 7d f6 1a       	cmpw   $0x1a,-0xa(%ebp)
c010946c:	74 31                	je     c010949f <handle_keywords+0x17e>
           (scancode == 0x1a) || (scancode == 0x1b) ||\
c010946e:	66 83 7d f6 1b       	cmpw   $0x1b,-0xa(%ebp)
c0109473:	74 2a                	je     c010949f <handle_keywords+0x17e>
c0109475:	66 83 7d f6 2b       	cmpw   $0x2b,-0xa(%ebp)
c010947a:	74 23                	je     c010949f <handle_keywords+0x17e>
           (scancode == 0x2b) || (scancode == 0x27) ||\
c010947c:	66 83 7d f6 27       	cmpw   $0x27,-0xa(%ebp)
c0109481:	74 1c                	je     c010949f <handle_keywords+0x17e>
c0109483:	66 83 7d f6 28       	cmpw   $0x28,-0xa(%ebp)
c0109488:	74 15                	je     c010949f <handle_keywords+0x17e>
           (scancode == 0x28) || (scancode == 0x33) ||\
c010948a:	66 83 7d f6 33       	cmpw   $0x33,-0xa(%ebp)
c010948f:	74 0e                	je     c010949f <handle_keywords+0x17e>
c0109491:	66 83 7d f6 34       	cmpw   $0x34,-0xa(%ebp)
c0109496:	74 07                	je     c010949f <handle_keywords+0x17e>
           (scancode == 0x34) || (scancode == 0x35)){
c0109498:	66 83 7d f6 35       	cmpw   $0x35,-0xa(%ebp)
c010949d:	75 34                	jne    c01094d3 <handle_keywords+0x1b2>
            if(shift_down_last)
c010949f:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
c01094a3:	74 06                	je     c01094ab <handle_keywords+0x18a>
                shift = 1;
c01094a5:	c6 45 f5 01          	movb   $0x1,-0xb(%ebp)
c01094a9:	eb 28                	jmp    c01094d3 <handle_keywords+0x1b2>
            else{
                if(shift_down_last && caps_lock_last)
c01094ab:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
c01094af:	74 0c                	je     c01094bd <handle_keywords+0x19c>
c01094b1:	80 7d f2 00          	cmpb   $0x0,-0xe(%ebp)
c01094b5:	74 06                	je     c01094bd <handle_keywords+0x19c>
                    shift = 0;
c01094b7:	c6 45 f5 00          	movb   $0x0,-0xb(%ebp)
c01094bb:	eb 16                	jmp    c01094d3 <handle_keywords+0x1b2>
                else if(shift_down_last || caps_lock_last)
c01094bd:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
c01094c1:	75 06                	jne    c01094c9 <handle_keywords+0x1a8>
c01094c3:	80 7d f2 00          	cmpb   $0x0,-0xe(%ebp)
c01094c7:	74 06                	je     c01094cf <handle_keywords+0x1ae>
                    shift = 1;
c01094c9:	c6 45 f5 01          	movb   $0x1,-0xb(%ebp)
c01094cd:	eb 04                	jmp    c01094d3 <handle_keywords+0x1b2>
                else
                    shift = 0;
c01094cf:	c6 45 f5 00          	movb   $0x0,-0xb(%ebp)
                }
           }
        uint8_t index = (scancode &= 0x00ff);
c01094d3:	66 81 65 f6 ff 00    	andw   $0xff,-0xa(%ebp)
c01094d9:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c01094dd:	88 45 f0             	mov    %al,-0x10(%ebp)
        char cur_char = key_map[index][shift];
c01094e0:	0f b6 55 f0          	movzbl -0x10(%ebp),%edx
c01094e4:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
c01094e8:	0f b6 84 50 a0 d0 d0 	movzbl -0x3f2f2f60(%eax,%edx,2),%eax
c01094ef:	c0 
c01094f0:	88 45 ef             	mov    %al,-0x11(%ebp)

        if(cur_char){
c01094f3:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
c01094f7:	74 34                	je     c010952d <handle_keywords+0x20c>
            vga_put_char(cur_char);
c01094f9:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
c01094fd:	83 ec 0c             	sub    $0xc,%esp
c0109500:	50                   	push   %eax
c0109501:	e8 18 cb ff ff       	call   c010601e <vga_put_char>
c0109506:	83 c4 10             	add    $0x10,%esp
            io_outb(0x20, 0x20);
c0109509:	83 ec 08             	sub    $0x8,%esp
c010950c:	6a 20                	push   $0x20
c010950e:	6a 20                	push   $0x20
c0109510:	e8 bc fa ff ff       	call   c0108fd1 <io_outb>
c0109515:	83 c4 10             	add    $0x10,%esp
            io_outb(0x20, 0x20);
c0109518:	83 ec 08             	sub    $0x8,%esp
c010951b:	6a 20                	push   $0x20
c010951d:	6a 20                	push   $0x20
c010951f:	e8 ad fa ff ff       	call   c0108fd1 <io_outb>
c0109524:	83 c4 10             	add    $0x10,%esp
            asm volatile("sti");
c0109527:	fb                   	sti    
            return;
c0109528:	e9 84 00 00 00       	jmp    c01095b1 <handle_keywords+0x290>
        }

        if(scancode == crtl_l_make || scancode == crtl_r_make)
c010952d:	66 83 7d f6 1d       	cmpw   $0x1d,-0xa(%ebp)
c0109532:	74 08                	je     c010953c <handle_keywords+0x21b>
c0109534:	66 81 7d f6 1d e0    	cmpw   $0xe01d,-0xa(%ebp)
c010953a:	75 09                	jne    c0109545 <handle_keywords+0x224>
            crtl_status = 1;
c010953c:	c6 05 60 bd d0 c0 01 	movb   $0x1,0xc0d0bd60
c0109543:	eb 2e                	jmp    c0109573 <handle_keywords+0x252>
        else if(scancode == shift_l_make || scancode == shift_r_make)
c0109545:	66 83 7d f6 2a       	cmpw   $0x2a,-0xa(%ebp)
c010954a:	74 07                	je     c0109553 <handle_keywords+0x232>
c010954c:	66 83 7d f6 36       	cmpw   $0x36,-0xa(%ebp)
c0109551:	75 09                	jne    c010955c <handle_keywords+0x23b>
            shift_status = 1;
c0109553:	c6 05 61 bd d0 c0 01 	movb   $0x1,0xc0d0bd61
c010955a:	eb 17                	jmp    c0109573 <handle_keywords+0x252>
        else if(scancode == caps_lock_make)
c010955c:	66 83 7d f6 3a       	cmpw   $0x3a,-0xa(%ebp)
c0109561:	75 4d                	jne    c01095b0 <handle_keywords+0x28f>
            caps_lock_status = ~caps_lock_status;
c0109563:	0f b6 05 63 bd d0 c0 	movzbl 0xc0d0bd63,%eax
c010956a:	f7 d0                	not    %eax
c010956c:	a2 63 bd d0 c0       	mov    %al,0xc0d0bd63
            (scancode == crtl_r_make)){
c0109571:	eb 3d                	jmp    c01095b0 <handle_keywords+0x28f>
c0109573:	eb 3b                	jmp    c01095b0 <handle_keywords+0x28f>
    }else{
        vga_put_char((char)(scancode && 0x00ff));
c0109575:	66 83 7d f6 00       	cmpw   $0x0,-0xa(%ebp)
c010957a:	0f 95 c0             	setne  %al
c010957d:	0f b6 c0             	movzbl %al,%eax
c0109580:	0f be c0             	movsbl %al,%eax
c0109583:	83 ec 0c             	sub    $0xc,%esp
c0109586:	50                   	push   %eax
c0109587:	e8 92 ca ff ff       	call   c010601e <vga_put_char>
c010958c:	83 c4 10             	add    $0x10,%esp
        io_outb(0x20, 0x20);
c010958f:	83 ec 08             	sub    $0x8,%esp
c0109592:	6a 20                	push   $0x20
c0109594:	6a 20                	push   $0x20
c0109596:	e8 36 fa ff ff       	call   c0108fd1 <io_outb>
c010959b:	83 c4 10             	add    $0x10,%esp
        io_outb(0x20, 0x20);
c010959e:	83 ec 08             	sub    $0x8,%esp
c01095a1:	6a 20                	push   $0x20
c01095a3:	6a 20                	push   $0x20
c01095a5:	e8 27 fa ff ff       	call   c0108fd1 <io_outb>
c01095aa:	83 c4 10             	add    $0x10,%esp
        asm volatile("sti");
c01095ad:	fb                   	sti    
c01095ae:	eb 01                	jmp    c01095b1 <handle_keywords+0x290>
            (scancode == crtl_r_make)){
c01095b0:	90                   	nop
    }
c01095b1:	c9                   	leave  
c01095b2:	c3                   	ret    

c01095b3 <__llist_add>:
{
c01095b3:	55                   	push   %ebp
c01095b4:	89 e5                	mov    %esp,%ebp
    next->prev = elem;
c01095b6:	8b 45 10             	mov    0x10(%ebp),%eax
c01095b9:	8b 55 08             	mov    0x8(%ebp),%edx
c01095bc:	89 10                	mov    %edx,(%eax)
    elem->next = next;
c01095be:	8b 45 08             	mov    0x8(%ebp),%eax
c01095c1:	8b 55 10             	mov    0x10(%ebp),%edx
c01095c4:	89 50 04             	mov    %edx,0x4(%eax)
    elem->prev = prev;
c01095c7:	8b 45 08             	mov    0x8(%ebp),%eax
c01095ca:	8b 55 0c             	mov    0xc(%ebp),%edx
c01095cd:	89 10                	mov    %edx,(%eax)
    prev->next = elem;
c01095cf:	8b 45 0c             	mov    0xc(%ebp),%eax
c01095d2:	8b 55 08             	mov    0x8(%ebp),%edx
c01095d5:	89 50 04             	mov    %edx,0x4(%eax)
}
c01095d8:	90                   	nop
c01095d9:	5d                   	pop    %ebp
c01095da:	c3                   	ret    

c01095db <llist_init_head>:
static inline void llist_init_head(struct llist_header* head) {
c01095db:	55                   	push   %ebp
c01095dc:	89 e5                	mov    %esp,%ebp
    head->next = head;
c01095de:	8b 45 08             	mov    0x8(%ebp),%eax
c01095e1:	8b 55 08             	mov    0x8(%ebp),%edx
c01095e4:	89 50 04             	mov    %edx,0x4(%eax)
    head->prev = head;
c01095e7:	8b 45 08             	mov    0x8(%ebp),%eax
c01095ea:	8b 55 08             	mov    0x8(%ebp),%edx
c01095ed:	89 10                	mov    %edx,(%eax)
}
c01095ef:	90                   	nop
c01095f0:	5d                   	pop    %ebp
c01095f1:	c3                   	ret    

c01095f2 <llist_append>:
{
c01095f2:	55                   	push   %ebp
c01095f3:	89 e5                	mov    %esp,%ebp
    __llist_add(elem, head, head->next);
c01095f5:	8b 45 08             	mov    0x8(%ebp),%eax
c01095f8:	8b 40 04             	mov    0x4(%eax),%eax
c01095fb:	50                   	push   %eax
c01095fc:	ff 75 08             	push   0x8(%ebp)
c01095ff:	ff 75 0c             	push   0xc(%ebp)
c0109602:	e8 ac ff ff ff       	call   c01095b3 <__llist_add>
c0109607:	83 c4 0c             	add    $0xc,%esp
}
c010960a:	90                   	nop
c010960b:	c9                   	leave  
c010960c:	c3                   	ret    

c010960d <io_inb>:
{
c010960d:	55                   	push   %ebp
c010960e:	89 e5                	mov    %esp,%ebp
c0109610:	83 ec 10             	sub    $0x10,%esp
    asm volatile("inb %w1,%0" : "=a"(data) : "d"(port));
c0109613:	8b 45 08             	mov    0x8(%ebp),%eax
c0109616:	89 c2                	mov    %eax,%edx
c0109618:	ec                   	in     (%dx),%al
c0109619:	88 45 ff             	mov    %al,-0x1(%ebp)
    return data;
c010961c:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c0109620:	c9                   	leave  
c0109621:	c3                   	ret    

c0109622 <io_insw>:
{
c0109622:	55                   	push   %ebp
c0109623:	89 e5                	mov    %esp,%ebp
c0109625:	57                   	push   %edi
c0109626:	53                   	push   %ebx
    asm volatile("cld\n"
c0109627:	8b 55 08             	mov    0x8(%ebp),%edx
c010962a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c010962d:	8b 45 10             	mov    0x10(%ebp),%eax
c0109630:	89 cb                	mov    %ecx,%ebx
c0109632:	89 df                	mov    %ebx,%edi
c0109634:	89 c1                	mov    %eax,%ecx
c0109636:	fc                   	cld    
c0109637:	f2 66 6d             	repnz insw (%dx),%es:(%edi)
c010963a:	89 c8                	mov    %ecx,%eax
c010963c:	89 fb                	mov    %edi,%ebx
c010963e:	89 5d 0c             	mov    %ebx,0xc(%ebp)
c0109641:	89 45 10             	mov    %eax,0x10(%ebp)
}
c0109644:	90                   	nop
c0109645:	5b                   	pop    %ebx
c0109646:	5f                   	pop    %edi
c0109647:	5d                   	pop    %ebp
c0109648:	c3                   	ret    

c0109649 <io_outb>:
{
c0109649:	55                   	push   %ebp
c010964a:	89 e5                	mov    %esp,%ebp
c010964c:	83 ec 04             	sub    $0x4,%esp
c010964f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0109652:	88 45 fc             	mov    %al,-0x4(%ebp)
    asm volatile("outb %0, %w1" : : "a"(data), "d"(port));
c0109655:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0109659:	8b 55 08             	mov    0x8(%ebp),%edx
c010965c:	ee                   	out    %al,(%dx)
}
c010965d:	90                   	nop
c010965e:	c9                   	leave  
c010965f:	c3                   	ret    

c0109660 <io_outsw>:
{
c0109660:	55                   	push   %ebp
c0109661:	89 e5                	mov    %esp,%ebp
c0109663:	56                   	push   %esi
c0109664:	53                   	push   %ebx
    asm volatile("cld\n"
c0109665:	8b 55 08             	mov    0x8(%ebp),%edx
c0109668:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c010966b:	8b 45 10             	mov    0x10(%ebp),%eax
c010966e:	89 cb                	mov    %ecx,%ebx
c0109670:	89 de                	mov    %ebx,%esi
c0109672:	89 c1                	mov    %eax,%ecx
c0109674:	fc                   	cld    
c0109675:	f2 66 6f             	repnz outsw %ds:(%esi),(%dx)
c0109678:	89 c8                	mov    %ecx,%eax
c010967a:	89 f3                	mov    %esi,%ebx
c010967c:	89 5d 0c             	mov    %ebx,0xc(%ebp)
c010967f:	89 45 10             	mov    %eax,0x10(%ebp)
}
c0109682:	90                   	nop
c0109683:	5b                   	pop    %ebx
c0109684:	5e                   	pop    %esi
c0109685:	5d                   	pop    %ebp
c0109686:	c3                   	ret    

c0109687 <select_disk>:
   struct   partition_table_entry partition_table[4];       // 分区表中有4项,共64字节
   uint16_t signature;		 // 启动扇区的结束标志是0x55,0xaa,
} __attribute__ ((packed));

/* 选择读写的硬盘 */
static void select_disk(struct disk* hd) {
c0109687:	55                   	push   %ebp
c0109688:	89 e5                	mov    %esp,%ebp
c010968a:	83 ec 10             	sub    $0x10,%esp
   uint8_t reg_device = BIT_DEV_MBS | BIT_DEV_LBA;
c010968d:	c6 45 ff e0          	movb   $0xe0,-0x1(%ebp)
   if (hd->dev_no == 1) {	// 若是从盘就置DEV位为1
c0109691:	8b 45 08             	mov    0x8(%ebp),%eax
c0109694:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
c0109698:	3c 01                	cmp    $0x1,%al
c010969a:	75 04                	jne    c01096a0 <select_disk+0x19>
      reg_device |= BIT_DEV_DEV;
c010969c:	80 4d ff 10          	orb    $0x10,-0x1(%ebp)
   }
   io_outb(reg_dev(hd->my_channel), reg_device);
c01096a0:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
c01096a4:	8b 55 08             	mov    0x8(%ebp),%edx
c01096a7:	8b 52 08             	mov    0x8(%edx),%edx
c01096aa:	0f b7 52 08          	movzwl 0x8(%edx),%edx
c01096ae:	0f b7 d2             	movzwl %dx,%edx
c01096b1:	83 c2 06             	add    $0x6,%edx
c01096b4:	50                   	push   %eax
c01096b5:	52                   	push   %edx
c01096b6:	e8 8e ff ff ff       	call   c0109649 <io_outb>
c01096bb:	83 c4 08             	add    $0x8,%esp
}
c01096be:	90                   	nop
c01096bf:	c9                   	leave  
c01096c0:	c3                   	ret    

c01096c1 <select_sector>:

/* 向硬盘控制器写入起始扇区地址及要读写的扇区数 */
static void select_sector(struct disk* hd, uint32_t lba, uint8_t sec_cnt) {
c01096c1:	55                   	push   %ebp
c01096c2:	89 e5                	mov    %esp,%ebp
c01096c4:	83 ec 14             	sub    $0x14,%esp
c01096c7:	8b 45 10             	mov    0x10(%ebp),%eax
c01096ca:	88 45 ec             	mov    %al,-0x14(%ebp)
   //ASSERT(lba <= max_lba);
   struct ide_channel* channel = hd->my_channel;
c01096cd:	8b 45 08             	mov    0x8(%ebp),%eax
c01096d0:	8b 40 08             	mov    0x8(%eax),%eax
c01096d3:	89 45 fc             	mov    %eax,-0x4(%ebp)

   /* 写入要读写的扇区数*/
   io_outb(reg_sect_cnt(channel), sec_cnt);	 // 如果sec_cnt为0,则表示写入256个扇区
c01096d6:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c01096da:	8b 55 fc             	mov    -0x4(%ebp),%edx
c01096dd:	0f b7 52 08          	movzwl 0x8(%edx),%edx
c01096e1:	0f b7 d2             	movzwl %dx,%edx
c01096e4:	83 c2 02             	add    $0x2,%edx
c01096e7:	50                   	push   %eax
c01096e8:	52                   	push   %edx
c01096e9:	e8 5b ff ff ff       	call   c0109649 <io_outb>
c01096ee:	83 c4 08             	add    $0x8,%esp

   /* 写入lba地址(即扇区号) */
   io_outb(reg_lba_l(channel), lba);		 // lba地址的低8位,不用单独取出低8位.outb函数中的汇编指令outb %b0, %w1会只用al。
c01096f1:	8b 45 0c             	mov    0xc(%ebp),%eax
c01096f4:	0f b6 c0             	movzbl %al,%eax
c01096f7:	8b 55 fc             	mov    -0x4(%ebp),%edx
c01096fa:	0f b7 52 08          	movzwl 0x8(%edx),%edx
c01096fe:	0f b7 d2             	movzwl %dx,%edx
c0109701:	83 c2 03             	add    $0x3,%edx
c0109704:	50                   	push   %eax
c0109705:	52                   	push   %edx
c0109706:	e8 3e ff ff ff       	call   c0109649 <io_outb>
c010970b:	83 c4 08             	add    $0x8,%esp
   io_outb(reg_lba_m(channel), lba >> 8);		 // lba地址的8~15位
c010970e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0109711:	c1 e8 08             	shr    $0x8,%eax
c0109714:	0f b6 c0             	movzbl %al,%eax
c0109717:	8b 55 fc             	mov    -0x4(%ebp),%edx
c010971a:	0f b7 52 08          	movzwl 0x8(%edx),%edx
c010971e:	0f b7 d2             	movzwl %dx,%edx
c0109721:	83 c2 04             	add    $0x4,%edx
c0109724:	50                   	push   %eax
c0109725:	52                   	push   %edx
c0109726:	e8 1e ff ff ff       	call   c0109649 <io_outb>
c010972b:	83 c4 08             	add    $0x8,%esp
   io_outb(reg_lba_h(channel), lba >> 16);		 // lba地址的16~23位
c010972e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0109731:	c1 e8 10             	shr    $0x10,%eax
c0109734:	0f b6 c0             	movzbl %al,%eax
c0109737:	8b 55 fc             	mov    -0x4(%ebp),%edx
c010973a:	0f b7 52 08          	movzwl 0x8(%edx),%edx
c010973e:	0f b7 d2             	movzwl %dx,%edx
c0109741:	83 c2 05             	add    $0x5,%edx
c0109744:	50                   	push   %eax
c0109745:	52                   	push   %edx
c0109746:	e8 fe fe ff ff       	call   c0109649 <io_outb>
c010974b:	83 c4 08             	add    $0x8,%esp

   /* 因为lba地址的24~27位要存储在device寄存器的0～3位,
    * 无法单独写入这4位,所以在此处把device寄存器再重新写入一次*/
   io_outb(reg_dev(channel), BIT_DEV_MBS | BIT_DEV_LBA | (hd->dev_no == 1 ? BIT_DEV_DEV : 0) | lba >> 24);
c010974e:	8b 45 08             	mov    0x8(%ebp),%eax
c0109751:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
c0109755:	3c 01                	cmp    $0x1,%al
c0109757:	75 07                	jne    c0109760 <select_sector+0x9f>
c0109759:	ba f0 ff ff ff       	mov    $0xfffffff0,%edx
c010975e:	eb 05                	jmp    c0109765 <select_sector+0xa4>
c0109760:	ba e0 ff ff ff       	mov    $0xffffffe0,%edx
c0109765:	8b 45 0c             	mov    0xc(%ebp),%eax
c0109768:	c1 e8 18             	shr    $0x18,%eax
c010976b:	09 d0                	or     %edx,%eax
c010976d:	0f b6 c0             	movzbl %al,%eax
c0109770:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0109773:	0f b7 52 08          	movzwl 0x8(%edx),%edx
c0109777:	0f b7 d2             	movzwl %dx,%edx
c010977a:	83 c2 06             	add    $0x6,%edx
c010977d:	50                   	push   %eax
c010977e:	52                   	push   %edx
c010977f:	e8 c5 fe ff ff       	call   c0109649 <io_outb>
c0109784:	83 c4 08             	add    $0x8,%esp
}
c0109787:	90                   	nop
c0109788:	c9                   	leave  
c0109789:	c3                   	ret    

c010978a <cmd_out>:

/* 向通道channel发命令cmd */
static void cmd_out(struct ide_channel* channel, uint8_t cmd) {
c010978a:	55                   	push   %ebp
c010978b:	89 e5                	mov    %esp,%ebp
c010978d:	83 ec 04             	sub    $0x4,%esp
c0109790:	8b 45 0c             	mov    0xc(%ebp),%eax
c0109793:	88 45 fc             	mov    %al,-0x4(%ebp)
/* 只要向硬盘发出了命令便将此标记置为true,硬盘中断处理程序需要根据它来判断 */
   channel->expecting_intr = true;
c0109796:	8b 45 08             	mov    0x8(%ebp),%eax
c0109799:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
   io_outb(reg_cmd(channel), cmd);
c01097a0:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c01097a4:	8b 55 08             	mov    0x8(%ebp),%edx
c01097a7:	0f b7 52 08          	movzwl 0x8(%edx),%edx
c01097ab:	0f b7 d2             	movzwl %dx,%edx
c01097ae:	83 c2 07             	add    $0x7,%edx
c01097b1:	50                   	push   %eax
c01097b2:	52                   	push   %edx
c01097b3:	e8 91 fe ff ff       	call   c0109649 <io_outb>
c01097b8:	83 c4 08             	add    $0x8,%esp
}
c01097bb:	90                   	nop
c01097bc:	c9                   	leave  
c01097bd:	c3                   	ret    

c01097be <read_from_sector>:

/* 硬盘读入sec_cnt个扇区的数据到buf */
static void read_from_sector(struct disk* hd, void* buf, uint8_t sec_cnt) {
c01097be:	55                   	push   %ebp
c01097bf:	89 e5                	mov    %esp,%ebp
c01097c1:	83 ec 14             	sub    $0x14,%esp
c01097c4:	8b 45 10             	mov    0x10(%ebp),%eax
c01097c7:	88 45 ec             	mov    %al,-0x14(%ebp)
   uint32_t size_in_byte;
   if (sec_cnt == 0) {
c01097ca:	80 7d ec 00          	cmpb   $0x0,-0x14(%ebp)
c01097ce:	75 09                	jne    c01097d9 <read_from_sector+0x1b>
   /* 因为sec_cnt是8位变量,由主调函数将其赋值时,若为256则会将最高位的1丢掉变为0 */
      size_in_byte = 256 * 512;
c01097d0:	c7 45 fc 00 00 02 00 	movl   $0x20000,-0x4(%ebp)
c01097d7:	eb 0a                	jmp    c01097e3 <read_from_sector+0x25>
   } else { 
      size_in_byte = sec_cnt * 512; 
c01097d9:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c01097dd:	c1 e0 09             	shl    $0x9,%eax
c01097e0:	89 45 fc             	mov    %eax,-0x4(%ebp)
   }
   io_insw(reg_data(hd->my_channel), buf, size_in_byte / 2);
c01097e3:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01097e6:	d1 e8                	shr    %eax
c01097e8:	89 c2                	mov    %eax,%edx
c01097ea:	8b 45 08             	mov    0x8(%ebp),%eax
c01097ed:	8b 40 08             	mov    0x8(%eax),%eax
c01097f0:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c01097f4:	0f b7 c0             	movzwl %ax,%eax
c01097f7:	52                   	push   %edx
c01097f8:	ff 75 0c             	push   0xc(%ebp)
c01097fb:	50                   	push   %eax
c01097fc:	e8 21 fe ff ff       	call   c0109622 <io_insw>
c0109801:	83 c4 0c             	add    $0xc,%esp
}
c0109804:	90                   	nop
c0109805:	c9                   	leave  
c0109806:	c3                   	ret    

c0109807 <write2sector>:

/* 将buf中sec_cnt扇区的数据写入硬盘 */
static void write2sector(struct disk* hd, void* buf, uint8_t sec_cnt) {
c0109807:	55                   	push   %ebp
c0109808:	89 e5                	mov    %esp,%ebp
c010980a:	83 ec 14             	sub    $0x14,%esp
c010980d:	8b 45 10             	mov    0x10(%ebp),%eax
c0109810:	88 45 ec             	mov    %al,-0x14(%ebp)
   uint32_t size_in_byte;
   if (sec_cnt == 0) {
c0109813:	80 7d ec 00          	cmpb   $0x0,-0x14(%ebp)
c0109817:	75 09                	jne    c0109822 <write2sector+0x1b>
   /* 因为sec_cnt是8位变量,由主调函数将其赋值时,若为256则会将最高位的1丢掉变为0 */
      size_in_byte = 256 * 512;
c0109819:	c7 45 fc 00 00 02 00 	movl   $0x20000,-0x4(%ebp)
c0109820:	eb 0a                	jmp    c010982c <write2sector+0x25>
   } else { 
      size_in_byte = sec_cnt * 512; 
c0109822:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0109826:	c1 e0 09             	shl    $0x9,%eax
c0109829:	89 45 fc             	mov    %eax,-0x4(%ebp)
   }
   io_outsw(reg_data(hd->my_channel), buf, size_in_byte / 2);
c010982c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010982f:	d1 e8                	shr    %eax
c0109831:	89 c2                	mov    %eax,%edx
c0109833:	8b 45 08             	mov    0x8(%ebp),%eax
c0109836:	8b 40 08             	mov    0x8(%eax),%eax
c0109839:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c010983d:	0f b7 c0             	movzwl %ax,%eax
c0109840:	52                   	push   %edx
c0109841:	ff 75 0c             	push   0xc(%ebp)
c0109844:	50                   	push   %eax
c0109845:	e8 16 fe ff ff       	call   c0109660 <io_outsw>
c010984a:	83 c4 0c             	add    $0xc,%esp
}
c010984d:	90                   	nop
c010984e:	c9                   	leave  
c010984f:	c3                   	ret    

c0109850 <ide_read>:
//    }
//    return false;
// }

/* 从硬盘读取sec_cnt个扇区到buf */
void ide_read(struct disk* hd, uint32_t lba, void* buf, uint32_t sec_cnt) {   // 此处的sec_cnt为32位大小
c0109850:	55                   	push   %ebp
c0109851:	89 e5                	mov    %esp,%ebp
c0109853:	83 ec 58             	sub    $0x58,%esp
   //ASSERT(lba <= max_lba);
   //ASSERT(sec_cnt > 0);
   //lock_acquire (&hd->my_channel->lock);

/* 1 先选择操作的硬盘 */
   select_disk(hd);
c0109856:	ff 75 08             	push   0x8(%ebp)
c0109859:	e8 29 fe ff ff       	call   c0109687 <select_disk>
c010985e:	83 c4 04             	add    $0x4,%esp

   uint32_t secs_op;		 // 每次操作的扇区数
   uint32_t secs_done = 0;	 // 已完成的扇区数
c0109861:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   while(secs_done < sec_cnt) {
c0109868:	e9 8c 00 00 00       	jmp    c01098f9 <ide_read+0xa9>
      if ((secs_done + 256) <= sec_cnt) {
c010986d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109870:	05 00 01 00 00       	add    $0x100,%eax
c0109875:	39 45 14             	cmp    %eax,0x14(%ebp)
c0109878:	72 09                	jb     c0109883 <ide_read+0x33>
	 secs_op = 256;
c010987a:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
c0109881:	eb 09                	jmp    c010988c <ide_read+0x3c>
      } else {
	 secs_op = sec_cnt - secs_done;
c0109883:	8b 45 14             	mov    0x14(%ebp),%eax
c0109886:	2b 45 f0             	sub    -0x10(%ebp),%eax
c0109889:	89 45 f4             	mov    %eax,-0xc(%ebp)
      }

   /* 2 写入待读入的扇区数和起始扇区号 */
      select_sector(hd, lba + secs_done, secs_op);
c010988c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010988f:	0f b6 c0             	movzbl %al,%eax
c0109892:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0109895:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0109898:	01 ca                	add    %ecx,%edx
c010989a:	50                   	push   %eax
c010989b:	52                   	push   %edx
c010989c:	ff 75 08             	push   0x8(%ebp)
c010989f:	e8 1d fe ff ff       	call   c01096c1 <select_sector>
c01098a4:	83 c4 0c             	add    $0xc,%esp

   /* 3 执行的命令写入reg_cmd寄存器 */
      cmd_out(hd->my_channel, CMD_READ_SECTOR);	      // 准备开始读数据
c01098a7:	8b 45 08             	mov    0x8(%ebp),%eax
c01098aa:	8b 40 08             	mov    0x8(%eax),%eax
c01098ad:	6a 20                	push   $0x20
c01098af:	50                   	push   %eax
c01098b0:	e8 d5 fe ff ff       	call   c010978a <cmd_out>
c01098b5:	83 c4 08             	add    $0x8,%esp
//       sema_down(&hd->my_channel->disk_done);
//    /*************************************************************/

   /* 4 检测硬盘状态是否可读 */
	 char error[64];
	 kprintf(error, "%s read sector %d failed!!!!!!\n", hd->name, lba);
c01098b8:	8b 45 08             	mov    0x8(%ebp),%eax
c01098bb:	ff 75 0c             	push   0xc(%ebp)
c01098be:	50                   	push   %eax
c01098bf:	68 60 e6 d0 c0       	push   $0xc0d0e660
c01098c4:	8d 45 b0             	lea    -0x50(%ebp),%eax
c01098c7:	50                   	push   %eax
c01098c8:	e8 b4 13 00 00       	call   c010ac81 <kprintf>
c01098cd:	83 c4 10             	add    $0x10,%esp
	 //PANIC(error);

   /* 5 把数据从硬盘的缓冲区中读出 */
      read_from_sector(hd, (void*)((uint32_t)buf + secs_done * 512), secs_op);
c01098d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01098d3:	0f b6 c0             	movzbl %al,%eax
c01098d6:	8b 55 f0             	mov    -0x10(%ebp),%edx
c01098d9:	89 d1                	mov    %edx,%ecx
c01098db:	c1 e1 09             	shl    $0x9,%ecx
c01098de:	8b 55 10             	mov    0x10(%ebp),%edx
c01098e1:	01 ca                	add    %ecx,%edx
c01098e3:	83 ec 04             	sub    $0x4,%esp
c01098e6:	50                   	push   %eax
c01098e7:	52                   	push   %edx
c01098e8:	ff 75 08             	push   0x8(%ebp)
c01098eb:	e8 ce fe ff ff       	call   c01097be <read_from_sector>
c01098f0:	83 c4 10             	add    $0x10,%esp
      secs_done += secs_op;
c01098f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01098f6:	01 45 f0             	add    %eax,-0x10(%ebp)
   while(secs_done < sec_cnt) {
c01098f9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01098fc:	3b 45 14             	cmp    0x14(%ebp),%eax
c01098ff:	0f 82 68 ff ff ff    	jb     c010986d <ide_read+0x1d>
   }
   //lock_release(&hd->my_channel->lock);
}
c0109905:	90                   	nop
c0109906:	90                   	nop
c0109907:	c9                   	leave  
c0109908:	c3                   	ret    

c0109909 <ide_write>:

/* 将buf中sec_cnt扇区数据写入硬盘 */
void ide_write(struct disk* hd, uint32_t lba, void* buf, uint32_t sec_cnt) {
c0109909:	55                   	push   %ebp
c010990a:	89 e5                	mov    %esp,%ebp
c010990c:	83 ec 58             	sub    $0x58,%esp
   //ASSERT(lba <= max_lba);
   //ASSERT(sec_cnt > 0);
   //lock_acquire (&hd->my_channel->lock);

/* 1 先选择操作的硬盘 */
   select_disk(hd);
c010990f:	ff 75 08             	push   0x8(%ebp)
c0109912:	e8 70 fd ff ff       	call   c0109687 <select_disk>
c0109917:	83 c4 04             	add    $0x4,%esp

   uint32_t secs_op;		 // 每次操作的扇区数
   uint32_t secs_done = 0;	 // 已完成的扇区数
c010991a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   while(secs_done < sec_cnt) {
c0109921:	e9 8b 00 00 00       	jmp    c01099b1 <ide_write+0xa8>
      if ((secs_done + 256) <= sec_cnt) {
c0109926:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109929:	05 00 01 00 00       	add    $0x100,%eax
c010992e:	39 45 14             	cmp    %eax,0x14(%ebp)
c0109931:	72 09                	jb     c010993c <ide_write+0x33>
	 secs_op = 256;
c0109933:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
c010993a:	eb 09                	jmp    c0109945 <ide_write+0x3c>
      } else {
	 secs_op = sec_cnt - secs_done;
c010993c:	8b 45 14             	mov    0x14(%ebp),%eax
c010993f:	2b 45 f0             	sub    -0x10(%ebp),%eax
c0109942:	89 45 f4             	mov    %eax,-0xc(%ebp)
      }

   /* 2 写入待写入的扇区数和起始扇区号 */
      select_sector(hd, lba + secs_done, secs_op);		      // 先将待读的块号lba地址和待读入的扇区数写入lba寄存器
c0109945:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109948:	0f b6 c0             	movzbl %al,%eax
c010994b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c010994e:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0109951:	01 ca                	add    %ecx,%edx
c0109953:	50                   	push   %eax
c0109954:	52                   	push   %edx
c0109955:	ff 75 08             	push   0x8(%ebp)
c0109958:	e8 64 fd ff ff       	call   c01096c1 <select_sector>
c010995d:	83 c4 0c             	add    $0xc,%esp

   /* 3 执行的命令写入reg_cmd寄存器 */
      cmd_out(hd->my_channel, CMD_WRITE_SECTOR);	      // 准备开始写数据
c0109960:	8b 45 08             	mov    0x8(%ebp),%eax
c0109963:	8b 40 08             	mov    0x8(%eax),%eax
c0109966:	6a 30                	push   $0x30
c0109968:	50                   	push   %eax
c0109969:	e8 1c fe ff ff       	call   c010978a <cmd_out>
c010996e:	83 c4 08             	add    $0x8,%esp

   /* 4 检测硬盘状态是否可读 */
	 char error[64];
	 kprintf("%s write sector %d failed!!!!!!\n", hd->name, lba);
c0109971:	8b 45 08             	mov    0x8(%ebp),%eax
c0109974:	83 ec 04             	sub    $0x4,%esp
c0109977:	ff 75 0c             	push   0xc(%ebp)
c010997a:	50                   	push   %eax
c010997b:	68 80 e6 d0 c0       	push   $0xc0d0e680
c0109980:	e8 fc 12 00 00       	call   c010ac81 <kprintf>
c0109985:	83 c4 10             	add    $0x10,%esp
	 //PANIC(error);

   /* 5 将数据写入硬盘 */
      write2sector(hd, (void*)((uint32_t)buf + secs_done * 512), secs_op);
c0109988:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010998b:	0f b6 c0             	movzbl %al,%eax
c010998e:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0109991:	89 d1                	mov    %edx,%ecx
c0109993:	c1 e1 09             	shl    $0x9,%ecx
c0109996:	8b 55 10             	mov    0x10(%ebp),%edx
c0109999:	01 ca                	add    %ecx,%edx
c010999b:	83 ec 04             	sub    $0x4,%esp
c010999e:	50                   	push   %eax
c010999f:	52                   	push   %edx
c01099a0:	ff 75 08             	push   0x8(%ebp)
c01099a3:	e8 5f fe ff ff       	call   c0109807 <write2sector>
c01099a8:	83 c4 10             	add    $0x10,%esp

      /* 在硬盘响应期间阻塞自己 */
      //sema_down(&hd->my_channel->disk_done);
      secs_done += secs_op;
c01099ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01099ae:	01 45 f0             	add    %eax,-0x10(%ebp)
   while(secs_done < sec_cnt) {
c01099b1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01099b4:	3b 45 14             	cmp    0x14(%ebp),%eax
c01099b7:	0f 82 69 ff ff ff    	jb     c0109926 <ide_write+0x1d>
   }
   /* 醒来后开始释放锁*/
   //lock_release(&hd->my_channel->lock);
}
c01099bd:	90                   	nop
c01099be:	90                   	nop
c01099bf:	c9                   	leave  
c01099c0:	c3                   	ret    

c01099c1 <swap_pairs_bytes>:

/* 将dst中len个相邻字节交换位置后存入buf */
static void swap_pairs_bytes(const char* dst, char* buf, uint32_t len) {
c01099c1:	55                   	push   %ebp
c01099c2:	89 e5                	mov    %esp,%ebp
c01099c4:	83 ec 10             	sub    $0x10,%esp
   uint8_t idx;
   for (idx = 0; idx < len; idx += 2) {
c01099c7:	c6 45 ff 00          	movb   $0x0,-0x1(%ebp)
c01099cb:	eb 35                	jmp    c0109a02 <swap_pairs_bytes+0x41>
      /* buf中存储dst中两相邻元素交换位置后的字符串*/
      buf[idx + 1] = *dst++;   
c01099cd:	8b 45 08             	mov    0x8(%ebp),%eax
c01099d0:	8d 50 01             	lea    0x1(%eax),%edx
c01099d3:	89 55 08             	mov    %edx,0x8(%ebp)
c01099d6:	0f b6 55 ff          	movzbl -0x1(%ebp),%edx
c01099da:	8d 4a 01             	lea    0x1(%edx),%ecx
c01099dd:	8b 55 0c             	mov    0xc(%ebp),%edx
c01099e0:	01 ca                	add    %ecx,%edx
c01099e2:	0f b6 00             	movzbl (%eax),%eax
c01099e5:	88 02                	mov    %al,(%edx)
      buf[idx]     = *dst++;   
c01099e7:	8b 45 08             	mov    0x8(%ebp),%eax
c01099ea:	8d 50 01             	lea    0x1(%eax),%edx
c01099ed:	89 55 08             	mov    %edx,0x8(%ebp)
c01099f0:	0f b6 4d ff          	movzbl -0x1(%ebp),%ecx
c01099f4:	8b 55 0c             	mov    0xc(%ebp),%edx
c01099f7:	01 ca                	add    %ecx,%edx
c01099f9:	0f b6 00             	movzbl (%eax),%eax
c01099fc:	88 02                	mov    %al,(%edx)
   for (idx = 0; idx < len; idx += 2) {
c01099fe:	80 45 ff 02          	addb   $0x2,-0x1(%ebp)
c0109a02:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
c0109a06:	39 45 10             	cmp    %eax,0x10(%ebp)
c0109a09:	77 c2                	ja     c01099cd <swap_pairs_bytes+0xc>
   }
   buf[idx] = '\0';
c0109a0b:	0f b6 55 ff          	movzbl -0x1(%ebp),%edx
c0109a0f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0109a12:	01 d0                	add    %edx,%eax
c0109a14:	c6 00 00             	movb   $0x0,(%eax)
}
c0109a17:	90                   	nop
c0109a18:	c9                   	leave  
c0109a19:	c3                   	ret    

c0109a1a <identify_disk>:

/* 获得硬盘参数信息 */
static void identify_disk(struct disk* hd) {
c0109a1a:	55                   	push   %ebp
c0109a1b:	89 e5                	mov    %esp,%ebp
c0109a1d:	81 ec 98 02 00 00    	sub    $0x298,%esp
   char id_info[512];
   select_disk(hd);
c0109a23:	ff 75 08             	push   0x8(%ebp)
c0109a26:	e8 5c fc ff ff       	call   c0109687 <select_disk>
c0109a2b:	83 c4 04             	add    $0x4,%esp
   cmd_out(hd->my_channel, CMD_IDENTIFY);
c0109a2e:	8b 45 08             	mov    0x8(%ebp),%eax
c0109a31:	8b 40 08             	mov    0x8(%eax),%eax
c0109a34:	68 ec 00 00 00       	push   $0xec
c0109a39:	50                   	push   %eax
c0109a3a:	e8 4b fd ff ff       	call   c010978a <cmd_out>
c0109a3f:	83 c4 08             	add    $0x8,%esp
 * 待硬盘处理完成后,通过中断处理程序将自己唤醒 */
   //sema_down(&hd->my_channel->disk_done);

/* 醒来后开始执行下面代码*/
   char error[64];
   kprintf(error, "%s identify failed!!!!!!\n", hd->name);
c0109a42:	8b 45 08             	mov    0x8(%ebp),%eax
c0109a45:	83 ec 04             	sub    $0x4,%esp
c0109a48:	50                   	push   %eax
c0109a49:	68 a1 e6 d0 c0       	push   $0xc0d0e6a1
c0109a4e:	8d 85 b0 fd ff ff    	lea    -0x250(%ebp),%eax
c0109a54:	50                   	push   %eax
c0109a55:	e8 27 12 00 00       	call   c010ac81 <kprintf>
c0109a5a:	83 c4 10             	add    $0x10,%esp
   read_from_sector(hd, id_info, 1);
c0109a5d:	83 ec 04             	sub    $0x4,%esp
c0109a60:	6a 01                	push   $0x1
c0109a62:	8d 85 f0 fd ff ff    	lea    -0x210(%ebp),%eax
c0109a68:	50                   	push   %eax
c0109a69:	ff 75 08             	push   0x8(%ebp)
c0109a6c:	e8 4d fd ff ff       	call   c01097be <read_from_sector>
c0109a71:	83 c4 10             	add    $0x10,%esp

   char buf[64];
   uint8_t sn_start = 10 * 2, sn_len = 20, md_start = 27 * 2, md_len = 40;
c0109a74:	c6 45 f7 14          	movb   $0x14,-0x9(%ebp)
c0109a78:	c6 45 f6 14          	movb   $0x14,-0xa(%ebp)
c0109a7c:	c6 45 f5 36          	movb   $0x36,-0xb(%ebp)
c0109a80:	c6 45 f4 28          	movb   $0x28,-0xc(%ebp)
   swap_pairs_bytes(&id_info[sn_start], buf, sn_len);
c0109a84:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
c0109a88:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
c0109a8c:	8d 8d f0 fd ff ff    	lea    -0x210(%ebp),%ecx
c0109a92:	01 ca                	add    %ecx,%edx
c0109a94:	83 ec 04             	sub    $0x4,%esp
c0109a97:	50                   	push   %eax
c0109a98:	8d 85 70 fd ff ff    	lea    -0x290(%ebp),%eax
c0109a9e:	50                   	push   %eax
c0109a9f:	52                   	push   %edx
c0109aa0:	e8 1c ff ff ff       	call   c01099c1 <swap_pairs_bytes>
c0109aa5:	83 c4 10             	add    $0x10,%esp
   kprintf("   disk %s info:\n      SN: %s\n", hd->name, buf);
c0109aa8:	8b 45 08             	mov    0x8(%ebp),%eax
c0109aab:	83 ec 04             	sub    $0x4,%esp
c0109aae:	8d 95 70 fd ff ff    	lea    -0x290(%ebp),%edx
c0109ab4:	52                   	push   %edx
c0109ab5:	50                   	push   %eax
c0109ab6:	68 bc e6 d0 c0       	push   $0xc0d0e6bc
c0109abb:	e8 c1 11 00 00       	call   c010ac81 <kprintf>
c0109ac0:	83 c4 10             	add    $0x10,%esp
   memset(buf, 0, sizeof(buf));
c0109ac3:	83 ec 04             	sub    $0x4,%esp
c0109ac6:	6a 40                	push   $0x40
c0109ac8:	6a 00                	push   $0x0
c0109aca:	8d 85 70 fd ff ff    	lea    -0x290(%ebp),%eax
c0109ad0:	50                   	push   %eax
c0109ad1:	e8 42 14 00 00       	call   c010af18 <memset>
c0109ad6:	83 c4 10             	add    $0x10,%esp
   swap_pairs_bytes(&id_info[md_start], buf, md_len);
c0109ad9:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0109add:	0f b6 55 f5          	movzbl -0xb(%ebp),%edx
c0109ae1:	8d 8d f0 fd ff ff    	lea    -0x210(%ebp),%ecx
c0109ae7:	01 ca                	add    %ecx,%edx
c0109ae9:	83 ec 04             	sub    $0x4,%esp
c0109aec:	50                   	push   %eax
c0109aed:	8d 85 70 fd ff ff    	lea    -0x290(%ebp),%eax
c0109af3:	50                   	push   %eax
c0109af4:	52                   	push   %edx
c0109af5:	e8 c7 fe ff ff       	call   c01099c1 <swap_pairs_bytes>
c0109afa:	83 c4 10             	add    $0x10,%esp
   kprintf("      MODULE: %s\n", buf);
c0109afd:	83 ec 08             	sub    $0x8,%esp
c0109b00:	8d 85 70 fd ff ff    	lea    -0x290(%ebp),%eax
c0109b06:	50                   	push   %eax
c0109b07:	68 db e6 d0 c0       	push   $0xc0d0e6db
c0109b0c:	e8 70 11 00 00       	call   c010ac81 <kprintf>
c0109b11:	83 c4 10             	add    $0x10,%esp
   uint32_t sectors = *(uint32_t*)&id_info[60 * 2];
c0109b14:	8d 85 f0 fd ff ff    	lea    -0x210(%ebp),%eax
c0109b1a:	83 c0 78             	add    $0x78,%eax
c0109b1d:	8b 00                	mov    (%eax),%eax
c0109b1f:	89 45 f0             	mov    %eax,-0x10(%ebp)
   kprintf("      SECTORS: %d\n", sectors);
c0109b22:	83 ec 08             	sub    $0x8,%esp
c0109b25:	ff 75 f0             	push   -0x10(%ebp)
c0109b28:	68 ed e6 d0 c0       	push   $0xc0d0e6ed
c0109b2d:	e8 4f 11 00 00       	call   c010ac81 <kprintf>
c0109b32:	83 c4 10             	add    $0x10,%esp
   kprintf("      CAPACITY: %dMB\n", sectors * 512 / 1024 / 1024);
c0109b35:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109b38:	c1 e0 09             	shl    $0x9,%eax
c0109b3b:	c1 e8 14             	shr    $0x14,%eax
c0109b3e:	83 ec 08             	sub    $0x8,%esp
c0109b41:	50                   	push   %eax
c0109b42:	68 00 e7 d0 c0       	push   $0xc0d0e700
c0109b47:	e8 35 11 00 00       	call   c010ac81 <kprintf>
c0109b4c:	83 c4 10             	add    $0x10,%esp
}
c0109b4f:	90                   	nop
c0109b50:	c9                   	leave  
c0109b51:	c3                   	ret    

c0109b52 <partition_scan>:

/* 扫描硬盘hd中地址为ext_lba的扇区中的所有分区 */
static void partition_scan(struct disk* hd, uint32_t ext_lba) {
c0109b52:	55                   	push   %ebp
c0109b53:	89 e5                	mov    %esp,%ebp
c0109b55:	53                   	push   %ebx
c0109b56:	83 ec 14             	sub    $0x14,%esp
   struct boot_sector* bs = k_malloc(sizeof(struct boot_sector));
c0109b59:	83 ec 0c             	sub    $0xc,%esp
c0109b5c:	68 00 02 00 00       	push   $0x200
c0109b61:	e8 60 d4 ff ff       	call   c0106fc6 <k_malloc>
c0109b66:	83 c4 10             	add    $0x10,%esp
c0109b69:	89 45 ec             	mov    %eax,-0x14(%ebp)
   ide_read(hd, ext_lba, bs, 1);
c0109b6c:	6a 01                	push   $0x1
c0109b6e:	ff 75 ec             	push   -0x14(%ebp)
c0109b71:	ff 75 0c             	push   0xc(%ebp)
c0109b74:	ff 75 08             	push   0x8(%ebp)
c0109b77:	e8 d4 fc ff ff       	call   c0109850 <ide_read>
c0109b7c:	83 c4 10             	add    $0x10,%esp
   uint8_t part_idx = 0;
c0109b7f:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
   struct partition_table_entry* p = bs->partition_table;
c0109b83:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0109b86:	05 be 01 00 00       	add    $0x1be,%eax
c0109b8b:	89 45 f0             	mov    %eax,-0x10(%ebp)

   /* 遍历分区表4个分区表项 */
   while (part_idx++ < 4) {
c0109b8e:	e9 62 02 00 00       	jmp    c0109df5 <partition_scan+0x2a3>
      if (p->fs_type == 0x5) {	 // 若为扩展分区
c0109b93:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109b96:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c0109b9a:	3c 05                	cmp    $0x5,%al
c0109b9c:	75 4f                	jne    c0109bed <partition_scan+0x9b>
	 if (ext_lba_base != 0) { 
c0109b9e:	a1 00 c7 d0 c0       	mov    0xc0d0c700,%eax
c0109ba3:	85 c0                	test   %eax,%eax
c0109ba5:	74 21                	je     c0109bc8 <partition_scan+0x76>
	 /* 子扩展分区的start_lba是相对于主引导扇区中的总扩展分区地址 */
	    partition_scan(hd, p->start_lba + ext_lba_base);
c0109ba7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109baa:	8b 50 08             	mov    0x8(%eax),%edx
c0109bad:	a1 00 c7 d0 c0       	mov    0xc0d0c700,%eax
c0109bb2:	01 d0                	add    %edx,%eax
c0109bb4:	83 ec 08             	sub    $0x8,%esp
c0109bb7:	50                   	push   %eax
c0109bb8:	ff 75 08             	push   0x8(%ebp)
c0109bbb:	e8 92 ff ff ff       	call   c0109b52 <partition_scan>
c0109bc0:	83 c4 10             	add    $0x10,%esp
c0109bc3:	e9 29 02 00 00       	jmp    c0109df1 <partition_scan+0x29f>
	 } else { // ext_lba_base为0表示是第一次读取引导块,也就是主引导记录所在的扇区
	 /* 记录下扩展分区的起始lba地址,后面所有的扩展分区地址都相对于此 */
	    ext_lba_base = p->start_lba;
c0109bc8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109bcb:	8b 40 08             	mov    0x8(%eax),%eax
c0109bce:	a3 00 c7 d0 c0       	mov    %eax,0xc0d0c700
	    partition_scan(hd, p->start_lba);
c0109bd3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109bd6:	8b 40 08             	mov    0x8(%eax),%eax
c0109bd9:	83 ec 08             	sub    $0x8,%esp
c0109bdc:	50                   	push   %eax
c0109bdd:	ff 75 08             	push   0x8(%ebp)
c0109be0:	e8 6d ff ff ff       	call   c0109b52 <partition_scan>
c0109be5:	83 c4 10             	add    $0x10,%esp
c0109be8:	e9 04 02 00 00       	jmp    c0109df1 <partition_scan+0x29f>
	 }
      } else if (p->fs_type != 0) { // 若是有效的分区类型
c0109bed:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109bf0:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c0109bf4:	84 c0                	test   %al,%al
c0109bf6:	0f 84 f5 01 00 00    	je     c0109df1 <partition_scan+0x29f>
	 if (ext_lba == 0) {	 // 此时全是主分区
c0109bfc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0109c00:	0f 85 ec 00 00 00    	jne    c0109cf2 <partition_scan+0x1a0>
	    hd->prim_parts[p_no].start_lba = ext_lba + p->start_lba;
c0109c06:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109c09:	8b 48 08             	mov    0x8(%eax),%ecx
c0109c0c:	0f b6 05 04 c7 d0 c0 	movzbl 0xc0d0c704,%eax
c0109c13:	0f b6 d0             	movzbl %al,%edx
c0109c16:	8b 45 0c             	mov    0xc(%ebp),%eax
c0109c19:	01 c1                	add    %eax,%ecx
c0109c1b:	8b 5d 08             	mov    0x8(%ebp),%ebx
c0109c1e:	89 d0                	mov    %edx,%eax
c0109c20:	01 c0                	add    %eax,%eax
c0109c22:	01 d0                	add    %edx,%eax
c0109c24:	c1 e0 04             	shl    $0x4,%eax
c0109c27:	01 d8                	add    %ebx,%eax
c0109c29:	83 c0 10             	add    $0x10,%eax
c0109c2c:	89 08                	mov    %ecx,(%eax)
	    hd->prim_parts[p_no].sec_cnt = p->sec_cnt;
c0109c2e:	0f b6 05 04 c7 d0 c0 	movzbl 0xc0d0c704,%eax
c0109c35:	0f b6 c8             	movzbl %al,%ecx
c0109c38:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109c3b:	8b 50 0c             	mov    0xc(%eax),%edx
c0109c3e:	8b 5d 08             	mov    0x8(%ebp),%ebx
c0109c41:	89 c8                	mov    %ecx,%eax
c0109c43:	01 c0                	add    %eax,%eax
c0109c45:	01 c8                	add    %ecx,%eax
c0109c47:	c1 e0 04             	shl    $0x4,%eax
c0109c4a:	01 d8                	add    %ebx,%eax
c0109c4c:	83 c0 14             	add    $0x14,%eax
c0109c4f:	89 10                	mov    %edx,(%eax)
	    hd->prim_parts[p_no].my_disk = hd;
c0109c51:	0f b6 05 04 c7 d0 c0 	movzbl 0xc0d0c704,%eax
c0109c58:	0f b6 d0             	movzbl %al,%edx
c0109c5b:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0109c5e:	89 d0                	mov    %edx,%eax
c0109c60:	01 c0                	add    %eax,%eax
c0109c62:	01 d0                	add    %edx,%eax
c0109c64:	c1 e0 04             	shl    $0x4,%eax
c0109c67:	01 c8                	add    %ecx,%eax
c0109c69:	8d 50 18             	lea    0x18(%eax),%edx
c0109c6c:	8b 45 08             	mov    0x8(%ebp),%eax
c0109c6f:	89 02                	mov    %eax,(%edx)
	    llist_append(&partition_list, &hd->prim_parts[p_no].part_tag);
c0109c71:	0f b6 05 04 c7 d0 c0 	movzbl 0xc0d0c704,%eax
c0109c78:	0f b6 d0             	movzbl %al,%edx
c0109c7b:	89 d0                	mov    %edx,%eax
c0109c7d:	01 c0                	add    %eax,%eax
c0109c7f:	01 d0                	add    %edx,%eax
c0109c81:	c1 e0 04             	shl    $0x4,%eax
c0109c84:	8d 50 10             	lea    0x10(%eax),%edx
c0109c87:	8b 45 08             	mov    0x8(%ebp),%eax
c0109c8a:	01 d0                	add    %edx,%eax
c0109c8c:	83 c0 0c             	add    $0xc,%eax
c0109c8f:	83 ec 08             	sub    $0x8,%esp
c0109c92:	50                   	push   %eax
c0109c93:	68 08 c7 d0 c0       	push   $0xc0d0c708
c0109c98:	e8 55 f9 ff ff       	call   c01095f2 <llist_append>
c0109c9d:	83 c4 10             	add    $0x10,%esp
	    kprintf(hd->prim_parts[p_no].name, "%s%d", hd->name, p_no + 1);
c0109ca0:	0f b6 05 04 c7 d0 c0 	movzbl 0xc0d0c704,%eax
c0109ca7:	0f b6 c0             	movzbl %al,%eax
c0109caa:	8d 58 01             	lea    0x1(%eax),%ebx
c0109cad:	8b 55 08             	mov    0x8(%ebp),%edx
c0109cb0:	0f b6 05 04 c7 d0 c0 	movzbl 0xc0d0c704,%eax
c0109cb7:	0f b6 c8             	movzbl %al,%ecx
c0109cba:	89 c8                	mov    %ecx,%eax
c0109cbc:	01 c0                	add    %eax,%eax
c0109cbe:	01 c8                	add    %ecx,%eax
c0109cc0:	c1 e0 04             	shl    $0x4,%eax
c0109cc3:	8d 48 20             	lea    0x20(%eax),%ecx
c0109cc6:	8b 45 08             	mov    0x8(%ebp),%eax
c0109cc9:	01 c8                	add    %ecx,%eax
c0109ccb:	83 c0 04             	add    $0x4,%eax
c0109cce:	53                   	push   %ebx
c0109ccf:	52                   	push   %edx
c0109cd0:	68 16 e7 d0 c0       	push   $0xc0d0e716
c0109cd5:	50                   	push   %eax
c0109cd6:	e8 a6 0f 00 00       	call   c010ac81 <kprintf>
c0109cdb:	83 c4 10             	add    $0x10,%esp
	    p_no++;
c0109cde:	0f b6 05 04 c7 d0 c0 	movzbl 0xc0d0c704,%eax
c0109ce5:	83 c0 01             	add    $0x1,%eax
c0109ce8:	a2 04 c7 d0 c0       	mov    %al,0xc0d0c704
c0109ced:	e9 ff 00 00 00       	jmp    c0109df1 <partition_scan+0x29f>
	    //ASSERT(p_no < 4);	    // 0,1,2,3
	 } else {
	    hd->logic_parts[l_no].start_lba = ext_lba + p->start_lba;
c0109cf2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109cf5:	8b 48 08             	mov    0x8(%eax),%ecx
c0109cf8:	0f b6 05 05 c7 d0 c0 	movzbl 0xc0d0c705,%eax
c0109cff:	0f b6 d0             	movzbl %al,%edx
c0109d02:	8b 45 0c             	mov    0xc(%ebp),%eax
c0109d05:	01 c1                	add    %eax,%ecx
c0109d07:	8b 5d 08             	mov    0x8(%ebp),%ebx
c0109d0a:	89 d0                	mov    %edx,%eax
c0109d0c:	01 c0                	add    %eax,%eax
c0109d0e:	01 d0                	add    %edx,%eax
c0109d10:	c1 e0 04             	shl    $0x4,%eax
c0109d13:	01 d8                	add    %ebx,%eax
c0109d15:	05 d0 00 00 00       	add    $0xd0,%eax
c0109d1a:	89 08                	mov    %ecx,(%eax)
	    hd->logic_parts[l_no].sec_cnt = p->sec_cnt;
c0109d1c:	0f b6 05 05 c7 d0 c0 	movzbl 0xc0d0c705,%eax
c0109d23:	0f b6 c8             	movzbl %al,%ecx
c0109d26:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109d29:	8b 50 0c             	mov    0xc(%eax),%edx
c0109d2c:	8b 5d 08             	mov    0x8(%ebp),%ebx
c0109d2f:	89 c8                	mov    %ecx,%eax
c0109d31:	01 c0                	add    %eax,%eax
c0109d33:	01 c8                	add    %ecx,%eax
c0109d35:	c1 e0 04             	shl    $0x4,%eax
c0109d38:	01 d8                	add    %ebx,%eax
c0109d3a:	05 d4 00 00 00       	add    $0xd4,%eax
c0109d3f:	89 10                	mov    %edx,(%eax)
	    hd->logic_parts[l_no].my_disk = hd;
c0109d41:	0f b6 05 05 c7 d0 c0 	movzbl 0xc0d0c705,%eax
c0109d48:	0f b6 d0             	movzbl %al,%edx
c0109d4b:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0109d4e:	89 d0                	mov    %edx,%eax
c0109d50:	01 c0                	add    %eax,%eax
c0109d52:	01 d0                	add    %edx,%eax
c0109d54:	c1 e0 04             	shl    $0x4,%eax
c0109d57:	01 c8                	add    %ecx,%eax
c0109d59:	8d 90 d8 00 00 00    	lea    0xd8(%eax),%edx
c0109d5f:	8b 45 08             	mov    0x8(%ebp),%eax
c0109d62:	89 02                	mov    %eax,(%edx)
	    llist_append(&partition_list, &hd->logic_parts[l_no].part_tag);
c0109d64:	0f b6 05 05 c7 d0 c0 	movzbl 0xc0d0c705,%eax
c0109d6b:	0f b6 d0             	movzbl %al,%edx
c0109d6e:	89 d0                	mov    %edx,%eax
c0109d70:	01 c0                	add    %eax,%eax
c0109d72:	01 d0                	add    %edx,%eax
c0109d74:	c1 e0 04             	shl    $0x4,%eax
c0109d77:	8d 90 d0 00 00 00    	lea    0xd0(%eax),%edx
c0109d7d:	8b 45 08             	mov    0x8(%ebp),%eax
c0109d80:	01 d0                	add    %edx,%eax
c0109d82:	83 c0 0c             	add    $0xc,%eax
c0109d85:	83 ec 08             	sub    $0x8,%esp
c0109d88:	50                   	push   %eax
c0109d89:	68 08 c7 d0 c0       	push   $0xc0d0c708
c0109d8e:	e8 5f f8 ff ff       	call   c01095f2 <llist_append>
c0109d93:	83 c4 10             	add    $0x10,%esp
	    kprintf(hd->logic_parts[l_no].name, "%s%d", hd->name, l_no + 5);	 // 逻辑分区数字是从5开始,主分区是1～4.
c0109d96:	0f b6 05 05 c7 d0 c0 	movzbl 0xc0d0c705,%eax
c0109d9d:	0f b6 c0             	movzbl %al,%eax
c0109da0:	8d 58 05             	lea    0x5(%eax),%ebx
c0109da3:	8b 55 08             	mov    0x8(%ebp),%edx
c0109da6:	0f b6 05 05 c7 d0 c0 	movzbl 0xc0d0c705,%eax
c0109dad:	0f b6 c8             	movzbl %al,%ecx
c0109db0:	89 c8                	mov    %ecx,%eax
c0109db2:	01 c0                	add    %eax,%eax
c0109db4:	01 c8                	add    %ecx,%eax
c0109db6:	c1 e0 04             	shl    $0x4,%eax
c0109db9:	8d 88 e0 00 00 00    	lea    0xe0(%eax),%ecx
c0109dbf:	8b 45 08             	mov    0x8(%ebp),%eax
c0109dc2:	01 c8                	add    %ecx,%eax
c0109dc4:	83 c0 04             	add    $0x4,%eax
c0109dc7:	53                   	push   %ebx
c0109dc8:	52                   	push   %edx
c0109dc9:	68 16 e7 d0 c0       	push   $0xc0d0e716
c0109dce:	50                   	push   %eax
c0109dcf:	e8 ad 0e 00 00       	call   c010ac81 <kprintf>
c0109dd4:	83 c4 10             	add    $0x10,%esp
	    l_no++;
c0109dd7:	0f b6 05 05 c7 d0 c0 	movzbl 0xc0d0c705,%eax
c0109dde:	83 c0 01             	add    $0x1,%eax
c0109de1:	a2 05 c7 d0 c0       	mov    %al,0xc0d0c705
	    if (l_no >= 8)    // 只支持8个逻辑分区,避免数组越界
c0109de6:	0f b6 05 05 c7 d0 c0 	movzbl 0xc0d0c705,%eax
c0109ded:	3c 07                	cmp    $0x7,%al
c0109def:	77 26                	ja     c0109e17 <partition_scan+0x2c5>
	       return;
	 }
      } 
      p++;
c0109df1:	83 45 f0 10          	addl   $0x10,-0x10(%ebp)
   while (part_idx++ < 4) {
c0109df5:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0109df9:	8d 50 01             	lea    0x1(%eax),%edx
c0109dfc:	88 55 f7             	mov    %dl,-0x9(%ebp)
c0109dff:	3c 03                	cmp    $0x3,%al
c0109e01:	0f 86 8c fd ff ff    	jbe    c0109b93 <partition_scan+0x41>
   }
   malloc_free(bs);
c0109e07:	83 ec 0c             	sub    $0xc,%esp
c0109e0a:	ff 75 ec             	push   -0x14(%ebp)
c0109e0d:	e8 6f d1 ff ff       	call   c0106f81 <malloc_free>
c0109e12:	83 c4 10             	add    $0x10,%esp
c0109e15:	eb 01                	jmp    c0109e18 <partition_scan+0x2c6>
	       return;
c0109e17:	90                   	nop
}
c0109e18:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0109e1b:	c9                   	leave  
c0109e1c:	c3                   	ret    

c0109e1d <partition_info>:

/* 打印分区信息 */
 static bool partition_info(struct list_elem* pelem, int arg UNUSED) {
c0109e1d:	55                   	push   %ebp
c0109e1e:	89 e5                	mov    %esp,%ebp
c0109e20:	83 ec 18             	sub    $0x18,%esp
    struct partition* part = elem2entry(struct partition, part_tag, pelem);
c0109e23:	8b 45 08             	mov    0x8(%ebp),%eax
c0109e26:	83 e8 0c             	sub    $0xc,%eax
c0109e29:	89 45 f4             	mov    %eax,-0xc(%ebp)
    kprintf("   %s start_lba:0x%x, sec_cnt:0x%x\n",part->name, part->start_lba, part->sec_cnt);
c0109e2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109e2f:	8b 50 04             	mov    0x4(%eax),%edx
c0109e32:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109e35:	8b 00                	mov    (%eax),%eax
c0109e37:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c0109e3a:	83 c1 14             	add    $0x14,%ecx
c0109e3d:	52                   	push   %edx
c0109e3e:	50                   	push   %eax
c0109e3f:	51                   	push   %ecx
c0109e40:	68 1c e7 d0 c0       	push   $0xc0d0e71c
c0109e45:	e8 37 0e 00 00       	call   c010ac81 <kprintf>
c0109e4a:	83 c4 10             	add    $0x10,%esp

// /* 在此处return false与函数本身功能无关,
//  * 只是为了让主调函数list_traversal继续向下遍历元素 */
    return false;
c0109e4d:	b8 00 00 00 00       	mov    $0x0,%eax
 }
c0109e52:	c9                   	leave  
c0109e53:	c3                   	ret    

c0109e54 <intr_hd_handler>:

/* 硬盘中断处理程序 */
void intr_hd_handler(isr_param* param) {
c0109e54:	55                   	push   %ebp
c0109e55:	89 e5                	mov    %esp,%ebp
c0109e57:	83 ec 10             	sub    $0x10,%esp
   //ASSERT(irq_no == 0x2e || irq_no == 0x2f);
   uint8_t irq_no = param->vector;
c0109e5a:	8b 45 08             	mov    0x8(%ebp),%eax
c0109e5d:	8b 40 20             	mov    0x20(%eax),%eax
c0109e60:	88 45 ff             	mov    %al,-0x1(%ebp)
   uint8_t ch_no = irq_no - 0x2e;
c0109e63:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
c0109e67:	83 e8 2e             	sub    $0x2e,%eax
c0109e6a:	88 45 fe             	mov    %al,-0x2(%ebp)
   struct ide_channel* channel = &channels[ch_no];
c0109e6d:	0f b6 45 fe          	movzbl -0x2(%ebp),%eax
c0109e71:	69 c0 b0 04 00 00    	imul   $0x4b0,%eax,%eax
c0109e77:	05 a0 bd d0 c0       	add    $0xc0d0bda0,%eax
c0109e7c:	89 45 f8             	mov    %eax,-0x8(%ebp)
   //ASSERT(channel->irq_no == irq_no);
/* 不必担心此中断是否对应的是这一次的expecting_intr,
 * 每次读写硬盘时会申请锁,从而保证了同步一致性 */
   if (channel->expecting_intr) {
c0109e7f:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0109e82:	8b 40 0c             	mov    0xc(%eax),%eax
c0109e85:	85 c0                	test   %eax,%eax
c0109e87:	74 20                	je     c0109ea9 <intr_hd_handler+0x55>
      channel->expecting_intr = false;
c0109e89:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0109e8c:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
      //sema_up(&channel->disk_done);

/* 读取状态寄存器使硬盘控制器认为此次的中断已被处理,
 * 从而硬盘可以继续执行新的读写 */
      io_inb(reg_status(channel));
c0109e93:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0109e96:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0109e9a:	0f b7 c0             	movzwl %ax,%eax
c0109e9d:	83 c0 07             	add    $0x7,%eax
c0109ea0:	50                   	push   %eax
c0109ea1:	e8 67 f7 ff ff       	call   c010960d <io_inb>
c0109ea6:	83 c4 04             	add    $0x4,%esp
   }
}
c0109ea9:	90                   	nop
c0109eaa:	c9                   	leave  
c0109eab:	c3                   	ret    

c0109eac <ide_init>:

/* 硬盘数据结构初始化 */
void ide_init() {
c0109eac:	55                   	push   %ebp
c0109ead:	89 e5                	mov    %esp,%ebp
c0109eaf:	83 ec 18             	sub    $0x18,%esp
   //printk("ide_init start\n");
   uint8_t hd_cnt = *((uint8_t*)(0x475));	      // 获取硬盘的数量
c0109eb2:	b8 75 04 00 00       	mov    $0x475,%eax
c0109eb7:	0f b6 00             	movzbl (%eax),%eax
c0109eba:	88 45 f5             	mov    %al,-0xb(%ebp)
   //ASSERT(hd_cnt > 0);
   llist_init_head(&partition_list);
c0109ebd:	68 08 c7 d0 c0       	push   $0xc0d0c708
c0109ec2:	e8 14 f7 ff ff       	call   c01095db <llist_init_head>
c0109ec7:	83 c4 04             	add    $0x4,%esp
   channel_cnt = DIV_ROUND_UP(hd_cnt, 2);	   // 一个ide通道上有两个硬盘,根据硬盘数量反推有几个ide通道
c0109eca:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
c0109ece:	83 c0 01             	add    $0x1,%eax
c0109ed1:	89 c2                	mov    %eax,%edx
c0109ed3:	c1 ea 1f             	shr    $0x1f,%edx
c0109ed6:	01 d0                	add    %edx,%eax
c0109ed8:	d1 f8                	sar    %eax
c0109eda:	a2 80 bd d0 c0       	mov    %al,0xc0d0bd80
   struct ide_channel* channel;
   uint8_t channel_no = 0, dev_no = 0; 
c0109edf:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
c0109ee3:	c6 45 f6 00          	movb   $0x0,-0xa(%ebp)

   /* 处理每个通道上的硬盘 */
   while (channel_no < channel_cnt) {
c0109ee7:	e9 4e 01 00 00       	jmp    c010a03a <ide_init+0x18e>
      channel = &channels[channel_no];
c0109eec:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0109ef0:	69 c0 b0 04 00 00    	imul   $0x4b0,%eax,%eax
c0109ef6:	05 a0 bd d0 c0       	add    $0xc0d0bda0,%eax
c0109efb:	89 45 f0             	mov    %eax,-0x10(%ebp)
      kprintf("ide%d", channel_no);
c0109efe:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0109f02:	83 ec 08             	sub    $0x8,%esp
c0109f05:	50                   	push   %eax
c0109f06:	68 40 e7 d0 c0       	push   $0xc0d0e740
c0109f0b:	e8 71 0d 00 00       	call   c010ac81 <kprintf>
c0109f10:	83 c4 10             	add    $0x10,%esp

      /* 为每个ide通道初始化端口基址及中断向量 */
      switch (channel_no) {
c0109f13:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0109f17:	85 c0                	test   %eax,%eax
c0109f19:	74 07                	je     c0109f22 <ide_init+0x76>
c0109f1b:	83 f8 01             	cmp    $0x1,%eax
c0109f1e:	74 14                	je     c0109f34 <ide_init+0x88>
c0109f20:	eb 23                	jmp    c0109f45 <ide_init+0x99>
	 case 0:
	    channel->port_base	 = 0x1f0;	   // ide0通道的起始端口号是0x1f0
c0109f22:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109f25:	66 c7 40 08 f0 01    	movw   $0x1f0,0x8(%eax)
	    channel->irq_no	 = 0x20 + 14;	   // 从片8259a上倒数第二的中断引脚,温盘,也就是ide0通道的的中断向量号
c0109f2b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109f2e:	c6 40 0a 2e          	movb   $0x2e,0xa(%eax)
	    break;
c0109f32:	eb 11                	jmp    c0109f45 <ide_init+0x99>
	 case 1:
	    channel->port_base	 = 0x170;	   // ide1通道的起始端口号是0x170
c0109f34:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109f37:	66 c7 40 08 70 01    	movw   $0x170,0x8(%eax)
	    channel->irq_no	 = 0x20 + 15;	   // 从8259A上的最后一个中断引脚,我们用来响应ide1通道上的硬盘中断
c0109f3d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109f40:	c6 40 0a 2f          	movb   $0x2f,0xa(%eax)
	    break;
c0109f44:	90                   	nop
      }

      channel->expecting_intr = false;		   // 未向硬盘写入指令时不期待硬盘的中断
c0109f45:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109f48:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)

   /* 初始化为0,目的是向硬盘控制器请求数据后,硬盘驱动sema_down此信号量会阻塞线程,
   直到硬盘完成后通过发中断,由中断处理程序将此信号量sema_up,唤醒线程. */
      //sema_init(&channel->disk_done, 0);

      intr_subscribe(0x20 + 14, intr_hd_handler);
c0109f4f:	83 ec 08             	sub    $0x8,%esp
c0109f52:	68 54 9e 10 c0       	push   $0xc0109e54
c0109f57:	6a 2e                	push   $0x2e
c0109f59:	e8 1f df ff ff       	call   c0107e7d <intr_subscribe>
c0109f5e:	83 c4 10             	add    $0x10,%esp
      intr_subscribe(0x20 + 15, intr_hd_handler);
c0109f61:	83 ec 08             	sub    $0x8,%esp
c0109f64:	68 54 9e 10 c0       	push   $0xc0109e54
c0109f69:	6a 2f                	push   $0x2f
c0109f6b:	e8 0d df ff ff       	call   c0107e7d <intr_subscribe>
c0109f70:	83 c4 10             	add    $0x10,%esp

      _set_idt_entry(0x20 + 14, 0x08, &intr_hd_handler1, 0);
c0109f73:	6a 00                	push   $0x0
c0109f75:	68 c1 81 10 c0       	push   $0xc01081c1
c0109f7a:	6a 08                	push   $0x8
c0109f7c:	6a 2e                	push   $0x2e
c0109f7e:	e8 bc ed ff ff       	call   c0108d3f <_set_idt_entry>
c0109f83:	83 c4 10             	add    $0x10,%esp
      _set_idt_entry(0x20 + 15, 0x08, &intr_hd_handler2, 0);
c0109f86:	6a 00                	push   $0x0
c0109f88:	68 c7 81 10 c0       	push   $0xc01081c7
c0109f8d:	6a 08                	push   $0x8
c0109f8f:	6a 2f                	push   $0x2f
c0109f91:	e8 a9 ed ff ff       	call   c0108d3f <_set_idt_entry>
c0109f96:	83 c4 10             	add    $0x10,%esp
      /* 分别获取两个硬盘的参数及分区信息 */
      while (dev_no < 2) {
c0109f99:	e9 84 00 00 00       	jmp    c010a022 <ide_init+0x176>
	 struct disk* hd = &channel->devices[dev_no];
c0109f9e:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
c0109fa2:	69 c0 50 02 00 00    	imul   $0x250,%eax,%eax
c0109fa8:	8d 50 10             	lea    0x10(%eax),%edx
c0109fab:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109fae:	01 d0                	add    %edx,%eax
c0109fb0:	89 45 ec             	mov    %eax,-0x14(%ebp)
	 hd->my_channel = channel;
c0109fb3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0109fb6:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0109fb9:	89 50 08             	mov    %edx,0x8(%eax)
	 hd->dev_no = dev_no;
c0109fbc:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0109fbf:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
c0109fc3:	88 50 0c             	mov    %dl,0xc(%eax)
	 kprintf("sd%c", 'a' + channel_no * 2 + dev_no);
c0109fc6:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0109fca:	01 c0                	add    %eax,%eax
c0109fcc:	8d 50 61             	lea    0x61(%eax),%edx
c0109fcf:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
c0109fd3:	01 d0                	add    %edx,%eax
c0109fd5:	83 ec 08             	sub    $0x8,%esp
c0109fd8:	50                   	push   %eax
c0109fd9:	68 46 e7 d0 c0       	push   $0xc0d0e746
c0109fde:	e8 9e 0c 00 00       	call   c010ac81 <kprintf>
c0109fe3:	83 c4 10             	add    $0x10,%esp
	 identify_disk(hd);	 // 获取硬盘参数
c0109fe6:	83 ec 0c             	sub    $0xc,%esp
c0109fe9:	ff 75 ec             	push   -0x14(%ebp)
c0109fec:	e8 29 fa ff ff       	call   c0109a1a <identify_disk>
c0109ff1:	83 c4 10             	add    $0x10,%esp
	 if (dev_no != 0) {	 // 内核本身的裸硬盘(hd60M.img)不处理
c0109ff4:	80 7d f6 00          	cmpb   $0x0,-0xa(%ebp)
c0109ff8:	74 10                	je     c010a00a <ide_init+0x15e>
	    partition_scan(hd, 0);  // 扫描该硬盘上的分区  
c0109ffa:	83 ec 08             	sub    $0x8,%esp
c0109ffd:	6a 00                	push   $0x0
c0109fff:	ff 75 ec             	push   -0x14(%ebp)
c010a002:	e8 4b fb ff ff       	call   c0109b52 <partition_scan>
c010a007:	83 c4 10             	add    $0x10,%esp
	 }
	 p_no = 0, l_no = 0;
c010a00a:	c6 05 04 c7 d0 c0 00 	movb   $0x0,0xc0d0c704
c010a011:	c6 05 05 c7 d0 c0 00 	movb   $0x0,0xc0d0c705
	 dev_no++; 
c010a018:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
c010a01c:	83 c0 01             	add    $0x1,%eax
c010a01f:	88 45 f6             	mov    %al,-0xa(%ebp)
      while (dev_no < 2) {
c010a022:	80 7d f6 01          	cmpb   $0x1,-0xa(%ebp)
c010a026:	0f 86 72 ff ff ff    	jbe    c0109f9e <ide_init+0xf2>
      }
      dev_no = 0;			  	   // 将硬盘驱动器号置0,为下一个channel的两个硬盘初始化。
c010a02c:	c6 45 f6 00          	movb   $0x0,-0xa(%ebp)
      channel_no++;				   // 下一个channel
c010a030:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c010a034:	83 c0 01             	add    $0x1,%eax
c010a037:	88 45 f7             	mov    %al,-0x9(%ebp)
   while (channel_no < channel_cnt) {
c010a03a:	0f b6 05 80 bd d0 c0 	movzbl 0xc0d0bd80,%eax
c010a041:	38 45 f7             	cmp    %al,-0x9(%ebp)
c010a044:	0f 82 a2 fe ff ff    	jb     c0109eec <ide_init+0x40>
   }

   //kprintf("\n   all partition info\n");
   /* 打印所有分区信息 */
   //list_traversal(&partition_list, partition_info, (int)NULL);
   kprintf("ide_init done\n");
c010a04a:	83 ec 0c             	sub    $0xc,%esp
c010a04d:	68 4b e7 d0 c0       	push   $0xc0d0e74b
c010a052:	e8 2a 0c 00 00       	call   c010ac81 <kprintf>
c010a057:	83 c4 10             	add    $0x10,%esp
}
c010a05a:	90                   	nop
c010a05b:	c9                   	leave  
c010a05c:	c3                   	ret    

c010a05d <syscall>:
{
c010a05d:	55                   	push   %ebp
c010a05e:	89 e5                	mov    %esp,%ebp
c010a060:	57                   	push   %edi
    asm volatile("int %0" ::"i"(0x80), "D"(callcode) : "eax");
c010a061:	8b 55 08             	mov    0x8(%ebp),%edx
c010a064:	89 d7                	mov    %edx,%edi
c010a066:	cd 80                	int    $0x80
}
c010a068:	90                   	nop
c010a069:	8b 7d fc             	mov    -0x4(%ebp),%edi
c010a06c:	c9                   	leave  
c010a06d:	c3                   	ret    

c010a06e <syscall_install>:
#include <kernel/process/peocess.h>
#include <syscall/syscall.h>

extern void syscall_handlr(isr_param* param);

void syscall_install() {
c010a06e:	55                   	push   %ebp
c010a06f:	89 e5                	mov    %esp,%ebp
c010a071:	83 ec 08             	sub    $0x8,%esp
    intr_subscribe(MELOX_SYS_CALL, syscall_handlr);
c010a074:	83 ec 08             	sub    $0x8,%esp
c010a077:	68 8c a0 10 c0       	push   $0xc010a08c
c010a07c:	68 80 00 00 00       	push   $0x80
c010a081:	e8 f7 dd ff ff       	call   c0107e7d <intr_subscribe>
c010a086:	83 c4 10             	add    $0x10,%esp
}
c010a089:	90                   	nop
c010a08a:	c9                   	leave  
c010a08b:	c3                   	ret    

c010a08c <syscall_handlr>:
c010a08c:	55                   	push   %ebp
c010a08d:	8b 6c 24 08          	mov    0x8(%esp),%ebp
c010a091:	8b 45 00             	mov    0x0(%ebp),%eax
c010a094:	3d 00 01 00 00       	cmp    $0x100,%eax
c010a099:	73 0d                	jae    c010a0a8 <syscall_handlr+0x1c>
c010a09b:	c1 e0 02             	shl    $0x2,%eax
c010a09e:	05 74 d1 d0 c0       	add    $0xc0d0d174,%eax
c010a0a3:	83 38 00             	cmpl   $0x0,(%eax)
c010a0a6:	75 04                	jne    c010a0ac <syscall_handlr+0x20>
c010a0a8:	f7 d8                	neg    %eax
c010a0aa:	5d                   	pop    %ebp
c010a0ab:	c3                   	ret    
c010a0ac:	ff 75 18             	push   0x18(%ebp)
c010a0af:	ff 75 14             	push   0x14(%ebp)
c010a0b2:	ff 75 10             	push   0x10(%ebp)
c010a0b5:	ff 75 0c             	push   0xc(%ebp)
c010a0b8:	ff 75 08             	push   0x8(%ebp)
c010a0bb:	ff 75 04             	push   0x4(%ebp)
c010a0be:	ff 10                	call   *(%eax)
c010a0c0:	89 45 00             	mov    %eax,0x0(%ebp)
c010a0c3:	83 c4 18             	add    $0x18,%esp
c010a0c6:	5d                   	pop    %ebp
c010a0c7:	c3                   	ret    

c010a0c8 <__assert_fail>:
#include <common.h>
#include <libs/mstdio.h>

static char buffer[1024];

void __assert_fail(const char* expr, const char* file, unsigned int line) {
c010a0c8:	55                   	push   %ebp
c010a0c9:	89 e5                	mov    %esp,%ebp
c010a0cb:	57                   	push   %edi
c010a0cc:	83 ec 04             	sub    $0x4,%esp
    kprintf(buffer, "%s (%s:%u)", expr, file, line);
c010a0cf:	83 ec 0c             	sub    $0xc,%esp
c010a0d2:	ff 75 10             	push   0x10(%ebp)
c010a0d5:	ff 75 0c             	push   0xc(%ebp)
c010a0d8:	ff 75 08             	push   0x8(%ebp)
c010a0db:	68 5a e7 d0 c0       	push   $0xc0d0e75a
c010a0e0:	68 20 c7 d0 c0       	push   $0xc0d0c720
c010a0e5:	e8 97 0b 00 00       	call   c010ac81 <kprintf>
c010a0ea:	83 c4 20             	add    $0x20,%esp

    // Here we load the buffer's address into %edi ("D" constraint)
    //  This is a convention we made that the LUNAIX_SYS_PANIC syscall will
    //  print the panic message passed via %edi. (see kernel/asm/x86/interrupts.c)
    asm(
c010a0ed:	b8 20 c7 d0 c0       	mov    $0xc0d0c720,%eax
c010a0f2:	89 c7                	mov    %eax,%edi
c010a0f4:	cd 20                	int    $0x20
        "int %0"
        ::"i"(32), "D"(buffer)
    );

    while(1);     // never reach
c010a0f6:	eb fe                	jmp    c010a0f6 <__assert_fail+0x2e>

c010a0f8 <cpu_rcr3>:
{
c010a0f8:	55                   	push   %ebp
c010a0f9:	89 e5                	mov    %esp,%ebp
c010a0fb:	83 ec 10             	sub    $0x10,%esp
    asm volatile("movl %%cr3,%0" : "=r" (val));
c010a0fe:	0f 20 d8             	mov    %cr3,%eax
c010a101:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return val;
c010a104:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c010a107:	c9                   	leave  
c010a108:	c3                   	ret    

c010a109 <cpu_invplg>:
{
c010a109:	55                   	push   %ebp
c010a10a:	89 e5                	mov    %esp,%ebp
    asm volatile("invlpg (%0)" ::"r"((unsigned int)va) : "memory");
c010a10c:	8b 45 08             	mov    0x8(%ebp),%eax
c010a10f:	0f 01 38             	invlpg (%eax)
};
c010a112:	90                   	nop
c010a113:	5d                   	pop    %ebp
c010a114:	c3                   	ret    

c010a115 <llist_init_head>:
static inline void llist_init_head(struct llist_header* head) {
c010a115:	55                   	push   %ebp
c010a116:	89 e5                	mov    %esp,%ebp
    head->next = head;
c010a118:	8b 45 08             	mov    0x8(%ebp),%eax
c010a11b:	8b 55 08             	mov    0x8(%ebp),%edx
c010a11e:	89 50 04             	mov    %edx,0x4(%eax)
    head->prev = head;
c010a121:	8b 45 08             	mov    0x8(%ebp),%eax
c010a124:	8b 55 08             	mov    0x8(%ebp),%edx
c010a127:	89 10                	mov    %edx,(%eax)
}
c010a129:	90                   	nop
c010a12a:	5d                   	pop    %ebp
c010a12b:	c3                   	ret    

c010a12c <syscall>:
{
c010a12c:	55                   	push   %ebp
c010a12d:	89 e5                	mov    %esp,%ebp
c010a12f:	57                   	push   %edi
    asm volatile("int %0" ::"i"(0x80), "D"(callcode) : "eax");
c010a130:	8b 55 08             	mov    0x8(%ebp),%edx
c010a133:	89 d7                	mov    %edx,%edi
c010a135:	cd 80                	int    $0x80
}
c010a137:	90                   	nop
c010a138:	8b 7d fc             	mov    -0x4(%ebp),%edi
c010a13b:	c9                   	leave  
c010a13c:	c3                   	ret    

c010a13d <__mxsys_fork>:
#include <libs/mstdio.h>

extern volatile struct m_pcb* __current;//TODO MOVE TO .H AND TODO SCHEDULE

__DEFINE_MXSYSCALL(pid_t, fork)
{
c010a13d:	55                   	push   %ebp
c010a13e:	89 e5                	mov    %esp,%ebp
c010a140:	83 ec 08             	sub    $0x8,%esp
    return m_fork();
c010a143:	e8 a5 02 00 00       	call   c010a3ed <m_fork>
}
c010a148:	c9                   	leave  
c010a149:	c3                   	ret    

c010a14a <__mxsys_getpid>:

__DEFINE_MXSYSCALL(pid_t, getpid)
{
c010a14a:	55                   	push   %ebp
c010a14b:	89 e5                	mov    %esp,%ebp
    return __current->pid;
c010a14d:	a1 20 cb d0 c0       	mov    0xc0d0cb20,%eax
c010a152:	8b 00                	mov    (%eax),%eax
}
c010a154:	5d                   	pop    %ebp
c010a155:	c3                   	ret    

c010a156 <__mxsys_getppid>:

__DEFINE_MXSYSCALL(pid_t, getppid)
{
c010a156:	55                   	push   %ebp
c010a157:	89 e5                	mov    %esp,%ebp
    return __current->parent->pid;
c010a159:	a1 20 cb d0 c0       	mov    0xc0d0cb20,%eax
c010a15e:	8b 40 04             	mov    0x4(%eax),%eax
c010a161:	8b 00                	mov    (%eax),%eax
}
c010a163:	5d                   	pop    %ebp
c010a164:	c3                   	ret    

c010a165 <init_proc>:

void init_proc(struct m_pcb* pcb)
{
c010a165:	55                   	push   %ebp
c010a166:	89 e5                	mov    %esp,%ebp
c010a168:	83 ec 08             	sub    $0x8,%esp
    memset(pcb, 0, sizeof(*pcb));
c010a16b:	83 ec 04             	sub    $0x4,%esp
c010a16e:	6a 6c                	push   $0x6c
c010a170:	6a 00                	push   $0x0
c010a172:	ff 75 08             	push   0x8(%ebp)
c010a175:	e8 9e 0d 00 00       	call   c010af18 <memset>
c010a17a:	83 c4 10             	add    $0x10,%esp

    pcb->pid = alloc_pid();
c010a17d:	e8 c3 07 00 00       	call   c010a945 <alloc_pid>
c010a182:	8b 55 08             	mov    0x8(%ebp),%edx
c010a185:	89 02                	mov    %eax,(%edx)
    pcb->state = PROC_CREATED;
c010a187:	8b 45 08             	mov    0x8(%ebp),%eax
c010a18a:	c6 40 44 10          	movb   $0x10,0x44(%eax)
    pcb->pro_ticks = 10;
c010a18e:	8b 45 08             	mov    0x8(%ebp),%eax
c010a191:	c7 40 5c 0a 00 00 00 	movl   $0xa,0x5c(%eax)
}
c010a198:	90                   	nop
c010a199:	c9                   	leave  
c010a19a:	c3                   	ret    

c010a19b <copy_pagetable>:

void* copy_pagetable(pid_t pid, uintptr_t mount_point)
{
c010a19b:	55                   	push   %ebp
c010a19c:	89 e5                	mov    %esp,%ebp
c010a19e:	83 ec 38             	sub    $0x38,%esp
    uint32_t a;
    if(pid == 1)
c010a1a1:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c010a1a5:	75 08                	jne    c010a1af <copy_pagetable+0x14>
        a = cpu_rcr3();
c010a1a7:	e8 4c ff ff ff       	call   c010a0f8 <cpu_rcr3>
c010a1ac:	89 45 ec             	mov    %eax,-0x14(%ebp)
    void* ptd_pp = pmm_alloc_page(pid, PP_FGPERSIST);
c010a1af:	83 ec 08             	sub    $0x8,%esp
c010a1b2:	6a 01                	push   $0x1
c010a1b4:	ff 75 08             	push   0x8(%ebp)
c010a1b7:	e8 af c6 ff ff       	call   c010686b <pmm_alloc_page>
c010a1bc:	83 c4 10             	add    $0x10,%esp
c010a1bf:	89 45 e8             	mov    %eax,-0x18(%ebp)
    pt_t* ptd = vmm_cover_map_page(pid, PD_MOUNT_1, ptd_pp, PG_PREM_RW,PG_PREM_RW);
c010a1c2:	83 ec 0c             	sub    $0xc,%esp
c010a1c5:	6a 03                	push   $0x3
c010a1c7:	6a 03                	push   $0x3
c010a1c9:	ff 75 e8             	push   -0x18(%ebp)
c010a1cc:	68 00 00 c0 af       	push   $0xafc00000
c010a1d1:	ff 75 08             	push   0x8(%ebp)
c010a1d4:	e8 e3 d4 ff ff       	call   c01076bc <vmm_cover_map_page>
c010a1d9:	83 c4 20             	add    $0x20,%esp
c010a1dc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    ptd_t* pptd = (ptd_t*)(mount_point | (0x3FF << 12));
c010a1df:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a1e2:	0d 00 f0 3f 00       	or     $0x3ff000,%eax
c010a1e7:	89 45 e0             	mov    %eax,-0x20(%ebp)

    for (size_t i = 0; i < PG_MAX_ENTRIES - 1; i++) {
c010a1ea:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c010a1f1:	e9 f8 00 00 00       	jmp    c010a2ee <copy_pagetable+0x153>
        ptd_t ptde = pptd[i];
c010a1f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010a1f9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010a200:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010a203:	01 d0                	add    %edx,%eax
c010a205:	8b 00                	mov    (%eax),%eax
c010a207:	89 45 dc             	mov    %eax,-0x24(%ebp)
        if (!ptde || !(ptde & PG_PRESENT)) {
c010a20a:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c010a20e:	74 0a                	je     c010a21a <copy_pagetable+0x7f>
c010a210:	8b 45 dc             	mov    -0x24(%ebp),%eax
c010a213:	83 e0 01             	and    $0x1,%eax
c010a216:	85 c0                	test   %eax,%eax
c010a218:	75 19                	jne    c010a233 <copy_pagetable+0x98>
            ptd[i] = ptde;
c010a21a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010a21d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010a224:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010a227:	01 c2                	add    %eax,%edx
c010a229:	8b 45 dc             	mov    -0x24(%ebp),%eax
c010a22c:	89 02                	mov    %eax,(%edx)
            continue;
c010a22e:	e9 b7 00 00 00       	jmp    c010a2ea <copy_pagetable+0x14f>
        }

        pt_t* ppt = (pt_t*)(mount_point | (i << 12));
c010a233:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010a236:	c1 e0 0c             	shl    $0xc,%eax
c010a239:	0b 45 0c             	or     0xc(%ebp),%eax
c010a23c:	89 45 d8             	mov    %eax,-0x28(%ebp)
        void* pt_pp = pmm_alloc_page(pid, PP_FGPERSIST);
c010a23f:	83 ec 08             	sub    $0x8,%esp
c010a242:	6a 01                	push   $0x1
c010a244:	ff 75 08             	push   0x8(%ebp)
c010a247:	e8 1f c6 ff ff       	call   c010686b <pmm_alloc_page>
c010a24c:	83 c4 10             	add    $0x10,%esp
c010a24f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        // if(pid == 1)
        //     kprintf("index%d,p0pde%x ", i, pt_pp);
        pt_t* pt = vmm_cover_map_page(pid, PG_MOUNT_2, pt_pp, PG_PREM_RW,PG_PREM_RW);
c010a252:	83 ec 0c             	sub    $0xc,%esp
c010a255:	6a 03                	push   $0x3
c010a257:	6a 03                	push   $0x3
c010a259:	ff 75 d4             	push   -0x2c(%ebp)
c010a25c:	68 00 e0 7f af       	push   $0xaf7fe000
c010a261:	ff 75 08             	push   0x8(%ebp)
c010a264:	e8 53 d4 ff ff       	call   c01076bc <vmm_cover_map_page>
c010a269:	83 c4 20             	add    $0x20,%esp
c010a26c:	89 45 d0             	mov    %eax,-0x30(%ebp)
        for (size_t j = 0; j < PG_MAX_ENTRIES; j++) {
c010a26f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c010a276:	eb 43                	jmp    c010a2bb <copy_pagetable+0x120>
            pt_t pte = ppt[j];
c010a278:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010a27b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010a282:	8b 45 d8             	mov    -0x28(%ebp),%eax
c010a285:	01 d0                	add    %edx,%eax
c010a287:	8b 00                	mov    (%eax),%eax
c010a289:	89 45 cc             	mov    %eax,-0x34(%ebp)
            pmm_ref_page(pid, PG_ENTRY_ADDR(pte));
c010a28c:	8b 45 cc             	mov    -0x34(%ebp),%eax
c010a28f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010a294:	83 ec 08             	sub    $0x8,%esp
c010a297:	50                   	push   %eax
c010a298:	ff 75 08             	push   0x8(%ebp)
c010a29b:	e8 9b c7 ff ff       	call   c0106a3b <pmm_ref_page>
c010a2a0:	83 c4 10             	add    $0x10,%esp
            pt[j] = pte;
c010a2a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010a2a6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010a2ad:	8b 45 d0             	mov    -0x30(%ebp),%eax
c010a2b0:	01 c2                	add    %eax,%edx
c010a2b2:	8b 45 cc             	mov    -0x34(%ebp),%eax
c010a2b5:	89 02                	mov    %eax,(%edx)
        for (size_t j = 0; j < PG_MAX_ENTRIES; j++) {
c010a2b7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c010a2bb:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
c010a2c2:	76 b4                	jbe    c010a278 <copy_pagetable+0xdd>
        }
        ptd[i] = (uint32_t)pt_pp | PG_PREM_RW;
c010a2c4:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c010a2c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010a2ca:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
c010a2d1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010a2d4:	01 c8                	add    %ecx,%eax
c010a2d6:	83 ca 03             	or     $0x3,%edx
c010a2d9:	89 10                	mov    %edx,(%eax)
        cpu_invplg(ptde);
c010a2db:	8b 45 dc             	mov    -0x24(%ebp),%eax
c010a2de:	83 ec 0c             	sub    $0xc,%esp
c010a2e1:	50                   	push   %eax
c010a2e2:	e8 22 fe ff ff       	call   c010a109 <cpu_invplg>
c010a2e7:	83 c4 10             	add    $0x10,%esp
    for (size_t i = 0; i < PG_MAX_ENTRIES - 1; i++) {
c010a2ea:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010a2ee:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
c010a2f5:	0f 86 fb fe ff ff    	jbe    c010a1f6 <copy_pagetable+0x5b>
    }
    ptd[PG_MAX_ENTRIES - 1] = PDE(T_SELF_REF_PERM, ptd_pp);
c010a2fb:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010a2fe:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010a303:	89 c2                	mov    %eax,%edx
c010a305:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010a308:	05 fc 0f 00 00       	add    $0xffc,%eax
c010a30d:	83 ca 1b             	or     $0x1b,%edx
c010a310:	89 10                	mov    %edx,(%eax)
    //pt_t* ppt = (pt_t*)(0xffc00000);
    //uint32_t b = ppt[1];
    return ptd_pp;
c010a312:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
c010a315:	c9                   	leave  
c010a316:	c3                   	ret    

c010a317 <setup_proc_mem>:

void* setup_proc_mem(struct m_pcb* proc, uintptr_t usedMnt)
{
c010a317:	55                   	push   %ebp
c010a318:	89 e5                	mov    %esp,%ebp
c010a31a:	83 ec 28             	sub    $0x28,%esp
    // copy the entire kernel page table
    pid_t pid = proc->pid;
c010a31d:	8b 45 08             	mov    0x8(%ebp),%eax
c010a320:	8b 00                	mov    (%eax),%eax
c010a322:	89 45 f0             	mov    %eax,-0x10(%ebp)
    void* pt_copy = copy_pagetable(pid, usedMnt);
c010a325:	83 ec 08             	sub    $0x8,%esp
c010a328:	ff 75 0c             	push   0xc(%ebp)
c010a32b:	ff 75 f0             	push   -0x10(%ebp)
c010a32e:	e8 68 fe ff ff       	call   c010a19b <copy_pagetable>
c010a333:	83 c4 10             	add    $0x10,%esp
c010a336:	89 45 ec             	mov    %eax,-0x14(%ebp)
    vmm_unmount_pd(PD_MOUNT_1);
c010a339:	83 ec 0c             	sub    $0xc,%esp
c010a33c:	68 00 00 c0 af       	push   $0xafc00000
c010a341:	e8 14 d8 ff ff       	call   c0107b5a <vmm_unmount_pd>
c010a346:	83 c4 10             	add    $0x10,%esp
    vmm_mount_pd(PD_MOUNT_2, pt_copy); // 将新进程的页表挂载到挂载点#2
c010a349:	83 ec 08             	sub    $0x8,%esp
c010a34c:	ff 75 ec             	push   -0x14(%ebp)
c010a34f:	68 00 00 80 af       	push   $0xaf800000
c010a354:	e8 c2 d7 ff ff       	call   c0107b1b <vmm_mount_pd>
c010a359:	83 c4 10             	add    $0x10,%esp
    //kprintf("pid%d, cr3%x ",pid, pt_copy);
    // copy the kernel stack
    int c = 0;
c010a35c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    for (size_t i = KSTACK_START >> 12; i <= (KSATCK_TOP >> 12); i++) {
c010a363:	c7 45 f4 f0 fb 0f 00 	movl   $0xffbf0,-0xc(%ebp)
c010a36a:	eb 6c                	jmp    c010a3d8 <setup_proc_mem+0xc1>
        volatile pt_t* ppte = &PTE_MOUNTED(PD_MOUNT_2, i);//get the stack page phy addr address point
c010a36c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010a36f:	25 ff 03 00 00       	and    $0x3ff,%eax
c010a374:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010a37b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010a37e:	c1 e0 02             	shl    $0x2,%eax
c010a381:	25 00 f0 3f 00       	and    $0x3ff000,%eax
c010a386:	0d 00 00 80 af       	or     $0xaf800000,%eax
c010a38b:	01 d0                	add    %edx,%eax
c010a38d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        //kprintf("ppte0x%x", ppte);
        /*
            The TLB caching keep the rewrite to PTE
            from updating. 
        */
        cpu_invplg(ppte);
c010a390:	83 ec 0c             	sub    $0xc,%esp
c010a393:	ff 75 e4             	push   -0x1c(%ebp)
c010a396:	e8 6e fd ff ff       	call   c010a109 <cpu_invplg>
c010a39b:	83 c4 10             	add    $0x10,%esp

        pt_t p = *ppte;
c010a39e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010a3a1:	8b 00                	mov    (%eax),%eax
c010a3a3:	89 45 e0             	mov    %eax,-0x20(%ebp)
        //kprintf("inex %d, padd%x ", c++, p);
        void* ppa = vmm_dup_page(pid, PG_ENTRY_ADDR(p));
c010a3a6:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010a3a9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010a3ae:	83 ec 08             	sub    $0x8,%esp
c010a3b1:	50                   	push   %eax
c010a3b2:	ff 75 f0             	push   -0x10(%ebp)
c010a3b5:	e8 cf d6 ff ff       	call   c0107a89 <vmm_dup_page>
c010a3ba:	83 c4 10             	add    $0x10,%esp
c010a3bd:	89 45 dc             	mov    %eax,-0x24(%ebp)
        //kprintf("ppa0x%x ", ppa);
        *ppte = (p & 0xfff) | (uintptr_t)ppa;
c010a3c0:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010a3c3:	25 ff 0f 00 00       	and    $0xfff,%eax
c010a3c8:	89 c2                	mov    %eax,%edx
c010a3ca:	8b 45 dc             	mov    -0x24(%ebp),%eax
c010a3cd:	09 c2                	or     %eax,%edx
c010a3cf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010a3d2:	89 10                	mov    %edx,(%eax)
    for (size_t i = KSTACK_START >> 12; i <= (KSATCK_TOP >> 12); i++) {
c010a3d4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010a3d8:	81 7d f4 ff fb 0f 00 	cmpl   $0xffbff,-0xc(%ebp)
c010a3df:	76 8b                	jbe    c010a36c <setup_proc_mem+0x55>
    // 定义用户栈区域，但是不分配实际的物理页。我们会在Page fault
    // handler里面实现动态分配物理页的逻辑。
    // if(pid == 0)
    //     proc->page_table = __current->page_table;
    // else
    proc->page_table = pt_copy;
c010a3e1:	8b 45 08             	mov    0x8(%ebp),%eax
c010a3e4:	8b 55 ec             	mov    -0x14(%ebp),%edx
c010a3e7:	89 50 64             	mov    %edx,0x64(%eax)
}
c010a3ea:	90                   	nop
c010a3eb:	c9                   	leave  
c010a3ec:	c3                   	ret    

c010a3ed <m_fork>:

pid_t m_fork()
{
c010a3ed:	55                   	push   %ebp
c010a3ee:	89 e5                	mov    %esp,%ebp
c010a3f0:	81 ec a8 00 00 00    	sub    $0xa8,%esp
    struct m_pcb curr_pcb;
    init_proc(&curr_pcb);
c010a3f6:	83 ec 0c             	sub    $0xc,%esp
c010a3f9:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
c010a3ff:	50                   	push   %eax
c010a400:	e8 60 fd ff ff       	call   c010a165 <init_proc>
c010a405:	83 c4 10             	add    $0x10,%esp

    curr_pcb.process_mm = __current->process_mm;
c010a408:	a1 20 cb d0 c0       	mov    0xc0d0cb20,%eax
c010a40d:	8b 40 58             	mov    0x58(%eax),%eax
c010a410:	89 45 bc             	mov    %eax,-0x44(%ebp)
    curr_pcb.intr_contxt = __current->intr_contxt;
c010a413:	a1 20 cb d0 c0       	mov    0xc0d0cb20,%eax
c010a418:	8b 50 08             	mov    0x8(%eax),%edx
c010a41b:	89 95 6c ff ff ff    	mov    %edx,-0x94(%ebp)
c010a421:	8b 50 0c             	mov    0xc(%eax),%edx
c010a424:	89 95 70 ff ff ff    	mov    %edx,-0x90(%ebp)
c010a42a:	8b 50 10             	mov    0x10(%eax),%edx
c010a42d:	89 95 74 ff ff ff    	mov    %edx,-0x8c(%ebp)
c010a433:	8b 50 14             	mov    0x14(%eax),%edx
c010a436:	89 95 78 ff ff ff    	mov    %edx,-0x88(%ebp)
c010a43c:	8b 50 18             	mov    0x18(%eax),%edx
c010a43f:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c010a445:	8b 50 1c             	mov    0x1c(%eax),%edx
c010a448:	89 55 80             	mov    %edx,-0x80(%ebp)
c010a44b:	8b 50 20             	mov    0x20(%eax),%edx
c010a44e:	89 55 84             	mov    %edx,-0x7c(%ebp)
c010a451:	8b 50 24             	mov    0x24(%eax),%edx
c010a454:	89 55 88             	mov    %edx,-0x78(%ebp)
c010a457:	8b 50 28             	mov    0x28(%eax),%edx
c010a45a:	89 55 8c             	mov    %edx,-0x74(%ebp)
c010a45d:	8b 50 2c             	mov    0x2c(%eax),%edx
c010a460:	89 55 90             	mov    %edx,-0x70(%ebp)
c010a463:	8b 50 30             	mov    0x30(%eax),%edx
c010a466:	89 55 94             	mov    %edx,-0x6c(%ebp)
c010a469:	8b 50 34             	mov    0x34(%eax),%edx
c010a46c:	89 55 98             	mov    %edx,-0x68(%ebp)
c010a46f:	8b 50 38             	mov    0x38(%eax),%edx
c010a472:	89 55 9c             	mov    %edx,-0x64(%ebp)
c010a475:	8b 50 3c             	mov    0x3c(%eax),%edx
c010a478:	89 55 a0             	mov    %edx,-0x60(%ebp)
c010a47b:	8b 40 40             	mov    0x40(%eax),%eax
c010a47e:	89 45 a4             	mov    %eax,-0x5c(%ebp)
    curr_pcb.parent = __current;
c010a481:	a1 20 cb d0 c0       	mov    0xc0d0cb20,%eax
c010a486:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)

#ifdef USE_KERNEL_PG
    setup_proc_mem(&pcb, PD_MOUNT_1); //挂载点#1是当前进程的页表
#else
    setup_proc_mem(&curr_pcb, PD_REFERENCED);
c010a48c:	83 ec 08             	sub    $0x8,%esp
c010a48f:	68 00 00 c0 ff       	push   $0xffc00000
c010a494:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
c010a49a:	50                   	push   %eax
c010a49b:	e8 77 fe ff ff       	call   c010a317 <setup_proc_mem>
c010a4a0:	83 c4 10             	add    $0x10,%esp
#endif

        // 根据 mm_region 进一步配置页表
    if (!__current->process_mm) {
c010a4a3:	a1 20 cb d0 c0       	mov    0xc0d0cb20,%eax
c010a4a8:	8b 40 58             	mov    0x58(%eax),%eax
c010a4ab:	85 c0                	test   %eax,%eax
c010a4ad:	0f 84 68 01 00 00    	je     c010a61b <m_fork+0x22e>
        goto not_copy;
    }

    llist_init_head(&curr_pcb.process_mm);
c010a4b3:	83 ec 0c             	sub    $0xc,%esp
c010a4b6:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
c010a4bc:	83 c0 58             	add    $0x58,%eax
c010a4bf:	50                   	push   %eax
c010a4c0:	e8 50 fc ff ff       	call   c010a115 <llist_init_head>
c010a4c5:	83 c4 10             	add    $0x10,%esp
    struct mm_region *pos, *n;
    llist_for_each(pos, n, &__current->process_mm->head, head)
c010a4c8:	a1 20 cb d0 c0       	mov    0xc0d0cb20,%eax
c010a4cd:	8b 40 58             	mov    0x58(%eax),%eax
c010a4d0:	8b 40 04             	mov    0x4(%eax),%eax
c010a4d3:	89 45 e8             	mov    %eax,-0x18(%ebp)
c010a4d6:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010a4d9:	89 45 f4             	mov    %eax,-0xc(%ebp)
c010a4dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010a4df:	8b 40 04             	mov    0x4(%eax),%eax
c010a4e2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c010a4e5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010a4e8:	89 45 f0             	mov    %eax,-0x10(%ebp)
c010a4eb:	e9 18 01 00 00       	jmp    c010a608 <m_fork+0x21b>
    {
        region_add(&curr_pcb, pos->start, pos->end, pos->attr);
c010a4f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010a4f3:	8b 48 10             	mov    0x10(%eax),%ecx
c010a4f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010a4f9:	8b 50 0c             	mov    0xc(%eax),%edx
c010a4fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010a4ff:	8b 40 08             	mov    0x8(%eax),%eax
c010a502:	51                   	push   %ecx
c010a503:	52                   	push   %edx
c010a504:	50                   	push   %eax
c010a505:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
c010a50b:	50                   	push   %eax
c010a50c:	e8 2d cd ff ff       	call   c010723e <region_add>
c010a511:	83 c4 10             	add    $0x10,%esp

        // 如果写共享，则不作处理。
        if ((pos->attr & REGION_WSHARED)) {
c010a514:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010a517:	8b 40 10             	mov    0x10(%eax),%eax
c010a51a:	83 e0 02             	and    $0x2,%eax
c010a51d:	85 c0                	test   %eax,%eax
c010a51f:	0f 85 cd 00 00 00    	jne    c010a5f2 <m_fork+0x205>
            continue;
        }

        uintptr_t start_vpn = PG_ALIGN(pos->start) >> 12;
c010a525:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010a528:	8b 40 08             	mov    0x8(%eax),%eax
c010a52b:	c1 e8 0c             	shr    $0xc,%eax
c010a52e:	89 45 e0             	mov    %eax,-0x20(%ebp)
        uintptr_t end_vpn = PG_ALIGN(pos->end) >> 12;
c010a531:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010a534:	8b 40 0c             	mov    0xc(%eax),%eax
c010a537:	c1 e8 0c             	shr    $0xc,%eax
c010a53a:	89 45 dc             	mov    %eax,-0x24(%ebp)
        for (size_t i = start_vpn; i < end_vpn; i++) {
c010a53d:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010a540:	89 45 ec             	mov    %eax,-0x14(%ebp)
c010a543:	e9 9c 00 00 00       	jmp    c010a5e4 <m_fork+0x1f7>
            pt_t* curproc = &PTE_MOUNTED(PD_MOUNT_1, i);
c010a548:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010a54b:	25 ff 03 00 00       	and    $0x3ff,%eax
c010a550:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010a557:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010a55a:	c1 e0 02             	shl    $0x2,%eax
c010a55d:	25 00 f0 3f 00       	and    $0x3ff000,%eax
c010a562:	0d 00 00 c0 af       	or     $0xafc00000,%eax
c010a567:	01 d0                	add    %edx,%eax
c010a569:	89 45 d8             	mov    %eax,-0x28(%ebp)
            pt_t* newproc = &PTE_MOUNTED(PD_MOUNT_2, i);
c010a56c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010a56f:	25 ff 03 00 00       	and    $0x3ff,%eax
c010a574:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010a57b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010a57e:	c1 e0 02             	shl    $0x2,%eax
c010a581:	25 00 f0 3f 00       	and    $0x3ff000,%eax
c010a586:	0d 00 00 80 af       	or     $0xaf800000,%eax
c010a58b:	01 d0                	add    %edx,%eax
c010a58d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
            cpu_invplg(newproc);
c010a590:	83 ec 0c             	sub    $0xc,%esp
c010a593:	ff 75 d4             	push   -0x2c(%ebp)
c010a596:	e8 6e fb ff ff       	call   c010a109 <cpu_invplg>
c010a59b:	83 c4 10             	add    $0x10,%esp

            if (pos->attr == REGION_RSHARED) {
c010a59e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010a5a1:	8b 40 10             	mov    0x10(%eax),%eax
c010a5a4:	83 f8 01             	cmp    $0x1,%eax
c010a5a7:	75 2e                	jne    c010a5d7 <m_fork+0x1ea>
                // 如果读共享，则将两者的都标注为只读，那么任何写入都将会应用COW策略。
                cpu_invplg(curproc);
c010a5a9:	83 ec 0c             	sub    $0xc,%esp
c010a5ac:	ff 75 d8             	push   -0x28(%ebp)
c010a5af:	e8 55 fb ff ff       	call   c010a109 <cpu_invplg>
c010a5b4:	83 c4 10             	add    $0x10,%esp
                *curproc = *curproc & ~PG_WRITE;
c010a5b7:	8b 45 d8             	mov    -0x28(%ebp),%eax
c010a5ba:	8b 00                	mov    (%eax),%eax
c010a5bc:	83 e0 fd             	and    $0xfffffffd,%eax
c010a5bf:	89 c2                	mov    %eax,%edx
c010a5c1:	8b 45 d8             	mov    -0x28(%ebp),%eax
c010a5c4:	89 10                	mov    %edx,(%eax)
                *newproc = *newproc & ~PG_WRITE;
c010a5c6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c010a5c9:	8b 00                	mov    (%eax),%eax
c010a5cb:	83 e0 fd             	and    $0xfffffffd,%eax
c010a5ce:	89 c2                	mov    %eax,%edx
c010a5d0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c010a5d3:	89 10                	mov    %edx,(%eax)
c010a5d5:	eb 09                	jmp    c010a5e0 <m_fork+0x1f3>
            } else {
                // 如果是私有页，则将该页从新进程中移除。
                *newproc = 0;
c010a5d7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c010a5da:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        for (size_t i = start_vpn; i < end_vpn; i++) {
c010a5e0:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c010a5e4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010a5e7:	3b 45 dc             	cmp    -0x24(%ebp),%eax
c010a5ea:	0f 82 58 ff ff ff    	jb     c010a548 <m_fork+0x15b>
c010a5f0:	eb 01                	jmp    c010a5f3 <m_fork+0x206>
            continue;
c010a5f2:	90                   	nop
    llist_for_each(pos, n, &__current->process_mm->head, head)
c010a5f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010a5f6:	89 45 f4             	mov    %eax,-0xc(%ebp)
c010a5f9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010a5fc:	8b 40 04             	mov    0x4(%eax),%eax
c010a5ff:	89 45 d0             	mov    %eax,-0x30(%ebp)
c010a602:	8b 45 d0             	mov    -0x30(%ebp),%eax
c010a605:	89 45 f0             	mov    %eax,-0x10(%ebp)
c010a608:	a1 20 cb d0 c0       	mov    0xc0d0cb20,%eax
c010a60d:	8b 40 58             	mov    0x58(%eax),%eax
c010a610:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c010a613:	0f 85 d7 fe ff ff    	jne    c010a4f0 <m_fork+0x103>
            }
        }
    }

not_copy:
c010a619:	eb 01                	jmp    c010a61c <m_fork+0x22f>
        goto not_copy;
c010a61b:	90                   	nop
    vmm_unmount_pd(PD_MOUNT_2);
c010a61c:	83 ec 0c             	sub    $0xc,%esp
c010a61f:	68 00 00 80 af       	push   $0xaf800000
c010a624:	e8 31 d5 ff ff       	call   c0107b5a <vmm_unmount_pd>
c010a629:	83 c4 10             	add    $0x10,%esp
    vmm_unmount_pd(PD_MOUNT_1);
c010a62c:	83 ec 0c             	sub    $0xc,%esp
c010a62f:	68 00 00 c0 af       	push   $0xafc00000
c010a634:	e8 21 d5 ff ff       	call   c0107b5a <vmm_unmount_pd>
c010a639:	83 c4 10             	add    $0x10,%esp
    vmm_unmount_pd(PG_MOUNT_2);
c010a63c:	83 ec 0c             	sub    $0xc,%esp
c010a63f:	68 00 e0 7f af       	push   $0xaf7fe000
c010a644:	e8 11 d5 ff ff       	call   c0107b5a <vmm_unmount_pd>
c010a649:	83 c4 10             	add    $0x10,%esp
    // 正如同fork，返回两次。
    curr_pcb.intr_contxt.registers.eax = 0;
c010a64c:	c7 85 6c ff ff ff 00 	movl   $0x0,-0x94(%ebp)
c010a653:	00 00 00 

    push_process(&curr_pcb);
c010a656:	83 ec 0c             	sub    $0xc,%esp
c010a659:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
c010a65f:	50                   	push   %eax
c010a660:	e8 34 03 00 00       	call   c010a999 <push_process>
c010a665:	83 c4 10             	add    $0x10,%esp
    return curr_pcb.pid;
c010a668:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
}
c010a66e:	c9                   	leave  
c010a66f:	c3                   	ret    

c010a670 <__del_pagetable>:

void __del_pagetable(pid_t pid, uintptr_t mount_point)
{
c010a670:	55                   	push   %ebp
c010a671:	89 e5                	mov    %esp,%ebp
c010a673:	83 ec 28             	sub    $0x28,%esp
    ptd_t* pptd = (ptd_t*)(mount_point | (0x3FF << 12));
c010a676:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a679:	0d 00 f0 3f 00       	or     $0x3ff000,%eax
c010a67e:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (size_t i = 0; i < PG_MAX_ENTRIES - 1; i++) {
c010a681:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c010a688:	e9 99 00 00 00       	jmp    c010a726 <__del_pagetable+0xb6>
        ptd_t ptde = pptd[i];
c010a68d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010a690:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010a697:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010a69a:	01 d0                	add    %edx,%eax
c010a69c:	8b 00                	mov    (%eax),%eax
c010a69e:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if (!ptde || !(ptde & PG_PRESENT)) {
c010a6a1:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c010a6a5:	74 7a                	je     c010a721 <__del_pagetable+0xb1>
c010a6a7:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010a6aa:	83 e0 01             	and    $0x1,%eax
c010a6ad:	85 c0                	test   %eax,%eax
c010a6af:	74 70                	je     c010a721 <__del_pagetable+0xb1>
            continue;
        }

        pt_t* ppt = (pt_t*)(mount_point | (i << 12));
c010a6b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010a6b4:	c1 e0 0c             	shl    $0xc,%eax
c010a6b7:	0b 45 0c             	or     0xc(%ebp),%eax
c010a6ba:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        for (size_t j = 0; j < PG_MAX_ENTRIES; j++) {
c010a6bd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c010a6c4:	eb 39                	jmp    c010a6ff <__del_pagetable+0x8f>
            pt_t pte = ppt[j];
c010a6c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010a6c9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010a6d0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010a6d3:	01 d0                	add    %edx,%eax
c010a6d5:	8b 00                	mov    (%eax),%eax
c010a6d7:	89 45 e0             	mov    %eax,-0x20(%ebp)
            // free the 4KB data page
            if ((pte & PG_PRESENT)) {
c010a6da:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010a6dd:	83 e0 01             	and    $0x1,%eax
c010a6e0:	85 c0                	test   %eax,%eax
c010a6e2:	74 17                	je     c010a6fb <__del_pagetable+0x8b>
                pmm_free_page(pid, PG_ENTRY_ADDR(pte));
c010a6e4:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010a6e7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010a6ec:	83 ec 08             	sub    $0x8,%esp
c010a6ef:	50                   	push   %eax
c010a6f0:	ff 75 08             	push   0x8(%ebp)
c010a6f3:	e8 ba c2 ff ff       	call   c01069b2 <pmm_free_page>
c010a6f8:	83 c4 10             	add    $0x10,%esp
        for (size_t j = 0; j < PG_MAX_ENTRIES; j++) {
c010a6fb:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c010a6ff:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
c010a706:	76 be                	jbe    c010a6c6 <__del_pagetable+0x56>
            }
        }
        // free the L2 page table
        pmm_free_page(pid, PG_ENTRY_ADDR(ptde));
c010a708:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010a70b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010a710:	83 ec 08             	sub    $0x8,%esp
c010a713:	50                   	push   %eax
c010a714:	ff 75 08             	push   0x8(%ebp)
c010a717:	e8 96 c2 ff ff       	call   c01069b2 <pmm_free_page>
c010a71c:	83 c4 10             	add    $0x10,%esp
c010a71f:	eb 01                	jmp    c010a722 <__del_pagetable+0xb2>
            continue;
c010a721:	90                   	nop
    for (size_t i = 0; i < PG_MAX_ENTRIES - 1; i++) {
c010a722:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010a726:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
c010a72d:	0f 86 5a ff ff ff    	jbe    c010a68d <__del_pagetable+0x1d>
    }
    // free the L1 directory
    pmm_free_page(pid, PG_ENTRY_ADDR(pptd[PG_MAX_ENTRIES - 1]));
c010a733:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010a736:	05 fc 0f 00 00       	add    $0xffc,%eax
c010a73b:	8b 00                	mov    (%eax),%eax
c010a73d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010a742:	83 ec 08             	sub    $0x8,%esp
c010a745:	50                   	push   %eax
c010a746:	ff 75 08             	push   0x8(%ebp)
c010a749:	e8 64 c2 ff ff       	call   c01069b2 <pmm_free_page>
c010a74e:	83 c4 10             	add    $0x10,%esp
c010a751:	90                   	nop
c010a752:	c9                   	leave  
c010a753:	c3                   	ret    

c010a754 <__llist_add>:
{
c010a754:	55                   	push   %ebp
c010a755:	89 e5                	mov    %esp,%ebp
    next->prev = elem;
c010a757:	8b 45 10             	mov    0x10(%ebp),%eax
c010a75a:	8b 55 08             	mov    0x8(%ebp),%edx
c010a75d:	89 10                	mov    %edx,(%eax)
    elem->next = next;
c010a75f:	8b 45 08             	mov    0x8(%ebp),%eax
c010a762:	8b 55 10             	mov    0x10(%ebp),%edx
c010a765:	89 50 04             	mov    %edx,0x4(%eax)
    elem->prev = prev;
c010a768:	8b 45 08             	mov    0x8(%ebp),%eax
c010a76b:	8b 55 0c             	mov    0xc(%ebp),%edx
c010a76e:	89 10                	mov    %edx,(%eax)
    prev->next = elem;
c010a770:	8b 45 0c             	mov    0xc(%ebp),%eax
c010a773:	8b 55 08             	mov    0x8(%ebp),%edx
c010a776:	89 50 04             	mov    %edx,0x4(%eax)
}
c010a779:	90                   	nop
c010a77a:	5d                   	pop    %ebp
c010a77b:	c3                   	ret    

c010a77c <llist_init_head>:
static inline void llist_init_head(struct llist_header* head) {
c010a77c:	55                   	push   %ebp
c010a77d:	89 e5                	mov    %esp,%ebp
    head->next = head;
c010a77f:	8b 45 08             	mov    0x8(%ebp),%eax
c010a782:	8b 55 08             	mov    0x8(%ebp),%edx
c010a785:	89 50 04             	mov    %edx,0x4(%eax)
    head->prev = head;
c010a788:	8b 45 08             	mov    0x8(%ebp),%eax
c010a78b:	8b 55 08             	mov    0x8(%ebp),%edx
c010a78e:	89 10                	mov    %edx,(%eax)
}
c010a790:	90                   	nop
c010a791:	5d                   	pop    %ebp
c010a792:	c3                   	ret    

c010a793 <llist_append>:
{
c010a793:	55                   	push   %ebp
c010a794:	89 e5                	mov    %esp,%ebp
    __llist_add(elem, head, head->next);
c010a796:	8b 45 08             	mov    0x8(%ebp),%eax
c010a799:	8b 40 04             	mov    0x4(%eax),%eax
c010a79c:	50                   	push   %eax
c010a79d:	ff 75 08             	push   0x8(%ebp)
c010a7a0:	ff 75 0c             	push   0xc(%ebp)
c010a7a3:	e8 ac ff ff ff       	call   c010a754 <__llist_add>
c010a7a8:	83 c4 0c             	add    $0xc,%esp
}
c010a7ab:	90                   	nop
c010a7ac:	c9                   	leave  
c010a7ad:	c3                   	ret    

c010a7ae <llist_empty>:

static inline int llist_empty(struct llist_header* elem) {
c010a7ae:	55                   	push   %ebp
c010a7af:	89 e5                	mov    %esp,%ebp
    return elem->next == elem;
c010a7b1:	8b 45 08             	mov    0x8(%ebp),%eax
c010a7b4:	8b 40 04             	mov    0x4(%eax),%eax
c010a7b7:	39 45 08             	cmp    %eax,0x8(%ebp)
c010a7ba:	0f 94 c0             	sete   %al
c010a7bd:	0f b6 c0             	movzbl %al,%eax
}
c010a7c0:	5d                   	pop    %ebp
c010a7c1:	c3                   	ret    

c010a7c2 <llist_delete>:

static inline void
llist_delete(struct llist_header* elem) {
c010a7c2:	55                   	push   %ebp
c010a7c3:	89 e5                	mov    %esp,%ebp
    elem->prev->next = elem->next;
c010a7c5:	8b 45 08             	mov    0x8(%ebp),%eax
c010a7c8:	8b 00                	mov    (%eax),%eax
c010a7ca:	8b 55 08             	mov    0x8(%ebp),%edx
c010a7cd:	8b 52 04             	mov    0x4(%edx),%edx
c010a7d0:	89 50 04             	mov    %edx,0x4(%eax)
    elem->next->prev = elem->next;
c010a7d3:	8b 45 08             	mov    0x8(%ebp),%eax
c010a7d6:	8b 40 04             	mov    0x4(%eax),%eax
c010a7d9:	8b 55 08             	mov    0x8(%ebp),%edx
c010a7dc:	8b 52 04             	mov    0x4(%edx),%edx
c010a7df:	89 10                	mov    %edx,(%eax)
    
    // make elem orphaned
    elem->prev = elem;
c010a7e1:	8b 45 08             	mov    0x8(%ebp),%eax
c010a7e4:	8b 55 08             	mov    0x8(%ebp),%edx
c010a7e7:	89 10                	mov    %edx,(%eax)
    elem->next = elem;
c010a7e9:	8b 45 08             	mov    0x8(%ebp),%eax
c010a7ec:	8b 55 08             	mov    0x8(%ebp),%edx
c010a7ef:	89 50 04             	mov    %edx,0x4(%eax)
}
c010a7f2:	90                   	nop
c010a7f3:	5d                   	pop    %ebp
c010a7f4:	c3                   	ret    

c010a7f5 <syscall>:
{
c010a7f5:	55                   	push   %ebp
c010a7f6:	89 e5                	mov    %esp,%ebp
c010a7f8:	57                   	push   %edi
    asm volatile("int %0" ::"i"(0x80), "D"(callcode) : "eax");
c010a7f9:	8b 55 08             	mov    0x8(%ebp),%edx
c010a7fc:	89 d7                	mov    %edx,%edi
c010a7fe:	cd 80                	int    $0x80
}
c010a800:	90                   	nop
c010a801:	8b 7d fc             	mov    -0x4(%ebp),%edi
c010a804:	c9                   	leave  
c010a805:	c3                   	ret    

c010a806 <sched_init>:
extern void __proc_table;

struct scheduler sched_ctx;

int sched_init()
{
c010a806:	55                   	push   %ebp
c010a807:	89 e5                	mov    %esp,%ebp
c010a809:	83 ec 18             	sub    $0x18,%esp
    size_t pg_size = ROUNDUP(sizeof(struct m_pcb) * MAX_PROCESS, 0x1000);
c010a80c:	c7 45 f4 00 e0 00 00 	movl   $0xe000,-0xc(%ebp)
    if(vmm_alloc_pages(KERNEL_PID, &__proc_table, pg_size, PG_PREM_RW, PP_FGPERSIST)){
c010a813:	83 ec 0c             	sub    $0xc,%esp
c010a816:	6a 01                	push   $0x1
c010a818:	6a 03                	push   $0x3
c010a81a:	ff 75 f4             	push   -0xc(%ebp)
c010a81d:	68 00 90 d1 c0       	push   $0xc0d19000
c010a822:	6a ff                	push   $0xffffffff
c010a824:	e8 5f cf ff ff       	call   c0107788 <vmm_alloc_pages>
c010a829:	83 c4 20             	add    $0x20,%esp
c010a82c:	85 c0                	test   %eax,%eax
c010a82e:	74 25                	je     c010a855 <sched_init+0x4f>
        sched_ctx = (struct scheduler){ ._procs = (struct m_pcb*)&__proc_table,
c010a830:	c7 05 ac cb d0 c0 00 	movl   $0xc0d19000,0xc0d0cbac
c010a837:	90 d1 c0 
c010a83a:	c7 05 b0 cb d0 c0 00 	movl   $0x0,0xc0d0cbb0
c010a841:	00 00 00 
c010a844:	c7 05 b4 cb d0 c0 00 	movl   $0x0,0xc0d0cbb4
c010a84b:	00 00 00 
                                    .ptable_len = 0,
                                    .procs_index = 0 };
                                    return 1;}
c010a84e:	b8 01 00 00 00       	mov    $0x1,%eax
c010a853:	eb 05                	jmp    c010a85a <sched_init+0x54>
    return 0;
c010a855:	b8 00 00 00 00       	mov    $0x0,%eax
    
}
c010a85a:	c9                   	leave  
c010a85b:	c3                   	ret    

c010a85c <run>:

void run(struct m_pcb* proc)
{
c010a85c:	55                   	push   %ebp
c010a85d:	89 e5                	mov    %esp,%ebp
    if (!(__current->state & ~PROC_RUNNING)) {
c010a85f:	a1 20 cb d0 c0       	mov    0xc0d0cb20,%eax
c010a864:	0f b6 40 44          	movzbl 0x44(%eax),%eax
c010a868:	0f b6 c0             	movzbl %al,%eax
c010a86b:	83 e0 fe             	and    $0xfffffffe,%eax
c010a86e:	85 c0                	test   %eax,%eax
c010a870:	75 09                	jne    c010a87b <run+0x1f>
        __current->state = PROC_STOPPED;
c010a872:	a1 20 cb d0 c0       	mov    0xc0d0cb20,%eax
c010a877:	c6 40 44 00          	movb   $0x0,0x44(%eax)
    }
    proc->state = PROC_RUNNING;
c010a87b:	8b 45 08             	mov    0x8(%ebp),%eax
c010a87e:	c6 40 44 01          	movb   $0x1,0x44(%eax)


    if (__current->page_table != proc->page_table) {
c010a882:	a1 20 cb d0 c0       	mov    0xc0d0cb20,%eax
c010a887:	8b 50 64             	mov    0x64(%eax),%edx
c010a88a:	8b 45 08             	mov    0x8(%ebp),%eax
c010a88d:	8b 40 64             	mov    0x64(%eax),%eax
c010a890:	39 c2                	cmp    %eax,%edx
c010a892:	74 15                	je     c010a8a9 <run+0x4d>
        __current = proc;
c010a894:	8b 45 08             	mov    0x8(%ebp),%eax
c010a897:	a3 20 cb d0 c0       	mov    %eax,0xc0d0cb20
        //asm("cli");
        //__asm__("movl %%ebx,%%cr3"::"b" (__current->page_table));
        __asm__("mov %0, %%cr3" ::"r"(__current->page_table));
c010a89c:	a1 20 cb d0 c0       	mov    0xc0d0cb20,%eax
c010a8a1:	8b 40 64             	mov    0x64(%eax),%eax
c010a8a4:	0f 22 d8             	mov    %eax,%cr3
c010a8a7:	eb 08                	jmp    c010a8b1 <run+0x55>
        //cpu_lcr3(__current->page_table);
        //asm("sti");
    } else {
        __current = proc;
c010a8a9:	8b 45 08             	mov    0x8(%ebp),%eax
c010a8ac:	a3 20 cb d0 c0       	mov    %eax,0xc0d0cb20

    // io_outb(0x20, 0x20);
    // io_outb(0xa0, 0x20);//EOI end the int

    asm volatile("pushl %0\n"
                 "jmp soft_iret\n" ::"r"(&__current->intr_contxt)
c010a8b1:	a1 20 cb d0 c0       	mov    0xc0d0cb20,%eax
c010a8b6:	83 c0 08             	add    $0x8,%eax
    asm volatile("pushl %0\n"
c010a8b9:	50                   	push   %eax
c010a8ba:	e9 26 d9 ff ff       	jmp    c01081e5 <soft_iret>
                 : "memory");
}
c010a8bf:	90                   	nop
c010a8c0:	5d                   	pop    %ebp
c010a8c1:	c3                   	ret    

c010a8c2 <schedule>:

void schedule()
{
c010a8c2:	55                   	push   %ebp
c010a8c3:	89 e5                	mov    %esp,%ebp
c010a8c5:	83 ec 10             	sub    $0x10,%esp
    if (!sched_ctx.ptable_len) {
c010a8c8:	a1 b4 cb d0 c0       	mov    0xc0d0cbb4,%eax
c010a8cd:	85 c0                	test   %eax,%eax
c010a8cf:	74 71                	je     c010a942 <schedule+0x80>
        return;
    }

    struct m_pcb* next;
    int prev_ptr = sched_ctx.procs_index;
c010a8d1:	a1 b0 cb d0 c0       	mov    0xc0d0cbb0,%eax
c010a8d6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int ptr = prev_ptr;
c010a8d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010a8dc:	89 45 f8             	mov    %eax,-0x8(%ebp)
    // round-robin scheduler
    do {
        ptr = (ptr + 1) % sched_ctx.ptable_len;
c010a8df:	8b 45 f8             	mov    -0x8(%ebp),%eax
c010a8e2:	83 c0 01             	add    $0x1,%eax
c010a8e5:	8b 0d b4 cb d0 c0    	mov    0xc0d0cbb4,%ecx
c010a8eb:	ba 00 00 00 00       	mov    $0x0,%edx
c010a8f0:	f7 f1                	div    %ecx
c010a8f2:	89 d0                	mov    %edx,%eax
c010a8f4:	89 45 f8             	mov    %eax,-0x8(%ebp)
        next = &sched_ctx._procs[ptr];
c010a8f7:	8b 15 ac cb d0 c0    	mov    0xc0d0cbac,%edx
c010a8fd:	8b 45 f8             	mov    -0x8(%ebp),%eax
c010a900:	6b c0 6c             	imul   $0x6c,%eax,%eax
c010a903:	01 d0                	add    %edx,%eax
c010a905:	89 45 fc             	mov    %eax,-0x4(%ebp)
    } while (next->state != PROC_STOPPED && ptr != prev_ptr);
c010a908:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010a90b:	0f b6 40 44          	movzbl 0x44(%eax),%eax
c010a90f:	84 c0                	test   %al,%al
c010a911:	74 08                	je     c010a91b <schedule+0x59>
c010a913:	8b 45 f8             	mov    -0x8(%ebp),%eax
c010a916:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c010a919:	75 c4                	jne    c010a8df <schedule+0x1d>

    sched_ctx.procs_index = ptr;
c010a91b:	8b 45 f8             	mov    -0x8(%ebp),%eax
c010a91e:	a3 b0 cb d0 c0       	mov    %eax,0xc0d0cbb0
    if(next->pid == 2)
c010a923:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010a926:	8b 00                	mov    (%eax),%eax
c010a928:	83 f8 02             	cmp    $0x2,%eax
c010a92b:	75 08                	jne    c010a935 <schedule+0x73>
        next = &sched_ctx._procs[0];
c010a92d:	a1 ac cb d0 c0       	mov    0xc0d0cbac,%eax
c010a932:	89 45 fc             	mov    %eax,-0x4(%ebp)
    run(next);
c010a935:	ff 75 fc             	push   -0x4(%ebp)
c010a938:	e8 1f ff ff ff       	call   c010a85c <run>
c010a93d:	83 c4 04             	add    $0x4,%esp
c010a940:	eb 01                	jmp    c010a943 <schedule+0x81>
        return;
c010a942:	90                   	nop
}
c010a943:	c9                   	leave  
c010a944:	c3                   	ret    

c010a945 <alloc_pid>:

pid_t alloc_pid()
{
c010a945:	55                   	push   %ebp
c010a946:	89 e5                	mov    %esp,%ebp
c010a948:	83 ec 18             	sub    $0x18,%esp
    pid_t i = 0;
c010a94b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    for (;
c010a952:	eb 04                	jmp    c010a958 <alloc_pid+0x13>
         i < sched_ctx.ptable_len && sched_ctx._procs[i].state != PROC_DESTROY;
         i++)
c010a954:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
         i < sched_ctx.ptable_len && sched_ctx._procs[i].state != PROC_DESTROY;
c010a958:	8b 15 b4 cb d0 c0    	mov    0xc0d0cbb4,%edx
c010a95e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010a961:	39 c2                	cmp    %eax,%edx
c010a963:	76 16                	jbe    c010a97b <alloc_pid+0x36>
c010a965:	8b 15 ac cb d0 c0    	mov    0xc0d0cbac,%edx
c010a96b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010a96e:	6b c0 6c             	imul   $0x6c,%eax,%eax
c010a971:	01 d0                	add    %edx,%eax
c010a973:	0f b6 40 44          	movzbl 0x44(%eax),%eax
c010a977:	3c 04                	cmp    $0x4,%al
c010a979:	75 d9                	jne    c010a954 <alloc_pid+0xf>
        ;

    if (i == MAX_PROCESS) {
c010a97b:	81 7d f4 00 02 00 00 	cmpl   $0x200,-0xc(%ebp)
c010a982:	75 10                	jne    c010a994 <alloc_pid+0x4f>
        kprintf("Panic in Ponyville shimmer!");
c010a984:	83 ec 0c             	sub    $0xc,%esp
c010a987:	68 65 e7 d0 c0       	push   $0xc0d0e765
c010a98c:	e8 f0 02 00 00       	call   c010ac81 <kprintf>
c010a991:	83 c4 10             	add    $0x10,%esp
    }
    return i;
c010a994:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c010a997:	c9                   	leave  
c010a998:	c3                   	ret    

c010a999 <push_process>:

void
push_process(struct m_pcb* process)
{
c010a999:	55                   	push   %ebp
c010a99a:	89 e5                	mov    %esp,%ebp
c010a99c:	57                   	push   %edi
c010a99d:	56                   	push   %esi
c010a99e:	53                   	push   %ebx
c010a99f:	83 ec 10             	sub    $0x10,%esp
    int index = process->pid;
c010a9a2:	8b 45 08             	mov    0x8(%ebp),%eax
c010a9a5:	8b 00                	mov    (%eax),%eax
c010a9a7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (index < 0 || index > sched_ctx.ptable_len) {
c010a9aa:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c010a9ae:	78 0d                	js     c010a9bd <push_process+0x24>
c010a9b0:	8b 15 b4 cb d0 c0    	mov    0xc0d0cbb4,%edx
c010a9b6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010a9b9:	39 c2                	cmp    %eax,%edx
c010a9bb:	73 11                	jae    c010a9ce <push_process+0x35>
        __current->k_status = MXINVLDPID;
c010a9bd:	a1 20 cb d0 c0       	mov    0xc0d0cb20,%eax
c010a9c2:	c7 40 68 fc ff ff ff 	movl   $0xfffffffc,0x68(%eax)
        return;
c010a9c9:	e9 92 00 00 00       	jmp    c010aa60 <push_process+0xc7>
    }

    if (index == sched_ctx.ptable_len) {
c010a9ce:	8b 15 b4 cb d0 c0    	mov    0xc0d0cbb4,%edx
c010a9d4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010a9d7:	39 c2                	cmp    %eax,%edx
c010a9d9:	75 0d                	jne    c010a9e8 <push_process+0x4f>
        sched_ctx.ptable_len++;
c010a9db:	a1 b4 cb d0 c0       	mov    0xc0d0cbb4,%eax
c010a9e0:	83 c0 01             	add    $0x1,%eax
c010a9e3:	a3 b4 cb d0 c0       	mov    %eax,0xc0d0cbb4
    }

    sched_ctx._procs[index] = *process;
c010a9e8:	8b 15 ac cb d0 c0    	mov    0xc0d0cbac,%edx
c010a9ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010a9f1:	6b c0 6c             	imul   $0x6c,%eax,%eax
c010a9f4:	01 c2                	add    %eax,%edx
c010a9f6:	8b 45 08             	mov    0x8(%ebp),%eax
c010a9f9:	89 c3                	mov    %eax,%ebx
c010a9fb:	b8 1b 00 00 00       	mov    $0x1b,%eax
c010aa00:	89 d7                	mov    %edx,%edi
c010aa02:	89 de                	mov    %ebx,%esi
c010aa04:	89 c1                	mov    %eax,%ecx
c010aa06:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)

    process = &sched_ctx._procs[index];
c010aa08:	8b 15 ac cb d0 c0    	mov    0xc0d0cbac,%edx
c010aa0e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010aa11:	6b c0 6c             	imul   $0x6c,%eax,%eax
c010aa14:	01 d0                	add    %edx,%eax
c010aa16:	89 45 08             	mov    %eax,0x8(%ebp)

    // make sure the address is in the range of process table
    llist_init_head(&process->children);
c010aa19:	8b 45 08             	mov    0x8(%ebp),%eax
c010aa1c:	83 c0 50             	add    $0x50,%eax
c010aa1f:	50                   	push   %eax
c010aa20:	e8 57 fd ff ff       	call   c010a77c <llist_init_head>
c010aa25:	83 c4 04             	add    $0x4,%esp
    // every process is the child of first process (pid=1)
    if (process->parent) {
c010aa28:	8b 45 08             	mov    0x8(%ebp),%eax
c010aa2b:	8b 40 04             	mov    0x4(%eax),%eax
c010aa2e:	85 c0                	test   %eax,%eax
c010aa30:	74 1b                	je     c010aa4d <push_process+0xb4>
        llist_append(&process->parent->children, &process->siblings);
c010aa32:	8b 45 08             	mov    0x8(%ebp),%eax
c010aa35:	8d 50 48             	lea    0x48(%eax),%edx
c010aa38:	8b 45 08             	mov    0x8(%ebp),%eax
c010aa3b:	8b 40 04             	mov    0x4(%eax),%eax
c010aa3e:	83 c0 50             	add    $0x50,%eax
c010aa41:	52                   	push   %edx
c010aa42:	50                   	push   %eax
c010aa43:	e8 4b fd ff ff       	call   c010a793 <llist_append>
c010aa48:	83 c4 08             	add    $0x8,%esp
c010aa4b:	eb 0c                	jmp    c010aa59 <push_process+0xc0>
    } else {
        process->parent = &sched_ctx._procs[0];
c010aa4d:	8b 15 ac cb d0 c0    	mov    0xc0d0cbac,%edx
c010aa53:	8b 45 08             	mov    0x8(%ebp),%eax
c010aa56:	89 50 04             	mov    %edx,0x4(%eax)
    }

    process->state = PROC_STOPPED;
c010aa59:	8b 45 08             	mov    0x8(%ebp),%eax
c010aa5c:	c6 40 44 00          	movb   $0x0,0x44(%eax)
}
c010aa60:	8d 65 f4             	lea    -0xc(%ebp),%esp
c010aa63:	5b                   	pop    %ebx
c010aa64:	5e                   	pop    %esi
c010aa65:	5f                   	pop    %edi
c010aa66:	5d                   	pop    %ebp
c010aa67:	c3                   	ret    

c010aa68 <terminate_proc>:

void terminate_proc(int exit_code)
{
c010aa68:	55                   	push   %ebp
c010aa69:	89 e5                	mov    %esp,%ebp
    __current->state = PROC_TERMNAT;
c010aa6b:	a1 20 cb d0 c0       	mov    0xc0d0cb20,%eax
c010aa70:	c6 40 44 02          	movb   $0x2,0x44(%eax)
    __current->exit_code = exit_code;
c010aa74:	a1 20 cb d0 c0       	mov    0xc0d0cb20,%eax
c010aa79:	8b 55 08             	mov    0x8(%ebp),%edx
c010aa7c:	89 50 60             	mov    %edx,0x60(%eax)

    schedule();
c010aa7f:	e8 3e fe ff ff       	call   c010a8c2 <schedule>
}
c010aa84:	90                   	nop
c010aa85:	5d                   	pop    %ebp
c010aa86:	c3                   	ret    

c010aa87 <__mxsys_sleep>:

__DEFINE_MXSYSCALL1(unsigned int, sleep, unsigned int, seconds)
{
c010aa87:	55                   	push   %ebp
c010aa88:	89 e5                	mov    %esp,%ebp
    if (!seconds) {
c010aa8a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c010aa8e:	75 07                	jne    c010aa97 <__mxsys_sleep+0x10>
        return 0;
c010aa90:	b8 00 00 00 00       	mov    $0x0,%eax
c010aa95:	eb 2f                	jmp    c010aac6 <__mxsys_sleep+0x3f>
    }
    if (__current->pro_ticks) {
c010aa97:	a1 20 cb d0 c0       	mov    0xc0d0cb20,%eax
c010aa9c:	8b 40 5c             	mov    0x5c(%eax),%eax
c010aa9f:	85 c0                	test   %eax,%eax
c010aaa1:	74 0a                	je     c010aaad <__mxsys_sleep+0x26>
        return __current->pro_ticks;
c010aaa3:	a1 20 cb d0 c0       	mov    0xc0d0cb20,%eax
c010aaa8:	8b 40 5c             	mov    0x5c(%eax),%eax
c010aaab:	eb 19                	jmp    c010aac6 <__mxsys_sleep+0x3f>
    }

    __current->intr_contxt.registers.eax = seconds;
c010aaad:	a1 20 cb d0 c0       	mov    0xc0d0cb20,%eax
c010aab2:	8b 55 08             	mov    0x8(%ebp),%edx
c010aab5:	89 50 08             	mov    %edx,0x8(%eax)
    __current->state = PROC_BLOCKED;
c010aab8:	a1 20 cb d0 c0       	mov    0xc0d0cb20,%eax
c010aabd:	c6 40 44 08          	movb   $0x8,0x44(%eax)
    schedule();
c010aac1:	e8 fc fd ff ff       	call   c010a8c2 <schedule>
}
c010aac6:	5d                   	pop    %ebp
c010aac7:	c3                   	ret    

c010aac8 <__mxsys_exit>:

__DEFINE_MXSYSCALL1(void, exit, int, status)
{
c010aac8:	55                   	push   %ebp
c010aac9:	89 e5                	mov    %esp,%ebp
    terminate_proc(status);
c010aacb:	ff 75 08             	push   0x8(%ebp)
c010aace:	e8 95 ff ff ff       	call   c010aa68 <terminate_proc>
c010aad3:	83 c4 04             	add    $0x4,%esp
}
c010aad6:	90                   	nop
c010aad7:	c9                   	leave  
c010aad8:	c3                   	ret    

c010aad9 <__mxsys_yield>:

__DEFINE_MXSYSCALL(void, yield)
{
c010aad9:	55                   	push   %ebp
c010aada:	89 e5                	mov    %esp,%ebp
    schedule();
c010aadc:	e8 e1 fd ff ff       	call   c010a8c2 <schedule>
}
c010aae1:	90                   	nop
c010aae2:	5d                   	pop    %ebp
c010aae3:	c3                   	ret    

c010aae4 <__mxsys_wait>:

__DEFINE_MXSYSCALL1(pid_t, wait, int*, status)
{
c010aae4:	55                   	push   %ebp
c010aae5:	89 e5                	mov    %esp,%ebp
c010aae7:	83 ec 28             	sub    $0x28,%esp
    pid_t cur = __current->pid;
c010aaea:	a1 20 cb d0 c0       	mov    0xc0d0cb20,%eax
c010aaef:	8b 00                	mov    (%eax),%eax
c010aaf1:	89 45 ec             	mov    %eax,-0x14(%ebp)
    struct m_pcb *proc, *n;
    if (llist_empty(&__current->children)) {
c010aaf4:	a1 20 cb d0 c0       	mov    0xc0d0cb20,%eax
c010aaf9:	83 c0 50             	add    $0x50,%eax
c010aafc:	50                   	push   %eax
c010aafd:	e8 ac fc ff ff       	call   c010a7ae <llist_empty>
c010ab02:	83 c4 04             	add    $0x4,%esp
c010ab05:	85 c0                	test   %eax,%eax
c010ab07:	74 07                	je     c010ab10 <__mxsys_wait+0x2c>
        return -1;
c010ab09:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c010ab0e:	eb 7d                	jmp    c010ab8d <__mxsys_wait+0xa9>
    }
repeat:
c010ab10:	90                   	nop
    llist_for_each(proc, n, &__current->children, siblings)
c010ab11:	a1 20 cb d0 c0       	mov    0xc0d0cb20,%eax
c010ab16:	8b 40 54             	mov    0x54(%eax),%eax
c010ab19:	89 45 e8             	mov    %eax,-0x18(%ebp)
c010ab1c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010ab1f:	83 e8 48             	sub    $0x48,%eax
c010ab22:	89 45 f4             	mov    %eax,-0xc(%ebp)
c010ab25:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010ab28:	8b 40 4c             	mov    0x4c(%eax),%eax
c010ab2b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c010ab2e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010ab31:	83 e8 48             	sub    $0x48,%eax
c010ab34:	89 45 f0             	mov    %eax,-0x10(%ebp)
c010ab37:	eb 23                	jmp    c010ab5c <__mxsys_wait+0x78>
    {
        if (proc->state == PROC_TERMNAT) {
c010ab39:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010ab3c:	0f b6 40 44          	movzbl 0x44(%eax),%eax
c010ab40:	3c 02                	cmp    $0x2,%al
c010ab42:	74 2c                	je     c010ab70 <__mxsys_wait+0x8c>
    llist_for_each(proc, n, &__current->children, siblings)
c010ab44:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010ab47:	89 45 f4             	mov    %eax,-0xc(%ebp)
c010ab4a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010ab4d:	8b 40 4c             	mov    0x4c(%eax),%eax
c010ab50:	89 45 e0             	mov    %eax,-0x20(%ebp)
c010ab53:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010ab56:	83 e8 48             	sub    $0x48,%eax
c010ab59:	89 45 f0             	mov    %eax,-0x10(%ebp)
c010ab5c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010ab5f:	8d 50 48             	lea    0x48(%eax),%edx
c010ab62:	a1 20 cb d0 c0       	mov    0xc0d0cb20,%eax
c010ab67:	83 c0 50             	add    $0x50,%eax
c010ab6a:	39 c2                	cmp    %eax,%edx
c010ab6c:	75 cb                	jne    c010ab39 <__mxsys_wait+0x55>
            goto done;
        }
    }
    // FIXME: 除了循环，也许有更高效的办法……
    // (在这里进行schedule，需要重写context switch!)
    goto repeat;
c010ab6e:	eb a1                	jmp    c010ab11 <__mxsys_wait+0x2d>
            goto done;
c010ab70:	90                   	nop

done:
    *status = proc->exit_code;
c010ab71:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010ab74:	8b 50 60             	mov    0x60(%eax),%edx
c010ab77:	8b 45 08             	mov    0x8(%ebp),%eax
c010ab7a:	89 10                	mov    %edx,(%eax)
    return destroy_process(proc->pid);
c010ab7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010ab7f:	8b 00                	mov    (%eax),%eax
c010ab81:	83 ec 0c             	sub    $0xc,%esp
c010ab84:	50                   	push   %eax
c010ab85:	e8 05 00 00 00       	call   c010ab8f <destroy_process>
c010ab8a:	83 c4 10             	add    $0x10,%esp
}
c010ab8d:	c9                   	leave  
c010ab8e:	c3                   	ret    

c010ab8f <destroy_process>:

extern void __del_pagetable(pid_t pid, uintptr_t mount_point);

pid_t destroy_process(pid_t pid)
{
c010ab8f:	55                   	push   %ebp
c010ab90:	89 e5                	mov    %esp,%ebp
c010ab92:	83 ec 28             	sub    $0x28,%esp
    int index = pid;
c010ab95:	8b 45 08             	mov    0x8(%ebp),%eax
c010ab98:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (index <= 0 || index > sched_ctx.ptable_len) {
c010ab9b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c010ab9f:	7e 0d                	jle    c010abae <destroy_process+0x1f>
c010aba1:	8b 15 b4 cb d0 c0    	mov    0xc0d0cbb4,%edx
c010aba7:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010abaa:	39 c2                	cmp    %eax,%edx
c010abac:	73 12                	jae    c010abc0 <destroy_process+0x31>
        __current->k_status = MXINVLDPID;
c010abae:	a1 20 cb d0 c0       	mov    0xc0d0cb20,%eax
c010abb3:	c7 40 68 fc ff ff ff 	movl   $0xfffffffc,0x68(%eax)
        return;
c010abba:	90                   	nop
c010abbb:	e9 bf 00 00 00       	jmp    c010ac7f <destroy_process+0xf0>
    }
    struct m_pcb* proc = &sched_ctx._procs[index];
c010abc0:	8b 15 ac cb d0 c0    	mov    0xc0d0cbac,%edx
c010abc6:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010abc9:	6b c0 6c             	imul   $0x6c,%eax,%eax
c010abcc:	01 d0                	add    %edx,%eax
c010abce:	89 45 e8             	mov    %eax,-0x18(%ebp)
    proc->state = PROC_DESTROY;
c010abd1:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010abd4:	c6 40 44 04          	movb   $0x4,0x44(%eax)
    llist_delete(&proc->siblings);
c010abd8:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010abdb:	83 c0 48             	add    $0x48,%eax
c010abde:	50                   	push   %eax
c010abdf:	e8 de fb ff ff       	call   c010a7c2 <llist_delete>
c010abe4:	83 c4 04             	add    $0x4,%esp

    if (proc->process_mm) {
c010abe7:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010abea:	8b 40 58             	mov    0x58(%eax),%eax
c010abed:	85 c0                	test   %eax,%eax
c010abef:	74 51                	je     c010ac42 <destroy_process+0xb3>
        struct mm_region *pos, *n;
        llist_for_each(pos, n, &proc->process_mm->head, head)
c010abf1:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010abf4:	8b 40 58             	mov    0x58(%eax),%eax
c010abf7:	8b 40 04             	mov    0x4(%eax),%eax
c010abfa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c010abfd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010ac00:	89 45 f4             	mov    %eax,-0xc(%ebp)
c010ac03:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010ac06:	8b 40 04             	mov    0x4(%eax),%eax
c010ac09:	89 45 e0             	mov    %eax,-0x20(%ebp)
c010ac0c:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010ac0f:	89 45 f0             	mov    %eax,-0x10(%ebp)
c010ac12:	eb 23                	jmp    c010ac37 <destroy_process+0xa8>
        {
            malloc_free(pos);
c010ac14:	83 ec 0c             	sub    $0xc,%esp
c010ac17:	ff 75 f4             	push   -0xc(%ebp)
c010ac1a:	e8 62 c3 ff ff       	call   c0106f81 <malloc_free>
c010ac1f:	83 c4 10             	add    $0x10,%esp
        llist_for_each(pos, n, &proc->process_mm->head, head)
c010ac22:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010ac25:	89 45 f4             	mov    %eax,-0xc(%ebp)
c010ac28:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010ac2b:	8b 40 04             	mov    0x4(%eax),%eax
c010ac2e:	89 45 dc             	mov    %eax,-0x24(%ebp)
c010ac31:	8b 45 dc             	mov    -0x24(%ebp),%eax
c010ac34:	89 45 f0             	mov    %eax,-0x10(%ebp)
c010ac37:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010ac3a:	8b 40 58             	mov    0x58(%eax),%eax
c010ac3d:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c010ac40:	75 d2                	jne    c010ac14 <destroy_process+0x85>
        }
    }

    vmm_mount_pd(PD_MOUNT_2, proc->page_table);
c010ac42:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010ac45:	8b 40 64             	mov    0x64(%eax),%eax
c010ac48:	83 ec 08             	sub    $0x8,%esp
c010ac4b:	50                   	push   %eax
c010ac4c:	68 00 00 80 af       	push   $0xaf800000
c010ac51:	e8 c5 ce ff ff       	call   c0107b1b <vmm_mount_pd>
c010ac56:	83 c4 10             	add    $0x10,%esp

    __del_pagetable(pid, PD_MOUNT_2);
c010ac59:	83 ec 08             	sub    $0x8,%esp
c010ac5c:	68 00 00 80 af       	push   $0xaf800000
c010ac61:	ff 75 08             	push   0x8(%ebp)
c010ac64:	e8 07 fa ff ff       	call   c010a670 <__del_pagetable>
c010ac69:	83 c4 10             	add    $0x10,%esp

    vmm_unmount_pd(PD_MOUNT_2);
c010ac6c:	83 ec 0c             	sub    $0xc,%esp
c010ac6f:	68 00 00 80 af       	push   $0xaf800000
c010ac74:	e8 e1 ce ff ff       	call   c0107b5a <vmm_unmount_pd>
c010ac79:	83 c4 10             	add    $0x10,%esp

    return pid;
c010ac7c:	8b 45 08             	mov    0x8(%ebp),%eax
c010ac7f:	c9                   	leave  
c010ac80:	c3                   	ret    

c010ac81 <kprintf>:
#include <libs/mstdio.h>
#include <vga/vga.h>
void kprintf (const char *format, ...)
{
c010ac81:	55                   	push   %ebp
c010ac82:	89 e5                	mov    %esp,%ebp
c010ac84:	83 ec 38             	sub    $0x38,%esp
  char **arg = (char **) &format;
c010ac87:	8d 45 08             	lea    0x8(%ebp),%eax
c010ac8a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  int c;
  char buf[20];

  arg++;
c010ac8d:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
  while ((c = *format++) != 0)
c010ac91:	e9 83 01 00 00       	jmp    c010ae19 <kprintf+0x198>
    {
      if (c != '%')
c010ac96:	83 7d f0 25          	cmpl   $0x25,-0x10(%ebp)
c010ac9a:	74 17                	je     c010acb3 <kprintf+0x32>
        vga_put_char (c);
c010ac9c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010ac9f:	0f be c0             	movsbl %al,%eax
c010aca2:	83 ec 0c             	sub    $0xc,%esp
c010aca5:	50                   	push   %eax
c010aca6:	e8 73 b3 ff ff       	call   c010601e <vga_put_char>
c010acab:	83 c4 10             	add    $0x10,%esp
c010acae:	e9 66 01 00 00       	jmp    c010ae19 <kprintf+0x198>
      else
        {
          char *p, *p2;
          int pad0 = 0, pad = 0;
c010acb3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
c010acba:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
          
          c = *format++;
c010acc1:	8b 45 08             	mov    0x8(%ebp),%eax
c010acc4:	8d 50 01             	lea    0x1(%eax),%edx
c010acc7:	89 55 08             	mov    %edx,0x8(%ebp)
c010acca:	0f b6 00             	movzbl (%eax),%eax
c010accd:	0f be c0             	movsbl %al,%eax
c010acd0:	89 45 f0             	mov    %eax,-0x10(%ebp)
          if (c == '0')
c010acd3:	83 7d f0 30          	cmpl   $0x30,-0x10(%ebp)
c010acd7:	75 19                	jne    c010acf2 <kprintf+0x71>
            {
              pad0 = 1;
c010acd9:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
              c = *format++;
c010ace0:	8b 45 08             	mov    0x8(%ebp),%eax
c010ace3:	8d 50 01             	lea    0x1(%eax),%edx
c010ace6:	89 55 08             	mov    %edx,0x8(%ebp)
c010ace9:	0f b6 00             	movzbl (%eax),%eax
c010acec:	0f be c0             	movsbl %al,%eax
c010acef:	89 45 f0             	mov    %eax,-0x10(%ebp)
            }

          if (c >= '0' && c <= '9')
c010acf2:	83 7d f0 2f          	cmpl   $0x2f,-0x10(%ebp)
c010acf6:	7e 21                	jle    c010ad19 <kprintf+0x98>
c010acf8:	83 7d f0 39          	cmpl   $0x39,-0x10(%ebp)
c010acfc:	7f 1b                	jg     c010ad19 <kprintf+0x98>
            {
              pad = c - '0';
c010acfe:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010ad01:	83 e8 30             	sub    $0x30,%eax
c010ad04:	89 45 e0             	mov    %eax,-0x20(%ebp)
              c = *format++;
c010ad07:	8b 45 08             	mov    0x8(%ebp),%eax
c010ad0a:	8d 50 01             	lea    0x1(%eax),%edx
c010ad0d:	89 55 08             	mov    %edx,0x8(%ebp)
c010ad10:	0f b6 00             	movzbl (%eax),%eax
c010ad13:	0f be c0             	movsbl %al,%eax
c010ad16:	89 45 f0             	mov    %eax,-0x10(%ebp)
            }

          switch (c)
c010ad19:	83 7d f0 78          	cmpl   $0x78,-0x10(%ebp)
c010ad1d:	74 2b                	je     c010ad4a <kprintf+0xc9>
c010ad1f:	83 7d f0 78          	cmpl   $0x78,-0x10(%ebp)
c010ad23:	0f 8f d5 00 00 00    	jg     c010adfe <kprintf+0x17d>
c010ad29:	83 7d f0 75          	cmpl   $0x75,-0x10(%ebp)
c010ad2d:	74 1b                	je     c010ad4a <kprintf+0xc9>
c010ad2f:	83 7d f0 75          	cmpl   $0x75,-0x10(%ebp)
c010ad33:	0f 8f c5 00 00 00    	jg     c010adfe <kprintf+0x17d>
c010ad39:	83 7d f0 64          	cmpl   $0x64,-0x10(%ebp)
c010ad3d:	74 0b                	je     c010ad4a <kprintf+0xc9>
c010ad3f:	83 7d f0 73          	cmpl   $0x73,-0x10(%ebp)
c010ad43:	74 2b                	je     c010ad70 <kprintf+0xef>
c010ad45:	e9 b4 00 00 00       	jmp    c010adfe <kprintf+0x17d>
            {
            case 'd':
            case 'u':
            case 'x':
              itoa (buf, c, *((int *) arg++));
c010ad4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010ad4d:	8d 50 04             	lea    0x4(%eax),%edx
c010ad50:	89 55 f4             	mov    %edx,-0xc(%ebp)
c010ad53:	8b 00                	mov    (%eax),%eax
c010ad55:	83 ec 04             	sub    $0x4,%esp
c010ad58:	50                   	push   %eax
c010ad59:	ff 75 f0             	push   -0x10(%ebp)
c010ad5c:	8d 45 cc             	lea    -0x34(%ebp),%eax
c010ad5f:	50                   	push   %eax
c010ad60:	e8 d4 00 00 00       	call   c010ae39 <itoa>
c010ad65:	83 c4 10             	add    $0x10,%esp
              p = buf;
c010ad68:	8d 45 cc             	lea    -0x34(%ebp),%eax
c010ad6b:	89 45 ec             	mov    %eax,-0x14(%ebp)
              goto string;
c010ad6e:	eb 1e                	jmp    c010ad8e <kprintf+0x10d>
              break;

            case 's':
              p = *arg++;
c010ad70:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010ad73:	8d 50 04             	lea    0x4(%eax),%edx
c010ad76:	89 55 f4             	mov    %edx,-0xc(%ebp)
c010ad79:	8b 00                	mov    (%eax),%eax
c010ad7b:	89 45 ec             	mov    %eax,-0x14(%ebp)
              if (! p)
c010ad7e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c010ad82:	75 09                	jne    c010ad8d <kprintf+0x10c>
                p = "(null)";
c010ad84:	c7 45 ec 81 e7 d0 c0 	movl   $0xc0d0e781,-0x14(%ebp)
c010ad8b:	eb 01                	jmp    c010ad8e <kprintf+0x10d>

            string:
c010ad8d:	90                   	nop
              for (p2 = p; *p2; p2++);
c010ad8e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010ad91:	89 45 e8             	mov    %eax,-0x18(%ebp)
c010ad94:	eb 04                	jmp    c010ad9a <kprintf+0x119>
c010ad96:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
c010ad9a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010ad9d:	0f b6 00             	movzbl (%eax),%eax
c010ada0:	84 c0                	test   %al,%al
c010ada2:	75 f2                	jne    c010ad96 <kprintf+0x115>
              for (; p2 < p + pad; p2++)
c010ada4:	eb 22                	jmp    c010adc8 <kprintf+0x147>
                vga_put_char (pad0 ? '0' : ' ');
c010ada6:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c010adaa:	74 07                	je     c010adb3 <kprintf+0x132>
c010adac:	b8 30 00 00 00       	mov    $0x30,%eax
c010adb1:	eb 05                	jmp    c010adb8 <kprintf+0x137>
c010adb3:	b8 20 00 00 00       	mov    $0x20,%eax
c010adb8:	83 ec 0c             	sub    $0xc,%esp
c010adbb:	50                   	push   %eax
c010adbc:	e8 5d b2 ff ff       	call   c010601e <vga_put_char>
c010adc1:	83 c4 10             	add    $0x10,%esp
              for (; p2 < p + pad; p2++)
c010adc4:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
c010adc8:	8b 55 e0             	mov    -0x20(%ebp),%edx
c010adcb:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010adce:	01 d0                	add    %edx,%eax
c010add0:	39 45 e8             	cmp    %eax,-0x18(%ebp)
c010add3:	72 d1                	jb     c010ada6 <kprintf+0x125>
              while (*p)
c010add5:	eb 1b                	jmp    c010adf2 <kprintf+0x171>
                vga_put_char (*p++);
c010add7:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010adda:	8d 50 01             	lea    0x1(%eax),%edx
c010addd:	89 55 ec             	mov    %edx,-0x14(%ebp)
c010ade0:	0f b6 00             	movzbl (%eax),%eax
c010ade3:	0f be c0             	movsbl %al,%eax
c010ade6:	83 ec 0c             	sub    $0xc,%esp
c010ade9:	50                   	push   %eax
c010adea:	e8 2f b2 ff ff       	call   c010601e <vga_put_char>
c010adef:	83 c4 10             	add    $0x10,%esp
              while (*p)
c010adf2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010adf5:	0f b6 00             	movzbl (%eax),%eax
c010adf8:	84 c0                	test   %al,%al
c010adfa:	75 db                	jne    c010add7 <kprintf+0x156>
              break;
c010adfc:	eb 1b                	jmp    c010ae19 <kprintf+0x198>

            default:
              vga_put_char (*((int *) arg++));
c010adfe:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010ae01:	8d 50 04             	lea    0x4(%eax),%edx
c010ae04:	89 55 f4             	mov    %edx,-0xc(%ebp)
c010ae07:	8b 00                	mov    (%eax),%eax
c010ae09:	0f be c0             	movsbl %al,%eax
c010ae0c:	83 ec 0c             	sub    $0xc,%esp
c010ae0f:	50                   	push   %eax
c010ae10:	e8 09 b2 ff ff       	call   c010601e <vga_put_char>
c010ae15:	83 c4 10             	add    $0x10,%esp
              break;
c010ae18:	90                   	nop
  while ((c = *format++) != 0)
c010ae19:	8b 45 08             	mov    0x8(%ebp),%eax
c010ae1c:	8d 50 01             	lea    0x1(%eax),%edx
c010ae1f:	89 55 08             	mov    %edx,0x8(%ebp)
c010ae22:	0f b6 00             	movzbl (%eax),%eax
c010ae25:	0f be c0             	movsbl %al,%eax
c010ae28:	89 45 f0             	mov    %eax,-0x10(%ebp)
c010ae2b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c010ae2f:	0f 85 61 fe ff ff    	jne    c010ac96 <kprintf+0x15>
            }
        }
    }
}
c010ae35:	90                   	nop
c010ae36:	90                   	nop
c010ae37:	c9                   	leave  
c010ae38:	c3                   	ret    

c010ae39 <itoa>:
#include <libs/mstdlib.h>

void
itoa (char *buf, int base, int d)
{
c010ae39:	55                   	push   %ebp
c010ae3a:	89 e5                	mov    %esp,%ebp
c010ae3c:	83 ec 20             	sub    $0x20,%esp
  char *p = buf;
c010ae3f:	8b 45 08             	mov    0x8(%ebp),%eax
c010ae42:	89 45 fc             	mov    %eax,-0x4(%ebp)
  char *p1, *p2;
  unsigned long ud = d;
c010ae45:	8b 45 10             	mov    0x10(%ebp),%eax
c010ae48:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int divisor = 10;
c010ae4b:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
  
  /* If %d is specified and D is minus, put ‘-’ in the head. */
  if (base == 'd' && d < 0)
c010ae52:	83 7d 0c 64          	cmpl   $0x64,0xc(%ebp)
c010ae56:	75 20                	jne    c010ae78 <itoa+0x3f>
c010ae58:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c010ae5c:	79 1a                	jns    c010ae78 <itoa+0x3f>
    {
      *p++ = '-';
c010ae5e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010ae61:	8d 50 01             	lea    0x1(%eax),%edx
c010ae64:	89 55 fc             	mov    %edx,-0x4(%ebp)
c010ae67:	c6 00 2d             	movb   $0x2d,(%eax)
      buf++;
c010ae6a:	83 45 08 01          	addl   $0x1,0x8(%ebp)
      ud = -d;
c010ae6e:	8b 45 10             	mov    0x10(%ebp),%eax
c010ae71:	f7 d8                	neg    %eax
c010ae73:	89 45 f0             	mov    %eax,-0x10(%ebp)
c010ae76:	eb 0d                	jmp    c010ae85 <itoa+0x4c>
    }
  else if (base == 'x')
c010ae78:	83 7d 0c 78          	cmpl   $0x78,0xc(%ebp)
c010ae7c:	75 07                	jne    c010ae85 <itoa+0x4c>
    divisor = 16;
c010ae7e:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)

  /* Divide UD by DIVISOR until UD == 0. */
  do
    {
      int remainder = ud % divisor;
c010ae85:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c010ae88:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010ae8b:	ba 00 00 00 00       	mov    $0x0,%edx
c010ae90:	f7 f1                	div    %ecx
c010ae92:	89 d0                	mov    %edx,%eax
c010ae94:	89 45 e8             	mov    %eax,-0x18(%ebp)
      
      *p++ = (remainder < 10) ? remainder + '0' : remainder + 'a' - 10;
c010ae97:	83 7d e8 09          	cmpl   $0x9,-0x18(%ebp)
c010ae9b:	7f 0a                	jg     c010aea7 <itoa+0x6e>
c010ae9d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010aea0:	83 c0 30             	add    $0x30,%eax
c010aea3:	89 c1                	mov    %eax,%ecx
c010aea5:	eb 08                	jmp    c010aeaf <itoa+0x76>
c010aea7:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010aeaa:	83 c0 57             	add    $0x57,%eax
c010aead:	89 c1                	mov    %eax,%ecx
c010aeaf:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010aeb2:	8d 50 01             	lea    0x1(%eax),%edx
c010aeb5:	89 55 fc             	mov    %edx,-0x4(%ebp)
c010aeb8:	88 08                	mov    %cl,(%eax)
    }
  while (ud /= divisor);
c010aeba:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c010aebd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010aec0:	ba 00 00 00 00       	mov    $0x0,%edx
c010aec5:	f7 f1                	div    %ecx
c010aec7:	89 45 f0             	mov    %eax,-0x10(%ebp)
c010aeca:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c010aece:	75 b5                	jne    c010ae85 <itoa+0x4c>

  /* Terminate BUF. */
  *p = 0;
c010aed0:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010aed3:	c6 00 00             	movb   $0x0,(%eax)
  
  /* Reverse BUF. */
  p1 = buf;
c010aed6:	8b 45 08             	mov    0x8(%ebp),%eax
c010aed9:	89 45 f8             	mov    %eax,-0x8(%ebp)
  p2 = p - 1;
c010aedc:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010aedf:	83 e8 01             	sub    $0x1,%eax
c010aee2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (p1 < p2)
c010aee5:	eb 25                	jmp    c010af0c <itoa+0xd3>
    {
      char tmp = *p1;
c010aee7:	8b 45 f8             	mov    -0x8(%ebp),%eax
c010aeea:	0f b6 00             	movzbl (%eax),%eax
c010aeed:	88 45 e7             	mov    %al,-0x19(%ebp)
      *p1 = *p2;
c010aef0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010aef3:	0f b6 10             	movzbl (%eax),%edx
c010aef6:	8b 45 f8             	mov    -0x8(%ebp),%eax
c010aef9:	88 10                	mov    %dl,(%eax)
      *p2 = tmp;
c010aefb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010aefe:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
c010af02:	88 10                	mov    %dl,(%eax)
      p1++;
c010af04:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
      p2--;
c010af08:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
  while (p1 < p2)
c010af0c:	8b 45 f8             	mov    -0x8(%ebp),%eax
c010af0f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c010af12:	72 d3                	jb     c010aee7 <itoa+0xae>
    }
c010af14:	90                   	nop
c010af15:	90                   	nop
c010af16:	c9                   	leave  
c010af17:	c3                   	ret    

c010af18 <memset>:
#include <libs/mstring.h>
#include <stdint.h>

void* memset(void* ptr, int value, size_t num)
{
c010af18:	55                   	push   %ebp
c010af19:	89 e5                	mov    %esp,%ebp
c010af1b:	83 ec 10             	sub    $0x10,%esp
    uint8_t* c_ptr = (uint8_t*)ptr;
c010af1e:	8b 45 08             	mov    0x8(%ebp),%eax
c010af21:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for (size_t i = 0; i < num; i++) {
c010af24:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c010af2b:	eb 11                	jmp    c010af3e <memset+0x26>
        *(c_ptr + i) = (uint8_t)value;
c010af2d:	8b 55 f8             	mov    -0x8(%ebp),%edx
c010af30:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010af33:	01 d0                	add    %edx,%eax
c010af35:	8b 55 0c             	mov    0xc(%ebp),%edx
c010af38:	88 10                	mov    %dl,(%eax)
    for (size_t i = 0; i < num; i++) {
c010af3a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c010af3e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010af41:	3b 45 10             	cmp    0x10(%ebp),%eax
c010af44:	72 e7                	jb     c010af2d <memset+0x15>
    }
    return ptr;
c010af46:	8b 45 08             	mov    0x8(%ebp),%eax
c010af49:	c9                   	leave  
c010af4a:	c3                   	ret    
