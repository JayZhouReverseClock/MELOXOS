
build/bin/melox.bin:     file format elf32-i386


Disassembly of section .virk_init_text:

00100000 <start-0xc>:
  100000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
  100006:	00 00                	add    %al,(%eax)
  100008:	fb                   	sti    
  100009:	4f                   	dec    %edi
  10000a:	52                   	push   %edx
  10000b:	e4                   	.byte 0xe4

0010000c <start>:
  10000c:	bc 00 60 10 00       	mov    $0x106000,%esp
  100011:	68 00 10 10 00       	push   $0x101000
  100016:	53                   	push   %ebx
  100017:	e8 64 00 00 00       	call   100080 <save_multiboot_info>
  10001c:	58                   	pop    %eax
  10001d:	58                   	pop    %eax
  10001e:	68 00 60 00 00       	push   $0x6000
  100023:	68 00 d0 28 00       	push   $0x28d000
  100028:	e8 a4 02 00 00       	call   1002d1 <kerner_init>
  10002d:	8b 04 24             	mov    (%esp),%eax
  100030:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  100035:	0f 22 d8             	mov    %eax,%cr3
  100038:	0f 20 c0             	mov    %cr0,%eax
  10003b:	0d 00 00 00 80       	or     $0x80000000,%eax
  100040:	0f 22 c0             	mov    %eax,%cr0
  100043:	58                   	pop    %eax
  100044:	58                   	pop    %eax
  100045:	68 a8 84 10 c0       	push   $0xc01084a8
  10004a:	c3                   	ret    

0010004b <_save_>:
extern uint8_t virkernel_start;
extern uint8_t virkernel_end ;
extern uint8_t __init_phykernel_end;
extern uint8_t _kernel_stack;

uint32_t _save_(uint8_t* destination, uint8_t* base, multiboot_uint32_t size) {
  10004b:	55                   	push   %ebp
  10004c:	89 e5                	mov    %esp,%ebp
  10004e:	83 ec 10             	sub    $0x10,%esp
    multiboot_uint32_t i = 0;
  100051:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    for (; i < size; i++)
  100058:	eb 19                	jmp    100073 <_save_+0x28>
    {
        *(destination + i) = *(base + i);
  10005a:	8b 55 0c             	mov    0xc(%ebp),%edx
  10005d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100060:	01 d0                	add    %edx,%eax
  100062:	8b 4d 08             	mov    0x8(%ebp),%ecx
  100065:	8b 55 fc             	mov    -0x4(%ebp),%edx
  100068:	01 ca                	add    %ecx,%edx
  10006a:	0f b6 00             	movzbl (%eax),%eax
  10006d:	88 02                	mov    %al,(%edx)
    for (; i < size; i++)
  10006f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  100073:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100076:	3b 45 10             	cmp    0x10(%ebp),%eax
  100079:	72 df                	jb     10005a <_save_+0xf>
    }
    return i;
  10007b:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  10007e:	c9                   	leave  
  10007f:	c3                   	ret    

00100080 <save_multiboot_info>:

void save_multiboot_info(multiboot_info_t* mb_info, multiboot_uint8_t* dest)
{
  100080:	55                   	push   %ebp
  100081:	89 e5                	mov    %esp,%ebp
  100083:	53                   	push   %ebx
  100084:	83 ec 10             	sub    $0x10,%esp
    uint32_t current = 0;
  100087:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    uint8_t* info_b = (uint8_t*) mb_info;
  10008e:	8b 45 08             	mov    0x8(%ebp),%eax
  100091:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for (; current < sizeof(multiboot_info_t); current++)
  100094:	eb 19                	jmp    1000af <save_multiboot_info+0x2f>
    {
        *(dest + current) = *(info_b + current);
  100096:	8b 55 f4             	mov    -0xc(%ebp),%edx
  100099:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10009c:	01 d0                	add    %edx,%eax
  10009e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1000a1:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1000a4:	01 ca                	add    %ecx,%edx
  1000a6:	0f b6 00             	movzbl (%eax),%eax
  1000a9:	88 02                	mov    %al,(%edx)
    for (; current < sizeof(multiboot_info_t); current++)
  1000ab:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  1000af:	83 7d f8 77          	cmpl   $0x77,-0x8(%ebp)
  1000b3:	76 e1                	jbe    100096 <save_multiboot_info+0x16>
    }

    ((multiboot_info_t*) dest)->mmap_addr = (uintptr_t)dest + current;
  1000b5:	8b 55 0c             	mov    0xc(%ebp),%edx
  1000b8:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1000bb:	01 c2                	add    %eax,%edx
  1000bd:	8b 45 0c             	mov    0xc(%ebp),%eax
  1000c0:	89 50 30             	mov    %edx,0x30(%eax)
    current += _save_(dest + current, (uint8_t*)mb_info->mmap_addr, mb_info->mmap_length);
  1000c3:	8b 45 08             	mov    0x8(%ebp),%eax
  1000c6:	8b 40 2c             	mov    0x2c(%eax),%eax
  1000c9:	8b 55 08             	mov    0x8(%ebp),%edx
  1000cc:	8b 52 30             	mov    0x30(%edx),%edx
  1000cf:	89 d1                	mov    %edx,%ecx
  1000d1:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  1000d4:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1000d7:	01 da                	add    %ebx,%edx
  1000d9:	50                   	push   %eax
  1000da:	51                   	push   %ecx
  1000db:	52                   	push   %edx
  1000dc:	e8 6a ff ff ff       	call   10004b <_save_>
  1000e1:	83 c4 0c             	add    $0xc,%esp
  1000e4:	01 45 f8             	add    %eax,-0x8(%ebp)

    if (present(mb_info->flags, MULTIBOOT_INFO_DRIVE_INFO)) {
  1000e7:	8b 45 08             	mov    0x8(%ebp),%eax
  1000ea:	8b 00                	mov    (%eax),%eax
  1000ec:	25 80 00 00 00       	and    $0x80,%eax
  1000f1:	85 c0                	test   %eax,%eax
  1000f3:	74 32                	je     100127 <save_multiboot_info+0xa7>
        ((multiboot_info_t*) dest)->drives_addr = (uintptr_t)dest + current;
  1000f5:	8b 55 0c             	mov    0xc(%ebp),%edx
  1000f8:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1000fb:	01 c2                	add    %eax,%edx
  1000fd:	8b 45 0c             	mov    0xc(%ebp),%eax
  100100:	89 50 38             	mov    %edx,0x38(%eax)
        current += _save_(dest + current, (uint8_t*)mb_info->drives_addr, mb_info->drives_length);
  100103:	8b 45 08             	mov    0x8(%ebp),%eax
  100106:	8b 40 34             	mov    0x34(%eax),%eax
  100109:	8b 55 08             	mov    0x8(%ebp),%edx
  10010c:	8b 52 38             	mov    0x38(%edx),%edx
  10010f:	89 d1                	mov    %edx,%ecx
  100111:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  100114:	8b 55 f8             	mov    -0x8(%ebp),%edx
  100117:	01 da                	add    %ebx,%edx
  100119:	50                   	push   %eax
  10011a:	51                   	push   %ecx
  10011b:	52                   	push   %edx
  10011c:	e8 2a ff ff ff       	call   10004b <_save_>
  100121:	83 c4 0c             	add    $0xc,%esp
  100124:	01 45 f8             	add    %eax,-0x8(%ebp)
    }
    multiboot_info_t* test = (multiboot_info_t*) dest;
  100127:	8b 45 0c             	mov    0xc(%ebp),%eax
  10012a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    multiboot_memory_map_t* testmap = (multiboot_memory_map_t*)mb_info->mmap_addr;
  10012d:	8b 45 08             	mov    0x8(%ebp),%eax
  100130:	8b 40 30             	mov    0x30(%eax),%eax
  100133:	89 45 ec             	mov    %eax,-0x14(%ebp)
}
  100136:	90                   	nop
  100137:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10013a:	c9                   	leave  
  10013b:	c3                   	ret    

0010013c <init_page>:

void init_page(ptd_t* pt)
{
  10013c:	55                   	push   %ebp
  10013d:	89 e5                	mov    %esp,%ebp
  10013f:	83 ec 30             	sub    $0x30,%esp
    SET_PDE(pt, 0, PDE(PG_PRESENT, pt + PG_MAX_ENTRIES));
  100142:	8b 45 08             	mov    0x8(%ebp),%eax
  100145:	05 00 10 00 00       	add    $0x1000,%eax
  10014a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  10014f:	83 c8 09             	or     $0x9,%eax
  100152:	89 c2                	mov    %eax,%edx
  100154:	8b 45 08             	mov    0x8(%ebp),%eax
  100157:	89 10                	mov    %edx,(%eax)
    ptd_t * tmp_paged_phy_addr = pt;
  100159:	8b 45 08             	mov    0x8(%ebp),%eax
  10015c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    ptd_t * tmp_paget_phy_addr = pt + 1024;
  10015f:	8b 45 08             	mov    0x8(%ebp),%eax
  100162:	05 00 10 00 00       	add    $0x1000,%eax
  100167:	89 45 e8             	mov    %eax,-0x18(%ebp)
    //identity map 1M memory
    for(uint32_t i = 0; i < 256; i++)
  10016a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  100171:	eb 20                	jmp    100193 <init_page+0x57>
        *(tmp_paget_phy_addr + i) = (((i << 12) & 0xFFFFF000UL) | (PG_PREM_RW & 0xfff));
  100173:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100176:	c1 e0 0c             	shl    $0xc,%eax
  100179:	89 c2                	mov    %eax,%edx
  10017b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10017e:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
  100185:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100188:	01 c8                	add    %ecx,%eax
  10018a:	83 ca 03             	or     $0x3,%edx
  10018d:	89 10                	mov    %edx,(%eax)
    for(uint32_t i = 0; i < 256; i++)
  10018f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  100193:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%ebp)
  10019a:	76 d7                	jbe    100173 <init_page+0x37>

    //identity map virkernel_init memory
    for(uint32_t i = 0; i < LOADOS_PAGE_COUNT; i++)
  10019c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  1001a3:	eb 29                	jmp    1001ce <init_page+0x92>
        *(tmp_paget_phy_addr + i + 256) = ((((i << 12) + MEM_1M) & 0xFFFFF000UL) | (PG_PREM_RW & 0xfff));
  1001a5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1001a8:	c1 e0 0c             	shl    $0xc,%eax
  1001ab:	8d 90 00 00 10 00    	lea    0x100000(%eax),%edx
  1001b1:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1001b4:	05 00 01 00 00       	add    $0x100,%eax
  1001b9:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
  1001c0:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1001c3:	01 c8                	add    %ecx,%eax
  1001c5:	83 ca 03             	or     $0x3,%edx
  1001c8:	89 10                	mov    %edx,(%eax)
    for(uint32_t i = 0; i < LOADOS_PAGE_COUNT; i++)
  1001ca:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  1001ce:	b8 00 60 10 00       	mov    $0x106000,%eax
  1001d3:	2d 01 f0 0f 00       	sub    $0xff001,%eax
  1001d8:	c1 e8 0c             	shr    $0xc,%eax
  1001db:	39 45 f8             	cmp    %eax,-0x8(%ebp)
  1001de:	72 c5                	jb     1001a5 <init_page+0x69>

    //now we map the kernel
    //calculate the virtrue kernrl page index
    uint32_t virk_pde_index = PD_INDEX(sym_val(virkernel_start));
  1001e0:	b8 00 60 10 c0       	mov    $0xc0106000,%eax
  1001e5:	c1 e8 16             	shr    $0x16,%eax
  1001e8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uint32_t virk_pte_index = PT_INDEX(sym_val(virkernel_start));
  1001eb:	b8 00 60 10 c0       	mov    $0xc0106000,%eax
  1001f0:	c1 e8 0c             	shr    $0xc,%eax
  1001f3:	25 ff 03 00 00       	and    $0x3ff,%eax
  1001f8:	89 45 e0             	mov    %eax,-0x20(%ebp)
    uint32_t virk_pg_counts = KERNEL_PAGE_COUNT;
  1001fb:	b8 00 30 29 c0       	mov    $0xc0293000,%eax
  100200:	05 00 10 00 00       	add    $0x1000,%eax
  100205:	83 e8 01             	sub    $0x1,%eax
  100208:	ba 00 60 10 c0       	mov    $0xc0106000,%edx
  10020d:	29 d0                	sub    %edx,%eax
  10020f:	c1 e8 0c             	shr    $0xc,%eax
  100212:	89 45 dc             	mov    %eax,-0x24(%ebp)

    //regist the vir_kernel page to page direction
    //we give 3 pagetable to virkel, is 3 * 4 = 12 mib size
    for(uint32_t i = 0; i < PG_TABLE_STACK - PG_TABLE_KERNEL; i++)
  100215:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  10021c:	eb 34                	jmp    100252 <init_page+0x116>
    {
        *(pt + virk_pde_index + i) = PDE(PG_PREM_RW, PT_ADDR(pt, PG_TABLE_KERNEL + i));
  10021e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100221:	83 c0 02             	add    $0x2,%eax
  100224:	c1 e0 0c             	shl    $0xc,%eax
  100227:	89 c2                	mov    %eax,%edx
  100229:	8b 45 08             	mov    0x8(%ebp),%eax
  10022c:	01 d0                	add    %edx,%eax
  10022e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  100233:	89 c2                	mov    %eax,%edx
  100235:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  100238:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10023b:	01 c8                	add    %ecx,%eax
  10023d:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
  100244:	8b 45 08             	mov    0x8(%ebp),%eax
  100247:	01 c8                	add    %ecx,%eax
  100249:	83 ca 0b             	or     $0xb,%edx
  10024c:	89 10                	mov    %edx,(%eax)
    for(uint32_t i = 0; i < PG_TABLE_STACK - PG_TABLE_KERNEL; i++)
  10024e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  100252:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
  100256:	76 c6                	jbe    10021e <init_page+0xe2>
    }

    //avoid kernel size > prepared page count
    if(virk_pg_counts > (PG_TABLE_STACK - PG_TABLE_KERNEL) * 1024)
  100258:	81 7d dc 00 0c 00 00 	cmpl   $0xc00,-0x24(%ebp)
  10025f:	76 02                	jbe    100263 <init_page+0x127>
    {
        while(1);
  100261:	eb fe                	jmp    100261 <init_page+0x125>
    }

    //calcul the phy address
    uint32_t virk_phy_addr = V2P(&virkernel_start);
  100263:	b8 00 60 10 c0       	mov    $0xc0106000,%eax
  100268:	05 00 00 00 40       	add    $0x40000000,%eax
  10026d:	89 45 d8             	mov    %eax,-0x28(%ebp)
    //map virtrue kernel page
    for(uint32_t i = 0; i < virk_pg_counts; i++)
  100270:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  100277:	eb 36                	jmp    1002af <init_page+0x173>
    {
        *(tmp_paget_phy_addr + 1024 + virk_pte_index + i) = (((virk_phy_addr + (i << 12)) & 0xFFFFF000UL) | (PG_PREM_RW & 0xfff));
  100279:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10027c:	c1 e0 0c             	shl    $0xc,%eax
  10027f:	89 c2                	mov    %eax,%edx
  100281:	8b 45 d8             	mov    -0x28(%ebp),%eax
  100284:	01 d0                	add    %edx,%eax
  100286:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  10028b:	89 c2                	mov    %eax,%edx
  10028d:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  100290:	8b 45 f0             	mov    -0x10(%ebp),%eax
  100293:	01 c8                	add    %ecx,%eax
  100295:	05 00 04 00 00       	add    $0x400,%eax
  10029a:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
  1002a1:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1002a4:	01 c8                	add    %ecx,%eax
  1002a6:	83 ca 03             	or     $0x3,%edx
  1002a9:	89 10                	mov    %edx,(%eax)
    for(uint32_t i = 0; i < virk_pg_counts; i++)
  1002ab:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
  1002af:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1002b2:	3b 45 dc             	cmp    -0x24(%ebp),%eax
  1002b5:	72 c2                	jb     100279 <init_page+0x13d>
    }

    //self map pd, to give the pd virture address
    SET_PDE(pt, 1023, PDE(T_SELF_REF_PERM, pt));
  1002b7:	8b 45 08             	mov    0x8(%ebp),%eax
  1002ba:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  1002bf:	89 c2                	mov    %eax,%edx
  1002c1:	8b 45 08             	mov    0x8(%ebp),%eax
  1002c4:	05 fc 0f 00 00       	add    $0xffc,%eax
  1002c9:	83 ca 1b             	or     $0x1b,%edx
  1002cc:	89 10                	mov    %edx,(%eax)
}
  1002ce:	90                   	nop
  1002cf:	c9                   	leave  
  1002d0:	c3                   	ret    

001002d1 <kerner_init>:

void kerner_init(ptd_t* pt, uint32_t pt_size)
{
  1002d1:	55                   	push   %ebp
  1002d2:	89 e5                	mov    %esp,%ebp
  1002d4:	83 ec 10             	sub    $0x10,%esp
    uint8_t* kpg = (uint8_t*) pt;
  1002d7:	8b 45 08             	mov    0x8(%ebp),%eax
  1002da:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for (uint32_t i = 0; i < pt_size; i++)
  1002dd:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1002e4:	eb 0f                	jmp    1002f5 <kerner_init+0x24>
    {
        *(kpg + i) = 0;
  1002e6:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1002e9:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1002ec:	01 d0                	add    %edx,%eax
  1002ee:	c6 00 00             	movb   $0x0,(%eax)
    for (uint32_t i = 0; i < pt_size; i++)
  1002f1:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  1002f5:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1002f8:	3b 45 0c             	cmp    0xc(%ebp),%eax
  1002fb:	72 e9                	jb     1002e6 <kerner_init+0x15>
    }
    init_page(pt);
  1002fd:	ff 75 08             	push   0x8(%ebp)
  100300:	e8 37 fe ff ff       	call   10013c <init_page>
  100305:	83 c4 04             	add    $0x4,%esp
  100308:	90                   	nop
  100309:	c9                   	leave  
  10030a:	c3                   	ret    

Disassembly of section .text:

c0106000 <init_vga_buffer>:
int XPOS = 0;

vga_attr *video;

void init_vga_buffer()
{
c0106000:	55                   	push   %ebp
c0106001:	89 e5                	mov    %esp,%ebp
    video = (vga_attr *) VIDEO;
c0106003:	c7 05 0c a0 10 c0 00 	movl   $0xb8000,0xc010a00c
c010600a:	80 0b 00 
}
c010600d:	90                   	nop
c010600e:	5d                   	pop    %ebp
c010600f:	c3                   	ret    

c0106010 <set_vga_buffer>:

void set_vga_buffer(void* vga_buf)
{
c0106010:	55                   	push   %ebp
c0106011:	89 e5                	mov    %esp,%ebp
    video = (vga_attr*)vga_buf;
c0106013:	8b 45 08             	mov    0x8(%ebp),%eax
c0106016:	a3 0c a0 10 c0       	mov    %eax,0xc010a00c
}
c010601b:	90                   	nop
c010601c:	5d                   	pop    %ebp
c010601d:	c3                   	ret    

c010601e <vga_put_char>:

void vga_put_char(char c)
{
c010601e:	55                   	push   %ebp
c010601f:	89 e5                	mov    %esp,%ebp
c0106021:	53                   	push   %ebx
c0106022:	83 ec 14             	sub    $0x14,%esp
c0106025:	8b 45 08             	mov    0x8(%ebp),%eax
c0106028:	88 45 f4             	mov    %al,-0xc(%ebp)
    if(c == '\n')
c010602b:	80 7d f4 0a          	cmpb   $0xa,-0xc(%ebp)
c010602f:	75 19                	jne    c010604a <vga_put_char+0x2c>
    {
        YPOS++;
c0106031:	a1 04 a0 10 c0       	mov    0xc010a004,%eax
c0106036:	83 c0 01             	add    $0x1,%eax
c0106039:	a3 04 a0 10 c0       	mov    %eax,0xc010a004
        XPOS = 0;
c010603e:	c7 05 08 a0 10 c0 00 	movl   $0x0,0xc010a008
c0106045:	00 00 00 
c0106048:	eb 54                	jmp    c010609e <vga_put_char+0x80>
    }else if(c == '\r')
c010604a:	80 7d f4 0d          	cmpb   $0xd,-0xc(%ebp)
c010604e:	75 0c                	jne    c010605c <vga_put_char+0x3e>
        XPOS = 0;
c0106050:	c7 05 08 a0 10 c0 00 	movl   $0x0,0xc010a008
c0106057:	00 00 00 
c010605a:	eb 42                	jmp    c010609e <vga_put_char+0x80>
    else{
        *(video + XPOS + YPOS * WIDTH) = (theme_color | c);
c010605c:	66 0f be 55 f4       	movsbw -0xc(%ebp),%dx
c0106061:	0f b7 05 00 a0 10 c0 	movzwl 0xc010a000,%eax
c0106068:	09 c2                	or     %eax,%edx
c010606a:	8b 0d 0c a0 10 c0    	mov    0xc010a00c,%ecx
c0106070:	a1 04 a0 10 c0       	mov    0xc010a004,%eax
c0106075:	89 c3                	mov    %eax,%ebx
c0106077:	89 d8                	mov    %ebx,%eax
c0106079:	c1 e0 02             	shl    $0x2,%eax
c010607c:	01 d8                	add    %ebx,%eax
c010607e:	c1 e0 04             	shl    $0x4,%eax
c0106081:	89 c3                	mov    %eax,%ebx
c0106083:	a1 08 a0 10 c0       	mov    0xc010a008,%eax
c0106088:	01 d8                	add    %ebx,%eax
c010608a:	01 c0                	add    %eax,%eax
c010608c:	01 c8                	add    %ecx,%eax
c010608e:	66 89 10             	mov    %dx,(%eax)
        XPOS++;
c0106091:	a1 08 a0 10 c0       	mov    0xc010a008,%eax
c0106096:	83 c0 01             	add    $0x1,%eax
c0106099:	a3 08 a0 10 c0       	mov    %eax,0xc010a008
    }
    if (XPOS >= WIDTH)
c010609e:	a1 08 a0 10 c0       	mov    0xc010a008,%eax
c01060a3:	83 f8 4f             	cmp    $0x4f,%eax
c01060a6:	7e 17                	jle    c01060bf <vga_put_char+0xa1>
    {
        YPOS++;
c01060a8:	a1 04 a0 10 c0       	mov    0xc010a004,%eax
c01060ad:	83 c0 01             	add    $0x1,%eax
c01060b0:	a3 04 a0 10 c0       	mov    %eax,0xc010a004
        XPOS = 0;
c01060b5:	c7 05 08 a0 10 c0 00 	movl   $0x0,0xc010a008
c01060bc:	00 00 00 
    }
    if(YPOS >= HIGHT)
c01060bf:	a1 04 a0 10 c0       	mov    0xc010a004,%eax
c01060c4:	83 f8 18             	cmp    $0x18,%eax
c01060c7:	7e 05                	jle    c01060ce <vga_put_char+0xb0>
        vga_scrollup();
c01060c9:	e8 be 00 00 00       	call   c010618c <vga_scrollup>
}
c01060ce:	90                   	nop
c01060cf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c01060d2:	c9                   	leave  
c01060d3:	c3                   	ret    

c01060d4 <vga_set_show>:

void vga_set_show(vga_attr flashing, vga_attr backgroud, vga_attr frontcolor)
{
c01060d4:	55                   	push   %ebp
c01060d5:	89 e5                	mov    %esp,%ebp
c01060d7:	83 ec 0c             	sub    $0xc,%esp
c01060da:	8b 4d 08             	mov    0x8(%ebp),%ecx
c01060dd:	8b 55 0c             	mov    0xc(%ebp),%edx
c01060e0:	8b 45 10             	mov    0x10(%ebp),%eax
c01060e3:	66 89 4d fc          	mov    %cx,-0x4(%ebp)
c01060e7:	66 89 55 f8          	mov    %dx,-0x8(%ebp)
c01060eb:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
    theme_color = (flashing << 7 | backgroud << 4 | frontcolor) << 8;
c01060ef:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
c01060f3:	c1 e0 07             	shl    $0x7,%eax
c01060f6:	89 c2                	mov    %eax,%edx
c01060f8:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
c01060fc:	c1 e0 04             	shl    $0x4,%eax
c01060ff:	09 c2                	or     %eax,%edx
c0106101:	0f b7 45 f4          	movzwl -0xc(%ebp),%eax
c0106105:	09 d0                	or     %edx,%eax
c0106107:	c1 e0 08             	shl    $0x8,%eax
c010610a:	66 a3 00 a0 10 c0    	mov    %ax,0xc010a000
}
c0106110:	90                   	nop
c0106111:	c9                   	leave  
c0106112:	c3                   	ret    

c0106113 <vga_put_str>:

void vga_put_str(char* str)
{
c0106113:	55                   	push   %ebp
c0106114:	89 e5                	mov    %esp,%ebp
c0106116:	83 ec 08             	sub    $0x8,%esp
    while (*str != '\0')
c0106119:	eb 19                	jmp    c0106134 <vga_put_str+0x21>
    {
        vga_put_char(*str);
c010611b:	8b 45 08             	mov    0x8(%ebp),%eax
c010611e:	0f b6 00             	movzbl (%eax),%eax
c0106121:	0f be c0             	movsbl %al,%eax
c0106124:	83 ec 0c             	sub    $0xc,%esp
c0106127:	50                   	push   %eax
c0106128:	e8 f1 fe ff ff       	call   c010601e <vga_put_char>
c010612d:	83 c4 10             	add    $0x10,%esp
        str++;
c0106130:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    while (*str != '\0')
c0106134:	8b 45 08             	mov    0x8(%ebp),%eax
c0106137:	0f b6 00             	movzbl (%eax),%eax
c010613a:	84 c0                	test   %al,%al
c010613c:	75 dd                	jne    c010611b <vga_put_str+0x8>
    }
}
c010613e:	90                   	nop
c010613f:	90                   	nop
c0106140:	c9                   	leave  
c0106141:	c3                   	ret    

c0106142 <vga_clear>:

void vga_clear()
{
c0106142:	55                   	push   %ebp
c0106143:	89 e5                	mov    %esp,%ebp
c0106145:	83 ec 10             	sub    $0x10,%esp
  
    for(int i = 0; i < WIDTH * HIGHT; i++)
c0106148:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c010614f:	eb 1b                	jmp    c010616c <vga_clear+0x2a>
        *(video + i) = theme_color;
c0106151:	8b 15 0c a0 10 c0    	mov    0xc010a00c,%edx
c0106157:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010615a:	01 c0                	add    %eax,%eax
c010615c:	01 c2                	add    %eax,%edx
c010615e:	0f b7 05 00 a0 10 c0 	movzwl 0xc010a000,%eax
c0106165:	66 89 02             	mov    %ax,(%edx)
    for(int i = 0; i < WIDTH * HIGHT; i++)
c0106168:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c010616c:	81 7d fc cf 07 00 00 	cmpl   $0x7cf,-0x4(%ebp)
c0106173:	7e dc                	jle    c0106151 <vga_clear+0xf>

    XPOS = 0;
c0106175:	c7 05 08 a0 10 c0 00 	movl   $0x0,0xc010a008
c010617c:	00 00 00 
    YPOS = 0;
c010617f:	c7 05 04 a0 10 c0 00 	movl   $0x0,0xc010a004
c0106186:	00 00 00 
}
c0106189:	90                   	nop
c010618a:	c9                   	leave  
c010618b:	c3                   	ret    

c010618c <vga_scrollup>:

void vga_scrollup()
{
c010618c:	55                   	push   %ebp
c010618d:	89 e5                	mov    %esp,%ebp
c010618f:	83 ec 10             	sub    $0x10,%esp
    unsigned int last_line = WIDTH * (HIGHT - 1);
c0106192:	c7 45 f4 80 07 00 00 	movl   $0x780,-0xc(%ebp)
    for (unsigned int i = 0; i < last_line; i++) {
c0106199:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c01061a0:	eb 27                	jmp    c01061c9 <vga_scrollup+0x3d>
        *(video + i) = *(video + WIDTH + i);
c01061a2:	8b 15 0c a0 10 c0    	mov    0xc010a00c,%edx
c01061a8:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01061ab:	83 c0 50             	add    $0x50,%eax
c01061ae:	01 c0                	add    %eax,%eax
c01061b0:	01 d0                	add    %edx,%eax
c01061b2:	8b 0d 0c a0 10 c0    	mov    0xc010a00c,%ecx
c01061b8:	8b 55 fc             	mov    -0x4(%ebp),%edx
c01061bb:	01 d2                	add    %edx,%edx
c01061bd:	01 ca                	add    %ecx,%edx
c01061bf:	0f b7 00             	movzwl (%eax),%eax
c01061c2:	66 89 02             	mov    %ax,(%edx)
    for (unsigned int i = 0; i < last_line; i++) {
c01061c5:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c01061c9:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01061cc:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c01061cf:	72 d1                	jb     c01061a2 <vga_scrollup+0x16>
    }
    for (unsigned int i = 0; i < WIDTH; i++) {
c01061d1:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c01061d8:	eb 20                	jmp    c01061fa <vga_scrollup+0x6e>
        *(video + i + last_line) = theme_color;
c01061da:	8b 15 0c a0 10 c0    	mov    0xc010a00c,%edx
c01061e0:	8b 4d f8             	mov    -0x8(%ebp),%ecx
c01061e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01061e6:	01 c8                	add    %ecx,%eax
c01061e8:	01 c0                	add    %eax,%eax
c01061ea:	01 c2                	add    %eax,%edx
c01061ec:	0f b7 05 00 a0 10 c0 	movzwl 0xc010a000,%eax
c01061f3:	66 89 02             	mov    %ax,(%edx)
    for (unsigned int i = 0; i < WIDTH; i++) {
c01061f6:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c01061fa:	83 7d f8 4f          	cmpl   $0x4f,-0x8(%ebp)
c01061fe:	76 da                	jbe    c01061da <vga_scrollup+0x4e>
    }
    YPOS = YPOS == 0 ? 0 : HIGHT - 1;
c0106200:	a1 04 a0 10 c0       	mov    0xc010a004,%eax
c0106205:	85 c0                	test   %eax,%eax
c0106207:	75 07                	jne    c0106210 <vga_scrollup+0x84>
c0106209:	b8 00 00 00 00       	mov    $0x0,%eax
c010620e:	eb 05                	jmp    c0106215 <vga_scrollup+0x89>
c0106210:	b8 18 00 00 00       	mov    $0x18,%eax
c0106215:	a3 04 a0 10 c0       	mov    %eax,0xc010a004
c010621a:	90                   	nop
c010621b:	c9                   	leave  
c010621c:	c3                   	ret    

c010621d <_kernel_init>:

/* Forward declarations. */
void _kernel_init (unsigned long addr);

void _kernel_init(unsigned long addr)
{
c010621d:	55                   	push   %ebp
c010621e:	89 e5                	mov    %esp,%ebp
c0106220:	53                   	push   %ebx
c0106221:	83 ec 44             	sub    $0x44,%esp
    multiboot_info_t *mbi;
    mbi = (multiboot_info_t *) addr;
c0106224:	8b 45 08             	mov    0x8(%ebp),%eax
c0106227:	89 45 e8             	mov    %eax,-0x18(%ebp)
    multiboot_memory_map_t* map = (multiboot_memory_map_t*)mbi->mmap_addr;
c010622a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010622d:	8b 40 30             	mov    0x30(%eax),%eax
c0106230:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    _init_idt();
c0106233:	e8 47 21 00 00       	call   c010837f <_init_idt>
    pmm_init(MEM_1MB + (mbi->mem_upper << 10));
c0106238:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010623b:	8b 40 08             	mov    0x8(%eax),%eax
c010623e:	c1 e0 0a             	shl    $0xa,%eax
c0106241:	05 00 00 10 00       	add    $0x100000,%eax
c0106246:	83 ec 0c             	sub    $0xc,%esp
c0106249:	50                   	push   %eax
c010624a:	e8 3c 04 00 00       	call   c010668b <pmm_init>
c010624f:	83 c4 10             	add    $0x10,%esp
    vmm_init();
c0106252:	e8 b0 0e 00 00       	call   c0107107 <vmm_init>

    init_vga_buffer();
c0106257:	e8 a4 fd ff ff       	call   c0106000 <init_vga_buffer>
    vga_set_show(0,VGA_COLOR_BLACK,VGA_COLOR_LIGHT_WHITE);
c010625c:	83 ec 04             	sub    $0x4,%esp
c010625f:	6a 0f                	push   $0xf
c0106261:	6a 00                	push   $0x0
c0106263:	6a 00                	push   $0x0
c0106265:	e8 6a fe ff ff       	call   c01060d4 <vga_set_show>
c010626a:	83 c4 10             	add    $0x10,%esp
    /* Clear the screen. */
    vga_clear();
c010626d:	e8 d0 fe ff ff       	call   c0106142 <vga_clear>
    // }

    /* Set MBI to the address of the Multiboot information structure. */

    /* Print out the flags. */
    kprintf("flags = 0x%x\n", (unsigned) mbi->flags);
c0106272:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0106275:	8b 00                	mov    (%eax),%eax
c0106277:	83 ec 08             	sub    $0x8,%esp
c010627a:	50                   	push   %eax
c010627b:	68 00 c0 28 c0       	push   $0xc028c000
c0106280:	e8 4c 2d 00 00       	call   c0108fd1 <kprintf>
c0106285:	83 c4 10             	add    $0x10,%esp

    /* Are mem_* valid? */
    if (CHECK_FLAG(mbi->flags, 0))
c0106288:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010628b:	8b 00                	mov    (%eax),%eax
c010628d:	83 e0 01             	and    $0x1,%eax
c0106290:	85 c0                	test   %eax,%eax
c0106292:	74 1e                	je     c01062b2 <_kernel_init+0x95>
        kprintf("mem_lower = %uKB, mem_upper = %uKB\n",(unsigned) mbi->mem_lower, (unsigned) mbi->mem_upper);
c0106294:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0106297:	8b 50 08             	mov    0x8(%eax),%edx
c010629a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010629d:	8b 40 04             	mov    0x4(%eax),%eax
c01062a0:	83 ec 04             	sub    $0x4,%esp
c01062a3:	52                   	push   %edx
c01062a4:	50                   	push   %eax
c01062a5:	68 10 c0 28 c0       	push   $0xc028c010
c01062aa:	e8 22 2d 00 00       	call   c0108fd1 <kprintf>
c01062af:	83 c4 10             	add    $0x10,%esp
    
    unsigned int map_size = mbi->mmap_length / sizeof(multiboot_memory_map_t);
c01062b2:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01062b5:	8b 40 2c             	mov    0x2c(%eax),%eax
c01062b8:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
c01062bd:	f7 e2                	mul    %edx
c01062bf:	89 d0                	mov    %edx,%eax
c01062c1:	c1 e8 04             	shr    $0x4,%eax
c01062c4:	89 45 e0             	mov    %eax,-0x20(%ebp)
    for (unsigned int i = 0; i < map_size; i++) {
c01062c7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c01062ce:	e9 1e 01 00 00       	jmp    c01063f1 <_kernel_init+0x1d4>
        multiboot_memory_map_t mmap = map[i];
c01062d3:	8b 55 f4             	mov    -0xc(%ebp),%edx
c01062d6:	89 d0                	mov    %edx,%eax
c01062d8:	01 c0                	add    %eax,%eax
c01062da:	01 d0                	add    %edx,%eax
c01062dc:	c1 e0 03             	shl    $0x3,%eax
c01062df:	89 c2                	mov    %eax,%edx
c01062e1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01062e4:	01 d0                	add    %edx,%eax
c01062e6:	8b 10                	mov    (%eax),%edx
c01062e8:	89 55 bc             	mov    %edx,-0x44(%ebp)
c01062eb:	8b 50 04             	mov    0x4(%eax),%edx
c01062ee:	89 55 c0             	mov    %edx,-0x40(%ebp)
c01062f1:	8b 50 08             	mov    0x8(%eax),%edx
c01062f4:	89 55 c4             	mov    %edx,-0x3c(%ebp)
c01062f7:	8b 50 0c             	mov    0xc(%eax),%edx
c01062fa:	89 55 c8             	mov    %edx,-0x38(%ebp)
c01062fd:	8b 50 10             	mov    0x10(%eax),%edx
c0106300:	89 55 cc             	mov    %edx,-0x34(%ebp)
c0106303:	8b 40 14             	mov    0x14(%eax),%eax
c0106306:	89 45 d0             	mov    %eax,-0x30(%ebp)
        kprintf("[MM] Base: 0x%x, len: %u KiB, type: %u\n",
               map[i].addr_low,
               map[i].len_low >> 10,
               map[i].type);
c0106309:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010630c:	89 d0                	mov    %edx,%eax
c010630e:	01 c0                	add    %eax,%eax
c0106310:	01 d0                	add    %edx,%eax
c0106312:	c1 e0 03             	shl    $0x3,%eax
c0106315:	89 c2                	mov    %eax,%edx
c0106317:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010631a:	01 d0                	add    %edx,%eax
        kprintf("[MM] Base: 0x%x, len: %u KiB, type: %u\n",
c010631c:	8b 50 14             	mov    0x14(%eax),%edx
               map[i].len_low >> 10,
c010631f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c0106322:	89 c8                	mov    %ecx,%eax
c0106324:	01 c0                	add    %eax,%eax
c0106326:	01 c8                	add    %ecx,%eax
c0106328:	c1 e0 03             	shl    $0x3,%eax
c010632b:	89 c1                	mov    %eax,%ecx
c010632d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0106330:	01 c8                	add    %ecx,%eax
c0106332:	8b 40 0c             	mov    0xc(%eax),%eax
        kprintf("[MM] Base: 0x%x, len: %u KiB, type: %u\n",
c0106335:	c1 e8 0a             	shr    $0xa,%eax
c0106338:	89 c3                	mov    %eax,%ebx
               map[i].addr_low,
c010633a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c010633d:	89 c8                	mov    %ecx,%eax
c010633f:	01 c0                	add    %eax,%eax
c0106341:	01 c8                	add    %ecx,%eax
c0106343:	c1 e0 03             	shl    $0x3,%eax
c0106346:	89 c1                	mov    %eax,%ecx
c0106348:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010634b:	01 c8                	add    %ecx,%eax
        kprintf("[MM] Base: 0x%x, len: %u KiB, type: %u\n",
c010634d:	8b 40 04             	mov    0x4(%eax),%eax
c0106350:	52                   	push   %edx
c0106351:	53                   	push   %ebx
c0106352:	50                   	push   %eax
c0106353:	68 34 c0 28 c0       	push   $0xc028c034
c0106358:	e8 74 2c 00 00       	call   c0108fd1 <kprintf>
c010635d:	83 c4 10             	add    $0x10,%esp
        if (mmap.type == MULTIBOOT_MEMORY_AVAILABLE) {
c0106360:	8b 45 d0             	mov    -0x30(%ebp),%eax
c0106363:	83 f8 01             	cmp    $0x1,%eax
c0106366:	0f 85 81 00 00 00    	jne    c01063ed <_kernel_init+0x1d0>
            // 整数向上取整除法
            uintptr_t pg = map[i].addr_low + 0x0fffU;
c010636c:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010636f:	89 d0                	mov    %edx,%eax
c0106371:	01 c0                	add    %eax,%eax
c0106373:	01 d0                	add    %edx,%eax
c0106375:	c1 e0 03             	shl    $0x3,%eax
c0106378:	89 c2                	mov    %eax,%edx
c010637a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010637d:	01 d0                	add    %edx,%eax
c010637f:	8b 40 04             	mov    0x4(%eax),%eax
c0106382:	05 ff 0f 00 00       	add    $0xfff,%eax
c0106387:	89 45 d4             	mov    %eax,-0x2c(%ebp)
            pmm_mark_chunk_free(pg >> 12, map[i].len_low >> 12);
c010638a:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010638d:	89 d0                	mov    %edx,%eax
c010638f:	01 c0                	add    %eax,%eax
c0106391:	01 d0                	add    %edx,%eax
c0106393:	c1 e0 03             	shl    $0x3,%eax
c0106396:	89 c2                	mov    %eax,%edx
c0106398:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010639b:	01 d0                	add    %edx,%eax
c010639d:	8b 40 0c             	mov    0xc(%eax),%eax
c01063a0:	c1 e8 0c             	shr    $0xc,%eax
c01063a3:	89 c2                	mov    %eax,%edx
c01063a5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c01063a8:	c1 e8 0c             	shr    $0xc,%eax
c01063ab:	83 ec 08             	sub    $0x8,%esp
c01063ae:	52                   	push   %edx
c01063af:	50                   	push   %eax
c01063b0:	e8 bb 03 00 00       	call   c0106770 <pmm_mark_chunk_free>
c01063b5:	83 c4 10             	add    $0x10,%esp
            kprintf("[MM] Freed %u pages start from 0x%x\n",
c01063b8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c01063bb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c01063c0:	89 c1                	mov    %eax,%ecx
                   map[i].len_low >> 12,
c01063c2:	8b 55 f4             	mov    -0xc(%ebp),%edx
c01063c5:	89 d0                	mov    %edx,%eax
c01063c7:	01 c0                	add    %eax,%eax
c01063c9:	01 d0                	add    %edx,%eax
c01063cb:	c1 e0 03             	shl    $0x3,%eax
c01063ce:	89 c2                	mov    %eax,%edx
c01063d0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01063d3:	01 d0                	add    %edx,%eax
c01063d5:	8b 40 0c             	mov    0xc(%eax),%eax
            kprintf("[MM] Freed %u pages start from 0x%x\n",
c01063d8:	c1 e8 0c             	shr    $0xc,%eax
c01063db:	83 ec 04             	sub    $0x4,%esp
c01063de:	51                   	push   %ecx
c01063df:	50                   	push   %eax
c01063e0:	68 5c c0 28 c0       	push   $0xc028c05c
c01063e5:	e8 e7 2b 00 00       	call   c0108fd1 <kprintf>
c01063ea:	83 c4 10             	add    $0x10,%esp
    for (unsigned int i = 0; i < map_size; i++) {
c01063ed:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c01063f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01063f4:	3b 45 e0             	cmp    -0x20(%ebp),%eax
c01063f7:	0f 82 d6 fe ff ff    	jb     c01062d3 <_kernel_init+0xb6>
                   pg & ~0x0fffU);
        }
    }

    // 将内核占据的页设为已占用
    size_t pg_count = (uintptr_t)(&virkernel_end  - &virkernel_start) >> 12;
c01063fd:	b8 00 30 29 c0       	mov    $0xc0293000,%eax
c0106402:	2d 00 60 10 c0       	sub    $0xc0106000,%eax
c0106407:	c1 e8 0c             	shr    $0xc,%eax
c010640a:	89 45 dc             	mov    %eax,-0x24(%ebp)
    pmm_mark_chunk_occupied(KERNEL_PID, V2P(&virkernel_start) >> 12, pg_count, 0);
c010640d:	b8 00 60 10 c0       	mov    $0xc0106000,%eax
c0106412:	05 00 00 00 40       	add    $0x40000000,%eax
c0106417:	c1 e8 0c             	shr    $0xc,%eax
c010641a:	6a 00                	push   $0x0
c010641c:	ff 75 dc             	push   -0x24(%ebp)
c010641f:	50                   	push   %eax
c0106420:	6a ff                	push   $0xffffffff
c0106422:	e8 8c 03 00 00       	call   c01067b3 <pmm_mark_chunk_occupied>
c0106427:	83 c4 10             	add    $0x10,%esp
    kprintf("[MM] Allocated %d pages for kernel.\n", pg_count);
c010642a:	83 ec 08             	sub    $0x8,%esp
c010642d:	ff 75 dc             	push   -0x24(%ebp)
c0106430:	68 84 c0 28 c0       	push   $0xc028c084
c0106435:	e8 97 2b 00 00       	call   c0108fd1 <kprintf>
c010643a:	83 c4 10             	add    $0x10,%esp

    size_t vga_buf_pgs = VGA_BUFFER_SIZE >> 12;
c010643d:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
    
    // 首先，标记VGA部分为已占用
    pmm_mark_chunk_occupied(KERNEL_PID, VIDEO >> 12, vga_buf_pgs, 0);
c0106444:	6a 00                	push   $0x0
c0106446:	ff 75 d8             	push   -0x28(%ebp)
c0106449:	68 b8 00 00 00       	push   $0xb8
c010644e:	6a ff                	push   $0xffffffff
c0106450:	e8 5e 03 00 00       	call   c01067b3 <pmm_mark_chunk_occupied>
c0106455:	83 c4 10             	add    $0x10,%esp
    
    // 重映射VGA文本缓冲区（以后会变成显存，i.e., framebuffer）
    for (size_t i = 0; i < vga_buf_pgs; i++)
c0106458:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c010645f:	eb 2f                	jmp    c0106490 <_kernel_init+0x273>
    {
        vmm_map_page(KERNEL_PID, VGA_BUFFER_VADDR + (i << 12), VIDEO + (i << 12), PG_PREM_RW, PG_PREM_RW);
c0106461:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106464:	c1 e0 0c             	shl    $0xc,%eax
c0106467:	05 00 80 0b 00       	add    $0xb8000,%eax
c010646c:	89 c2                	mov    %eax,%edx
c010646e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106471:	c1 e0 0c             	shl    $0xc,%eax
c0106474:	2d 00 00 00 50       	sub    $0x50000000,%eax
c0106479:	83 ec 0c             	sub    $0xc,%esp
c010647c:	6a 03                	push   $0x3
c010647e:	6a 03                	push   $0x3
c0106480:	52                   	push   %edx
c0106481:	50                   	push   %eax
c0106482:	6a ff                	push   $0xffffffff
c0106484:	e8 3f 0e 00 00       	call   c01072c8 <vmm_map_page>
c0106489:	83 c4 20             	add    $0x20,%esp
    for (size_t i = 0; i < vga_buf_pgs; i++)
c010648c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0106490:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106493:	3b 45 d8             	cmp    -0x28(%ebp),%eax
c0106496:	72 c9                	jb     c0106461 <_kernel_init+0x244>
    }
    set_vga_buffer(VGA_BUFFER_VADDR);
c0106498:	83 ec 0c             	sub    $0xc,%esp
c010649b:	68 00 00 00 b0       	push   $0xb0000000
c01064a0:	e8 6b fb ff ff       	call   c0106010 <set_vga_buffer>
c01064a5:	83 c4 10             	add    $0x10,%esp
    kprintf("[MM] Mapped VGA to %x.\n", VGA_BUFFER_VADDR);
c01064a8:	83 ec 08             	sub    $0x8,%esp
c01064ab:	68 00 00 00 b0       	push   $0xb0000000
c01064b0:	68 a9 c0 28 c0       	push   $0xc028c0a9
c01064b5:	e8 17 2b 00 00       	call   c0108fd1 <kprintf>
c01064ba:	83 c4 10             	add    $0x10,%esp

    // 为内核创建一个专属栈空间。
    for (size_t i = 0; i < (K_STACK_SIZE >> 12); i++) {
c01064bd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c01064c4:	eb 23                	jmp    c01064e9 <_kernel_init+0x2cc>
        vmm_alloc_page(KERNEL_PID, K_STACK_START + (i << 12), NULL, PG_PREM_RW, PG_PREM_RW);
c01064c6:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01064c9:	c1 e0 0c             	shl    $0xc,%eax
c01064cc:	2d 00 00 50 00       	sub    $0x500000,%eax
c01064d1:	83 ec 0c             	sub    $0xc,%esp
c01064d4:	6a 03                	push   $0x3
c01064d6:	6a 03                	push   $0x3
c01064d8:	6a 00                	push   $0x0
c01064da:	50                   	push   %eax
c01064db:	6a ff                	push   $0xffffffff
c01064dd:	e8 91 11 00 00       	call   c0107673 <vmm_alloc_page>
c01064e2:	83 c4 20             	add    $0x20,%esp
    for (size_t i = 0; i < (K_STACK_SIZE >> 12); i++) {
c01064e5:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c01064e9:	81 7d ec ff 00 00 00 	cmpl   $0xff,-0x14(%ebp)
c01064f0:	76 d4                	jbe    c01064c6 <_kernel_init+0x2a9>
    }
    kprintf("[MM] Allocated %d pages for stack start at %p\n", K_STACK_SIZE>>12, K_STACK_START);
c01064f2:	83 ec 04             	sub    $0x4,%esp
c01064f5:	68 00 00 b0 ff       	push   $0xffb00000
c01064fa:	68 00 01 00 00       	push   $0x100
c01064ff:	68 c4 c0 28 c0       	push   $0xc028c0c4
c0106504:	e8 c8 2a 00 00       	call   c0108fd1 <kprintf>
c0106509:	83 c4 10             	add    $0x10,%esp

    //give malloc init
    mem_init();
c010650c:	e8 69 08 00 00       	call   c0106d7a <mem_init>
    kprintf("[MM] Malloc Init Success \n");
c0106511:	83 ec 0c             	sub    $0xc,%esp
c0106514:	68 f3 c0 28 c0       	push   $0xc028c0f3
c0106519:	e8 b3 2a 00 00       	call   c0108fd1 <kprintf>
c010651e:	83 c4 10             	add    $0x10,%esp
    kprintf("[KERNEL] === Initialization Done === \n\n");
c0106521:	83 ec 0c             	sub    $0xc,%esp
c0106524:	68 10 c1 28 c0       	push   $0xc028c110
c0106529:	e8 a3 2a 00 00       	call   c0108fd1 <kprintf>
c010652e:	83 c4 10             	add    $0x10,%esp

    vga_put_str("MELOX OS\n");
c0106531:	83 ec 0c             	sub    $0xc,%esp
c0106534:	68 38 c1 28 c0       	push   $0xc028c138
c0106539:	e8 d5 fb ff ff       	call   c0106113 <vga_put_str>
c010653e:	83 c4 10             	add    $0x10,%esp
     //__asm__("int $1");
}
c0106541:	90                   	nop
c0106542:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0106545:	c9                   	leave  
c0106546:	c3                   	ret    

c0106547 <_kernel_finnal_init>:

void _kernel_finnal_init() {
c0106547:	55                   	push   %ebp
c0106548:	89 e5                	mov    %esp,%ebp
c010654a:	83 ec 18             	sub    $0x18,%esp
    //kprintf("[KERNEL] === Post Initialization === \n");
    size_t virk_init_pg_count = ((uintptr_t)(&__init_phykernel_end)) >> 12;
c010654d:	b8 00 60 10 00       	mov    $0x106000,%eax
c0106552:	c1 e8 0c             	shr    $0xc,%eax
c0106555:	89 45 f0             	mov    %eax,-0x10(%ebp)
    kprintf("[MM] Releaseing %d pages from 0x0.\n", virk_init_pg_count);
c0106558:	83 ec 08             	sub    $0x8,%esp
c010655b:	ff 75 f0             	push   -0x10(%ebp)
c010655e:	68 44 c1 28 c0       	push   $0xc028c144
c0106563:	e8 69 2a 00 00       	call   c0108fd1 <kprintf>
c0106568:	83 c4 10             	add    $0x10,%esp
    
    // // 清除 hhk_init 与前1MiB的映射
    for (size_t i = 0; i < virk_init_pg_count; i++) {
c010656b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0106572:	eb 18                	jmp    c010658c <_kernel_finnal_init+0x45>

        vmm_unmap_page(KERNEL_PID, (i << 12));
c0106574:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106577:	c1 e0 0c             	shl    $0xc,%eax
c010657a:	83 ec 08             	sub    $0x8,%esp
c010657d:	50                   	push   %eax
c010657e:	6a ff                	push   $0xffffffff
c0106580:	e8 af 13 00 00       	call   c0107934 <vmm_unmap_page>
c0106585:	83 c4 10             	add    $0x10,%esp
    for (size_t i = 0; i < virk_init_pg_count; i++) {
c0106588:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010658c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010658f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0106592:	72 e0                	jb     c0106574 <_kernel_finnal_init+0x2d>
    // }
    // for (size_t i = 256; i < virk_init_pg_count; i++) {

    //     vmm_unmap_page((i << 12));
    // }
    kprintf("[KERNEL] === Post Initialization Done === \n\n");
c0106594:	83 ec 0c             	sub    $0xc,%esp
c0106597:	68 68 c1 28 c0       	push   $0xc028c168
c010659c:	e8 30 2a 00 00       	call   c0108fd1 <kprintf>
c01065a1:	83 c4 10             	add    $0x10,%esp
}
c01065a4:	90                   	nop
c01065a5:	c9                   	leave  
c01065a6:	c3                   	ret    

c01065a7 <_kernel_main>:

void _kernel_main()
{
c01065a7:	55                   	push   %ebp
c01065a8:	89 e5                	mov    %esp,%ebp
c01065aa:	81 ec 18 01 00 00    	sub    $0x118,%esp
    char* buf[64];
    
    kprintf("We are now running in virtual address space!\n\n");
c01065b0:	83 ec 0c             	sub    $0xc,%esp
c01065b3:	68 98 c1 28 c0       	push   $0xc028c198
c01065b8:	e8 14 2a 00 00       	call   c0108fd1 <kprintf>
c01065bd:	83 c4 10             	add    $0x10,%esp
    
    cpu_get_brand(buf);
c01065c0:	83 ec 0c             	sub    $0xc,%esp
c01065c3:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
c01065c9:	50                   	push   %eax
c01065ca:	e8 af 1a 00 00       	call   c010807e <cpu_get_brand>
c01065cf:	83 c4 10             	add    $0x10,%esp
    kprintf("CPU: %s\n\n", buf);
c01065d2:	83 ec 08             	sub    $0x8,%esp
c01065d5:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
c01065db:	50                   	push   %eax
c01065dc:	68 c7 c1 28 c0       	push   $0xc028c1c7
c01065e1:	e8 eb 29 00 00       	call   c0108fd1 <kprintf>
c01065e6:	83 c4 10             	add    $0x10,%esp

    uintptr_t k_start = vmm_v2p(&virkernel_start);
c01065e9:	83 ec 0c             	sub    $0xc,%esp
c01065ec:	68 00 60 10 c0       	push   $0xc0106000
c01065f1:	e8 60 14 00 00       	call   c0107a56 <vmm_v2p>
c01065f6:	83 c4 10             	add    $0x10,%esp
c01065f9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    kprintf("The kernel's base address mapping: %x->%x\n", &virkernel_start, k_start);
c01065fc:	83 ec 04             	sub    $0x4,%esp
c01065ff:	ff 75 f4             	push   -0xc(%ebp)
c0106602:	68 00 60 10 c0       	push   $0xc0106000
c0106607:	68 d4 c1 28 c0       	push   $0xc028c1d4
c010660c:	e8 c0 29 00 00       	call   c0108fd1 <kprintf>
c0106611:	83 c4 10             	add    $0x10,%esp
    //__asm__("int $0");
    // test malloc & free

    uint8_t* big_ = k_malloc(1000);
c0106614:	83 ec 0c             	sub    $0xc,%esp
c0106617:	68 e8 03 00 00       	push   $0x3e8
c010661c:	e8 4b 09 00 00       	call   c0106f6c <k_malloc>
c0106621:	83 c4 10             	add    $0x10,%esp
c0106624:	89 45 f0             	mov    %eax,-0x10(%ebp)
    big_[0] = 123;
c0106627:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010662a:	c6 00 7b             	movb   $0x7b,(%eax)
    big_[1] = 23;
c010662d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106630:	83 c0 01             	add    $0x1,%eax
c0106633:	c6 00 17             	movb   $0x17,(%eax)
    big_[2] = 3;
c0106636:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106639:	83 c0 02             	add    $0x2,%eax
c010663c:	c6 00 03             	movb   $0x3,(%eax)

    kprintf("malloc %d, %d, %d\n", big_[0], big_[1], big_[2]);
c010663f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106642:	83 c0 02             	add    $0x2,%eax
c0106645:	0f b6 00             	movzbl (%eax),%eax
c0106648:	0f b6 c8             	movzbl %al,%ecx
c010664b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010664e:	83 c0 01             	add    $0x1,%eax
c0106651:	0f b6 00             	movzbl (%eax),%eax
c0106654:	0f b6 d0             	movzbl %al,%edx
c0106657:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010665a:	0f b6 00             	movzbl (%eax),%eax
c010665d:	0f b6 c0             	movzbl %al,%eax
c0106660:	51                   	push   %ecx
c0106661:	52                   	push   %edx
c0106662:	50                   	push   %eax
c0106663:	68 ff c1 28 c0       	push   $0xc028c1ff
c0106668:	e8 64 29 00 00       	call   c0108fd1 <kprintf>
c010666d:	83 c4 10             	add    $0x10,%esp
    malloc_free(big_);
c0106670:	83 ec 0c             	sub    $0xc,%esp
c0106673:	ff 75 f0             	push   -0x10(%ebp)
c0106676:	e8 ac 08 00 00       	call   c0106f27 <malloc_free>
c010667b:	83 c4 10             	add    $0x10,%esp

    timer_init();
c010667e:	e8 97 15 00 00       	call   c0107c1a <timer_init>
    init_keyboard();
c0106683:	e8 90 21 00 00       	call   c0108818 <init_keyboard>
c0106688:	90                   	nop
c0106689:	c9                   	leave  
c010668a:	c3                   	ret    

c010668b <pmm_init>:

#ifdef MEMSTRUCT
static struct pp_struct pm_table[PM_BMP_MAX_SIZE];

void pmm_init(uintptr_t mem_upper_lim)
{
c010668b:	55                   	push   %ebp
c010668c:	89 e5                	mov    %esp,%ebp
c010668e:	83 ec 10             	sub    $0x10,%esp
    pg_lookup_ptr = LOOKUP_START;
c0106691:	c7 05 20 a0 10 c0 01 	movl   $0x1,0xc010a020
c0106698:	00 00 00 
    max_pg = (PG_ALIGN(mem_upper_lim) >> 12);
c010669b:	8b 45 08             	mov    0x8(%ebp),%eax
c010669e:	c1 e8 0c             	shr    $0xc,%eax
c01066a1:	a3 24 a0 10 c0       	mov    %eax,0xc010a024

    for (size_t i = 0; i < PM_BMP_MAX_SIZE; i++) {
c01066a6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c01066ad:	eb 49                	jmp    c01066f8 <pmm_init+0x6d>
        pm_table[i] = (struct pp_struct) {
c01066af:	8b 55 fc             	mov    -0x4(%ebp),%edx
c01066b2:	89 d0                	mov    %edx,%eax
c01066b4:	01 c0                	add    %eax,%eax
c01066b6:	01 d0                	add    %edx,%eax
c01066b8:	c1 e0 02             	shl    $0x2,%eax
c01066bb:	05 40 a0 10 c0       	add    $0xc010a040,%eax
c01066c0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c01066c6:	8b 55 fc             	mov    -0x4(%ebp),%edx
c01066c9:	89 d0                	mov    %edx,%eax
c01066cb:	01 c0                	add    %eax,%eax
c01066cd:	01 d0                	add    %edx,%eax
c01066cf:	c1 e0 02             	shl    $0x2,%eax
c01066d2:	05 44 a0 10 c0       	add    $0xc010a044,%eax
c01066d7:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
c01066dd:	8b 55 fc             	mov    -0x4(%ebp),%edx
c01066e0:	89 d0                	mov    %edx,%eax
c01066e2:	01 c0                	add    %eax,%eax
c01066e4:	01 d0                	add    %edx,%eax
c01066e6:	c1 e0 02             	shl    $0x2,%eax
c01066e9:	05 48 a0 10 c0       	add    $0xc010a048,%eax
c01066ee:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    for (size_t i = 0; i < PM_BMP_MAX_SIZE; i++) {
c01066f4:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c01066f8:	81 7d fc ff ff 01 00 	cmpl   $0x1ffff,-0x4(%ebp)
c01066ff:	76 ae                	jbe    c01066af <pmm_init+0x24>
            .owner = 0,
            .attr = 0,
            .ref_counts = 1
        };
    }
}
c0106701:	90                   	nop
c0106702:	90                   	nop
c0106703:	c9                   	leave  
c0106704:	c3                   	ret    

c0106705 <pmm_mark_page_free>:

void pmm_mark_page_free(uintptr_t ppn)
{
c0106705:	55                   	push   %ebp
c0106706:	89 e5                	mov    %esp,%ebp
    pm_table[ppn].ref_counts = 0;
c0106708:	8b 55 08             	mov    0x8(%ebp),%edx
c010670b:	89 d0                	mov    %edx,%eax
c010670d:	01 c0                	add    %eax,%eax
c010670f:	01 d0                	add    %edx,%eax
c0106711:	c1 e0 02             	shl    $0x2,%eax
c0106714:	05 44 a0 10 c0       	add    $0xc010a044,%eax
c0106719:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
c010671f:	90                   	nop
c0106720:	5d                   	pop    %ebp
c0106721:	c3                   	ret    

c0106722 <pmm_mark_page_occupied>:

void pmm_mark_page_occupied(pid_t owner, uintptr_t ppn, pp_attr_t attr)
{
c0106722:	55                   	push   %ebp
c0106723:	89 e5                	mov    %esp,%ebp
c0106725:	83 ec 10             	sub    $0x10,%esp
    pm_table[ppn] = (struct pp_struct) {
c0106728:	8b 55 0c             	mov    0xc(%ebp),%edx
c010672b:	89 d0                	mov    %edx,%eax
c010672d:	01 c0                	add    %eax,%eax
c010672f:	01 d0                	add    %edx,%eax
c0106731:	c1 e0 02             	shl    $0x2,%eax
c0106734:	8d 90 40 a0 10 c0    	lea    -0x3fef5fc0(%eax),%edx
c010673a:	8b 45 08             	mov    0x8(%ebp),%eax
c010673d:	89 02                	mov    %eax,(%edx)
c010673f:	8b 55 0c             	mov    0xc(%ebp),%edx
c0106742:	89 d0                	mov    %edx,%eax
c0106744:	01 c0                	add    %eax,%eax
c0106746:	01 d0                	add    %edx,%eax
c0106748:	c1 e0 02             	shl    $0x2,%eax
c010674b:	05 44 a0 10 c0       	add    $0xc010a044,%eax
c0106750:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
c0106756:	8b 55 0c             	mov    0xc(%ebp),%edx
c0106759:	89 d0                	mov    %edx,%eax
c010675b:	01 c0                	add    %eax,%eax
c010675d:	01 d0                	add    %edx,%eax
c010675f:	c1 e0 02             	shl    $0x2,%eax
c0106762:	8d 90 48 a0 10 c0    	lea    -0x3fef5fb8(%eax),%edx
c0106768:	8b 45 10             	mov    0x10(%ebp),%eax
c010676b:	89 02                	mov    %eax,(%edx)
        .owner = owner,
        .ref_counts = 1,
        .attr = attr
    };
}
c010676d:	90                   	nop
c010676e:	c9                   	leave  
c010676f:	c3                   	ret    

c0106770 <pmm_mark_chunk_free>:

void pmm_mark_chunk_free(uintptr_t start_ppn, size_t page_count)
{
c0106770:	55                   	push   %ebp
c0106771:	89 e5                	mov    %esp,%ebp
c0106773:	83 ec 10             	sub    $0x10,%esp
    for (size_t i = start_ppn; i < start_ppn + page_count && i < max_pg; i++)
c0106776:	8b 45 08             	mov    0x8(%ebp),%eax
c0106779:	89 45 fc             	mov    %eax,-0x4(%ebp)
c010677c:	eb 1b                	jmp    c0106799 <pmm_mark_chunk_free+0x29>
    {
        pm_table[i].ref_counts = 0;
c010677e:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0106781:	89 d0                	mov    %edx,%eax
c0106783:	01 c0                	add    %eax,%eax
c0106785:	01 d0                	add    %edx,%eax
c0106787:	c1 e0 02             	shl    $0x2,%eax
c010678a:	05 44 a0 10 c0       	add    $0xc010a044,%eax
c010678f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    for (size_t i = start_ppn; i < start_ppn + page_count && i < max_pg; i++)
c0106795:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0106799:	8b 55 08             	mov    0x8(%ebp),%edx
c010679c:	8b 45 0c             	mov    0xc(%ebp),%eax
c010679f:	01 d0                	add    %edx,%eax
c01067a1:	39 45 fc             	cmp    %eax,-0x4(%ebp)
c01067a4:	73 0a                	jae    c01067b0 <pmm_mark_chunk_free+0x40>
c01067a6:	a1 24 a0 10 c0       	mov    0xc010a024,%eax
c01067ab:	39 45 fc             	cmp    %eax,-0x4(%ebp)
c01067ae:	72 ce                	jb     c010677e <pmm_mark_chunk_free+0xe>
    }
}
c01067b0:	90                   	nop
c01067b1:	c9                   	leave  
c01067b2:	c3                   	ret    

c01067b3 <pmm_mark_chunk_occupied>:

void pmm_mark_chunk_occupied(pid_t owner, uint32_t start_ppn, size_t page_count, pp_attr_t attr)
{
c01067b3:	55                   	push   %ebp
c01067b4:	89 e5                	mov    %esp,%ebp
c01067b6:	83 ec 10             	sub    $0x10,%esp
    for (size_t i = start_ppn; i < start_ppn + page_count && i < max_pg; i++)
c01067b9:	8b 45 0c             	mov    0xc(%ebp),%eax
c01067bc:	89 45 fc             	mov    %eax,-0x4(%ebp)
c01067bf:	eb 49                	jmp    c010680a <pmm_mark_chunk_occupied+0x57>
    {
        pm_table[i] = (struct pp_struct) {
c01067c1:	8b 55 fc             	mov    -0x4(%ebp),%edx
c01067c4:	89 d0                	mov    %edx,%eax
c01067c6:	01 c0                	add    %eax,%eax
c01067c8:	01 d0                	add    %edx,%eax
c01067ca:	c1 e0 02             	shl    $0x2,%eax
c01067cd:	8d 90 40 a0 10 c0    	lea    -0x3fef5fc0(%eax),%edx
c01067d3:	8b 45 08             	mov    0x8(%ebp),%eax
c01067d6:	89 02                	mov    %eax,(%edx)
c01067d8:	8b 55 fc             	mov    -0x4(%ebp),%edx
c01067db:	89 d0                	mov    %edx,%eax
c01067dd:	01 c0                	add    %eax,%eax
c01067df:	01 d0                	add    %edx,%eax
c01067e1:	c1 e0 02             	shl    $0x2,%eax
c01067e4:	05 44 a0 10 c0       	add    $0xc010a044,%eax
c01067e9:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
c01067ef:	8b 55 fc             	mov    -0x4(%ebp),%edx
c01067f2:	89 d0                	mov    %edx,%eax
c01067f4:	01 c0                	add    %eax,%eax
c01067f6:	01 d0                	add    %edx,%eax
c01067f8:	c1 e0 02             	shl    $0x2,%eax
c01067fb:	8d 90 48 a0 10 c0    	lea    -0x3fef5fb8(%eax),%edx
c0106801:	8b 45 14             	mov    0x14(%ebp),%eax
c0106804:	89 02                	mov    %eax,(%edx)
    for (size_t i = start_ppn; i < start_ppn + page_count && i < max_pg; i++)
c0106806:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c010680a:	8b 55 0c             	mov    0xc(%ebp),%edx
c010680d:	8b 45 10             	mov    0x10(%ebp),%eax
c0106810:	01 d0                	add    %edx,%eax
c0106812:	39 45 fc             	cmp    %eax,-0x4(%ebp)
c0106815:	73 0a                	jae    c0106821 <pmm_mark_chunk_occupied+0x6e>
c0106817:	a1 24 a0 10 c0       	mov    0xc010a024,%eax
c010681c:	39 45 fc             	cmp    %eax,-0x4(%ebp)
c010681f:	72 a0                	jb     c01067c1 <pmm_mark_chunk_occupied+0xe>
            .owner = owner,
            .ref_counts = 1,
            .attr = attr
        };
    }
}
c0106821:	90                   	nop
c0106822:	c9                   	leave  
c0106823:	c3                   	ret    

c0106824 <pmm_alloc_page>:

void* pmm_alloc_page(pid_t owner, pp_attr_t attr)
{
c0106824:	55                   	push   %ebp
c0106825:	89 e5                	mov    %esp,%ebp
c0106827:	83 ec 20             	sub    $0x20,%esp
        // Next fit approach. Maximize the throughput!
    uintptr_t good_page_found = NULL;
c010682a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    size_t old_pg_ptr = pg_lookup_ptr;
c0106831:	a1 20 a0 10 c0       	mov    0xc010a020,%eax
c0106836:	89 45 f8             	mov    %eax,-0x8(%ebp)
    size_t upper_lim = max_pg;
c0106839:	a1 24 a0 10 c0       	mov    0xc010a024,%eax
c010683e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    struct pp_struct* pm;
    while (!good_page_found && pg_lookup_ptr < upper_lim) {
c0106841:	eb 7d                	jmp    c01068c0 <pmm_alloc_page+0x9c>
        pm = &pm_table[pg_lookup_ptr];
c0106843:	8b 15 20 a0 10 c0    	mov    0xc010a020,%edx
c0106849:	89 d0                	mov    %edx,%eax
c010684b:	01 c0                	add    %eax,%eax
c010684d:	01 d0                	add    %edx,%eax
c010684f:	c1 e0 02             	shl    $0x2,%eax
c0106852:	05 40 a0 10 c0       	add    $0xc010a040,%eax
c0106857:	89 45 f0             	mov    %eax,-0x10(%ebp)

        // skip the fully occupied chunk, reduce # of iterations
        if (!pm->ref_counts) {
c010685a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010685d:	8b 40 04             	mov    0x4(%eax),%eax
c0106860:	85 c0                	test   %eax,%eax
c0106862:	75 28                	jne    c010688c <pmm_alloc_page+0x68>
                *pm = (struct pp_struct) {
c0106864:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106867:	8b 55 08             	mov    0x8(%ebp),%edx
c010686a:	89 10                	mov    %edx,(%eax)
c010686c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010686f:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
c0106876:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106879:	8b 55 0c             	mov    0xc(%ebp),%edx
c010687c:	89 50 08             	mov    %edx,0x8(%eax)
                .attr = attr,
                .owner = owner,
                .ref_counts = 1
            };
            good_page_found = pg_lookup_ptr << 12;
c010687f:	a1 20 a0 10 c0       	mov    0xc010a020,%eax
c0106884:	c1 e0 0c             	shl    $0xc,%eax
c0106887:	89 45 fc             	mov    %eax,-0x4(%ebp)
c010688a:	eb 34                	jmp    c01068c0 <pmm_alloc_page+0x9c>
        } else {
            pg_lookup_ptr ++;
c010688c:	a1 20 a0 10 c0       	mov    0xc010a020,%eax
c0106891:	83 c0 01             	add    $0x1,%eax
c0106894:	a3 20 a0 10 c0       	mov    %eax,0xc010a020

            // We've searched the interval [old_pg_ptr, max_pg) but failed
            //   may be chances in [1, old_pg_ptr) ?
            // Let's find out!
            if (pg_lookup_ptr >= upper_lim && old_pg_ptr != LOOKUP_START) {
c0106899:	a1 20 a0 10 c0       	mov    0xc010a020,%eax
c010689e:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c01068a1:	77 1d                	ja     c01068c0 <pmm_alloc_page+0x9c>
c01068a3:	83 7d f8 01          	cmpl   $0x1,-0x8(%ebp)
c01068a7:	74 17                	je     c01068c0 <pmm_alloc_page+0x9c>
                upper_lim = old_pg_ptr;
c01068a9:	8b 45 f8             	mov    -0x8(%ebp),%eax
c01068ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
                pg_lookup_ptr = LOOKUP_START;
c01068af:	c7 05 20 a0 10 c0 01 	movl   $0x1,0xc010a020
c01068b6:	00 00 00 
                old_pg_ptr = LOOKUP_START;
c01068b9:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
    while (!good_page_found && pg_lookup_ptr < upper_lim) {
c01068c0:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c01068c4:	75 0e                	jne    c01068d4 <pmm_alloc_page+0xb0>
c01068c6:	a1 20 a0 10 c0       	mov    0xc010a020,%eax
c01068cb:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c01068ce:	0f 87 6f ff ff ff    	ja     c0106843 <pmm_alloc_page+0x1f>
        }
    }
    // if (!good_page_found) {
    //     __current->k_status = LXOUTOFMEM;
    // }
    return (void*)good_page_found;
c01068d4:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c01068d7:	c9                   	leave  
c01068d8:	c3                   	ret    

c01068d9 <pmm_alloc_cpage>:

void* pmm_alloc_cpage(pid_t owner, size_t num_pages, pp_attr_t attr) {
c01068d9:	55                   	push   %ebp
c01068da:	89 e5                	mov    %esp,%ebp
c01068dc:	83 ec 10             	sub    $0x10,%esp
    size_t p1 = 0;
c01068df:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    size_t p2 = 0;
c01068e6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

    while (p2 < max_pg && p2 - p1 < num_pages)
c01068ed:	eb 28                	jmp    c0106917 <pmm_alloc_cpage+0x3e>
    {
        (!(&pm_table[p2])->ref_counts) ? (p2++) : (p1 = p2);
c01068ef:	8b 55 f8             	mov    -0x8(%ebp),%edx
c01068f2:	89 d0                	mov    %edx,%eax
c01068f4:	01 c0                	add    %eax,%eax
c01068f6:	01 d0                	add    %edx,%eax
c01068f8:	c1 e0 02             	shl    $0x2,%eax
c01068fb:	05 44 a0 10 c0       	add    $0xc010a044,%eax
c0106900:	8b 00                	mov    (%eax),%eax
c0106902:	85 c0                	test   %eax,%eax
c0106904:	75 0b                	jne    c0106911 <pmm_alloc_cpage+0x38>
c0106906:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0106909:	83 c0 01             	add    $0x1,%eax
c010690c:	89 45 f8             	mov    %eax,-0x8(%ebp)
c010690f:	eb 06                	jmp    c0106917 <pmm_alloc_cpage+0x3e>
c0106911:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0106914:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while (p2 < max_pg && p2 - p1 < num_pages)
c0106917:	a1 24 a0 10 c0       	mov    0xc010a024,%eax
c010691c:	39 45 f8             	cmp    %eax,-0x8(%ebp)
c010691f:	73 0b                	jae    c010692c <pmm_alloc_cpage+0x53>
c0106921:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0106924:	2b 45 fc             	sub    -0x4(%ebp),%eax
c0106927:	39 45 0c             	cmp    %eax,0xc(%ebp)
c010692a:	77 c3                	ja     c01068ef <pmm_alloc_cpage+0x16>
    }

    if (p2 < max_pg) {
c010692c:	a1 24 a0 10 c0       	mov    0xc010a024,%eax
c0106931:	39 45 f8             	cmp    %eax,-0x8(%ebp)
c0106934:	73 07                	jae    c010693d <pmm_alloc_cpage+0x64>
        return NULL;
c0106936:	b8 00 00 00 00       	mov    $0x0,%eax
c010693b:	eb 1a                	jmp    c0106957 <pmm_alloc_cpage+0x7e>
    }

    pmm_mark_chunk_occupied(owner, p1, num_pages, attr);
c010693d:	ff 75 10             	push   0x10(%ebp)
c0106940:	ff 75 0c             	push   0xc(%ebp)
c0106943:	ff 75 fc             	push   -0x4(%ebp)
c0106946:	ff 75 08             	push   0x8(%ebp)
c0106949:	e8 65 fe ff ff       	call   c01067b3 <pmm_mark_chunk_occupied>
c010694e:	83 c4 10             	add    $0x10,%esp

    return p1 << 12;
c0106951:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106954:	c1 e0 0c             	shl    $0xc,%eax
}
c0106957:	c9                   	leave  
c0106958:	c3                   	ret    

c0106959 <pmm_free_page>:

int pmm_free_page(pid_t owner, void* page)
{
c0106959:	55                   	push   %ebp
c010695a:	89 e5                	mov    %esp,%ebp
c010695c:	83 ec 10             	sub    $0x10,%esp
    struct pp_struct* pm = &pm_table[(intptr_t)page >> 12];
c010695f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0106962:	c1 f8 0c             	sar    $0xc,%eax
c0106965:	89 c2                	mov    %eax,%edx
c0106967:	89 d0                	mov    %edx,%eax
c0106969:	01 c0                	add    %eax,%eax
c010696b:	01 d0                	add    %edx,%eax
c010696d:	c1 e0 02             	shl    $0x2,%eax
c0106970:	05 40 a0 10 c0       	add    $0xc010a040,%eax
c0106975:	89 45 fc             	mov    %eax,-0x4(%ebp)
    
    // Oops, double free!
    if (!(pm->ref_counts)) {
c0106978:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010697b:	8b 40 04             	mov    0x4(%eax),%eax
c010697e:	85 c0                	test   %eax,%eax
c0106980:	75 07                	jne    c0106989 <pmm_free_page+0x30>
        return 0;
c0106982:	b8 00 00 00 00       	mov    $0x0,%eax
c0106987:	eb 2e                	jmp    c01069b7 <pmm_free_page+0x5e>
    }

    // 检查权限，保证：1) 用户只能释放用户页； 2) 内核可释放所有页。
    if ((pm->owner & owner) == pm->owner) {
c0106989:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010698c:	8b 00                	mov    (%eax),%eax
c010698e:	23 45 08             	and    0x8(%ebp),%eax
c0106991:	89 c2                	mov    %eax,%edx
c0106993:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106996:	8b 00                	mov    (%eax),%eax
c0106998:	39 c2                	cmp    %eax,%edx
c010699a:	75 16                	jne    c01069b2 <pmm_free_page+0x59>
        pm->ref_counts--;
c010699c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010699f:	8b 40 04             	mov    0x4(%eax),%eax
c01069a2:	8d 50 ff             	lea    -0x1(%eax),%edx
c01069a5:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01069a8:	89 50 04             	mov    %edx,0x4(%eax)
        return 1;
c01069ab:	b8 01 00 00 00       	mov    $0x1,%eax
c01069b0:	eb 05                	jmp    c01069b7 <pmm_free_page+0x5e>
    }
    return 0;
c01069b2:	b8 00 00 00 00       	mov    $0x0,%eax
    
}
c01069b7:	c9                   	leave  
c01069b8:	c3                   	ret    

c01069b9 <pmm_query>:

struct pp_struct* pmm_query(void* pa) {
c01069b9:	55                   	push   %ebp
c01069ba:	89 e5                	mov    %esp,%ebp
c01069bc:	83 ec 10             	sub    $0x10,%esp
    uint32_t ppn = (uintptr_t)pa >> 12;
c01069bf:	8b 45 08             	mov    0x8(%ebp),%eax
c01069c2:	c1 e8 0c             	shr    $0xc,%eax
c01069c5:	89 45 fc             	mov    %eax,-0x4(%ebp)
    
    if (ppn >= PM_BMP_MAX_SIZE) {
c01069c8:	81 7d fc ff ff 01 00 	cmpl   $0x1ffff,-0x4(%ebp)
c01069cf:	76 07                	jbe    c01069d8 <pmm_query+0x1f>
        return NULL;
c01069d1:	b8 00 00 00 00       	mov    $0x0,%eax
c01069d6:	eb 11                	jmp    c01069e9 <pmm_query+0x30>
    }

    return &pm_table[ppn];
c01069d8:	8b 55 fc             	mov    -0x4(%ebp),%edx
c01069db:	89 d0                	mov    %edx,%eax
c01069dd:	01 c0                	add    %eax,%eax
c01069df:	01 d0                	add    %edx,%eax
c01069e1:	c1 e0 02             	shl    $0x2,%eax
c01069e4:	05 40 a0 10 c0       	add    $0xc010a040,%eax
}
c01069e9:	c9                   	leave  
c01069ea:	c3                   	ret    

c01069eb <pmm_ref_page>:

int pmm_ref_page(pid_t owner, void* page) {
c01069eb:	55                   	push   %ebp
c01069ec:	89 e5                	mov    %esp,%ebp
c01069ee:	83 ec 10             	sub    $0x10,%esp
    (void*) owner;      // TODO: do smth with owner
    
    uint32_t ppn = (uintptr_t)page >> 12;
c01069f1:	8b 45 0c             	mov    0xc(%ebp),%eax
c01069f4:	c1 e8 0c             	shr    $0xc,%eax
c01069f7:	89 45 fc             	mov    %eax,-0x4(%ebp)
    
    if (ppn >= PM_BMP_MAX_SIZE) {
c01069fa:	81 7d fc ff ff 01 00 	cmpl   $0x1ffff,-0x4(%ebp)
c0106a01:	76 07                	jbe    c0106a0a <pmm_ref_page+0x1f>
        return 0;
c0106a03:	b8 00 00 00 00       	mov    $0x0,%eax
c0106a08:	eb 39                	jmp    c0106a43 <pmm_ref_page+0x58>
    }

    struct pp_struct* pm = &pm_table[ppn];
c0106a0a:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0106a0d:	89 d0                	mov    %edx,%eax
c0106a0f:	01 c0                	add    %eax,%eax
c0106a11:	01 d0                	add    %edx,%eax
c0106a13:	c1 e0 02             	shl    $0x2,%eax
c0106a16:	05 40 a0 10 c0       	add    $0xc010a040,%eax
c0106a1b:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if (!pm->ref_counts) {
c0106a1e:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0106a21:	8b 40 04             	mov    0x4(%eax),%eax
c0106a24:	85 c0                	test   %eax,%eax
c0106a26:	75 07                	jne    c0106a2f <pmm_ref_page+0x44>
        return 0;
c0106a28:	b8 00 00 00 00       	mov    $0x0,%eax
c0106a2d:	eb 14                	jmp    c0106a43 <pmm_ref_page+0x58>
    }

    pm->ref_counts++;
c0106a2f:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0106a32:	8b 40 04             	mov    0x4(%eax),%eax
c0106a35:	8d 50 01             	lea    0x1(%eax),%edx
c0106a38:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0106a3b:	89 50 04             	mov    %edx,0x4(%eax)
    return 1;
c0106a3e:	b8 01 00 00 00       	mov    $0x1,%eax
}
c0106a43:	c9                   	leave  
c0106a44:	c3                   	ret    

c0106a45 <extend_heap>:
 * @brief extend heap
 * 
 * @param extend size
 */
static void* extend_heap(size_t words)
{
c0106a45:	55                   	push   %ebp
c0106a46:	89 e5                	mov    %esp,%ebp
c0106a48:	83 ec 18             	sub    $0x18,%esp
    char* bp = mem_brk;
c0106a4b:	a1 48 a0 28 c0       	mov    0xc028a048,%eax
c0106a50:	89 45 f4             	mov    %eax,-0xc(%ebp)
    size_t size;
    //align
    size = (words % 2) ? words * WSIZE : (words + 1) * WSIZE;
c0106a53:	8b 45 08             	mov    0x8(%ebp),%eax
c0106a56:	83 e0 01             	and    $0x1,%eax
c0106a59:	85 c0                	test   %eax,%eax
c0106a5b:	74 08                	je     c0106a65 <extend_heap+0x20>
c0106a5d:	8b 45 08             	mov    0x8(%ebp),%eax
c0106a60:	c1 e0 02             	shl    $0x2,%eax
c0106a63:	eb 09                	jmp    c0106a6e <extend_heap+0x29>
c0106a65:	8b 45 08             	mov    0x8(%ebp),%eax
c0106a68:	83 c0 01             	add    $0x1,%eax
c0106a6b:	c1 e0 02             	shl    $0x2,%eax
c0106a6e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    mem_sbrk(size + WSIZE);
c0106a71:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106a74:	83 c0 04             	add    $0x4,%eax
c0106a77:	83 ec 0c             	sub    $0xc,%esp
c0106a7a:	50                   	push   %eax
c0106a7b:	e8 64 03 00 00       	call   c0106de4 <mem_sbrk>
c0106a80:	83 c4 10             	add    $0x10,%esp

    //initialize free block header/footer and the epilogue header
    PUT(HDRP(bp), PACK(size, 0)); // free block header
c0106a83:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106a86:	8d 50 fc             	lea    -0x4(%eax),%edx
c0106a89:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106a8c:	89 02                	mov    %eax,(%edx)
    PUT(FTRP(bp), PACK(size, 0)); // free block foot //TODO CRUSH HERE, ADD ONE PAGE OUT OF RANGE, WE ONLY GIVE ONE PAGE, MEYBE PAGE FAULT
c0106a8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106a91:	83 e8 04             	sub    $0x4,%eax
c0106a94:	8b 00                	mov    (%eax),%eax
c0106a96:	83 e0 f8             	and    $0xfffffff8,%eax
c0106a99:	8d 50 f8             	lea    -0x8(%eax),%edx
c0106a9c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106a9f:	01 c2                	add    %eax,%edx
c0106aa1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106aa4:	89 02                	mov    %eax,(%edx)
    PUT(HDRP(NEXT_BLKP(bp)), PACK(0, 1)); //NEW Epilogue header
c0106aa6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106aa9:	83 e8 04             	sub    $0x4,%eax
c0106aac:	8b 00                	mov    (%eax),%eax
c0106aae:	83 e0 f8             	and    $0xfffffff8,%eax
c0106ab1:	8d 50 fc             	lea    -0x4(%eax),%edx
c0106ab4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106ab7:	01 d0                	add    %edx,%eax
c0106ab9:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

    //Coalesce if previous block is free
    return coalesce(bp);
c0106abf:	83 ec 0c             	sub    $0xc,%esp
c0106ac2:	ff 75 f4             	push   -0xc(%ebp)
c0106ac5:	e8 05 00 00 00       	call   c0106acf <coalesce>
c0106aca:	83 c4 10             	add    $0x10,%esp
}
c0106acd:	c9                   	leave  
c0106ace:	c3                   	ret    

c0106acf <coalesce>:
 * @brief Coalesce free blk
 * 
 * @param Coalesce bp pointer
 */
static void* coalesce(void* bp)
{
c0106acf:	55                   	push   %ebp
c0106ad0:	89 e5                	mov    %esp,%ebp
c0106ad2:	83 ec 10             	sub    $0x10,%esp
    size_t prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));
c0106ad5:	8b 45 08             	mov    0x8(%ebp),%eax
c0106ad8:	83 e8 04             	sub    $0x4,%eax
c0106adb:	8b 00                	mov    (%eax),%eax
c0106add:	83 e0 f8             	and    $0xfffffff8,%eax
c0106ae0:	8d 50 f8             	lea    -0x8(%eax),%edx
c0106ae3:	8b 45 08             	mov    0x8(%ebp),%eax
c0106ae6:	01 d0                	add    %edx,%eax
c0106ae8:	8b 00                	mov    (%eax),%eax
c0106aea:	83 e0 01             	and    $0x1,%eax
c0106aed:	89 45 fc             	mov    %eax,-0x4(%ebp)
    size_t next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));
c0106af0:	8b 45 08             	mov    0x8(%ebp),%eax
c0106af3:	83 e8 04             	sub    $0x4,%eax
c0106af6:	8b 00                	mov    (%eax),%eax
c0106af8:	83 e0 f8             	and    $0xfffffff8,%eax
c0106afb:	8d 50 fc             	lea    -0x4(%eax),%edx
c0106afe:	8b 45 08             	mov    0x8(%ebp),%eax
c0106b01:	01 d0                	add    %edx,%eax
c0106b03:	8b 00                	mov    (%eax),%eax
c0106b05:	83 e0 01             	and    $0x1,%eax
c0106b08:	89 45 f8             	mov    %eax,-0x8(%ebp)
    size_t size = GET_SIZE(HDRP(bp));
c0106b0b:	8b 45 08             	mov    0x8(%ebp),%eax
c0106b0e:	83 e8 04             	sub    $0x4,%eax
c0106b11:	8b 00                	mov    (%eax),%eax
c0106b13:	83 e0 f8             	and    $0xfffffff8,%eax
c0106b16:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(prev_alloc && next_alloc)
c0106b19:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0106b1d:	74 0e                	je     c0106b2d <coalesce+0x5e>
c0106b1f:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0106b23:	74 08                	je     c0106b2d <coalesce+0x5e>
        return bp;
c0106b25:	8b 45 08             	mov    0x8(%ebp),%eax
c0106b28:	e9 3e 01 00 00       	jmp    c0106c6b <coalesce+0x19c>

    else if(prev_alloc && !next_alloc)
c0106b2d:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0106b31:	74 49                	je     c0106b7c <coalesce+0xad>
c0106b33:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0106b37:	75 43                	jne    c0106b7c <coalesce+0xad>
    {
        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));
c0106b39:	8b 45 08             	mov    0x8(%ebp),%eax
c0106b3c:	83 e8 04             	sub    $0x4,%eax
c0106b3f:	8b 00                	mov    (%eax),%eax
c0106b41:	83 e0 f8             	and    $0xfffffff8,%eax
c0106b44:	8d 50 fc             	lea    -0x4(%eax),%edx
c0106b47:	8b 45 08             	mov    0x8(%ebp),%eax
c0106b4a:	01 d0                	add    %edx,%eax
c0106b4c:	8b 00                	mov    (%eax),%eax
c0106b4e:	83 e0 f8             	and    $0xfffffff8,%eax
c0106b51:	01 45 f4             	add    %eax,-0xc(%ebp)
        PUT(HDRP(bp), PACK(size, 0));
c0106b54:	8b 45 08             	mov    0x8(%ebp),%eax
c0106b57:	8d 50 fc             	lea    -0x4(%eax),%edx
c0106b5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106b5d:	89 02                	mov    %eax,(%edx)
        PUT(FTRP(bp), PACK(size, 0));
c0106b5f:	8b 45 08             	mov    0x8(%ebp),%eax
c0106b62:	83 e8 04             	sub    $0x4,%eax
c0106b65:	8b 00                	mov    (%eax),%eax
c0106b67:	83 e0 f8             	and    $0xfffffff8,%eax
c0106b6a:	8d 50 f8             	lea    -0x8(%eax),%edx
c0106b6d:	8b 45 08             	mov    0x8(%ebp),%eax
c0106b70:	01 c2                	add    %eax,%edx
c0106b72:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106b75:	89 02                	mov    %eax,(%edx)
c0106b77:	e9 ec 00 00 00       	jmp    c0106c68 <coalesce+0x199>
    }

    else if(!prev_alloc && next_alloc)
c0106b7c:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0106b80:	75 6b                	jne    c0106bed <coalesce+0x11e>
c0106b82:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0106b86:	74 65                	je     c0106bed <coalesce+0x11e>
    {
        size += GET_SIZE(HDRP(PREV_BLKP(bp)));//TO DO ,THERE IS PEOBLEM, CRUSH HERE
c0106b88:	8b 45 08             	mov    0x8(%ebp),%eax
c0106b8b:	83 e8 08             	sub    $0x8,%eax
c0106b8e:	8b 00                	mov    (%eax),%eax
c0106b90:	83 e0 f8             	and    $0xfffffff8,%eax
c0106b93:	ba fc ff ff ff       	mov    $0xfffffffc,%edx
c0106b98:	29 c2                	sub    %eax,%edx
c0106b9a:	8b 45 08             	mov    0x8(%ebp),%eax
c0106b9d:	01 d0                	add    %edx,%eax
c0106b9f:	8b 00                	mov    (%eax),%eax
c0106ba1:	83 e0 f8             	and    $0xfffffff8,%eax
c0106ba4:	01 45 f4             	add    %eax,-0xc(%ebp)
        PUT(FTRP(bp), PACK(size, 0));
c0106ba7:	8b 45 08             	mov    0x8(%ebp),%eax
c0106baa:	83 e8 04             	sub    $0x4,%eax
c0106bad:	8b 00                	mov    (%eax),%eax
c0106baf:	83 e0 f8             	and    $0xfffffff8,%eax
c0106bb2:	8d 50 f8             	lea    -0x8(%eax),%edx
c0106bb5:	8b 45 08             	mov    0x8(%ebp),%eax
c0106bb8:	01 c2                	add    %eax,%edx
c0106bba:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106bbd:	89 02                	mov    %eax,(%edx)
        PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0));
c0106bbf:	8b 45 08             	mov    0x8(%ebp),%eax
c0106bc2:	83 e8 08             	sub    $0x8,%eax
c0106bc5:	8b 00                	mov    (%eax),%eax
c0106bc7:	83 e0 f8             	and    $0xfffffff8,%eax
c0106bca:	ba fc ff ff ff       	mov    $0xfffffffc,%edx
c0106bcf:	29 c2                	sub    %eax,%edx
c0106bd1:	8b 45 08             	mov    0x8(%ebp),%eax
c0106bd4:	01 c2                	add    %eax,%edx
c0106bd6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106bd9:	89 02                	mov    %eax,(%edx)
        bp = PREV_BLKP(bp);
c0106bdb:	8b 45 08             	mov    0x8(%ebp),%eax
c0106bde:	83 e8 08             	sub    $0x8,%eax
c0106be1:	8b 00                	mov    (%eax),%eax
c0106be3:	83 e0 f8             	and    $0xfffffff8,%eax
c0106be6:	f7 d8                	neg    %eax
c0106be8:	01 45 08             	add    %eax,0x8(%ebp)
c0106beb:	eb 7b                	jmp    c0106c68 <coalesce+0x199>
    }

    else{
        size += GET_SIZE(HDRP(PREV_BLKP(bp))) + GET_SIZE(FTRP(NEXT_BLKP(bp)));
c0106bed:	8b 45 08             	mov    0x8(%ebp),%eax
c0106bf0:	83 e8 08             	sub    $0x8,%eax
c0106bf3:	8b 00                	mov    (%eax),%eax
c0106bf5:	83 e0 f8             	and    $0xfffffff8,%eax
c0106bf8:	ba fc ff ff ff       	mov    $0xfffffffc,%edx
c0106bfd:	29 c2                	sub    %eax,%edx
c0106bff:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c02:	01 d0                	add    %edx,%eax
c0106c04:	8b 00                	mov    (%eax),%eax
c0106c06:	83 e0 f8             	and    $0xfffffff8,%eax
c0106c09:	89 c2                	mov    %eax,%edx
c0106c0b:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c0e:	83 e8 04             	sub    $0x4,%eax
c0106c11:	8b 00                	mov    (%eax),%eax
c0106c13:	83 e0 f8             	and    $0xfffffff8,%eax
c0106c16:	8d 48 f8             	lea    -0x8(%eax),%ecx
c0106c19:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c1c:	01 c8                	add    %ecx,%eax
c0106c1e:	8b 00                	mov    (%eax),%eax
c0106c20:	83 e0 f8             	and    $0xfffffff8,%eax
c0106c23:	01 d0                	add    %edx,%eax
c0106c25:	01 45 f4             	add    %eax,-0xc(%ebp)
        PUT(FTRP(PREV_BLKP(bp)), PACK(size, 0));
c0106c28:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c2b:	83 e8 04             	sub    $0x4,%eax
c0106c2e:	8b 00                	mov    (%eax),%eax
c0106c30:	83 e0 f8             	and    $0xfffffff8,%eax
c0106c33:	8d 50 f8             	lea    -0x8(%eax),%edx
c0106c36:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c39:	01 c2                	add    %eax,%edx
c0106c3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106c3e:	89 02                	mov    %eax,(%edx)
        PUT(HDRP(NEXT_BLKP(bp)), PACK(size, 0));
c0106c40:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c43:	83 e8 04             	sub    $0x4,%eax
c0106c46:	8b 00                	mov    (%eax),%eax
c0106c48:	83 e0 f8             	and    $0xfffffff8,%eax
c0106c4b:	8d 50 fc             	lea    -0x4(%eax),%edx
c0106c4e:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c51:	01 c2                	add    %eax,%edx
c0106c53:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106c56:	89 02                	mov    %eax,(%edx)
        bp = PREV_BLKP(bp);
c0106c58:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c5b:	83 e8 08             	sub    $0x8,%eax
c0106c5e:	8b 00                	mov    (%eax),%eax
c0106c60:	83 e0 f8             	and    $0xfffffff8,%eax
c0106c63:	f7 d8                	neg    %eax
c0106c65:	01 45 08             	add    %eax,0x8(%ebp)
    }
    return bp;
c0106c68:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0106c6b:	c9                   	leave  
c0106c6c:	c3                   	ret    

c0106c6d <find_fit>:
 * @brief find free blk
 * 
 * @param find size
 */
static void* find_fit(size_t asize)// we just traverse heap
{
c0106c6d:	55                   	push   %ebp
c0106c6e:	89 e5                	mov    %esp,%ebp
c0106c70:	83 ec 10             	sub    $0x10,%esp
    void* bp = heap_listp;
c0106c73:	a1 40 a0 28 c0       	mov    0xc028a040,%eax
c0106c78:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while(GET_ALLOC(HDRP(bp)) || (GET_SIZE(HDRP(bp)) < asize))
c0106c7b:	eb 2f                	jmp    c0106cac <find_fit+0x3f>
    {
        if(GET_SIZE(bp) != 0 && GET_ALLOC(bp) != 1)
c0106c7d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106c80:	8b 00                	mov    (%eax),%eax
c0106c82:	83 e0 f8             	and    $0xfffffff8,%eax
c0106c85:	85 c0                	test   %eax,%eax
c0106c87:	74 1c                	je     c0106ca5 <find_fit+0x38>
c0106c89:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106c8c:	8b 00                	mov    (%eax),%eax
c0106c8e:	83 e0 01             	and    $0x1,%eax
c0106c91:	85 c0                	test   %eax,%eax
c0106c93:	75 10                	jne    c0106ca5 <find_fit+0x38>
            bp = NEXT_BLKP(bp);
c0106c95:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106c98:	83 e8 04             	sub    $0x4,%eax
c0106c9b:	8b 00                	mov    (%eax),%eax
c0106c9d:	83 e0 f8             	and    $0xfffffff8,%eax
c0106ca0:	01 45 fc             	add    %eax,-0x4(%ebp)
c0106ca3:	eb 07                	jmp    c0106cac <find_fit+0x3f>
        else
            return NULL;
c0106ca5:	b8 00 00 00 00       	mov    $0x0,%eax
c0106caa:	eb 22                	jmp    c0106cce <find_fit+0x61>
    while(GET_ALLOC(HDRP(bp)) || (GET_SIZE(HDRP(bp)) < asize))
c0106cac:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106caf:	83 e8 04             	sub    $0x4,%eax
c0106cb2:	8b 00                	mov    (%eax),%eax
c0106cb4:	83 e0 01             	and    $0x1,%eax
c0106cb7:	85 c0                	test   %eax,%eax
c0106cb9:	75 c2                	jne    c0106c7d <find_fit+0x10>
c0106cbb:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106cbe:	83 e8 04             	sub    $0x4,%eax
c0106cc1:	8b 00                	mov    (%eax),%eax
c0106cc3:	83 e0 f8             	and    $0xfffffff8,%eax
c0106cc6:	39 45 08             	cmp    %eax,0x8(%ebp)
c0106cc9:	77 b2                	ja     c0106c7d <find_fit+0x10>
    }
    return bp;
c0106ccb:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0106cce:	c9                   	leave  
c0106ccf:	c3                   	ret    

c0106cd0 <place>:
 * @brief place the blk
 * 
 * @param blk,size
 */
static void place(void* bp, size_t asize)
{
c0106cd0:	55                   	push   %ebp
c0106cd1:	89 e5                	mov    %esp,%ebp
c0106cd3:	83 ec 10             	sub    $0x10,%esp
    size_t bp_allsize = GET_SIZE(HDRP(bp));
c0106cd6:	8b 45 08             	mov    0x8(%ebp),%eax
c0106cd9:	83 e8 04             	sub    $0x4,%eax
c0106cdc:	8b 00                	mov    (%eax),%eax
c0106cde:	83 e0 f8             	and    $0xfffffff8,%eax
c0106ce1:	89 45 fc             	mov    %eax,-0x4(%ebp)
    size_t remain_size = bp_allsize - asize;
c0106ce4:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106ce7:	2b 45 0c             	sub    0xc(%ebp),%eax
c0106cea:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if(remain_size >= 2*DSIZE)
c0106ced:	83 7d f8 0f          	cmpl   $0xf,-0x8(%ebp)
c0106cf1:	76 5b                	jbe    c0106d4e <place+0x7e>
    {
        PUT(HDRP(bp), PACK(asize, 1));
c0106cf3:	8b 45 08             	mov    0x8(%ebp),%eax
c0106cf6:	83 e8 04             	sub    $0x4,%eax
c0106cf9:	8b 55 0c             	mov    0xc(%ebp),%edx
c0106cfc:	83 ca 01             	or     $0x1,%edx
c0106cff:	89 10                	mov    %edx,(%eax)
        PUT(FTRP(bp), PACK(asize, 1));
c0106d01:	8b 45 08             	mov    0x8(%ebp),%eax
c0106d04:	83 e8 04             	sub    $0x4,%eax
c0106d07:	8b 00                	mov    (%eax),%eax
c0106d09:	83 e0 f8             	and    $0xfffffff8,%eax
c0106d0c:	8d 50 f8             	lea    -0x8(%eax),%edx
c0106d0f:	8b 45 08             	mov    0x8(%ebp),%eax
c0106d12:	01 d0                	add    %edx,%eax
c0106d14:	8b 55 0c             	mov    0xc(%ebp),%edx
c0106d17:	83 ca 01             	or     $0x1,%edx
c0106d1a:	89 10                	mov    %edx,(%eax)
        PUT(HDRP(NEXT_BLKP(bp)), PACK(remain_size, 0));
c0106d1c:	8b 45 08             	mov    0x8(%ebp),%eax
c0106d1f:	83 e8 04             	sub    $0x4,%eax
c0106d22:	8b 00                	mov    (%eax),%eax
c0106d24:	83 e0 f8             	and    $0xfffffff8,%eax
c0106d27:	8d 50 fc             	lea    -0x4(%eax),%edx
c0106d2a:	8b 45 08             	mov    0x8(%ebp),%eax
c0106d2d:	01 c2                	add    %eax,%edx
c0106d2f:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0106d32:	89 02                	mov    %eax,(%edx)
        PUT(FTRP(NEXT_BLKP(bp)), PACK(remain_size, 0));
c0106d34:	8b 45 08             	mov    0x8(%ebp),%eax
c0106d37:	83 e8 04             	sub    $0x4,%eax
c0106d3a:	8b 00                	mov    (%eax),%eax
c0106d3c:	83 e0 f8             	and    $0xfffffff8,%eax
c0106d3f:	8d 50 f8             	lea    -0x8(%eax),%edx
c0106d42:	8b 45 08             	mov    0x8(%ebp),%eax
c0106d45:	01 c2                	add    %eax,%edx
c0106d47:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0106d4a:	89 02                	mov    %eax,(%edx)
    }else{
        PUT(HDRP(bp), PACK(bp_allsize, 1));
        PUT(FTRP(bp), PACK(bp_allsize, 1));
    }
}
c0106d4c:	eb 29                	jmp    c0106d77 <place+0xa7>
        PUT(HDRP(bp), PACK(bp_allsize, 1));
c0106d4e:	8b 45 08             	mov    0x8(%ebp),%eax
c0106d51:	83 e8 04             	sub    $0x4,%eax
c0106d54:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0106d57:	83 ca 01             	or     $0x1,%edx
c0106d5a:	89 10                	mov    %edx,(%eax)
        PUT(FTRP(bp), PACK(bp_allsize, 1));
c0106d5c:	8b 45 08             	mov    0x8(%ebp),%eax
c0106d5f:	83 e8 04             	sub    $0x4,%eax
c0106d62:	8b 00                	mov    (%eax),%eax
c0106d64:	83 e0 f8             	and    $0xfffffff8,%eax
c0106d67:	8d 50 f8             	lea    -0x8(%eax),%edx
c0106d6a:	8b 45 08             	mov    0x8(%ebp),%eax
c0106d6d:	01 d0                	add    %edx,%eax
c0106d6f:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0106d72:	83 ca 01             	or     $0x1,%edx
c0106d75:	89 10                	mov    %edx,(%eax)
}
c0106d77:	90                   	nop
c0106d78:	c9                   	leave  
c0106d79:	c3                   	ret    

c0106d7a <mem_init>:

//following is head file function

void mem_init()
{
c0106d7a:	55                   	push   %ebp
c0106d7b:	89 e5                	mov    %esp,%ebp
c0106d7d:	83 ec 18             	sub    $0x18,%esp
    mem_heap = &__heap_start;
c0106d80:	c7 05 44 a0 28 c0 00 	movl   $0xc0293000,0xc028a044
c0106d87:	30 29 c0 
    //mem_heap = (char*)Malloc(MAX_HEAP);
    mem_brk = mem_heap;
c0106d8a:	a1 44 a0 28 c0       	mov    0xc028a044,%eax
c0106d8f:	a3 48 a0 28 c0       	mov    %eax,0xc028a048
    //mem_max_addr = (char*)(mem_heap + MAX_HEAP);
    mem_max_addr = (char*)K_STACK_START;
c0106d94:	c7 05 4c a0 28 c0 00 	movl   $0xffb00000,0xc028a04c
c0106d9b:	00 b0 ff 
    uint8_t* pgaddr = 0;
c0106d9e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    if((pgaddr = vmm_alloc_page(KERNEL_PID, mem_brk, NULL, PG_PREM_RW, PG_PREM_RW)) == NULL)
c0106da5:	a1 48 a0 28 c0       	mov    0xc028a048,%eax
c0106daa:	83 ec 0c             	sub    $0xc,%esp
c0106dad:	6a 03                	push   $0x3
c0106daf:	6a 03                	push   $0x3
c0106db1:	6a 00                	push   $0x0
c0106db3:	50                   	push   %eax
c0106db4:	6a ff                	push   $0xffffffff
c0106db6:	e8 b8 08 00 00       	call   c0107673 <vmm_alloc_page>
c0106dbb:	83 c4 20             	add    $0x20,%esp
c0106dbe:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0106dc1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0106dc5:	74 1a                	je     c0106de1 <mem_init+0x67>
        return;
    kprintf("malloc init phy address is 0x%x\n", pgaddr);
c0106dc7:	83 ec 08             	sub    $0x8,%esp
c0106dca:	ff 75 f4             	push   -0xc(%ebp)
c0106dcd:	68 14 c2 28 c0       	push   $0xc028c214
c0106dd2:	e8 fa 21 00 00       	call   c0108fd1 <kprintf>
c0106dd7:	83 c4 10             	add    $0x10,%esp
    malloc_init();
c0106dda:	e8 bb 00 00 00       	call   c0106e9a <malloc_init>
c0106ddf:	eb 01                	jmp    c0106de2 <mem_init+0x68>
        return;
c0106de1:	90                   	nop
}
c0106de2:	c9                   	leave  
c0106de3:	c3                   	ret    

c0106de4 <mem_sbrk>:

void* mem_sbrk(int incr)
{
c0106de4:	55                   	push   %ebp
c0106de5:	89 e5                	mov    %esp,%ebp
c0106de7:	83 ec 18             	sub    $0x18,%esp
    char* old = mem_brk;
c0106dea:	a1 48 a0 28 c0       	mov    0xc028a048,%eax
c0106def:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if((incr < 0) || ((mem_brk + incr) > mem_max_addr))
c0106df2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0106df6:	78 14                	js     c0106e0c <mem_sbrk+0x28>
c0106df8:	8b 15 48 a0 28 c0    	mov    0xc028a048,%edx
c0106dfe:	8b 45 08             	mov    0x8(%ebp),%eax
c0106e01:	01 c2                	add    %eax,%edx
c0106e03:	a1 4c a0 28 c0       	mov    0xc028a04c,%eax
c0106e08:	39 c2                	cmp    %eax,%edx
c0106e0a:	76 0a                	jbe    c0106e16 <mem_sbrk+0x32>
    {
        return (void*)-1;
c0106e0c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0106e11:	e9 82 00 00 00       	jmp    c0106e98 <mem_sbrk+0xb4>
    }
    char* new = mem_brk + incr;
c0106e16:	8b 15 48 a0 28 c0    	mov    0xc028a048,%edx
c0106e1c:	8b 45 08             	mov    0x8(%ebp),%eax
c0106e1f:	01 d0                	add    %edx,%eax
c0106e21:	89 45 f0             	mov    %eax,-0x10(%ebp)
    unsigned int diff = PG_ALIGN(new) - PG_ALIGN(old);
c0106e24:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106e27:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0106e2c:	89 c2                	mov    %eax,%edx
c0106e2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106e31:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0106e36:	89 c1                	mov    %eax,%ecx
c0106e38:	89 d0                	mov    %edx,%eax
c0106e3a:	29 c8                	sub    %ecx,%eax
c0106e3c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(diff)
c0106e3f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0106e43:	74 40                	je     c0106e85 <mem_sbrk+0xa1>
    {
        uint8_t* pgaddr = -1;
c0106e45:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,-0x18(%ebp)
        if(!(pgaddr = vmm_alloc_page(KERNEL_PID, new, NULL, PG_PREM_RW,PG_PREM_RW)))
c0106e4c:	83 ec 0c             	sub    $0xc,%esp
c0106e4f:	6a 03                	push   $0x3
c0106e51:	6a 03                	push   $0x3
c0106e53:	6a 00                	push   $0x0
c0106e55:	ff 75 f0             	push   -0x10(%ebp)
c0106e58:	6a ff                	push   $0xffffffff
c0106e5a:	e8 14 08 00 00       	call   c0107673 <vmm_alloc_page>
c0106e5f:	83 c4 20             	add    $0x20,%esp
c0106e62:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0106e65:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0106e69:	75 07                	jne    c0106e72 <mem_sbrk+0x8e>
        {
            return NULL;
c0106e6b:	b8 00 00 00 00       	mov    $0x0,%eax
c0106e70:	eb 26                	jmp    c0106e98 <mem_sbrk+0xb4>
        }
        kprintf("head new page is 0x%x\n", pgaddr);
c0106e72:	83 ec 08             	sub    $0x8,%esp
c0106e75:	ff 75 e8             	push   -0x18(%ebp)
c0106e78:	68 35 c2 28 c0       	push   $0xc028c235
c0106e7d:	e8 4f 21 00 00       	call   c0108fd1 <kprintf>
c0106e82:	83 c4 10             	add    $0x10,%esp
    }
    mem_brk += incr;
c0106e85:	8b 15 48 a0 28 c0    	mov    0xc028a048,%edx
c0106e8b:	8b 45 08             	mov    0x8(%ebp),%eax
c0106e8e:	01 d0                	add    %edx,%eax
c0106e90:	a3 48 a0 28 c0       	mov    %eax,0xc028a048
    return (void*)old;
c0106e95:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0106e98:	c9                   	leave  
c0106e99:	c3                   	ret    

c0106e9a <malloc_init>:

int malloc_init()
{
c0106e9a:	55                   	push   %ebp
c0106e9b:	89 e5                	mov    %esp,%ebp
c0106e9d:	83 ec 08             	sub    $0x8,%esp
    if((heap_listp = mem_sbrk(4 * WSIZE)) == (void*) - 1)
c0106ea0:	83 ec 0c             	sub    $0xc,%esp
c0106ea3:	6a 10                	push   $0x10
c0106ea5:	e8 3a ff ff ff       	call   c0106de4 <mem_sbrk>
c0106eaa:	83 c4 10             	add    $0x10,%esp
c0106ead:	a3 40 a0 28 c0       	mov    %eax,0xc028a040
c0106eb2:	a1 40 a0 28 c0       	mov    0xc028a040,%eax
c0106eb7:	83 f8 ff             	cmp    $0xffffffff,%eax
c0106eba:	75 07                	jne    c0106ec3 <malloc_init+0x29>
        return -1;
c0106ebc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0106ec1:	eb 62                	jmp    c0106f25 <malloc_init+0x8b>
    PUT(heap_listp, 0);
c0106ec3:	a1 40 a0 28 c0       	mov    0xc028a040,%eax
c0106ec8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    PUT(heap_listp + (1*WSIZE), PACK(DSIZE, 1));
c0106ece:	a1 40 a0 28 c0       	mov    0xc028a040,%eax
c0106ed3:	83 c0 04             	add    $0x4,%eax
c0106ed6:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
    PUT(heap_listp + (2*WSIZE), PACK(DSIZE, 1));
c0106edc:	a1 40 a0 28 c0       	mov    0xc028a040,%eax
c0106ee1:	83 c0 08             	add    $0x8,%eax
c0106ee4:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
    PUT(heap_listp + (3*WSIZE), PACK(0, 1));
c0106eea:	a1 40 a0 28 c0       	mov    0xc028a040,%eax
c0106eef:	83 c0 0c             	add    $0xc,%eax
c0106ef2:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    heap_listp += (2*WSIZE);
c0106ef8:	a1 40 a0 28 c0       	mov    0xc028a040,%eax
c0106efd:	83 c0 08             	add    $0x8,%eax
c0106f00:	a3 40 a0 28 c0       	mov    %eax,0xc028a040

    //extend free heap with free blk og CHUNKSIZE size
    //mem_sbrk((CHUNKSIZE - WSIZE));
    if(extend_heap((CHUNKSIZE - WSIZE)  / WSIZE) == NULL)
c0106f05:	83 ec 0c             	sub    $0xc,%esp
c0106f08:	68 ff 03 00 00       	push   $0x3ff
c0106f0d:	e8 33 fb ff ff       	call   c0106a45 <extend_heap>
c0106f12:	83 c4 10             	add    $0x10,%esp
c0106f15:	85 c0                	test   %eax,%eax
c0106f17:	75 07                	jne    c0106f20 <malloc_init+0x86>
        return -1;
c0106f19:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0106f1e:	eb 05                	jmp    c0106f25 <malloc_init+0x8b>
    return 0;
c0106f20:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0106f25:	c9                   	leave  
c0106f26:	c3                   	ret    

c0106f27 <malloc_free>:

void malloc_free(void* bp)
{
c0106f27:	55                   	push   %ebp
c0106f28:	89 e5                	mov    %esp,%ebp
c0106f2a:	83 ec 10             	sub    $0x10,%esp
    size_t size = GET_SIZE(HDRP(bp));
c0106f2d:	8b 45 08             	mov    0x8(%ebp),%eax
c0106f30:	83 e8 04             	sub    $0x4,%eax
c0106f33:	8b 00                	mov    (%eax),%eax
c0106f35:	83 e0 f8             	and    $0xfffffff8,%eax
c0106f38:	89 45 fc             	mov    %eax,-0x4(%ebp)

    PUT(HDRP(bp), PACK(size, 0));
c0106f3b:	8b 45 08             	mov    0x8(%ebp),%eax
c0106f3e:	8d 50 fc             	lea    -0x4(%eax),%edx
c0106f41:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106f44:	89 02                	mov    %eax,(%edx)
    PUT(FTRP(bp), PACK(size, 0));
c0106f46:	8b 45 08             	mov    0x8(%ebp),%eax
c0106f49:	83 e8 04             	sub    $0x4,%eax
c0106f4c:	8b 00                	mov    (%eax),%eax
c0106f4e:	83 e0 f8             	and    $0xfffffff8,%eax
c0106f51:	8d 50 f8             	lea    -0x8(%eax),%edx
c0106f54:	8b 45 08             	mov    0x8(%ebp),%eax
c0106f57:	01 c2                	add    %eax,%edx
c0106f59:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106f5c:	89 02                	mov    %eax,(%edx)
    coalesce(bp);
c0106f5e:	ff 75 08             	push   0x8(%ebp)
c0106f61:	e8 69 fb ff ff       	call   c0106acf <coalesce>
c0106f66:	83 c4 04             	add    $0x4,%esp
}
c0106f69:	90                   	nop
c0106f6a:	c9                   	leave  
c0106f6b:	c3                   	ret    

c0106f6c <k_malloc>:

void* k_malloc(size_t size)
{
c0106f6c:	55                   	push   %ebp
c0106f6d:	89 e5                	mov    %esp,%ebp
c0106f6f:	83 ec 18             	sub    $0x18,%esp
    size_t asize;
    size_t extendsize;
    char* bp;

    if(size == 0)
c0106f72:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0106f76:	75 0a                	jne    c0106f82 <k_malloc+0x16>
        return NULL;
c0106f78:	b8 00 00 00 00       	mov    $0x0,%eax
c0106f7d:	e9 8a 00 00 00       	jmp    c010700c <k_malloc+0xa0>
    
    //THE MIN blk is 2*DSIZE, ONE DSIZE means head and foot, one is align
    if(size <= DSIZE)
c0106f82:	83 7d 08 08          	cmpl   $0x8,0x8(%ebp)
c0106f86:	77 09                	ja     c0106f91 <k_malloc+0x25>
        asize = 2 * DSIZE;
c0106f88:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
c0106f8f:	eb 0e                	jmp    c0106f9f <k_malloc+0x33>
    else
        asize = DSIZE * ((size + DSIZE) + (DSIZE - 1)) / DSIZE; // Round up 
c0106f91:	8b 45 08             	mov    0x8(%ebp),%eax
c0106f94:	83 c0 0f             	add    $0xf,%eax
c0106f97:	25 ff ff ff 1f       	and    $0x1fffffff,%eax
c0106f9c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    //search the free list of fit
    if((bp = find_fit(asize)) != NULL)
c0106f9f:	ff 75 f4             	push   -0xc(%ebp)
c0106fa2:	e8 c6 fc ff ff       	call   c0106c6d <find_fit>
c0106fa7:	83 c4 04             	add    $0x4,%esp
c0106faa:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0106fad:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0106fb1:	74 13                	je     c0106fc6 <k_malloc+0x5a>
    {
        place(bp, asize);
c0106fb3:	ff 75 f4             	push   -0xc(%ebp)
c0106fb6:	ff 75 f0             	push   -0x10(%ebp)
c0106fb9:	e8 12 fd ff ff       	call   c0106cd0 <place>
c0106fbe:	83 c4 08             	add    $0x8,%esp
        return bp;
c0106fc1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106fc4:	eb 46                	jmp    c010700c <k_malloc+0xa0>
    }

    //no fit found try to extend head mem
    extendsize = MAX(asize, CHUNKSIZE);
c0106fc6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106fc9:	ba 00 10 00 00       	mov    $0x1000,%edx
c0106fce:	39 d0                	cmp    %edx,%eax
c0106fd0:	0f 42 c2             	cmovb  %edx,%eax
c0106fd3:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if((bp = extend_heap(extendsize / WSIZE)) == NULL)
c0106fd6:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0106fd9:	c1 e8 02             	shr    $0x2,%eax
c0106fdc:	83 ec 0c             	sub    $0xc,%esp
c0106fdf:	50                   	push   %eax
c0106fe0:	e8 60 fa ff ff       	call   c0106a45 <extend_heap>
c0106fe5:	83 c4 10             	add    $0x10,%esp
c0106fe8:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0106feb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0106fef:	75 07                	jne    c0106ff8 <k_malloc+0x8c>
        return NULL;
c0106ff1:	b8 00 00 00 00       	mov    $0x0,%eax
c0106ff6:	eb 14                	jmp    c010700c <k_malloc+0xa0>
    place(bp, asize);
c0106ff8:	83 ec 08             	sub    $0x8,%esp
c0106ffb:	ff 75 f4             	push   -0xc(%ebp)
c0106ffe:	ff 75 f0             	push   -0x10(%ebp)
c0107001:	e8 ca fc ff ff       	call   c0106cd0 <place>
c0107006:	83 c4 10             	add    $0x10,%esp
    return bp;
c0107009:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010700c:	c9                   	leave  
c010700d:	c3                   	ret    

c010700e <__llist_add>:
};

static inline void __llist_add(struct llist_header* elem,
            struct llist_header* prev,
            struct llist_header* next)
{
c010700e:	55                   	push   %ebp
c010700f:	89 e5                	mov    %esp,%ebp
    next->prev = elem;
c0107011:	8b 45 10             	mov    0x10(%ebp),%eax
c0107014:	8b 55 08             	mov    0x8(%ebp),%edx
c0107017:	89 10                	mov    %edx,(%eax)
    elem->next = next;
c0107019:	8b 45 08             	mov    0x8(%ebp),%eax
c010701c:	8b 55 10             	mov    0x10(%ebp),%edx
c010701f:	89 50 04             	mov    %edx,0x4(%eax)
    elem->prev = prev;
c0107022:	8b 45 08             	mov    0x8(%ebp),%eax
c0107025:	8b 55 0c             	mov    0xc(%ebp),%edx
c0107028:	89 10                	mov    %edx,(%eax)
    prev->next = elem;
c010702a:	8b 45 0c             	mov    0xc(%ebp),%eax
c010702d:	8b 55 08             	mov    0x8(%ebp),%edx
c0107030:	89 50 04             	mov    %edx,0x4(%eax)
}
c0107033:	90                   	nop
c0107034:	5d                   	pop    %ebp
c0107035:	c3                   	ret    

c0107036 <llist_init_head>:

static inline void llist_init_head(struct llist_header* head) {
c0107036:	55                   	push   %ebp
c0107037:	89 e5                	mov    %esp,%ebp
    head->next = head;
c0107039:	8b 45 08             	mov    0x8(%ebp),%eax
c010703c:	8b 55 08             	mov    0x8(%ebp),%edx
c010703f:	89 50 04             	mov    %edx,0x4(%eax)
    head->prev = head;
c0107042:	8b 45 08             	mov    0x8(%ebp),%eax
c0107045:	8b 55 08             	mov    0x8(%ebp),%edx
c0107048:	89 10                	mov    %edx,(%eax)
}
c010704a:	90                   	nop
c010704b:	5d                   	pop    %ebp
c010704c:	c3                   	ret    

c010704d <llist_append>:

static inline void llist_append(struct llist_header* head, struct llist_header* elem)
{
c010704d:	55                   	push   %ebp
c010704e:	89 e5                	mov    %esp,%ebp
    __llist_add(elem, head, head->next);
c0107050:	8b 45 08             	mov    0x8(%ebp),%eax
c0107053:	8b 40 04             	mov    0x4(%eax),%eax
c0107056:	50                   	push   %eax
c0107057:	ff 75 08             	push   0x8(%ebp)
c010705a:	ff 75 0c             	push   0xc(%ebp)
c010705d:	e8 ac ff ff ff       	call   c010700e <__llist_add>
c0107062:	83 c4 0c             	add    $0xc,%esp
}
c0107065:	90                   	nop
c0107066:	c9                   	leave  
c0107067:	c3                   	ret    

c0107068 <region_add>:
#include <kernel/memory/region.h>
#include <kernel/memory/malloc.h>
#include <libs/list.h>
void region_add(struct m_pcb* proc,unsigned long start, unsigned long end, unsigned int attr) {
c0107068:	55                   	push   %ebp
c0107069:	89 e5                	mov    %esp,%ebp
c010706b:	83 ec 28             	sub    $0x28,%esp
    struct mm_region* region = k_malloc(sizeof(struct mm_region));
c010706e:	83 ec 0c             	sub    $0xc,%esp
c0107071:	6a 14                	push   $0x14
c0107073:	e8 f4 fe ff ff       	call   c0106f6c <k_malloc>
c0107078:	83 c4 10             	add    $0x10,%esp
c010707b:	89 45 f4             	mov    %eax,-0xc(%ebp)

    *region = (struct mm_region) {
c010707e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107081:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c0107087:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
c010708e:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
c0107095:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
c010709c:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
c01070a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01070a6:	8b 55 0c             	mov    0xc(%ebp),%edx
c01070a9:	89 50 08             	mov    %edx,0x8(%eax)
c01070ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01070af:	8b 55 10             	mov    0x10(%ebp),%edx
c01070b2:	89 50 0c             	mov    %edx,0xc(%eax)
c01070b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01070b8:	8b 55 14             	mov    0x14(%ebp),%edx
c01070bb:	89 50 10             	mov    %edx,0x10(%eax)
        .attr = attr,
        .end = end,
        .start = start
    };
    if (!proc->process_mm) {
c01070be:	8b 45 08             	mov    0x8(%ebp),%eax
c01070c1:	8b 40 48             	mov    0x48(%eax),%eax
c01070c4:	85 c0                	test   %eax,%eax
c01070c6:	75 1a                	jne    c01070e2 <region_add+0x7a>
        llist_init_head(&region->head);
c01070c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01070cb:	83 ec 0c             	sub    $0xc,%esp
c01070ce:	50                   	push   %eax
c01070cf:	e8 62 ff ff ff       	call   c0107036 <llist_init_head>
c01070d4:	83 c4 10             	add    $0x10,%esp
        proc->process_mm = region;
c01070d7:	8b 45 08             	mov    0x8(%ebp),%eax
c01070da:	8b 55 f4             	mov    -0xc(%ebp),%edx
c01070dd:	89 50 48             	mov    %edx,0x48(%eax)
    }
    else {
        llist_append(&proc->process_mm->head, &region->head);
    }
c01070e0:	eb 16                	jmp    c01070f8 <region_add+0x90>
        llist_append(&proc->process_mm->head, &region->head);
c01070e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01070e5:	8b 55 08             	mov    0x8(%ebp),%edx
c01070e8:	8b 52 48             	mov    0x48(%edx),%edx
c01070eb:	83 ec 08             	sub    $0x8,%esp
c01070ee:	50                   	push   %eax
c01070ef:	52                   	push   %edx
c01070f0:	e8 58 ff ff ff       	call   c010704d <llist_append>
c01070f5:	83 c4 10             	add    $0x10,%esp
c01070f8:	90                   	nop
c01070f9:	c9                   	leave  
c01070fa:	c3                   	ret    

c01070fb <cpu_invplg>:

reg32 cpu_r_cr3();


static inline void cpu_invplg(void* va)
{
c01070fb:	55                   	push   %ebp
c01070fc:	89 e5                	mov    %esp,%ebp
    asm volatile("invlpg (%0)" ::"r"((unsigned int)va) : "memory");
c01070fe:	8b 45 08             	mov    0x8(%ebp),%eax
c0107101:	0f 01 38             	invlpg (%eax)
};
c0107104:	90                   	nop
c0107105:	5d                   	pop    %ebp
c0107106:	c3                   	ret    

c0107107 <vmm_init>:
#include <kernel/memory/vir_mem.h>
#include <libs/mstring.h>

void vmm_init() {
c0107107:	55                   	push   %ebp
c0107108:	89 e5                	mov    %esp,%ebp
    // TODO: something here?
}
c010710a:	90                   	nop
c010710b:	5d                   	pop    %ebp
c010710c:	c3                   	ret    

c010710d <get_pd>:

// TODO: Move these nasty inline asm stuff into hal
//      These should be arch dependent
ptd_t* get_pd() {
c010710d:	55                   	push   %ebp
c010710e:	89 e5                	mov    %esp,%ebp
c0107110:	83 ec 10             	sub    $0x10,%esp
    ptd_t* pd;
    #ifdef __ARCH_IA32
    __asm__(
c0107113:	0f 20 d8             	mov    %cr3,%eax
c0107116:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010711b:	89 45 fc             	mov    %eax,-0x4(%ebp)
        "movl %%cr3, %0\n"
        "andl $0xfffff000, %0"
        : "=r"(pd)
    );
    #endif
    return P2V(pd);
c010711e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0107121:	2d 00 00 00 40       	sub    $0x40000000,%eax
}
c0107126:	c9                   	leave  
c0107127:	c3                   	ret    

c0107128 <set_pd>:

void set_pd(ptd_t* pd) {
c0107128:	55                   	push   %ebp
c0107129:	89 e5                	mov    %esp,%ebp
    #ifdef __ARCH_IA32
    __asm__(
c010712b:	8b 45 08             	mov    0x8(%ebp),%eax
c010712e:	89 c0                	mov    %eax,%eax
c0107130:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0107135:	0f 22 d8             	mov    %eax,%cr3
        "movl %%eax, %%cr3\n"
        :
        : "r" (pd)
    );
    #endif
}
c0107138:	90                   	nop
c0107139:	5d                   	pop    %ebp
c010713a:	c3                   	ret    

c010713b <vmm_init_pd>:

ptd_t* vmm_init_pd() {
c010713b:	55                   	push   %ebp
c010713c:	89 e5                	mov    %esp,%ebp
c010713e:	83 ec 18             	sub    $0x18,%esp
    ptd_t* dir = pmm_alloc_page(KERNEL_PID, PP_FGPERSIST);
c0107141:	83 ec 08             	sub    $0x8,%esp
c0107144:	6a 01                	push   $0x1
c0107146:	6a ff                	push   $0xffffffff
c0107148:	e8 d7 f6 ff ff       	call   c0106824 <pmm_alloc_page>
c010714d:	83 c4 10             	add    $0x10,%esp
c0107150:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for (size_t i = 0; i < 1024; i++)
c0107153:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c010715a:	eb 19                	jmp    c0107175 <vmm_init_pd+0x3a>
    {
        dir[i] = 0;
c010715c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010715f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0107166:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107169:	01 d0                	add    %edx,%eax
c010716b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    for (size_t i = 0; i < 1024; i++)
c0107171:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0107175:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
c010717c:	76 de                	jbe    c010715c <vmm_init_pd+0x21>
    }
    
    // 自己映射自己，方便我们在软件层面进行查表地址转换
    dir[1023] = PDE(T_SELF_REF_PERM, dir);
c010717e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107181:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0107186:	89 c2                	mov    %eax,%edx
c0107188:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010718b:	05 fc 0f 00 00       	add    $0xffc,%eax
c0107190:	83 ca 1b             	or     $0x1b,%edx
c0107193:	89 10                	mov    %edx,(%eax)

    return dir;
c0107195:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0107198:	c9                   	leave  
c0107199:	c3                   	ret    

c010719a <__vmm_map_alloc>:
                   uint32_t l1_inx,
                   uint32_t l2_inx,
                   uintptr_t pa,
                   pt_attr attr,
                   int forced)
{
c010719a:	55                   	push   %ebp
c010719b:	89 e5                	mov    %esp,%ebp
c010719d:	53                   	push   %ebx
c010719e:	83 ec 14             	sub    $0x14,%esp
    ptd_t* ptd = (ptd_t*)PTD_BASE_VADDR;
c01071a1:	c7 45 f4 00 f0 ff ff 	movl   $0xfffff000,-0xc(%ebp)
    pt_t* pt = (uintptr_t)PT_VADDR(l1_inx);
c01071a8:	8b 45 0c             	mov    0xc(%ebp),%eax
c01071ab:	c1 e0 0c             	shl    $0xc,%eax
c01071ae:	0d 00 00 c0 ff       	or     $0xffc00000,%eax
c01071b3:	89 45 f0             	mov    %eax,-0x10(%ebp)


    // See if attr make sense
    assert(attr <= 128);
c01071b6:	81 7d 18 80 00 00 00 	cmpl   $0x80,0x18(%ebp)
c01071bd:	76 1a                	jbe    c01071d9 <__vmm_map_alloc+0x3f>
c01071bf:	83 ec 04             	sub    $0x4,%esp
c01071c2:	68 9e 00 00 00       	push   $0x9e
c01071c7:	68 4c c2 28 c0       	push   $0xc028c24c
c01071cc:	68 65 c2 28 c0       	push   $0xc028c265
c01071d1:	e8 32 19 00 00       	call   c0108b08 <__assert_fail>
c01071d6:	83 c4 10             	add    $0x10,%esp

    if (!ptd[l1_inx]) {
c01071d9:	8b 45 0c             	mov    0xc(%ebp),%eax
c01071dc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c01071e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01071e6:	01 d0                	add    %edx,%eax
c01071e8:	8b 00                	mov    (%eax),%eax
c01071ea:	85 c0                	test   %eax,%eax
c01071ec:	75 6b                	jne    c0107259 <__vmm_map_alloc+0xbf>
        uint8_t* new_pt_pa = pmm_alloc_page(pid, PP_FGPERSIST);
c01071ee:	83 ec 08             	sub    $0x8,%esp
c01071f1:	6a 01                	push   $0x1
c01071f3:	ff 75 08             	push   0x8(%ebp)
c01071f6:	e8 29 f6 ff ff       	call   c0106824 <pmm_alloc_page>
c01071fb:	83 c4 10             	add    $0x10,%esp
c01071fe:	89 45 ec             	mov    %eax,-0x14(%ebp)

        // 物理内存已满！
        if (!new_pt_pa) {
c0107201:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0107205:	75 0a                	jne    c0107211 <__vmm_map_alloc+0x77>
            return 0;
c0107207:	b8 00 00 00 00       	mov    $0x0,%eax
c010720c:	e9 b2 00 00 00       	jmp    c01072c3 <__vmm_map_alloc+0x129>
        }

        // This must be writable
        ptd[l1_inx] = PDE(attr | PG_WRITE, new_pt_pa);
c0107211:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0107214:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0107219:	89 c1                	mov    %eax,%ecx
c010721b:	8b 45 18             	mov    0x18(%ebp),%eax
c010721e:	83 c8 0a             	or     $0xa,%eax
c0107221:	25 ff 0f 00 00       	and    $0xfff,%eax
c0107226:	89 c2                	mov    %eax,%edx
c0107228:	8b 45 0c             	mov    0xc(%ebp),%eax
c010722b:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
c0107232:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107235:	01 d8                	add    %ebx,%eax
c0107237:	09 ca                	or     %ecx,%edx
c0107239:	89 10                	mov    %edx,(%eax)
        memset((void*)PT_VADDR(l1_inx), 0, PM_PAGE_SIZE);
c010723b:	8b 45 0c             	mov    0xc(%ebp),%eax
c010723e:	c1 e0 0c             	shl    $0xc,%eax
c0107241:	0d 00 00 c0 ff       	or     $0xffc00000,%eax
c0107246:	83 ec 04             	sub    $0x4,%esp
c0107249:	68 00 10 00 00       	push   $0x1000
c010724e:	6a 00                	push   $0x0
c0107250:	50                   	push   %eax
c0107251:	e8 12 20 00 00       	call   c0109268 <memset>
c0107256:	83 c4 10             	add    $0x10,%esp
    }

    if (pt[l2_inx]) {
c0107259:	8b 45 10             	mov    0x10(%ebp),%eax
c010725c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0107263:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107266:	01 d0                	add    %edx,%eax
c0107268:	8b 00                	mov    (%eax),%eax
c010726a:	85 c0                	test   %eax,%eax
c010726c:	74 0d                	je     c010727b <__vmm_map_alloc+0xe1>
        if (!forced) {
c010726e:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
c0107272:	75 07                	jne    c010727b <__vmm_map_alloc+0xe1>
            return 0;
c0107274:	b8 00 00 00 00       	mov    $0x0,%eax
c0107279:	eb 48                	jmp    c01072c3 <__vmm_map_alloc+0x129>
        }
    }

    if ((HAS_FLAGS(attr, PG_PRESENT))) {
c010727b:	8b 45 18             	mov    0x18(%ebp),%eax
c010727e:	83 e0 01             	and    $0x1,%eax
c0107281:	85 c0                	test   %eax,%eax
c0107283:	74 12                	je     c0107297 <__vmm_map_alloc+0xfd>
        // add one on reference count, regardless of existence.
        pmm_ref_page(pid, pa);
c0107285:	8b 45 14             	mov    0x14(%ebp),%eax
c0107288:	83 ec 08             	sub    $0x8,%esp
c010728b:	50                   	push   %eax
c010728c:	ff 75 08             	push   0x8(%ebp)
c010728f:	e8 57 f7 ff ff       	call   c01069eb <pmm_ref_page>
c0107294:	83 c4 10             	add    $0x10,%esp
    }

    pt[l2_inx] = PTE(attr, pa);
c0107297:	8b 45 14             	mov    0x14(%ebp),%eax
c010729a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010729f:	89 c1                	mov    %eax,%ecx
c01072a1:	8b 45 18             	mov    0x18(%ebp),%eax
c01072a4:	25 ff 0f 00 00       	and    $0xfff,%eax
c01072a9:	89 c2                	mov    %eax,%edx
c01072ab:	8b 45 10             	mov    0x10(%ebp),%eax
c01072ae:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
c01072b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01072b8:	01 d8                	add    %ebx,%eax
c01072ba:	09 ca                	or     %ecx,%edx
c01072bc:	89 10                	mov    %edx,(%eax)

    return 1;
c01072be:	b8 01 00 00 00       	mov    $0x1,%eax
}
c01072c3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c01072c6:	c9                   	leave  
c01072c7:	c3                   	ret    

c01072c8 <vmm_map_page>:

void* vmm_map_page(pid_t pid, void* va, void* pa, pt_attr dattr, pt_attr tattr) {
c01072c8:	55                   	push   %ebp
c01072c9:	89 e5                	mov    %esp,%ebp
c01072cb:	53                   	push   %ebx
c01072cc:	83 ec 24             	sub    $0x24,%esp
    // 显然，对空指针进行映射没有意义。
    if (!pa || !va) {
c01072cf:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c01072d3:	74 06                	je     c01072db <vmm_map_page+0x13>
c01072d5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c01072d9:	75 0a                	jne    c01072e5 <vmm_map_page+0x1d>
        return NULL;
c01072db:	b8 00 00 00 00       	mov    $0x0,%eax
c01072e0:	e9 d7 01 00 00       	jmp    c01074bc <vmm_map_page+0x1f4>
    }

    uintptr_t pd_offset = PD_INDEX(va);
c01072e5:	8b 45 0c             	mov    0xc(%ebp),%eax
c01072e8:	c1 e8 16             	shr    $0x16,%eax
c01072eb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uintptr_t pt_offset = PT_INDEX(va);
c01072ee:	8b 45 0c             	mov    0xc(%ebp),%eax
c01072f1:	c1 e8 0c             	shr    $0xc,%eax
c01072f4:	25 ff 03 00 00       	and    $0x3ff,%eax
c01072f9:	89 45 f0             	mov    %eax,-0x10(%ebp)
    ptd_t* ptd = (ptd_t*)PTD_BASE_VADDR;
c01072fc:	c7 45 e4 00 f0 ff ff 	movl   $0xfffff000,-0x1c(%ebp)

    // 在页表与页目录中找到一个可用的空位进行映射（位于va或其附近）
    ptd_t* pde = ptd[pd_offset];
c0107303:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107306:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010730d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0107310:	01 d0                	add    %edx,%eax
c0107312:	8b 00                	mov    (%eax),%eax
c0107314:	89 45 ec             	mov    %eax,-0x14(%ebp)
    pt_t* pt = (uintptr_t)PT_VADDR(pd_offset);
c0107317:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010731a:	c1 e0 0c             	shl    $0xc,%eax
c010731d:	0d 00 00 c0 ff       	or     $0xffc00000,%eax
c0107322:	89 45 e8             	mov    %eax,-0x18(%ebp)
    while (pde && pd_offset < 1024) {
c0107325:	e9 9b 00 00 00       	jmp    c01073c5 <vmm_map_page+0xfd>
        if (pt_offset == 1024) {
c010732a:	81 7d f0 00 04 00 00 	cmpl   $0x400,-0x10(%ebp)
c0107331:	75 2d                	jne    c0107360 <vmm_map_page+0x98>
            pd_offset++;
c0107333:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
            pt_offset = 0;
c0107337:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            pde = ptd[pd_offset];
c010733e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107341:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0107348:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010734b:	01 d0                	add    %edx,%eax
c010734d:	8b 00                	mov    (%eax),%eax
c010734f:	89 45 ec             	mov    %eax,-0x14(%ebp)
            pt = (pt_t*)PT_VADDR(pd_offset);
c0107352:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107355:	c1 e0 0c             	shl    $0xc,%eax
c0107358:	0d 00 00 c0 ff       	or     $0xffc00000,%eax
c010735d:	89 45 e8             	mov    %eax,-0x18(%ebp)
        }
        // 页表有空位，只需要开辟一个新的 PTE
        if (pt && !pt[pt_offset]) {
c0107360:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0107364:	74 5b                	je     c01073c1 <vmm_map_page+0xf9>
c0107366:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107369:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0107370:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0107373:	01 d0                	add    %edx,%eax
c0107375:	8b 00                	mov    (%eax),%eax
c0107377:	85 c0                	test   %eax,%eax
c0107379:	75 46                	jne    c01073c1 <vmm_map_page+0xf9>
            pt[pt_offset] = PTE(tattr, pa);
c010737b:	8b 45 10             	mov    0x10(%ebp),%eax
c010737e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0107383:	89 c1                	mov    %eax,%ecx
c0107385:	8b 45 18             	mov    0x18(%ebp),%eax
c0107388:	25 ff 0f 00 00       	and    $0xfff,%eax
c010738d:	89 c2                	mov    %eax,%edx
c010738f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107392:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
c0107399:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010739c:	01 d8                	add    %ebx,%eax
c010739e:	09 ca                	or     %ecx,%edx
c01073a0:	89 10                	mov    %edx,(%eax)
            return V_ADDR(pd_offset, pt_offset, PG_OFFSET(va));
c01073a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01073a5:	c1 e0 16             	shl    $0x16,%eax
c01073a8:	89 c2                	mov    %eax,%edx
c01073aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01073ad:	c1 e0 0c             	shl    $0xc,%eax
c01073b0:	09 c2                	or     %eax,%edx
c01073b2:	8b 45 0c             	mov    0xc(%ebp),%eax
c01073b5:	25 ff 0f 00 00       	and    $0xfff,%eax
c01073ba:	09 d0                	or     %edx,%eax
c01073bc:	e9 fb 00 00 00       	jmp    c01074bc <vmm_map_page+0x1f4>
        }
        pt_offset++;
c01073c1:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    while (pde && pd_offset < 1024) {
c01073c5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c01073c9:	74 0d                	je     c01073d8 <vmm_map_page+0x110>
c01073cb:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
c01073d2:	0f 86 52 ff ff ff    	jbe    c010732a <vmm_map_page+0x62>
    }
    
    // 页目录与所有页表已满！
    if (pd_offset > 1024) {
c01073d8:	81 7d f4 00 04 00 00 	cmpl   $0x400,-0xc(%ebp)
c01073df:	76 0a                	jbe    c01073eb <vmm_map_page+0x123>
        return NULL;
c01073e1:	b8 00 00 00 00       	mov    $0x0,%eax
c01073e6:	e9 d1 00 00 00       	jmp    c01074bc <vmm_map_page+0x1f4>
    }

    // 页目录有空位，需要开辟一个新的 PDE
    uint8_t* new_pt_pa = pmm_alloc_page(pid, PP_FGPERSIST);
c01073eb:	83 ec 08             	sub    $0x8,%esp
c01073ee:	6a 01                	push   $0x1
c01073f0:	ff 75 08             	push   0x8(%ebp)
c01073f3:	e8 2c f4 ff ff       	call   c0106824 <pmm_alloc_page>
c01073f8:	83 c4 10             	add    $0x10,%esp
c01073fb:	89 45 e0             	mov    %eax,-0x20(%ebp)
    
    // 物理内存已满！
    if (!new_pt_pa) {
c01073fe:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0107402:	75 0a                	jne    c010740e <vmm_map_page+0x146>
        return NULL;
c0107404:	b8 00 00 00 00       	mov    $0x0,%eax
c0107409:	e9 ae 00 00 00       	jmp    c01074bc <vmm_map_page+0x1f4>
    }
    
    ptd[pd_offset] = PDE(dattr, new_pt_pa);
c010740e:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0107411:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0107416:	89 c1                	mov    %eax,%ecx
c0107418:	8b 45 14             	mov    0x14(%ebp),%eax
c010741b:	83 c8 08             	or     $0x8,%eax
c010741e:	25 ff 0f 00 00       	and    $0xfff,%eax
c0107423:	89 c2                	mov    %eax,%edx
c0107425:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107428:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
c010742f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0107432:	01 d8                	add    %ebx,%eax
c0107434:	09 ca                	or     %ecx,%edx
c0107436:	89 10                	mov    %edx,(%eax)
    
    memset((void*)PT_VADDR(pd_offset), 0, PM_PAGE_SIZE);
c0107438:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010743b:	c1 e0 0c             	shl    $0xc,%eax
c010743e:	0d 00 00 c0 ff       	or     $0xffc00000,%eax
c0107443:	83 ec 04             	sub    $0x4,%esp
c0107446:	68 00 10 00 00       	push   $0x1000
c010744b:	6a 00                	push   $0x0
c010744d:	50                   	push   %eax
c010744e:	e8 15 1e 00 00       	call   c0109268 <memset>
c0107453:	83 c4 10             	add    $0x10,%esp


    if ((HAS_FLAGS(tattr, PG_PRESENT) && HAS_FLAGS(dattr, PG_PRESENT))) {
c0107456:	8b 45 18             	mov    0x18(%ebp),%eax
c0107459:	83 e0 01             	and    $0x1,%eax
c010745c:	85 c0                	test   %eax,%eax
c010745e:	74 1b                	je     c010747b <vmm_map_page+0x1b3>
c0107460:	8b 45 14             	mov    0x14(%ebp),%eax
c0107463:	83 e0 01             	and    $0x1,%eax
c0107466:	85 c0                	test   %eax,%eax
c0107468:	74 11                	je     c010747b <vmm_map_page+0x1b3>
        // add one on reference count, regardless of existence.
        pmm_ref_page(pid, pa);
c010746a:	83 ec 08             	sub    $0x8,%esp
c010746d:	ff 75 10             	push   0x10(%ebp)
c0107470:	ff 75 08             	push   0x8(%ebp)
c0107473:	e8 73 f5 ff ff       	call   c01069eb <pmm_ref_page>
c0107478:	83 c4 10             	add    $0x10,%esp
    }
    pt[pt_offset] = PTE(tattr, pa);
c010747b:	8b 45 10             	mov    0x10(%ebp),%eax
c010747e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0107483:	89 c1                	mov    %eax,%ecx
c0107485:	8b 45 18             	mov    0x18(%ebp),%eax
c0107488:	25 ff 0f 00 00       	and    $0xfff,%eax
c010748d:	89 c2                	mov    %eax,%edx
c010748f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107492:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
c0107499:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010749c:	01 d8                	add    %ebx,%eax
c010749e:	09 ca                	or     %ecx,%edx
c01074a0:	89 10                	mov    %edx,(%eax)

    return V_ADDR(pd_offset, pt_offset, PG_OFFSET(va));
c01074a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01074a5:	c1 e0 16             	shl    $0x16,%eax
c01074a8:	89 c2                	mov    %eax,%edx
c01074aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01074ad:	c1 e0 0c             	shl    $0xc,%eax
c01074b0:	09 c2                	or     %eax,%edx
c01074b2:	8b 45 0c             	mov    0xc(%ebp),%eax
c01074b5:	25 ff 0f 00 00       	and    $0xfff,%eax
c01074ba:	09 d0                	or     %edx,%eax
}
c01074bc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c01074bf:	c9                   	leave  
c01074c0:	c3                   	ret    

c01074c1 <vmm_cover_map_page>:

void* vmm_cover_map_page(pid_t pid, void* va, void* pa, pt_attr dattr, pt_attr tattr)
{
c01074c1:	55                   	push   %ebp
c01074c2:	89 e5                	mov    %esp,%ebp
c01074c4:	53                   	push   %ebx
c01074c5:	83 ec 24             	sub    $0x24,%esp
        // 显然，对空指针进行映射没有意义。
    if (!pa || !va) {
c01074c8:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c01074cc:	74 06                	je     c01074d4 <vmm_cover_map_page+0x13>
c01074ce:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c01074d2:	75 0a                	jne    c01074de <vmm_cover_map_page+0x1d>
        return NULL;
c01074d4:	b8 00 00 00 00       	mov    $0x0,%eax
c01074d9:	e9 90 01 00 00       	jmp    c010766e <vmm_cover_map_page+0x1ad>
    }

    uintptr_t pd_offset = PD_INDEX(va);
c01074de:	8b 45 0c             	mov    0xc(%ebp),%eax
c01074e1:	c1 e8 16             	shr    $0x16,%eax
c01074e4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uintptr_t pt_offset = PT_INDEX(va);
c01074e7:	8b 45 0c             	mov    0xc(%ebp),%eax
c01074ea:	c1 e8 0c             	shr    $0xc,%eax
c01074ed:	25 ff 03 00 00       	and    $0x3ff,%eax
c01074f2:	89 45 f0             	mov    %eax,-0x10(%ebp)
    ptd_t* ptd = (ptd_t*)PTD_BASE_VADDR;
c01074f5:	c7 45 ec 00 f0 ff ff 	movl   $0xfffff000,-0x14(%ebp)

    // 在页表与页目录中找到一个可用的空位进行映射（位于va或其附近）
    ptd_t* pde = ptd[pd_offset];
c01074fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01074ff:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0107506:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0107509:	01 d0                	add    %edx,%eax
c010750b:	8b 00                	mov    (%eax),%eax
c010750d:	89 45 e8             	mov    %eax,-0x18(%ebp)
    pt_t* pt = (uintptr_t)PT_VADDR(pd_offset); 
c0107510:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107513:	c1 e0 0c             	shl    $0xc,%eax
c0107516:	0d 00 00 c0 ff       	or     $0xffc00000,%eax
c010751b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(!pde)
c010751e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0107522:	75 6b                	jne    c010758f <vmm_cover_map_page+0xce>
    {
        uint8_t* new_pt_pa = pmm_alloc_page(pid, PP_FGPERSIST);
c0107524:	83 ec 08             	sub    $0x8,%esp
c0107527:	6a 01                	push   $0x1
c0107529:	ff 75 08             	push   0x8(%ebp)
c010752c:	e8 f3 f2 ff ff       	call   c0106824 <pmm_alloc_page>
c0107531:	83 c4 10             	add    $0x10,%esp
c0107534:	89 45 e0             	mov    %eax,-0x20(%ebp)
        if (!new_pt_pa) {
c0107537:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c010753b:	75 0a                	jne    c0107547 <vmm_cover_map_page+0x86>
            return NULL;
c010753d:	b8 00 00 00 00       	mov    $0x0,%eax
c0107542:	e9 27 01 00 00       	jmp    c010766e <vmm_cover_map_page+0x1ad>
        }

        ptd[pd_offset] = PDE(dattr, new_pt_pa);
c0107547:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010754a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010754f:	89 c1                	mov    %eax,%ecx
c0107551:	8b 45 14             	mov    0x14(%ebp),%eax
c0107554:	83 c8 08             	or     $0x8,%eax
c0107557:	25 ff 0f 00 00       	and    $0xfff,%eax
c010755c:	89 c2                	mov    %eax,%edx
c010755e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107561:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
c0107568:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010756b:	01 d8                	add    %ebx,%eax
c010756d:	09 ca                	or     %ecx,%edx
c010756f:	89 10                	mov    %edx,(%eax)
        memset((void*)PT_VADDR(pd_offset), 0, PM_PAGE_SIZE);
c0107571:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107574:	c1 e0 0c             	shl    $0xc,%eax
c0107577:	0d 00 00 c0 ff       	or     $0xffc00000,%eax
c010757c:	83 ec 04             	sub    $0x4,%esp
c010757f:	68 00 10 00 00       	push   $0x1000
c0107584:	6a 00                	push   $0x0
c0107586:	50                   	push   %eax
c0107587:	e8 dc 1c 00 00       	call   c0109268 <memset>
c010758c:	83 c4 10             	add    $0x10,%esp

    }   

    // 页目录有空位，需要开辟一个新的 PDE
    uint8_t* new_pt_pa = pmm_alloc_page(pid, PP_FGPERSIST);
c010758f:	83 ec 08             	sub    $0x8,%esp
c0107592:	6a 01                	push   $0x1
c0107594:	ff 75 08             	push   0x8(%ebp)
c0107597:	e8 88 f2 ff ff       	call   c0106824 <pmm_alloc_page>
c010759c:	83 c4 10             	add    $0x10,%esp
c010759f:	89 45 dc             	mov    %eax,-0x24(%ebp)
    
    // 物理内存已满！
    if (!new_pt_pa) {
c01075a2:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c01075a6:	75 0a                	jne    c01075b2 <vmm_cover_map_page+0xf1>
        return NULL;
c01075a8:	b8 00 00 00 00       	mov    $0x0,%eax
c01075ad:	e9 bc 00 00 00       	jmp    c010766e <vmm_cover_map_page+0x1ad>
    }
    
    ptd[pd_offset] = PDE(dattr, new_pt_pa);
c01075b2:	8b 45 dc             	mov    -0x24(%ebp),%eax
c01075b5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c01075ba:	89 c1                	mov    %eax,%ecx
c01075bc:	8b 45 14             	mov    0x14(%ebp),%eax
c01075bf:	83 c8 08             	or     $0x8,%eax
c01075c2:	25 ff 0f 00 00       	and    $0xfff,%eax
c01075c7:	89 c2                	mov    %eax,%edx
c01075c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01075cc:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
c01075d3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01075d6:	01 d8                	add    %ebx,%eax
c01075d8:	09 ca                	or     %ecx,%edx
c01075da:	89 10                	mov    %edx,(%eax)
    
    memset((void*)PT_VADDR(pd_offset), 0, PM_PAGE_SIZE);
c01075dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01075df:	c1 e0 0c             	shl    $0xc,%eax
c01075e2:	0d 00 00 c0 ff       	or     $0xffc00000,%eax
c01075e7:	83 ec 04             	sub    $0x4,%esp
c01075ea:	68 00 10 00 00       	push   $0x1000
c01075ef:	6a 00                	push   $0x0
c01075f1:	50                   	push   %eax
c01075f2:	e8 71 1c 00 00       	call   c0109268 <memset>
c01075f7:	83 c4 10             	add    $0x10,%esp

    if (HAS_FLAGS(tattr, PG_PRESENT) && HAS_FLAGS(dattr, PG_PRESENT)) {
c01075fa:	8b 45 18             	mov    0x18(%ebp),%eax
c01075fd:	83 e0 01             	and    $0x1,%eax
c0107600:	85 c0                	test   %eax,%eax
c0107602:	74 1b                	je     c010761f <vmm_cover_map_page+0x15e>
c0107604:	8b 45 14             	mov    0x14(%ebp),%eax
c0107607:	83 e0 01             	and    $0x1,%eax
c010760a:	85 c0                	test   %eax,%eax
c010760c:	74 11                	je     c010761f <vmm_cover_map_page+0x15e>
        // add one on reference count, regardless of existence.
        pmm_ref_page(pid, pa);
c010760e:	83 ec 08             	sub    $0x8,%esp
c0107611:	ff 75 10             	push   0x10(%ebp)
c0107614:	ff 75 08             	push   0x8(%ebp)
c0107617:	e8 cf f3 ff ff       	call   c01069eb <pmm_ref_page>
c010761c:	83 c4 10             	add    $0x10,%esp
    }
    pt[pt_offset] = PTE(tattr, pa);
c010761f:	8b 45 10             	mov    0x10(%ebp),%eax
c0107622:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0107627:	89 c1                	mov    %eax,%ecx
c0107629:	8b 45 18             	mov    0x18(%ebp),%eax
c010762c:	25 ff 0f 00 00       	and    $0xfff,%eax
c0107631:	89 c2                	mov    %eax,%edx
c0107633:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107636:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
c010763d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0107640:	01 d8                	add    %ebx,%eax
c0107642:	09 ca                	or     %ecx,%edx
c0107644:	89 10                	mov    %edx,(%eax)

    cpu_invplg(va);
c0107646:	83 ec 0c             	sub    $0xc,%esp
c0107649:	ff 75 0c             	push   0xc(%ebp)
c010764c:	e8 aa fa ff ff       	call   c01070fb <cpu_invplg>
c0107651:	83 c4 10             	add    $0x10,%esp

    return V_ADDR(pd_offset, pt_offset, PG_OFFSET(va));
c0107654:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107657:	c1 e0 16             	shl    $0x16,%eax
c010765a:	89 c2                	mov    %eax,%edx
c010765c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010765f:	c1 e0 0c             	shl    $0xc,%eax
c0107662:	09 c2                	or     %eax,%edx
c0107664:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107667:	25 ff 0f 00 00       	and    $0xfff,%eax
c010766c:	09 d0                	or     %edx,%eax
}
c010766e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0107671:	c9                   	leave  
c0107672:	c3                   	ret    

c0107673 <vmm_alloc_page>:

void* vmm_alloc_page(pid_t pid, void* vpn, void** pa, pt_attr dattr, pt_attr tattr)
{
c0107673:	55                   	push   %ebp
c0107674:	89 e5                	mov    %esp,%ebp
c0107676:	83 ec 18             	sub    $0x18,%esp
    void* pp = pmm_alloc_page(pid, tattr);
c0107679:	83 ec 08             	sub    $0x8,%esp
c010767c:	ff 75 18             	push   0x18(%ebp)
c010767f:	ff 75 08             	push   0x8(%ebp)
c0107682:	e8 9d f1 ff ff       	call   c0106824 <pmm_alloc_page>
c0107687:	83 c4 10             	add    $0x10,%esp
c010768a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    void* result = vmm_map_page(pid, vpn, pp, dattr, tattr);
c010768d:	83 ec 0c             	sub    $0xc,%esp
c0107690:	ff 75 18             	push   0x18(%ebp)
c0107693:	ff 75 14             	push   0x14(%ebp)
c0107696:	ff 75 f4             	push   -0xc(%ebp)
c0107699:	ff 75 0c             	push   0xc(%ebp)
c010769c:	ff 75 08             	push   0x8(%ebp)
c010769f:	e8 24 fc ff ff       	call   c01072c8 <vmm_map_page>
c01076a4:	83 c4 20             	add    $0x20,%esp
c01076a7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (!result) {
c01076aa:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c01076ae:	75 11                	jne    c01076c1 <vmm_alloc_page+0x4e>
        pmm_free_page(pid, pp);
c01076b0:	83 ec 08             	sub    $0x8,%esp
c01076b3:	ff 75 f4             	push   -0xc(%ebp)
c01076b6:	ff 75 08             	push   0x8(%ebp)
c01076b9:	e8 9b f2 ff ff       	call   c0106959 <pmm_free_page>
c01076be:	83 c4 10             	add    $0x10,%esp
    }
    pa ? (*pa = pp) : 0;
c01076c1:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c01076c5:	74 08                	je     c01076cf <vmm_alloc_page+0x5c>
c01076c7:	8b 45 10             	mov    0x10(%ebp),%eax
c01076ca:	8b 55 f4             	mov    -0xc(%ebp),%edx
c01076cd:	89 10                	mov    %edx,(%eax)
    return result;
c01076cf:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c01076d2:	c9                   	leave  
c01076d3:	c3                   	ret    

c01076d4 <vmm_alloc_pages>:

int vmm_alloc_pages(pid_t pid, void* va, size_t sz, pt_attr tattr, pp_attr_t pattr)
{
c01076d4:	55                   	push   %ebp
c01076d5:	89 e5                	mov    %esp,%ebp
c01076d7:	83 ec 28             	sub    $0x28,%esp
    assert((uintptr_t)va % PG_SIZE == 0) assert(sz % PG_SIZE == 0);
c01076da:	8b 45 0c             	mov    0xc(%ebp),%eax
c01076dd:	25 ff 0f 00 00       	and    $0xfff,%eax
c01076e2:	85 c0                	test   %eax,%eax
c01076e4:	74 1a                	je     c0107700 <vmm_alloc_pages+0x2c>
c01076e6:	83 ec 04             	sub    $0x4,%esp
c01076e9:	68 32 01 00 00       	push   $0x132
c01076ee:	68 4c c2 28 c0       	push   $0xc028c24c
c01076f3:	68 71 c2 28 c0       	push   $0xc028c271
c01076f8:	e8 0b 14 00 00       	call   c0108b08 <__assert_fail>
c01076fd:	83 c4 10             	add    $0x10,%esp
c0107700:	8b 45 10             	mov    0x10(%ebp),%eax
c0107703:	25 ff 0f 00 00       	and    $0xfff,%eax
c0107708:	85 c0                	test   %eax,%eax
c010770a:	74 1a                	je     c0107726 <vmm_alloc_pages+0x52>
c010770c:	83 ec 04             	sub    $0x4,%esp
c010770f:	68 32 01 00 00       	push   $0x132
c0107714:	68 4c c2 28 c0       	push   $0xc028c24c
c0107719:	68 8e c2 28 c0       	push   $0xc028c28e
c010771e:	e8 e5 13 00 00       	call   c0108b08 <__assert_fail>
c0107723:	83 c4 10             	add    $0x10,%esp

    void* va_ = va;
c0107726:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107729:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for (size_t i = 0; i < (sz >> PG_SIZE_BITS); i++, va_ += PG_SIZE) {
c010772c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0107733:	e9 97 00 00 00       	jmp    c01077cf <vmm_alloc_pages+0xfb>
        void* pp = pmm_alloc_page(pid, pattr);
c0107738:	83 ec 08             	sub    $0x8,%esp
c010773b:	ff 75 18             	push   0x18(%ebp)
c010773e:	ff 75 08             	push   0x8(%ebp)
c0107741:	e8 de f0 ff ff       	call   c0106824 <pmm_alloc_page>
c0107746:	83 c4 10             	add    $0x10,%esp
c0107749:	89 45 e8             	mov    %eax,-0x18(%ebp)
        uint32_t l1_index = PD_INDEX(va_);
c010774c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010774f:	c1 e8 16             	shr    $0x16,%eax
c0107752:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        uint32_t l2_index = PT_INDEX(va_);
c0107755:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107758:	c1 e8 0c             	shr    $0xc,%eax
c010775b:	25 ff 03 00 00       	and    $0x3ff,%eax
c0107760:	89 45 e0             	mov    %eax,-0x20(%ebp)
        if (!pp || !__vmm_map_alloc(
c0107763:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0107767:	74 21                	je     c010778a <vmm_alloc_pages+0xb6>
c0107769:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010776c:	83 ec 08             	sub    $0x8,%esp
c010776f:	6a 00                	push   $0x0
c0107771:	ff 75 14             	push   0x14(%ebp)
c0107774:	50                   	push   %eax
c0107775:	ff 75 e0             	push   -0x20(%ebp)
c0107778:	ff 75 e4             	push   -0x1c(%ebp)
c010777b:	ff 75 08             	push   0x8(%ebp)
c010777e:	e8 17 fa ff ff       	call   c010719a <__vmm_map_alloc>
c0107783:	83 c4 20             	add    $0x20,%esp
c0107786:	85 c0                	test   %eax,%eax
c0107788:	75 3a                	jne    c01077c4 <vmm_alloc_pages+0xf0>
                     pid,
                     l1_index, l2_index, (uintptr_t)pp, tattr, false)) {
            // if one failed, release previous allocated pages.
            va_ = va;
c010778a:	8b 45 0c             	mov    0xc(%ebp),%eax
c010778d:	89 45 f4             	mov    %eax,-0xc(%ebp)
            for (size_t j = 0; j < i; j++, va_ += PG_SIZE) {
c0107790:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0107797:	eb 1c                	jmp    c01077b5 <vmm_alloc_pages+0xe1>
                vmm_unmap_page(pid, va_);
c0107799:	83 ec 08             	sub    $0x8,%esp
c010779c:	ff 75 f4             	push   -0xc(%ebp)
c010779f:	ff 75 08             	push   0x8(%ebp)
c01077a2:	e8 8d 01 00 00       	call   c0107934 <vmm_unmap_page>
c01077a7:	83 c4 10             	add    $0x10,%esp
            for (size_t j = 0; j < i; j++, va_ += PG_SIZE) {
c01077aa:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c01077ae:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
c01077b5:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01077b8:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c01077bb:	72 dc                	jb     c0107799 <vmm_alloc_pages+0xc5>
            }

            return false;
c01077bd:	b8 00 00 00 00       	mov    $0x0,%eax
c01077c2:	eb 1f                	jmp    c01077e3 <vmm_alloc_pages+0x10f>
    for (size_t i = 0; i < (sz >> PG_SIZE_BITS); i++, va_ += PG_SIZE) {
c01077c4:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c01077c8:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
c01077cf:	8b 45 10             	mov    0x10(%ebp),%eax
c01077d2:	c1 e8 0c             	shr    $0xc,%eax
c01077d5:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c01077d8:	0f 82 5a ff ff ff    	jb     c0107738 <vmm_alloc_pages+0x64>
        }
    }

    return true;
c01077de:	b8 01 00 00 00       	mov    $0x1,%eax
}
c01077e3:	c9                   	leave  
c01077e4:	c3                   	ret    

c01077e5 <vmm_set_mapping>:

int vmm_set_mapping(pid_t pid, void* va, void* pa, pt_attr attr)
{
c01077e5:	55                   	push   %ebp
c01077e6:	89 e5                	mov    %esp,%ebp
c01077e8:	83 ec 18             	sub    $0x18,%esp
    assert(((uintptr_t)va & 0xFFFU) == 0);
c01077eb:	8b 45 0c             	mov    0xc(%ebp),%eax
c01077ee:	25 ff 0f 00 00       	and    $0xfff,%eax
c01077f3:	85 c0                	test   %eax,%eax
c01077f5:	74 1a                	je     c0107811 <vmm_set_mapping+0x2c>
c01077f7:	83 ec 04             	sub    $0x4,%esp
c01077fa:	68 4b 01 00 00       	push   $0x14b
c01077ff:	68 4c c2 28 c0       	push   $0xc028c24c
c0107804:	68 a0 c2 28 c0       	push   $0xc028c2a0
c0107809:	e8 fa 12 00 00       	call   c0108b08 <__assert_fail>
c010780e:	83 c4 10             	add    $0x10,%esp

    uint32_t l1_index = PD_INDEX(va);
c0107811:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107814:	c1 e8 16             	shr    $0x16,%eax
c0107817:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t l2_index = PT_INDEX(va);
c010781a:	8b 45 0c             	mov    0xc(%ebp),%eax
c010781d:	c1 e8 0c             	shr    $0xc,%eax
c0107820:	25 ff 03 00 00       	and    $0x3ff,%eax
c0107825:	89 45 f0             	mov    %eax,-0x10(%ebp)

    // prevent map of recursive mapping region
    if (l1_index == 1023) {
c0107828:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
c010782f:	75 07                	jne    c0107838 <vmm_set_mapping+0x53>
        return 0;
c0107831:	b8 00 00 00 00       	mov    $0x0,%eax
c0107836:	eb 22                	jmp    c010785a <vmm_set_mapping+0x75>
    }
    
    __vmm_map_alloc(pid, l1_index, l2_index, (uintptr_t)pa, attr, false);
c0107838:	8b 45 10             	mov    0x10(%ebp),%eax
c010783b:	83 ec 08             	sub    $0x8,%esp
c010783e:	6a 00                	push   $0x0
c0107840:	ff 75 14             	push   0x14(%ebp)
c0107843:	50                   	push   %eax
c0107844:	ff 75 f0             	push   -0x10(%ebp)
c0107847:	ff 75 f4             	push   -0xc(%ebp)
c010784a:	ff 75 08             	push   0x8(%ebp)
c010784d:	e8 48 f9 ff ff       	call   c010719a <__vmm_map_alloc>
c0107852:	83 c4 20             	add    $0x20,%esp
    return 1;
c0107855:	b8 01 00 00 00       	mov    $0x1,%eax
}
c010785a:	c9                   	leave  
c010785b:	c3                   	ret    

c010785c <__vmm_unmap_unalloc>:

void __vmm_unmap_unalloc(pid_t pid, void* va, int free_ppage)
{
c010785c:	55                   	push   %ebp
c010785d:	89 e5                	mov    %esp,%ebp
c010785f:	83 ec 28             	sub    $0x28,%esp
    assert(((uintptr_t)va & 0xFFFU) == 0);
c0107862:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107865:	25 ff 0f 00 00       	and    $0xfff,%eax
c010786a:	85 c0                	test   %eax,%eax
c010786c:	74 1a                	je     c0107888 <__vmm_unmap_unalloc+0x2c>
c010786e:	83 ec 04             	sub    $0x4,%esp
c0107871:	68 5b 01 00 00       	push   $0x15b
c0107876:	68 4c c2 28 c0       	push   $0xc028c24c
c010787b:	68 a0 c2 28 c0       	push   $0xc028c2a0
c0107880:	e8 83 12 00 00       	call   c0108b08 <__assert_fail>
c0107885:	83 c4 10             	add    $0x10,%esp

    uint32_t l1_index = PD_INDEX(va);
c0107888:	8b 45 0c             	mov    0xc(%ebp),%eax
c010788b:	c1 e8 16             	shr    $0x16,%eax
c010788e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t l2_index = PT_INDEX(va);
c0107891:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107894:	c1 e8 0c             	shr    $0xc,%eax
c0107897:	25 ff 03 00 00       	and    $0x3ff,%eax
c010789c:	89 45 f0             	mov    %eax,-0x10(%ebp)

    // prevent unmap of recursive mapping region
    if (l1_index == 1023) {
c010789f:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
c01078a6:	0f 84 85 00 00 00    	je     c0107931 <__vmm_unmap_unalloc+0xd5>
        return;
    }

    ptd_t* ptd = (ptd_t*)PTD_BASE_VADDR;
c01078ac:	c7 45 ec 00 f0 ff ff 	movl   $0xfffff000,-0x14(%ebp)

    if (ptd[l1_index]) {
c01078b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01078b6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c01078bd:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01078c0:	01 d0                	add    %edx,%eax
c01078c2:	8b 00                	mov    (%eax),%eax
c01078c4:	85 c0                	test   %eax,%eax
c01078c6:	74 6a                	je     c0107932 <__vmm_unmap_unalloc+0xd6>
        pt_t* pt = (uintptr_t)PT_VADDR(l1_index);
c01078c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01078cb:	c1 e0 0c             	shl    $0xc,%eax
c01078ce:	0d 00 00 c0 ff       	or     $0xffc00000,%eax
c01078d3:	89 45 e8             	mov    %eax,-0x18(%ebp)
        pt_t pte = pt[l2_index];
c01078d6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01078d9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c01078e0:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01078e3:	01 d0                	add    %edx,%eax
c01078e5:	8b 00                	mov    (%eax),%eax
c01078e7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if (IS_CACHED(pte) && free_ppage) {
c01078ea:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01078ed:	83 e0 01             	and    $0x1,%eax
c01078f0:	85 c0                	test   %eax,%eax
c01078f2:	74 18                	je     c010790c <__vmm_unmap_unalloc+0xb0>
c01078f4:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c01078f8:	74 12                	je     c010790c <__vmm_unmap_unalloc+0xb0>
            pmm_free_page(pid, (void*)pte);
c01078fa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01078fd:	83 ec 08             	sub    $0x8,%esp
c0107900:	50                   	push   %eax
c0107901:	ff 75 08             	push   0x8(%ebp)
c0107904:	e8 50 f0 ff ff       	call   c0106959 <pmm_free_page>
c0107909:	83 c4 10             	add    $0x10,%esp
        }
        cpu_invplg(va);
c010790c:	83 ec 0c             	sub    $0xc,%esp
c010790f:	ff 75 0c             	push   0xc(%ebp)
c0107912:	e8 e4 f7 ff ff       	call   c01070fb <cpu_invplg>
c0107917:	83 c4 10             	add    $0x10,%esp

        pt[l2_index] = 0;
c010791a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010791d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0107924:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0107927:	01 d0                	add    %edx,%eax
c0107929:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c010792f:	eb 01                	jmp    c0107932 <__vmm_unmap_unalloc+0xd6>
        return;
c0107931:	90                   	nop
    }
}
c0107932:	c9                   	leave  
c0107933:	c3                   	ret    

c0107934 <vmm_unmap_page>:

void vmm_unmap_page(pid_t pid, void* va)
{
c0107934:	55                   	push   %ebp
c0107935:	89 e5                	mov    %esp,%ebp
c0107937:	83 ec 08             	sub    $0x8,%esp
    __vmm_unmap_unalloc(pid, va, true);
c010793a:	83 ec 04             	sub    $0x4,%esp
c010793d:	6a 01                	push   $0x1
c010793f:	ff 75 0c             	push   0xc(%ebp)
c0107942:	ff 75 08             	push   0x8(%ebp)
c0107945:	e8 12 ff ff ff       	call   c010785c <__vmm_unmap_unalloc>
c010794a:	83 c4 10             	add    $0x10,%esp
}
c010794d:	90                   	nop
c010794e:	c9                   	leave  
c010794f:	c3                   	ret    

c0107950 <vmm_unset_mapping>:

void vmm_unset_mapping(void* va)
{
c0107950:	55                   	push   %ebp
c0107951:	89 e5                	mov    %esp,%ebp
c0107953:	83 ec 08             	sub    $0x8,%esp
    __vmm_unmap_unalloc(0, va, false);
c0107956:	83 ec 04             	sub    $0x4,%esp
c0107959:	6a 00                	push   $0x0
c010795b:	ff 75 08             	push   0x8(%ebp)
c010795e:	6a 00                	push   $0x0
c0107960:	e8 f7 fe ff ff       	call   c010785c <__vmm_unmap_unalloc>
c0107965:	83 c4 10             	add    $0x10,%esp
}
c0107968:	90                   	nop
c0107969:	c9                   	leave  
c010796a:	c3                   	ret    

c010796b <vmm_lookup>:

v_mapping vmm_lookup(void* va)
{
c010796b:	55                   	push   %ebp
c010796c:	89 e5                	mov    %esp,%ebp
c010796e:	83 ec 38             	sub    $0x38,%esp
    assert(((uintptr_t)va & 0xFFFU) == 0);
c0107971:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107974:	25 ff 0f 00 00       	and    $0xfff,%eax
c0107979:	85 c0                	test   %eax,%eax
c010797b:	74 1a                	je     c0107997 <vmm_lookup+0x2c>
c010797d:	83 ec 04             	sub    $0x4,%esp
c0107980:	68 7f 01 00 00       	push   $0x17f
c0107985:	68 4c c2 28 c0       	push   $0xc028c24c
c010798a:	68 a0 c2 28 c0       	push   $0xc028c2a0
c010798f:	e8 74 11 00 00       	call   c0108b08 <__assert_fail>
c0107994:	83 c4 10             	add    $0x10,%esp

    uint32_t l1_index = PD_INDEX(va);
c0107997:	8b 45 0c             	mov    0xc(%ebp),%eax
c010799a:	c1 e8 16             	shr    $0x16,%eax
c010799d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t l2_index = PT_INDEX(va);
c01079a0:	8b 45 0c             	mov    0xc(%ebp),%eax
c01079a3:	c1 e8 0c             	shr    $0xc,%eax
c01079a6:	25 ff 03 00 00       	and    $0x3ff,%eax
c01079ab:	89 45 f0             	mov    %eax,-0x10(%ebp)

    ptd_t* ptd = (ptd_t*)PTD_BASE_VADDR;
c01079ae:	c7 45 ec 00 f0 ff ff 	movl   $0xfffff000,-0x14(%ebp)

    v_mapping mapping = { .flags = 0, .pa = 0, .pn = 0 };
c01079b5:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
c01079bc:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
c01079c3:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
c01079ca:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    if (ptd[l1_index]) {
c01079d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01079d4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c01079db:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01079de:	01 d0                	add    %edx,%eax
c01079e0:	8b 00                	mov    (%eax),%eax
c01079e2:	85 c0                	test   %eax,%eax
c01079e4:	74 4f                	je     c0107a35 <vmm_lookup+0xca>
        pt_t* pt = (uintptr_t)PT_VADDR(l1_index);
c01079e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01079e9:	c1 e0 0c             	shl    $0xc,%eax
c01079ec:	0d 00 00 c0 ff       	or     $0xffc00000,%eax
c01079f1:	89 45 e8             	mov    %eax,-0x18(%ebp)
        pt_t* l2pte = &pt[l2_index];
c01079f4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01079f7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c01079fe:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0107a01:	01 d0                	add    %edx,%eax
c0107a03:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if (l2pte) {
c0107a06:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0107a0a:	74 29                	je     c0107a35 <vmm_lookup+0xca>
            mapping.flags = PG_ENTRY_FLAGS(*l2pte);
c0107a0c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0107a0f:	8b 00                	mov    (%eax),%eax
c0107a11:	66 25 ff 0f          	and    $0xfff,%ax
c0107a15:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
            mapping.pa = PG_ENTRY_ADDR(*l2pte);
c0107a19:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0107a1c:	8b 00                	mov    (%eax),%eax
c0107a1e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0107a23:	89 45 d8             	mov    %eax,-0x28(%ebp)
            mapping.pn = mapping.pa >> PG_SIZE_BITS;
c0107a26:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0107a29:	c1 e8 0c             	shr    $0xc,%eax
c0107a2c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
            mapping.pte = l2pte;
c0107a2f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0107a32:	89 45 e0             	mov    %eax,-0x20(%ebp)
        }
    }

    return mapping;
c0107a35:	8b 45 08             	mov    0x8(%ebp),%eax
c0107a38:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c0107a3b:	89 10                	mov    %edx,(%eax)
c0107a3d:	8b 55 d8             	mov    -0x28(%ebp),%edx
c0107a40:	89 50 04             	mov    %edx,0x4(%eax)
c0107a43:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0107a46:	89 50 08             	mov    %edx,0x8(%eax)
c0107a49:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0107a4c:	89 50 0c             	mov    %edx,0xc(%eax)
}
c0107a4f:	8b 45 08             	mov    0x8(%ebp),%eax
c0107a52:	c9                   	leave  
c0107a53:	c2 04 00             	ret    $0x4

c0107a56 <vmm_v2p>:

void* vmm_v2p(void* va)
{
c0107a56:	55                   	push   %ebp
c0107a57:	89 e5                	mov    %esp,%ebp
c0107a59:	83 ec 18             	sub    $0x18,%esp
    return (void*)vmm_lookup(va).pa;
c0107a5c:	8d 45 e8             	lea    -0x18(%ebp),%eax
c0107a5f:	83 ec 08             	sub    $0x8,%esp
c0107a62:	ff 75 08             	push   0x8(%ebp)
c0107a65:	50                   	push   %eax
c0107a66:	e8 00 ff ff ff       	call   c010796b <vmm_lookup>
c0107a6b:	83 c4 0c             	add    $0xc,%esp
c0107a6e:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
c0107a71:	c9                   	leave  
c0107a72:	c3                   	ret    

c0107a73 <vmm_dup_page>:

void* vmm_dup_page(pid_t pid, void* pa)
{
c0107a73:	55                   	push   %ebp
c0107a74:	89 e5                	mov    %esp,%ebp
c0107a76:	57                   	push   %edi
c0107a77:	56                   	push   %esi
c0107a78:	53                   	push   %ebx
c0107a79:	83 ec 1c             	sub    $0x1c,%esp
    void* new_ppg = pmm_alloc_page(pid, 0);
c0107a7c:	83 ec 08             	sub    $0x8,%esp
c0107a7f:	6a 00                	push   $0x0
c0107a81:	ff 75 08             	push   0x8(%ebp)
c0107a84:	e8 9b ed ff ff       	call   c0106824 <pmm_alloc_page>
c0107a89:	83 c4 10             	add    $0x10,%esp
c0107a8c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    vmm_cover_map_page(pid, PG_MOUNT_3, new_ppg, PG_PREM_RW,PG_PREM_RW);
c0107a8f:	83 ec 0c             	sub    $0xc,%esp
c0107a92:	6a 03                	push   $0x3
c0107a94:	6a 03                	push   $0x3
c0107a96:	ff 75 e4             	push   -0x1c(%ebp)
c0107a99:	68 00 d0 7f af       	push   $0xaf7fd000
c0107a9e:	ff 75 08             	push   0x8(%ebp)
c0107aa1:	e8 1b fa ff ff       	call   c01074c1 <vmm_cover_map_page>
c0107aa6:	83 c4 20             	add    $0x20,%esp
    vmm_cover_map_page(pid, PG_MOUNT_4, pa, PG_PREM_RW,PG_PREM_RW);
c0107aa9:	83 ec 0c             	sub    $0xc,%esp
c0107aac:	6a 03                	push   $0x3
c0107aae:	6a 03                	push   $0x3
c0107ab0:	ff 75 0c             	push   0xc(%ebp)
c0107ab3:	68 00 c0 7f af       	push   $0xaf7fc000
c0107ab8:	ff 75 08             	push   0x8(%ebp)
c0107abb:	e8 01 fa ff ff       	call   c01074c1 <vmm_cover_map_page>
c0107ac0:	83 c4 20             	add    $0x20,%esp

    asm volatile (
c0107ac3:	b8 00 04 00 00       	mov    $0x400,%eax
c0107ac8:	ba 00 d0 7f af       	mov    $0xaf7fd000,%edx
c0107acd:	bb 00 c0 7f af       	mov    $0xaf7fc000,%ebx
c0107ad2:	89 c1                	mov    %eax,%ecx
c0107ad4:	89 d7                	mov    %edx,%edi
c0107ad6:	89 de                	mov    %ebx,%esi
c0107ad8:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
        "movl %2, %%esi\n"
        "rep movsl\n"
        :: "c"(1024), "r"(PG_MOUNT_3), "r"(PG_MOUNT_4)
        : "memory", "%edi", "%esi");

    vmm_unset_mapping(PG_MOUNT_3);
c0107ada:	83 ec 0c             	sub    $0xc,%esp
c0107add:	68 00 d0 7f af       	push   $0xaf7fd000
c0107ae2:	e8 69 fe ff ff       	call   c0107950 <vmm_unset_mapping>
c0107ae7:	83 c4 10             	add    $0x10,%esp
    vmm_unset_mapping(PG_MOUNT_4);
c0107aea:	83 ec 0c             	sub    $0xc,%esp
c0107aed:	68 00 c0 7f af       	push   $0xaf7fc000
c0107af2:	e8 59 fe ff ff       	call   c0107950 <vmm_unset_mapping>
c0107af7:	83 c4 10             	add    $0x10,%esp

    return new_ppg;
c0107afa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
c0107afd:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0107b00:	5b                   	pop    %ebx
c0107b01:	5e                   	pop    %esi
c0107b02:	5f                   	pop    %edi
c0107b03:	5d                   	pop    %ebp
c0107b04:	c3                   	ret    

c0107b05 <vmm_mount_pd>:

void* vmm_mount_pd(uintptr_t mnt, void* pde)
{
c0107b05:	55                   	push   %ebp
c0107b06:	89 e5                	mov    %esp,%ebp
c0107b08:	83 ec 10             	sub    $0x10,%esp
    ptd_t* l1pt = (ptd_t*)PTD_BASE_VADDR;
c0107b0b:	c7 45 fc 00 f0 ff ff 	movl   $0xfffff000,-0x4(%ebp)
    l1pt[(mnt >> 22)] = PDE(T_SELF_REF_PERM, pde);
c0107b12:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107b15:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0107b1a:	89 c2                	mov    %eax,%edx
c0107b1c:	8b 45 08             	mov    0x8(%ebp),%eax
c0107b1f:	c1 e8 16             	shr    $0x16,%eax
c0107b22:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
c0107b29:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0107b2c:	01 c8                	add    %ecx,%eax
c0107b2e:	83 ca 1b             	or     $0x1b,%edx
c0107b31:	89 10                	mov    %edx,(%eax)
    cpu_invplg(mnt);
c0107b33:	8b 45 08             	mov    0x8(%ebp),%eax
c0107b36:	50                   	push   %eax
c0107b37:	e8 bf f5 ff ff       	call   c01070fb <cpu_invplg>
c0107b3c:	83 c4 04             	add    $0x4,%esp
    return mnt;
c0107b3f:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0107b42:	c9                   	leave  
c0107b43:	c3                   	ret    

c0107b44 <vmm_unmount_pd>:

void* vmm_unmount_pd(uintptr_t mnt)
{
c0107b44:	55                   	push   %ebp
c0107b45:	89 e5                	mov    %esp,%ebp
c0107b47:	83 ec 10             	sub    $0x10,%esp
    ptd_t* l1pt = (ptd_t*)PTD_BASE_VADDR;
c0107b4a:	c7 45 fc 00 f0 ff ff 	movl   $0xfffff000,-0x4(%ebp)
    l1pt[(mnt >> 22)] = 0;
c0107b51:	8b 45 08             	mov    0x8(%ebp),%eax
c0107b54:	c1 e8 16             	shr    $0x16,%eax
c0107b57:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0107b5e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0107b61:	01 d0                	add    %edx,%eax
c0107b63:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    cpu_invplg(mnt);
c0107b69:	8b 45 08             	mov    0x8(%ebp),%eax
c0107b6c:	50                   	push   %eax
c0107b6d:	e8 89 f5 ff ff       	call   c01070fb <cpu_invplg>
c0107b72:	83 c4 04             	add    $0x4,%esp
}
c0107b75:	90                   	nop
c0107b76:	c9                   	leave  
c0107b77:	c3                   	ret    

c0107b78 <io_outb>:
                 : "memory", "cc");
}

static inline void
io_outb(int port, uint8_t data)
{
c0107b78:	55                   	push   %ebp
c0107b79:	89 e5                	mov    %esp,%ebp
c0107b7b:	83 ec 04             	sub    $0x4,%esp
c0107b7e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107b81:	88 45 fc             	mov    %al,-0x4(%ebp)
    asm volatile("outb %0, %w1" : : "a"(data), "d"(port));
c0107b84:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0107b88:	8b 55 08             	mov    0x8(%ebp),%edx
c0107b8b:	ee                   	out    %al,(%dx)
}
c0107b8c:	90                   	nop
c0107b8d:	c9                   	leave  
c0107b8e:	c3                   	ret    

c0107b8f <frequence_set>:
#define PIT_CONTROL_PORT 0X43

//WRITE COUNTER
static void frequence_set(uint8_t counter_port, uint8_t counter_no, 
                         uint8_t rwl, uint8_t counter_mode, uint16_t counter_value)
{
c0107b8f:	55                   	push   %ebp
c0107b90:	89 e5                	mov    %esp,%ebp
c0107b92:	57                   	push   %edi
c0107b93:	56                   	push   %esi
c0107b94:	53                   	push   %ebx
c0107b95:	83 ec 14             	sub    $0x14,%esp
c0107b98:	8b 75 08             	mov    0x8(%ebp),%esi
c0107b9b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
c0107b9e:	8b 4d 10             	mov    0x10(%ebp),%ecx
c0107ba1:	8b 55 14             	mov    0x14(%ebp),%edx
c0107ba4:	8b 7d 18             	mov    0x18(%ebp),%edi
c0107ba7:	89 f0                	mov    %esi,%eax
c0107ba9:	88 45 f0             	mov    %al,-0x10(%ebp)
c0107bac:	88 5d ec             	mov    %bl,-0x14(%ebp)
c0107baf:	88 4d e8             	mov    %cl,-0x18(%ebp)
c0107bb2:	88 55 e4             	mov    %dl,-0x1c(%ebp)
c0107bb5:	89 f8                	mov    %edi,%eax
c0107bb7:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
    io_outb(PIT_CONTROL_PORT, (uint8_t)(counter_no << 6 | rwl << 4 | counter_mode << 1));
c0107bbb:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0107bbf:	c1 e0 06             	shl    $0x6,%eax
c0107bc2:	89 c2                	mov    %eax,%edx
c0107bc4:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c0107bc8:	c1 e0 04             	shl    $0x4,%eax
c0107bcb:	09 c2                	or     %eax,%edx
c0107bcd:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0107bd1:	01 c0                	add    %eax,%eax
c0107bd3:	09 d0                	or     %edx,%eax
c0107bd5:	0f b6 c0             	movzbl %al,%eax
c0107bd8:	50                   	push   %eax
c0107bd9:	6a 43                	push   $0x43
c0107bdb:	e8 98 ff ff ff       	call   c0107b78 <io_outb>
c0107be0:	83 c4 08             	add    $0x8,%esp
    io_outb(counter_port, (uint8_t)counter_value);
c0107be3:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
c0107be7:	0f b6 d0             	movzbl %al,%edx
c0107bea:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
c0107bee:	52                   	push   %edx
c0107bef:	50                   	push   %eax
c0107bf0:	e8 83 ff ff ff       	call   c0107b78 <io_outb>
c0107bf5:	83 c4 08             	add    $0x8,%esp
    io_outb(counter_port, (uint8_t)(counter_value >> 8));
c0107bf8:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
c0107bfc:	66 c1 e8 08          	shr    $0x8,%ax
c0107c00:	0f b6 d0             	movzbl %al,%edx
c0107c03:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
c0107c07:	52                   	push   %edx
c0107c08:	50                   	push   %eax
c0107c09:	e8 6a ff ff ff       	call   c0107b78 <io_outb>
c0107c0e:	83 c4 08             	add    $0x8,%esp
}
c0107c11:	90                   	nop
c0107c12:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0107c15:	5b                   	pop    %ebx
c0107c16:	5e                   	pop    %esi
c0107c17:	5f                   	pop    %edi
c0107c18:	5d                   	pop    %ebp
c0107c19:	c3                   	ret    

c0107c1a <timer_init>:

void timer_init(){
c0107c1a:	55                   	push   %ebp
c0107c1b:	89 e5                	mov    %esp,%ebp
c0107c1d:	83 ec 08             	sub    $0x8,%esp
    kprintf("timer intr start\n");
c0107c20:	83 ec 0c             	sub    $0xc,%esp
c0107c23:	68 be c2 28 c0       	push   $0xc028c2be
c0107c28:	e8 a4 13 00 00       	call   c0108fd1 <kprintf>
c0107c2d:	83 c4 10             	add    $0x10,%esp
    frequence_set(CURRENTR0_PORT, CURRENTR0_NO, READ_WRITE_LATCH, CURRENTR_MODE, CURRENTR0_VALUE);
c0107c30:	83 ec 0c             	sub    $0xc,%esp
c0107c33:	68 9b 2e 00 00       	push   $0x2e9b
c0107c38:	6a 02                	push   $0x2
c0107c3a:	6a 03                	push   $0x3
c0107c3c:	6a 00                	push   $0x0
c0107c3e:	6a 40                	push   $0x40
c0107c40:	e8 4a ff ff ff       	call   c0107b8f <frequence_set>
c0107c45:	83 c4 20             	add    $0x20,%esp
    kprintf("timer init down\n");
c0107c48:	83 ec 0c             	sub    $0xc,%esp
c0107c4b:	68 d0 c2 28 c0       	push   $0xc028c2d0
c0107c50:	e8 7c 13 00 00       	call   c0108fd1 <kprintf>
c0107c55:	83 c4 10             	add    $0x10,%esp
c0107c58:	90                   	nop
c0107c59:	c9                   	leave  
c0107c5a:	c3                   	ret    

c0107c5b <_divide_err>:
#include <libs/mstdio.h>
#include <kernel/interrupt/interupt_fun.h>
#include <vga/vga.h>

void _divide_err(unsigned long addr, int err_code)
{
c0107c5b:	55                   	push   %ebp
c0107c5c:	89 e5                	mov    %esp,%ebp
c0107c5e:	83 ec 08             	sub    $0x8,%esp
    vga_set_show(1,VGA_COLOR_BLACK,VGA_COLOR_BLUE);
c0107c61:	83 ec 04             	sub    $0x4,%esp
c0107c64:	6a 01                	push   $0x1
c0107c66:	6a 00                	push   $0x0
c0107c68:	6a 01                	push   $0x1
c0107c6a:	e8 65 e4 ff ff       	call   c01060d4 <vga_set_show>
c0107c6f:	83 c4 10             	add    $0x10,%esp
    kprintf("divide err addr = 0x%x,err code = %d\n", addr,err_code);
c0107c72:	83 ec 04             	sub    $0x4,%esp
c0107c75:	ff 75 0c             	push   0xc(%ebp)
c0107c78:	ff 75 08             	push   0x8(%ebp)
c0107c7b:	68 e4 c2 28 c0       	push   $0xc028c2e4
c0107c80:	e8 4c 13 00 00       	call   c0108fd1 <kprintf>
c0107c85:	83 c4 10             	add    $0x10,%esp
}
c0107c88:	90                   	nop
c0107c89:	c9                   	leave  
c0107c8a:	c3                   	ret    

c0107c8b <do_double_fault>:

void do_double_fault(unsigned long addr, int err_code)
{
c0107c8b:	55                   	push   %ebp
c0107c8c:	89 e5                	mov    %esp,%ebp
c0107c8e:	83 ec 08             	sub    $0x8,%esp
	kprintf("double_fault addr = 0x%x,err code = %d\n", addr,err_code);
c0107c91:	83 ec 04             	sub    $0x4,%esp
c0107c94:	ff 75 0c             	push   0xc(%ebp)
c0107c97:	ff 75 08             	push   0x8(%ebp)
c0107c9a:	68 0c c3 28 c0       	push   $0xc028c30c
c0107c9f:	e8 2d 13 00 00       	call   c0108fd1 <kprintf>
c0107ca4:	83 c4 10             	add    $0x10,%esp
}
c0107ca7:	90                   	nop
c0107ca8:	c9                   	leave  
c0107ca9:	c3                   	ret    

c0107caa <do_general_protection>:

void do_general_protection(unsigned long addr, int err_code)
{
c0107caa:	55                   	push   %ebp
c0107cab:	89 e5                	mov    %esp,%ebp
c0107cad:	83 ec 08             	sub    $0x8,%esp
	kprintf("general_protection addr = 0x%x,err code = %d\n", addr,err_code);
c0107cb0:	83 ec 04             	sub    $0x4,%esp
c0107cb3:	ff 75 0c             	push   0xc(%ebp)
c0107cb6:	ff 75 08             	push   0x8(%ebp)
c0107cb9:	68 34 c3 28 c0       	push   $0xc028c334
c0107cbe:	e8 0e 13 00 00       	call   c0108fd1 <kprintf>
c0107cc3:	83 c4 10             	add    $0x10,%esp
}
c0107cc6:	90                   	nop
c0107cc7:	c9                   	leave  
c0107cc8:	c3                   	ret    

c0107cc9 <do_int3>:


void do_int3(unsigned long addr, int err_code)
{
c0107cc9:	55                   	push   %ebp
c0107cca:	89 e5                	mov    %esp,%ebp
c0107ccc:	83 ec 08             	sub    $0x8,%esp
    kprintf("int3 addr = 0x%x,err code = %d\n", addr,err_code);
c0107ccf:	83 ec 04             	sub    $0x4,%esp
c0107cd2:	ff 75 0c             	push   0xc(%ebp)
c0107cd5:	ff 75 08             	push   0x8(%ebp)
c0107cd8:	68 64 c3 28 c0       	push   $0xc028c364
c0107cdd:	e8 ef 12 00 00       	call   c0108fd1 <kprintf>
c0107ce2:	83 c4 10             	add    $0x10,%esp
}
c0107ce5:	90                   	nop
c0107ce6:	c9                   	leave  
c0107ce7:	c3                   	ret    

c0107ce8 <do_nmi>:

void do_nmi(unsigned long addr, int err_code)
{
c0107ce8:	55                   	push   %ebp
c0107ce9:	89 e5                	mov    %esp,%ebp
c0107ceb:	83 ec 08             	sub    $0x8,%esp
	kprintf("nmi addr = 0x%x,err code = %d\n", addr,err_code);
c0107cee:	83 ec 04             	sub    $0x4,%esp
c0107cf1:	ff 75 0c             	push   0xc(%ebp)
c0107cf4:	ff 75 08             	push   0x8(%ebp)
c0107cf7:	68 84 c3 28 c0       	push   $0xc028c384
c0107cfc:	e8 d0 12 00 00       	call   c0108fd1 <kprintf>
c0107d01:	83 c4 10             	add    $0x10,%esp
}
c0107d04:	90                   	nop
c0107d05:	c9                   	leave  
c0107d06:	c3                   	ret    

c0107d07 <do_debug>:

void do_debug(unsigned long addr, int err_code)
{
c0107d07:	55                   	push   %ebp
c0107d08:	89 e5                	mov    %esp,%ebp
c0107d0a:	83 ec 08             	sub    $0x8,%esp
	kprintf("debug addr = 0x%x,err code = %d\n", addr,err_code);
c0107d0d:	83 ec 04             	sub    $0x4,%esp
c0107d10:	ff 75 0c             	push   0xc(%ebp)
c0107d13:	ff 75 08             	push   0x8(%ebp)
c0107d16:	68 a4 c3 28 c0       	push   $0xc028c3a4
c0107d1b:	e8 b1 12 00 00       	call   c0108fd1 <kprintf>
c0107d20:	83 c4 10             	add    $0x10,%esp
}
c0107d23:	90                   	nop
c0107d24:	c9                   	leave  
c0107d25:	c3                   	ret    

c0107d26 <do_overflow>:

void do_overflow(unsigned long addr, int err_code)
{
c0107d26:	55                   	push   %ebp
c0107d27:	89 e5                	mov    %esp,%ebp
c0107d29:	83 ec 08             	sub    $0x8,%esp
	kprintf("overflow addr = 0x%x,err code = %d\n", addr,err_code);
c0107d2c:	83 ec 04             	sub    $0x4,%esp
c0107d2f:	ff 75 0c             	push   0xc(%ebp)
c0107d32:	ff 75 08             	push   0x8(%ebp)
c0107d35:	68 c8 c3 28 c0       	push   $0xc028c3c8
c0107d3a:	e8 92 12 00 00       	call   c0108fd1 <kprintf>
c0107d3f:	83 c4 10             	add    $0x10,%esp
}
c0107d42:	90                   	nop
c0107d43:	c9                   	leave  
c0107d44:	c3                   	ret    

c0107d45 <do_bounds>:

void do_bounds(unsigned long addr, int err_code)
{
c0107d45:	55                   	push   %ebp
c0107d46:	89 e5                	mov    %esp,%ebp
c0107d48:	83 ec 08             	sub    $0x8,%esp
	kprintf("bounds addr = 0x%x,err code = %d\n", addr,err_code);
c0107d4b:	83 ec 04             	sub    $0x4,%esp
c0107d4e:	ff 75 0c             	push   0xc(%ebp)
c0107d51:	ff 75 08             	push   0x8(%ebp)
c0107d54:	68 ec c3 28 c0       	push   $0xc028c3ec
c0107d59:	e8 73 12 00 00       	call   c0108fd1 <kprintf>
c0107d5e:	83 c4 10             	add    $0x10,%esp
}
c0107d61:	90                   	nop
c0107d62:	c9                   	leave  
c0107d63:	c3                   	ret    

c0107d64 <do_invalid_op>:

void do_invalid_op(unsigned long addr, int err_code)
{
c0107d64:	55                   	push   %ebp
c0107d65:	89 e5                	mov    %esp,%ebp
c0107d67:	83 ec 08             	sub    $0x8,%esp
	kprintf("invalid_op addr = 0x%x,err code = %d\n", addr,err_code);
c0107d6a:	83 ec 04             	sub    $0x4,%esp
c0107d6d:	ff 75 0c             	push   0xc(%ebp)
c0107d70:	ff 75 08             	push   0x8(%ebp)
c0107d73:	68 10 c4 28 c0       	push   $0xc028c410
c0107d78:	e8 54 12 00 00       	call   c0108fd1 <kprintf>
c0107d7d:	83 c4 10             	add    $0x10,%esp
}
c0107d80:	90                   	nop
c0107d81:	c9                   	leave  
c0107d82:	c3                   	ret    

c0107d83 <do_device_not_available>:

void do_device_not_available(unsigned long addr, int err_code)
{
c0107d83:	55                   	push   %ebp
c0107d84:	89 e5                	mov    %esp,%ebp
c0107d86:	83 ec 08             	sub    $0x8,%esp
	kprintf("device_not_availabel addr = 0x%x,err code = %d\n", addr,err_code);
c0107d89:	83 ec 04             	sub    $0x4,%esp
c0107d8c:	ff 75 0c             	push   0xc(%ebp)
c0107d8f:	ff 75 08             	push   0x8(%ebp)
c0107d92:	68 38 c4 28 c0       	push   $0xc028c438
c0107d97:	e8 35 12 00 00       	call   c0108fd1 <kprintf>
c0107d9c:	83 c4 10             	add    $0x10,%esp
}
c0107d9f:	90                   	nop
c0107da0:	c9                   	leave  
c0107da1:	c3                   	ret    

c0107da2 <do_coprocessor_segment_overrun>:

void do_coprocessor_segment_overrun(unsigned long addr, int err_code)
{
c0107da2:	55                   	push   %ebp
c0107da3:	89 e5                	mov    %esp,%ebp
c0107da5:	83 ec 08             	sub    $0x8,%esp
	kprintf("coprprocessor_segment_overrun addr = 0x%x,err code = %d\n", addr,err_code);
c0107da8:	83 ec 04             	sub    $0x4,%esp
c0107dab:	ff 75 0c             	push   0xc(%ebp)
c0107dae:	ff 75 08             	push   0x8(%ebp)
c0107db1:	68 68 c4 28 c0       	push   $0xc028c468
c0107db6:	e8 16 12 00 00       	call   c0108fd1 <kprintf>
c0107dbb:	83 c4 10             	add    $0x10,%esp
}
c0107dbe:	90                   	nop
c0107dbf:	c9                   	leave  
c0107dc0:	c3                   	ret    

c0107dc1 <do_invalid_TSS>:

void do_invalid_TSS(unsigned long addr, int err_code)
{
c0107dc1:	55                   	push   %ebp
c0107dc2:	89 e5                	mov    %esp,%ebp
c0107dc4:	83 ec 08             	sub    $0x8,%esp
	kprintf("invalid_TSS addr = 0x%x,err code = %d\n", addr,err_code);
c0107dc7:	83 ec 04             	sub    $0x4,%esp
c0107dca:	ff 75 0c             	push   0xc(%ebp)
c0107dcd:	ff 75 08             	push   0x8(%ebp)
c0107dd0:	68 a4 c4 28 c0       	push   $0xc028c4a4
c0107dd5:	e8 f7 11 00 00       	call   c0108fd1 <kprintf>
c0107dda:	83 c4 10             	add    $0x10,%esp
}
c0107ddd:	90                   	nop
c0107dde:	c9                   	leave  
c0107ddf:	c3                   	ret    

c0107de0 <do_segment_not_present>:

void do_segment_not_present(unsigned long addr, int err_code)
{
c0107de0:	55                   	push   %ebp
c0107de1:	89 e5                	mov    %esp,%ebp
c0107de3:	83 ec 08             	sub    $0x8,%esp
	kprintf("segment not present addr = 0x%x,err code = %d\n", addr,err_code);
c0107de6:	83 ec 04             	sub    $0x4,%esp
c0107de9:	ff 75 0c             	push   0xc(%ebp)
c0107dec:	ff 75 08             	push   0x8(%ebp)
c0107def:	68 cc c4 28 c0       	push   $0xc028c4cc
c0107df4:	e8 d8 11 00 00       	call   c0108fd1 <kprintf>
c0107df9:	83 c4 10             	add    $0x10,%esp
}
c0107dfc:	90                   	nop
c0107dfd:	c9                   	leave  
c0107dfe:	c3                   	ret    

c0107dff <do_stack_segment>:

void do_stack_segment(unsigned long addr, int err_code)
{
c0107dff:	55                   	push   %ebp
c0107e00:	89 e5                	mov    %esp,%ebp
c0107e02:	83 ec 08             	sub    $0x8,%esp
	kprintf("stack_segment addr = 0x%x,err code = %d\n", addr,err_code);
c0107e05:	83 ec 04             	sub    $0x4,%esp
c0107e08:	ff 75 0c             	push   0xc(%ebp)
c0107e0b:	ff 75 08             	push   0x8(%ebp)
c0107e0e:	68 fc c4 28 c0       	push   $0xc028c4fc
c0107e13:	e8 b9 11 00 00       	call   c0108fd1 <kprintf>
c0107e18:	83 c4 10             	add    $0x10,%esp
}
c0107e1b:	90                   	nop
c0107e1c:	c9                   	leave  
c0107e1d:	c3                   	ret    

c0107e1e <do_coprocessor_error>:

void do_coprocessor_error(unsigned long addr, int err_code)
{
c0107e1e:	55                   	push   %ebp
c0107e1f:	89 e5                	mov    %esp,%ebp
c0107e21:	83 ec 08             	sub    $0x8,%esp
    kprintf("coprocessor_err addr = 0x%x,err code = %d\n", addr,err_code);
c0107e24:	83 ec 04             	sub    $0x4,%esp
c0107e27:	ff 75 0c             	push   0xc(%ebp)
c0107e2a:	ff 75 08             	push   0x8(%ebp)
c0107e2d:	68 28 c5 28 c0       	push   $0xc028c528
c0107e32:	e8 9a 11 00 00       	call   c0108fd1 <kprintf>
c0107e37:	83 c4 10             	add    $0x10,%esp
}
c0107e3a:	90                   	nop
c0107e3b:	c9                   	leave  
c0107e3c:	c3                   	ret    

c0107e3d <do_reserved>:

void do_reserved(unsigned long addr, int err_code)
{
c0107e3d:	55                   	push   %ebp
c0107e3e:	89 e5                	mov    %esp,%ebp
c0107e40:	83 ec 08             	sub    $0x8,%esp
	kprintf("reserved addr = 0x%x,err code = %d\n", addr,err_code);
c0107e43:	83 ec 04             	sub    $0x4,%esp
c0107e46:	ff 75 0c             	push   0xc(%ebp)
c0107e49:	ff 75 08             	push   0x8(%ebp)
c0107e4c:	68 54 c5 28 c0       	push   $0xc028c554
c0107e51:	e8 7b 11 00 00       	call   c0108fd1 <kprintf>
c0107e56:	83 c4 10             	add    $0x10,%esp
}
c0107e59:	90                   	nop
c0107e5a:	c9                   	leave  
c0107e5b:	c3                   	ret    

c0107e5c <_no_err_code>:
c0107e5c:	87 04 24             	xchg   %eax,(%esp)
c0107e5f:	53                   	push   %ebx
c0107e60:	51                   	push   %ecx
c0107e61:	52                   	push   %edx
c0107e62:	57                   	push   %edi
c0107e63:	56                   	push   %esi
c0107e64:	55                   	push   %ebp
c0107e65:	1e                   	push   %ds
c0107e66:	06                   	push   %es
c0107e67:	0f a0                	push   %fs
c0107e69:	6a 00                	push   $0x0
c0107e6b:	8d 54 24 2c          	lea    0x2c(%esp),%edx
c0107e6f:	52                   	push   %edx
c0107e70:	ba 10 00 00 00       	mov    $0x10,%edx
c0107e75:	8e da                	mov    %edx,%ds
c0107e77:	8e c2                	mov    %edx,%es
c0107e79:	8e e2                	mov    %edx,%fs
c0107e7b:	ff d0                	call   *%eax
c0107e7d:	83 c4 08             	add    $0x8,%esp
c0107e80:	0f a1                	pop    %fs
c0107e82:	07                   	pop    %es
c0107e83:	1f                   	pop    %ds
c0107e84:	5d                   	pop    %ebp
c0107e85:	5e                   	pop    %esi
c0107e86:	5f                   	pop    %edi
c0107e87:	5a                   	pop    %edx
c0107e88:	59                   	pop    %ecx
c0107e89:	5b                   	pop    %ebx
c0107e8a:	58                   	pop    %eax
c0107e8b:	cf                   	iret   

c0107e8c <_err_code>:
c0107e8c:	87 44 24 04          	xchg   %eax,0x4(%esp)
c0107e90:	87 1c 24             	xchg   %ebx,(%esp)
c0107e93:	51                   	push   %ecx
c0107e94:	52                   	push   %edx
c0107e95:	57                   	push   %edi
c0107e96:	56                   	push   %esi
c0107e97:	55                   	push   %ebp
c0107e98:	1e                   	push   %ds
c0107e99:	06                   	push   %es
c0107e9a:	0f a0                	push   %fs
c0107e9c:	50                   	push   %eax
c0107e9d:	8d 44 24 2c          	lea    0x2c(%esp),%eax
c0107ea1:	50                   	push   %eax
c0107ea2:	b8 10 00 00 00       	mov    $0x10,%eax
c0107ea7:	8e d8                	mov    %eax,%ds
c0107ea9:	8e c0                	mov    %eax,%es
c0107eab:	8e e0                	mov    %eax,%fs
c0107ead:	ff d3                	call   *%ebx
c0107eaf:	83 c4 08             	add    $0x8,%esp
c0107eb2:	0f a1                	pop    %fs
c0107eb4:	07                   	pop    %es
c0107eb5:	1f                   	pop    %ds
c0107eb6:	5d                   	pop    %ebp
c0107eb7:	5e                   	pop    %esi
c0107eb8:	5f                   	pop    %edi
c0107eb9:	5a                   	pop    %edx
c0107eba:	59                   	pop    %ecx
c0107ebb:	5b                   	pop    %ebx
c0107ebc:	58                   	pop    %eax
c0107ebd:	cf                   	iret   

c0107ebe <divide_error>:
c0107ebe:	68 5b 7c 10 c0       	push   $0xc0107c5b
c0107ec3:	eb 97                	jmp    c0107e5c <_no_err_code>

c0107ec5 <debug>:
c0107ec5:	68 c9 7c 10 c0       	push   $0xc0107cc9
c0107eca:	eb 90                	jmp    c0107e5c <_no_err_code>

c0107ecc <nmi>:
c0107ecc:	68 e8 7c 10 c0       	push   $0xc0107ce8
c0107ed1:	eb 89                	jmp    c0107e5c <_no_err_code>

c0107ed3 <int3>:
c0107ed3:	68 c9 7c 10 c0       	push   $0xc0107cc9
c0107ed8:	eb 82                	jmp    c0107e5c <_no_err_code>

c0107eda <overflow>:
c0107eda:	68 26 7d 10 c0       	push   $0xc0107d26
c0107edf:	e9 78 ff ff ff       	jmp    c0107e5c <_no_err_code>

c0107ee4 <bounds>:
c0107ee4:	68 45 7d 10 c0       	push   $0xc0107d45
c0107ee9:	e9 6e ff ff ff       	jmp    c0107e5c <_no_err_code>

c0107eee <invalid_op>:
c0107eee:	68 64 7d 10 c0       	push   $0xc0107d64
c0107ef3:	e9 64 ff ff ff       	jmp    c0107e5c <_no_err_code>

c0107ef8 <coprocessor_segment_overrun>:
c0107ef8:	68 a2 7d 10 c0       	push   $0xc0107da2
c0107efd:	e9 5a ff ff ff       	jmp    c0107e5c <_no_err_code>

c0107f02 <reserved>:
c0107f02:	68 3d 7e 10 c0       	push   $0xc0107e3d
c0107f07:	e9 50 ff ff ff       	jmp    c0107e5c <_no_err_code>

c0107f0c <invalid_TSS>:
c0107f0c:	68 c1 7d 10 c0       	push   $0xc0107dc1
c0107f11:	e9 76 ff ff ff       	jmp    c0107e8c <_err_code>

c0107f16 <segment_not_present>:
c0107f16:	68 e0 7d 10 c0       	push   $0xc0107de0
c0107f1b:	e9 6c ff ff ff       	jmp    c0107e8c <_err_code>

c0107f20 <stack_segment>:
c0107f20:	68 ff 7d 10 c0       	push   $0xc0107dff
c0107f25:	e9 62 ff ff ff       	jmp    c0107e8c <_err_code>

c0107f2a <general_protection>:
c0107f2a:	68 aa 7c 10 c0       	push   $0xc0107caa
c0107f2f:	e9 58 ff ff ff       	jmp    c0107e8c <_err_code>

c0107f34 <__get_cpuid_max>:
   pointer is non-null, then first four bytes of the signature
   (as found in ebx register) are returned in location pointed by sig.  */

static __inline unsigned int
__get_cpuid_max (unsigned int __ext, unsigned int *__sig)
{
c0107f34:	55                   	push   %ebp
c0107f35:	89 e5                	mov    %esp,%ebp
c0107f37:	53                   	push   %ebx
c0107f38:	83 ec 10             	sub    $0x10,%esp
  unsigned int __eax, __ebx, __ecx, __edx;

#ifndef __x86_64__
  /* See if we can use cpuid.  On AMD64 we always can.  */
#if __GNUC__ >= 3
  __asm__ ("pushf{l|d}\n\t"
c0107f3b:	9c                   	pushf  
c0107f3c:	9c                   	pushf  
c0107f3d:	5a                   	pop    %edx
c0107f3e:	89 d0                	mov    %edx,%eax
c0107f40:	81 f2 00 00 20 00    	xor    $0x200000,%edx
c0107f46:	52                   	push   %edx
c0107f47:	9d                   	popf   
c0107f48:	9c                   	pushf  
c0107f49:	5a                   	pop    %edx
c0107f4a:	9d                   	popf   
c0107f4b:	89 55 f8             	mov    %edx,-0x8(%ebp)
c0107f4e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	   "popfl\n\t"
	   : "=&r" (__eax), "=&r" (__ebx)
	   : "i" (0x00200000));
#endif

  if (!((__eax ^ __ebx) & 0x00200000))
c0107f51:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0107f54:	33 45 f4             	xor    -0xc(%ebp),%eax
c0107f57:	25 00 00 20 00       	and    $0x200000,%eax
c0107f5c:	85 c0                	test   %eax,%eax
c0107f5e:	75 07                	jne    c0107f67 <__get_cpuid_max+0x33>
    return 0;
c0107f60:	b8 00 00 00 00       	mov    $0x0,%eax
c0107f65:	eb 30                	jmp    c0107f97 <__get_cpuid_max+0x63>
#endif

  /* Host supports cpuid.  Return highest supported cpuid input value.  */
  __cpuid (__ext, __eax, __ebx, __ecx, __edx);
c0107f67:	8b 45 08             	mov    0x8(%ebp),%eax
c0107f6a:	b9 00 00 00 00       	mov    $0x0,%ecx
c0107f6f:	ba 00 00 00 00       	mov    $0x0,%edx
c0107f74:	89 cb                	mov    %ecx,%ebx
c0107f76:	89 d1                	mov    %edx,%ecx
c0107f78:	0f a2                	cpuid  
c0107f7a:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0107f7d:	89 5d f4             	mov    %ebx,-0xc(%ebp)
c0107f80:	89 4d f0             	mov    %ecx,-0x10(%ebp)
c0107f83:	89 55 ec             	mov    %edx,-0x14(%ebp)

  if (__sig)
c0107f86:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0107f8a:	74 08                	je     c0107f94 <__get_cpuid_max+0x60>
    *__sig = __ebx;
c0107f8c:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107f8f:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0107f92:	89 10                	mov    %edx,(%eax)

  return __eax;
c0107f94:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
c0107f97:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0107f9a:	c9                   	leave  
c0107f9b:	c3                   	ret    

c0107f9c <__get_cpuid>:

static __inline int
__get_cpuid (unsigned int __leaf,
	     unsigned int *__eax, unsigned int *__ebx,
	     unsigned int *__ecx, unsigned int *__edx)
{
c0107f9c:	55                   	push   %ebp
c0107f9d:	89 e5                	mov    %esp,%ebp
c0107f9f:	56                   	push   %esi
c0107fa0:	53                   	push   %ebx
c0107fa1:	83 ec 10             	sub    $0x10,%esp
  unsigned int __ext = __leaf & 0x80000000;
c0107fa4:	8b 45 08             	mov    0x8(%ebp),%eax
c0107fa7:	25 00 00 00 80       	and    $0x80000000,%eax
c0107fac:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned int __maxlevel = __get_cpuid_max (__ext, 0);
c0107faf:	6a 00                	push   $0x0
c0107fb1:	ff 75 f4             	push   -0xc(%ebp)
c0107fb4:	e8 7b ff ff ff       	call   c0107f34 <__get_cpuid_max>
c0107fb9:	83 c4 08             	add    $0x8,%esp
c0107fbc:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if (__maxlevel == 0 || __maxlevel < __leaf)
c0107fbf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0107fc3:	74 08                	je     c0107fcd <__get_cpuid+0x31>
c0107fc5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107fc8:	3b 45 08             	cmp    0x8(%ebp),%eax
c0107fcb:	73 07                	jae    c0107fd4 <__get_cpuid+0x38>
    return 0;
c0107fcd:	b8 00 00 00 00       	mov    $0x0,%eax
c0107fd2:	eb 2c                	jmp    c0108000 <__get_cpuid+0x64>

  __cpuid (__leaf, *__eax, *__ebx, *__ecx, *__edx);
c0107fd4:	8b 45 08             	mov    0x8(%ebp),%eax
c0107fd7:	b9 00 00 00 00       	mov    $0x0,%ecx
c0107fdc:	ba 00 00 00 00       	mov    $0x0,%edx
c0107fe1:	89 cb                	mov    %ecx,%ebx
c0107fe3:	89 d1                	mov    %edx,%ecx
c0107fe5:	0f a2                	cpuid  
c0107fe7:	8b 75 0c             	mov    0xc(%ebp),%esi
c0107fea:	89 06                	mov    %eax,(%esi)
c0107fec:	8b 45 10             	mov    0x10(%ebp),%eax
c0107fef:	89 18                	mov    %ebx,(%eax)
c0107ff1:	8b 45 14             	mov    0x14(%ebp),%eax
c0107ff4:	89 08                	mov    %ecx,(%eax)
c0107ff6:	8b 45 18             	mov    0x18(%ebp),%eax
c0107ff9:	89 10                	mov    %edx,(%eax)
  return 1;
c0107ffb:	b8 01 00 00 00       	mov    $0x1,%eax
}
c0108000:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0108003:	5b                   	pop    %ebx
c0108004:	5e                   	pop    %esi
c0108005:	5d                   	pop    %ebp
c0108006:	c3                   	ret    

c0108007 <cpu_get_model>:
#include <kernel/cpu/cpu.h>
#include <stdint.h>
#include <cpuid.h>

void cpu_get_model(char* model_out) {
c0108007:	55                   	push   %ebp
c0108008:	89 e5                	mov    %esp,%ebp
c010800a:	83 ec 20             	sub    $0x20,%esp
    uint32_t* out = (uint32_t*)model_out;
c010800d:	8b 45 08             	mov    0x8(%ebp),%eax
c0108010:	89 45 fc             	mov    %eax,-0x4(%ebp)
    reg32 eax, ebx, edx, ecx;
    
    __get_cpuid(0, &eax, &ebx, &ecx, &edx);
c0108013:	8d 45 f0             	lea    -0x10(%ebp),%eax
c0108016:	50                   	push   %eax
c0108017:	8d 45 ec             	lea    -0x14(%ebp),%eax
c010801a:	50                   	push   %eax
c010801b:	8d 45 f4             	lea    -0xc(%ebp),%eax
c010801e:	50                   	push   %eax
c010801f:	8d 45 f8             	lea    -0x8(%ebp),%eax
c0108022:	50                   	push   %eax
c0108023:	6a 00                	push   $0x0
c0108025:	e8 72 ff ff ff       	call   c0107f9c <__get_cpuid>
c010802a:	83 c4 14             	add    $0x14,%esp

    out[0] = ebx;
c010802d:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0108030:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0108033:	89 10                	mov    %edx,(%eax)
    out[1] = edx;
c0108035:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0108038:	8d 50 04             	lea    0x4(%eax),%edx
c010803b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010803e:	89 02                	mov    %eax,(%edx)
    out[2] = ecx;
c0108040:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0108043:	8d 50 08             	lea    0x8(%eax),%edx
c0108046:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0108049:	89 02                	mov    %eax,(%edx)
    model_out[12] = '\0';
c010804b:	8b 45 08             	mov    0x8(%ebp),%eax
c010804e:	83 c0 0c             	add    $0xc,%eax
c0108051:	c6 00 00             	movb   $0x0,(%eax)
}
c0108054:	90                   	nop
c0108055:	c9                   	leave  
c0108056:	c3                   	ret    

c0108057 <cpu_brand_string_supported>:

#define BRAND_LEAF 0x80000000UL

int cpu_brand_string_supported() {
c0108057:	55                   	push   %ebp
c0108058:	89 e5                	mov    %esp,%ebp
c010805a:	83 ec 10             	sub    $0x10,%esp
    reg32 supported = __get_cpuid_max(BRAND_LEAF, 0);
c010805d:	6a 00                	push   $0x0
c010805f:	68 00 00 00 80       	push   $0x80000000
c0108064:	e8 cb fe ff ff       	call   c0107f34 <__get_cpuid_max>
c0108069:	83 c4 08             	add    $0x8,%esp
c010806c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return (supported >= 0x80000004UL);
c010806f:	81 7d fc 03 00 00 80 	cmpl   $0x80000003,-0x4(%ebp)
c0108076:	0f 97 c0             	seta   %al
c0108079:	0f b6 c0             	movzbl %al,%eax
}
c010807c:	c9                   	leave  
c010807d:	c3                   	ret    

c010807e <cpu_get_brand>:

void cpu_get_brand(char* brand_out) {
c010807e:	55                   	push   %ebp
c010807f:	89 e5                	mov    %esp,%ebp
c0108081:	83 ec 20             	sub    $0x20,%esp
    if(!cpu_brand_string_supported()) {
c0108084:	e8 ce ff ff ff       	call   c0108057 <cpu_brand_string_supported>
c0108089:	85 c0                	test   %eax,%eax
c010808b:	75 0f                	jne    c010809c <cpu_get_brand+0x1e>
        brand_out[0] = '?';
c010808d:	8b 45 08             	mov    0x8(%ebp),%eax
c0108090:	c6 00 3f             	movb   $0x3f,(%eax)
        brand_out[1] = '\0';
c0108093:	8b 45 08             	mov    0x8(%ebp),%eax
c0108096:	83 c0 01             	add    $0x1,%eax
c0108099:	c6 00 00             	movb   $0x0,(%eax)
    }
    uint32_t* out = (uint32_t*) brand_out;
c010809c:	8b 45 08             	mov    0x8(%ebp),%eax
c010809f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    reg32 eax, ebx, edx, ecx;
    for (uint32_t i = 2, j = 0; i < 5; i++)
c01080a2:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
c01080a9:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c01080b0:	e9 83 00 00 00       	jmp    c0108138 <cpu_get_brand+0xba>
    {
        __get_cpuid(BRAND_LEAF + i, &eax, &ebx, &ecx, &edx);
c01080b5:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01080b8:	8d 90 00 00 00 80    	lea    -0x80000000(%eax),%edx
c01080be:	8d 45 e8             	lea    -0x18(%ebp),%eax
c01080c1:	50                   	push   %eax
c01080c2:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c01080c5:	50                   	push   %eax
c01080c6:	8d 45 ec             	lea    -0x14(%ebp),%eax
c01080c9:	50                   	push   %eax
c01080ca:	8d 45 f0             	lea    -0x10(%ebp),%eax
c01080cd:	50                   	push   %eax
c01080ce:	52                   	push   %edx
c01080cf:	e8 c8 fe ff ff       	call   c0107f9c <__get_cpuid>
c01080d4:	83 c4 14             	add    $0x14,%esp
        out[j] = eax;
c01080d7:	8b 45 f8             	mov    -0x8(%ebp),%eax
c01080da:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c01080e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01080e4:	01 c2                	add    %eax,%edx
c01080e6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01080e9:	89 02                	mov    %eax,(%edx)
        out[j + 1] = ebx;
c01080eb:	8b 45 f8             	mov    -0x8(%ebp),%eax
c01080ee:	83 c0 01             	add    $0x1,%eax
c01080f1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c01080f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01080fb:	01 c2                	add    %eax,%edx
c01080fd:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0108100:	89 02                	mov    %eax,(%edx)
        out[j + 2] = ecx;
c0108102:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0108105:	83 c0 02             	add    $0x2,%eax
c0108108:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010810f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108112:	01 c2                	add    %eax,%edx
c0108114:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0108117:	89 02                	mov    %eax,(%edx)
        out[j + 3] = edx;
c0108119:	8b 45 f8             	mov    -0x8(%ebp),%eax
c010811c:	83 c0 03             	add    $0x3,%eax
c010811f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0108126:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108129:	01 c2                	add    %eax,%edx
c010812b:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010812e:	89 02                	mov    %eax,(%edx)
        j+=4;
c0108130:	83 45 f8 04          	addl   $0x4,-0x8(%ebp)
    for (uint32_t i = 2, j = 0; i < 5; i++)
c0108134:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0108138:	83 7d fc 04          	cmpl   $0x4,-0x4(%ebp)
c010813c:	0f 86 73 ff ff ff    	jbe    c01080b5 <cpu_get_brand+0x37>
    }
    brand_out[48] = '\0';
c0108142:	8b 45 08             	mov    0x8(%ebp),%eax
c0108145:	83 c0 30             	add    $0x30,%eax
c0108148:	c6 00 00             	movb   $0x0,(%eax)
}
c010814b:	90                   	nop
c010814c:	c9                   	leave  
c010814d:	c3                   	ret    

c010814e <cpu_r_cr0>:

reg32 cpu_r_cr0() {
c010814e:	55                   	push   %ebp
c010814f:	89 e5                	mov    %esp,%ebp
    asm volatile ("mov %cr0, %eax");
c0108151:	0f 20 c0             	mov    %cr0,%eax
}
c0108154:	90                   	nop
c0108155:	5d                   	pop    %ebp
c0108156:	c3                   	ret    

c0108157 <cpu_r_cr2>:

reg32 cpu_r_cr2() {
c0108157:	55                   	push   %ebp
c0108158:	89 e5                	mov    %esp,%ebp
    asm volatile ("mov %cr2, %eax");
c010815a:	0f 20 d0             	mov    %cr2,%eax
}
c010815d:	90                   	nop
c010815e:	5d                   	pop    %ebp
c010815f:	c3                   	ret    

c0108160 <cpu_r_cr3>:

reg32 cpu_r_cr3() {
c0108160:	55                   	push   %ebp
c0108161:	89 e5                	mov    %esp,%ebp
    asm volatile ("mov %cr3, %eax");
c0108163:	0f 20 d8             	mov    %cr3,%eax
}
c0108166:	90                   	nop
c0108167:	5d                   	pop    %ebp
c0108168:	c3                   	ret    

c0108169 <cpu_w_cr0>:

void cpu_w_cr0(reg32 v) {
c0108169:	55                   	push   %ebp
c010816a:	89 e5                	mov    %esp,%ebp
    asm volatile (
c010816c:	8b 45 08             	mov    0x8(%ebp),%eax
c010816f:	0f 22 c0             	mov    %eax,%cr0
        "mov %0, %%cr0"
        :: "r"(v)
    );
}
c0108172:	90                   	nop
c0108173:	5d                   	pop    %ebp
c0108174:	c3                   	ret    

c0108175 <cpu_w_cr2>:

void cpu_w_cr2(reg32 v) {
c0108175:	55                   	push   %ebp
c0108176:	89 e5                	mov    %esp,%ebp
    asm volatile (
c0108178:	8b 45 08             	mov    0x8(%ebp),%eax
c010817b:	0f 22 d0             	mov    %eax,%cr2
        "mov %0, %%cr2"
        :: "r"(v)
    );
}
c010817e:	90                   	nop
c010817f:	5d                   	pop    %ebp
c0108180:	c3                   	ret    

c0108181 <cpu_w_cr3>:

void cpu_w_cr3(reg32 v) {
c0108181:	55                   	push   %ebp
c0108182:	89 e5                	mov    %esp,%ebp
    asm volatile (
c0108184:	8b 45 08             	mov    0x8(%ebp),%eax
c0108187:	0f 22 d8             	mov    %eax,%cr3
        "mov %0, %%cr3"
        :: "r"(v)
    );
}
c010818a:	90                   	nop
c010818b:	5d                   	pop    %ebp
c010818c:	c3                   	ret    

c010818d <_set_gdt_entry>:
#define GDT_ENTRY 5

uint64_t _gdt[5];
uint16_t _gdt_limit = sizeof(_gdt) - 1;

void _set_gdt_entry(uint32_t index, uint32_t base, uint32_t limit, uint32_t flags) {
c010818d:	55                   	push   %ebp
c010818e:	89 e5                	mov    %esp,%ebp
c0108190:	57                   	push   %edi
c0108191:	56                   	push   %esi
c0108192:	53                   	push   %ebx
c0108193:	83 ec 0c             	sub    $0xc,%esp
    _gdt[index] = SEG_BASE_H(base) | flags | SEG_LIM_H(limit) | SEG_BASE_M(base);
c0108196:	8b 45 0c             	mov    0xc(%ebp),%eax
c0108199:	25 00 00 00 ff       	and    $0xff000000,%eax
c010819e:	0b 45 14             	or     0x14(%ebp),%eax
c01081a1:	89 c2                	mov    %eax,%edx
c01081a3:	8b 45 10             	mov    0x10(%ebp),%eax
c01081a6:	25 00 00 0f 00       	and    $0xf0000,%eax
c01081ab:	09 c2                	or     %eax,%edx
c01081ad:	8b 45 0c             	mov    0xc(%ebp),%eax
c01081b0:	c1 e8 10             	shr    $0x10,%eax
c01081b3:	0f b6 c0             	movzbl %al,%eax
c01081b6:	09 d0                	or     %edx,%eax
c01081b8:	ba 00 00 00 00       	mov    $0x0,%edx
c01081bd:	8b 75 08             	mov    0x8(%ebp),%esi
c01081c0:	89 04 f5 60 a0 28 c0 	mov    %eax,-0x3fd75fa0(,%esi,8)
c01081c7:	89 14 f5 64 a0 28 c0 	mov    %edx,-0x3fd75f9c(,%esi,8)
    _gdt[index] <<= 32;
c01081ce:	8b 45 08             	mov    0x8(%ebp),%eax
c01081d1:	8b 14 c5 64 a0 28 c0 	mov    -0x3fd75f9c(,%eax,8),%edx
c01081d8:	8b 04 c5 60 a0 28 c0 	mov    -0x3fd75fa0(,%eax,8),%eax
c01081df:	89 c2                	mov    %eax,%edx
c01081e1:	b8 00 00 00 00       	mov    $0x0,%eax
c01081e6:	8b 75 08             	mov    0x8(%ebp),%esi
c01081e9:	89 04 f5 60 a0 28 c0 	mov    %eax,-0x3fd75fa0(,%esi,8)
c01081f0:	89 14 f5 64 a0 28 c0 	mov    %edx,-0x3fd75f9c(,%esi,8)
    _gdt[index] |= SEG_BASE_L(base) | SEG_LIM_L(limit);
c01081f7:	8b 45 08             	mov    0x8(%ebp),%eax
c01081fa:	8b 14 c5 64 a0 28 c0 	mov    -0x3fd75f9c(,%eax,8),%edx
c0108201:	8b 04 c5 60 a0 28 c0 	mov    -0x3fd75fa0(,%eax,8),%eax
c0108208:	8b 75 0c             	mov    0xc(%ebp),%esi
c010820b:	89 f7                	mov    %esi,%edi
c010820d:	c1 e7 10             	shl    $0x10,%edi
c0108210:	8b 75 10             	mov    0x10(%ebp),%esi
c0108213:	0f b7 f6             	movzwl %si,%esi
c0108216:	09 fe                	or     %edi,%esi
c0108218:	bf 00 00 00 00       	mov    $0x0,%edi
c010821d:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0108220:	89 55 ec             	mov    %edx,-0x14(%ebp)
c0108223:	09 f0                	or     %esi,%eax
c0108225:	89 c1                	mov    %eax,%ecx
c0108227:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010822a:	09 f8                	or     %edi,%eax
c010822c:	89 c3                	mov    %eax,%ebx
c010822e:	8b 45 08             	mov    0x8(%ebp),%eax
c0108231:	89 0c c5 60 a0 28 c0 	mov    %ecx,-0x3fd75fa0(,%eax,8)
c0108238:	89 1c c5 64 a0 28 c0 	mov    %ebx,-0x3fd75f9c(,%eax,8)
}
c010823f:	90                   	nop
c0108240:	83 c4 0c             	add    $0xc,%esp
c0108243:	5b                   	pop    %ebx
c0108244:	5e                   	pop    %esi
c0108245:	5f                   	pop    %edi
c0108246:	5d                   	pop    %ebp
c0108247:	c3                   	ret    

c0108248 <_init_gdt>:
// 
void
_init_gdt() {
c0108248:	55                   	push   %ebp
c0108249:	89 e5                	mov    %esp,%ebp
    _set_gdt_entry(0, 0, 0, 0);
c010824b:	6a 00                	push   $0x0
c010824d:	6a 00                	push   $0x0
c010824f:	6a 00                	push   $0x0
c0108251:	6a 00                	push   $0x0
c0108253:	e8 35 ff ff ff       	call   c010818d <_set_gdt_entry>
c0108258:	83 c4 10             	add    $0x10,%esp
    _set_gdt_entry(1, 0, 0xfffff, SEG_R0_CODE);
c010825b:	68 00 9a c0 00       	push   $0xc09a00
c0108260:	68 ff ff 0f 00       	push   $0xfffff
c0108265:	6a 00                	push   $0x0
c0108267:	6a 01                	push   $0x1
c0108269:	e8 1f ff ff ff       	call   c010818d <_set_gdt_entry>
c010826e:	83 c4 10             	add    $0x10,%esp
    _set_gdt_entry(2, 0, 0xfffff, SEG_R0_DATA);
c0108271:	68 00 92 c0 00       	push   $0xc09200
c0108276:	68 ff ff 0f 00       	push   $0xfffff
c010827b:	6a 00                	push   $0x0
c010827d:	6a 02                	push   $0x2
c010827f:	e8 09 ff ff ff       	call   c010818d <_set_gdt_entry>
c0108284:	83 c4 10             	add    $0x10,%esp
    _set_gdt_entry(3, 0, 0xfffff, SEG_R3_CODE);
c0108287:	68 00 fa c0 00       	push   $0xc0fa00
c010828c:	68 ff ff 0f 00       	push   $0xfffff
c0108291:	6a 00                	push   $0x0
c0108293:	6a 03                	push   $0x3
c0108295:	e8 f3 fe ff ff       	call   c010818d <_set_gdt_entry>
c010829a:	83 c4 10             	add    $0x10,%esp
    _set_gdt_entry(4, 0, 0xfffff, SEG_R3_DATA);
c010829d:	68 00 f2 c0 00       	push   $0xc0f200
c01082a2:	68 ff ff 0f 00       	push   $0xfffff
c01082a7:	6a 00                	push   $0x0
c01082a9:	6a 04                	push   $0x4
c01082ab:	e8 dd fe ff ff       	call   c010818d <_set_gdt_entry>
c01082b0:	83 c4 10             	add    $0x10,%esp
c01082b3:	90                   	nop
c01082b4:	c9                   	leave  
c01082b5:	c3                   	ret    

c01082b6 <_set_idt_entry>:
#define IDT_ENTRY 80

uint64_t _idt[IDT_ENTRY];
uint16_t _idt_limit = sizeof(_idt) - 1;

void _set_idt_entry(uint32_t vector, uint16_t seg_selector, void (*isr)(), uint8_t dpl) {
c01082b6:	55                   	push   %ebp
c01082b7:	89 e5                	mov    %esp,%ebp
c01082b9:	57                   	push   %edi
c01082ba:	56                   	push   %esi
c01082bb:	53                   	push   %ebx
c01082bc:	83 ec 24             	sub    $0x24,%esp
c01082bf:	8b 45 0c             	mov    0xc(%ebp),%eax
c01082c2:	8b 55 14             	mov    0x14(%ebp),%edx
c01082c5:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
c01082c9:	89 d0                	mov    %edx,%eax
c01082cb:	88 45 d8             	mov    %al,-0x28(%ebp)
    uintptr_t offset = (uintptr_t)isr;
c01082ce:	8b 45 10             	mov    0x10(%ebp),%eax
c01082d1:	89 45 ec             	mov    %eax,-0x14(%ebp)
    _idt[vector] = (offset & 0xffff0000) | IDT_ATTR(dpl);
c01082d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01082d7:	66 b8 00 00          	mov    $0x0,%ax
c01082db:	89 c2                	mov    %eax,%edx
c01082dd:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
c01082e1:	c1 e0 0d             	shl    $0xd,%eax
c01082e4:	25 00 60 00 00       	and    $0x6000,%eax
c01082e9:	09 d0                	or     %edx,%eax
c01082eb:	80 cc 8e             	or     $0x8e,%ah
c01082ee:	ba 00 00 00 00       	mov    $0x0,%edx
c01082f3:	8b 75 08             	mov    0x8(%ebp),%esi
c01082f6:	89 04 f5 a0 a0 28 c0 	mov    %eax,-0x3fd75f60(,%esi,8)
c01082fd:	89 14 f5 a4 a0 28 c0 	mov    %edx,-0x3fd75f5c(,%esi,8)
    _idt[vector] <<= 32;
c0108304:	8b 45 08             	mov    0x8(%ebp),%eax
c0108307:	8b 14 c5 a4 a0 28 c0 	mov    -0x3fd75f5c(,%eax,8),%edx
c010830e:	8b 04 c5 a0 a0 28 c0 	mov    -0x3fd75f60(,%eax,8),%eax
c0108315:	89 c2                	mov    %eax,%edx
c0108317:	b8 00 00 00 00       	mov    $0x0,%eax
c010831c:	8b 75 08             	mov    0x8(%ebp),%esi
c010831f:	89 04 f5 a0 a0 28 c0 	mov    %eax,-0x3fd75f60(,%esi,8)
c0108326:	89 14 f5 a4 a0 28 c0 	mov    %edx,-0x3fd75f5c(,%esi,8)
    _idt[vector] |= (seg_selector << 16) | (offset & 0x0000ffff);
c010832d:	8b 45 08             	mov    0x8(%ebp),%eax
c0108330:	8b 14 c5 a4 a0 28 c0 	mov    -0x3fd75f5c(,%eax,8),%edx
c0108337:	8b 04 c5 a0 a0 28 c0 	mov    -0x3fd75f60(,%eax,8),%eax
c010833e:	0f b7 75 dc          	movzwl -0x24(%ebp),%esi
c0108342:	c1 e6 10             	shl    $0x10,%esi
c0108345:	89 f7                	mov    %esi,%edi
c0108347:	8b 75 ec             	mov    -0x14(%ebp),%esi
c010834a:	0f b7 f6             	movzwl %si,%esi
c010834d:	09 fe                	or     %edi,%esi
c010834f:	bf 00 00 00 00       	mov    $0x0,%edi
c0108354:	89 45 d0             	mov    %eax,-0x30(%ebp)
c0108357:	89 55 d4             	mov    %edx,-0x2c(%ebp)
c010835a:	09 f0                	or     %esi,%eax
c010835c:	89 c1                	mov    %eax,%ecx
c010835e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0108361:	09 f8                	or     %edi,%eax
c0108363:	89 c3                	mov    %eax,%ebx
c0108365:	8b 45 08             	mov    0x8(%ebp),%eax
c0108368:	89 0c c5 a0 a0 28 c0 	mov    %ecx,-0x3fd75f60(,%eax,8)
c010836f:	89 1c c5 a4 a0 28 c0 	mov    %ebx,-0x3fd75f5c(,%eax,8)
}
c0108376:	90                   	nop
c0108377:	83 c4 24             	add    $0x24,%esp
c010837a:	5b                   	pop    %ebx
c010837b:	5e                   	pop    %esi
c010837c:	5f                   	pop    %edi
c010837d:	5d                   	pop    %ebp
c010837e:	c3                   	ret    

c010837f <_init_idt>:

void _init_idt()
{
c010837f:	55                   	push   %ebp
c0108380:	89 e5                	mov    %esp,%ebp
c0108382:	83 ec 10             	sub    $0x10,%esp
    _set_idt_entry(FAULT_DIVISION_ERROR, 0x08, &divide_error, 0);
c0108385:	6a 00                	push   $0x0
c0108387:	68 be 7e 10 c0       	push   $0xc0107ebe
c010838c:	6a 08                	push   $0x8
c010838e:	6a 00                	push   $0x0
c0108390:	e8 21 ff ff ff       	call   c01082b6 <_set_idt_entry>
c0108395:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(FAULT_TRAP_DEBUG_EXCEPTION, 0x08, &debug, 0);
c0108398:	6a 00                	push   $0x0
c010839a:	68 c5 7e 10 c0       	push   $0xc0107ec5
c010839f:	6a 08                	push   $0x8
c01083a1:	6a 01                	push   $0x1
c01083a3:	e8 0e ff ff ff       	call   c01082b6 <_set_idt_entry>
c01083a8:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(INT_NMI, 0x08, &nmi, 0);
c01083ab:	6a 00                	push   $0x0
c01083ad:	68 cc 7e 10 c0       	push   $0xc0107ecc
c01083b2:	6a 08                	push   $0x8
c01083b4:	6a 02                	push   $0x2
c01083b6:	e8 fb fe ff ff       	call   c01082b6 <_set_idt_entry>
c01083bb:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(TRAP_BREAKPOINT, 0x08, &int3, 0);
c01083be:	6a 00                	push   $0x0
c01083c0:	68 d3 7e 10 c0       	push   $0xc0107ed3
c01083c5:	6a 08                	push   $0x8
c01083c7:	6a 03                	push   $0x3
c01083c9:	e8 e8 fe ff ff       	call   c01082b6 <_set_idt_entry>
c01083ce:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(TRAP_OVERFLOW, 0x08, &overflow, 0);
c01083d1:	6a 00                	push   $0x0
c01083d3:	68 da 7e 10 c0       	push   $0xc0107eda
c01083d8:	6a 08                	push   $0x8
c01083da:	6a 04                	push   $0x4
c01083dc:	e8 d5 fe ff ff       	call   c01082b6 <_set_idt_entry>
c01083e1:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(FAULT_BOUND_EXCEED, 0x08, &bounds, 0);
c01083e4:	6a 00                	push   $0x0
c01083e6:	68 e4 7e 10 c0       	push   $0xc0107ee4
c01083eb:	6a 08                	push   $0x8
c01083ed:	6a 05                	push   $0x5
c01083ef:	e8 c2 fe ff ff       	call   c01082b6 <_set_idt_entry>
c01083f4:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(FAULT_INVALID_OPCODE, 0x08, &invalid_op, 0);
c01083f7:	6a 00                	push   $0x0
c01083f9:	68 ee 7e 10 c0       	push   $0xc0107eee
c01083fe:	6a 08                	push   $0x8
c0108400:	6a 06                	push   $0x6
c0108402:	e8 af fe ff ff       	call   c01082b6 <_set_idt_entry>
c0108407:	83 c4 10             	add    $0x10,%esp
    //_set_idt_entry(FAULT_NO_MATH_PROCESSOR, 0x08, &device_not_available, 0);
    //_set_idt_entry(ABORT_DOUBLE_FAULT, 0x08, &double_fault, 0);
    _set_idt_entry(FAULT_RESERVED_0, 0x08, &coprocessor_segment_overrun, 0);
c010840a:	6a 00                	push   $0x0
c010840c:	68 f8 7e 10 c0       	push   $0xc0107ef8
c0108411:	6a 08                	push   $0x8
c0108413:	6a 09                	push   $0x9
c0108415:	e8 9c fe ff ff       	call   c01082b6 <_set_idt_entry>
c010841a:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(FAULT_INVALID_TSS, 0x08, &invalid_TSS, 0);
c010841d:	6a 00                	push   $0x0
c010841f:	68 0c 7f 10 c0       	push   $0xc0107f0c
c0108424:	6a 08                	push   $0x8
c0108426:	6a 0a                	push   $0xa
c0108428:	e8 89 fe ff ff       	call   c01082b6 <_set_idt_entry>
c010842d:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(FAULT_SEG_NOT_PRESENT, 0x08, &segment_not_present, 0);
c0108430:	6a 00                	push   $0x0
c0108432:	68 16 7f 10 c0       	push   $0xc0107f16
c0108437:	6a 08                	push   $0x8
c0108439:	6a 0b                	push   $0xb
c010843b:	e8 76 fe ff ff       	call   c01082b6 <_set_idt_entry>
c0108440:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(FAULT_STACK_SEG_FAULT, 0x08, &stack_segment, 0);
c0108443:	6a 00                	push   $0x0
c0108445:	68 20 7f 10 c0       	push   $0xc0107f20
c010844a:	6a 08                	push   $0x8
c010844c:	6a 0c                	push   $0xc
c010844e:	e8 63 fe ff ff       	call   c01082b6 <_set_idt_entry>
c0108453:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(FAULT_GENERAL_PROTECTION, 0x08, &general_protection, 0);
c0108456:	6a 00                	push   $0x0
c0108458:	68 2a 7f 10 c0       	push   $0xc0107f2a
c010845d:	6a 08                	push   $0x8
c010845f:	6a 0d                	push   $0xd
c0108461:	e8 50 fe ff ff       	call   c01082b6 <_set_idt_entry>
c0108466:	83 c4 10             	add    $0x10,%esp
    //_set_idt_entry(FAULT_PAGE_FAULT, 0x08, page_fault, 0);
    _set_idt_entry(FAULT_RESERVED_1, 0x08, &reserved, 0);
c0108469:	6a 00                	push   $0x0
c010846b:	68 02 7f 10 c0       	push   $0xc0107f02
c0108470:	6a 08                	push   $0x8
c0108472:	6a 0f                	push   $0xf
c0108474:	e8 3d fe ff ff       	call   c01082b6 <_set_idt_entry>
c0108479:	83 c4 10             	add    $0x10,%esp
    //_set_idt_entry(FAULT_X87_FAULT, 0x08, coprocessor_error, 0);
    for (int i=17;i < 48;i++)
c010847c:	c7 45 fc 11 00 00 00 	movl   $0x11,-0x4(%ebp)
c0108483:	eb 19                	jmp    c010849e <_init_idt+0x11f>
		  _set_idt_entry(i, 0x08, &reserved, 0);
c0108485:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0108488:	6a 00                	push   $0x0
c010848a:	68 02 7f 10 c0       	push   $0xc0107f02
c010848f:	6a 08                	push   $0x8
c0108491:	50                   	push   %eax
c0108492:	e8 1f fe ff ff       	call   c01082b6 <_set_idt_entry>
c0108497:	83 c4 10             	add    $0x10,%esp
    for (int i=17;i < 48;i++)
c010849a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c010849e:	83 7d fc 2f          	cmpl   $0x2f,-0x4(%ebp)
c01084a2:	7e e1                	jle    c0108485 <_init_idt+0x106>
    //_set_idt_entry(45, 0x08, irq13, 0);
c01084a4:	90                   	nop
c01084a5:	90                   	nop
c01084a6:	c9                   	leave  
c01084a7:	c3                   	ret    

c01084a8 <_kernel_start>:
c01084a8:	e8 9b fd ff ff       	call   c0108248 <_init_gdt>
c01084ad:	68 60 a0 28 c0       	push   $0xc028a060
c01084b2:	66 ff 35 00 b0 28 c0 	pushw  0xc028b000
c01084b9:	0f 01 14 24          	lgdtl  (%esp)
c01084bd:	66 b9 10 00          	mov    $0x10,%cx
c01084c1:	8e c1                	mov    %ecx,%es
c01084c3:	8e d9                	mov    %ecx,%ds
c01084c5:	8e e1                	mov    %ecx,%fs
c01084c7:	8e e9                	mov    %ecx,%gs
c01084c9:	8e d1                	mov    %ecx,%ss
c01084cb:	66 6a 08             	pushw  $0x8
c01084ce:	68 d4 84 10 c0       	push   $0xc01084d4
c01084d3:	cb                   	lret   

c01084d4 <_after_gdt>:
c01084d4:	c7 04 24 00 10 10 00 	movl   $0x101000,(%esp)
c01084db:	e8 3d dd ff ff       	call   c010621d <_kernel_init>
c01084e0:	bc f0 ff bf ff       	mov    $0xffbffff0,%esp
c01084e5:	e8 5d e0 ff ff       	call   c0106547 <_kernel_finnal_init>
c01084ea:	83 ec 06             	sub    $0x6,%esp
c01084ed:	c7 44 24 02 a0 a0 28 	movl   $0xc028a0a0,0x2(%esp)
c01084f4:	c0 
c01084f5:	66 a1 02 b0 28 c0    	mov    0xc028b002,%ax
c01084fb:	66 89 04 24          	mov    %ax,(%esp)
c01084ff:	0f 01 1c 24          	lidtl  (%esp)
c0108503:	83 c4 06             	add    $0x6,%esp
c0108506:	e8 9c e0 ff ff       	call   c01065a7 <_kernel_main>

c010850b <j_>:
c010850b:	f4                   	hlt    
c010850c:	eb fd                	jmp    c010850b <j_>

c010850e <io_inb>:
{
c010850e:	55                   	push   %ebp
c010850f:	89 e5                	mov    %esp,%ebp
c0108511:	83 ec 10             	sub    $0x10,%esp
    asm volatile("inb %w1,%0" : "=a"(data) : "d"(port));
c0108514:	8b 45 08             	mov    0x8(%ebp),%eax
c0108517:	89 c2                	mov    %eax,%edx
c0108519:	ec                   	in     (%dx),%al
c010851a:	88 45 ff             	mov    %al,-0x1(%ebp)
    return data;
c010851d:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c0108521:	c9                   	leave  
c0108522:	c3                   	ret    

c0108523 <io_outb>:
{
c0108523:	55                   	push   %ebp
c0108524:	89 e5                	mov    %esp,%ebp
c0108526:	83 ec 04             	sub    $0x4,%esp
c0108529:	8b 45 0c             	mov    0xc(%ebp),%eax
c010852c:	88 45 fc             	mov    %al,-0x4(%ebp)
    asm volatile("outb %0, %w1" : : "a"(data), "d"(port));
c010852f:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0108533:	8b 55 08             	mov    0x8(%ebp),%edx
c0108536:	ee                   	out    %al,(%dx)
}
c0108537:	90                   	nop
c0108538:	c9                   	leave  
c0108539:	c3                   	ret    

c010853a <cpu_delay>:
io_outl(int port, uint32_t data)
{
    asm volatile("outl %0,%w1" : : "a"(data), "d"(port));
}

static inline void cpu_delay(){
c010853a:	55                   	push   %ebp
c010853b:	89 e5                	mov    %esp,%ebp
c010853d:	83 ec 10             	sub    $0x10,%esp
    for(int i = 0; i < 3; i++);
c0108540:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0108547:	eb 04                	jmp    c010854d <cpu_delay+0x13>
c0108549:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c010854d:	83 7d fc 02          	cmpl   $0x2,-0x4(%ebp)
c0108551:	7e f6                	jle    c0108549 <cpu_delay+0xf>
}
c0108553:	90                   	nop
c0108554:	90                   	nop
c0108555:	c9                   	leave  
c0108556:	c3                   	ret    

c0108557 <init_8259>:
//other keys tmp do not hand
};
#endif

void init_8259()
{
c0108557:	55                   	push   %ebp
c0108558:	89 e5                	mov    %esp,%ebp
    asm volatile("cli");
c010855a:	fa                   	cli    

    //ICW1
    io_outb(0x20, 0x11);
c010855b:	6a 11                	push   $0x11
c010855d:	6a 20                	push   $0x20
c010855f:	e8 bf ff ff ff       	call   c0108523 <io_outb>
c0108564:	83 c4 08             	add    $0x8,%esp
    cpu_delay();
c0108567:	e8 ce ff ff ff       	call   c010853a <cpu_delay>
    io_outb(0xa0, 0x11);
c010856c:	6a 11                	push   $0x11
c010856e:	68 a0 00 00 00       	push   $0xa0
c0108573:	e8 ab ff ff ff       	call   c0108523 <io_outb>
c0108578:	83 c4 08             	add    $0x8,%esp
    cpu_delay();
c010857b:	e8 ba ff ff ff       	call   c010853a <cpu_delay>

    //ICW2
    io_outb(0x21, 0x20);
c0108580:	6a 20                	push   $0x20
c0108582:	6a 21                	push   $0x21
c0108584:	e8 9a ff ff ff       	call   c0108523 <io_outb>
c0108589:	83 c4 08             	add    $0x8,%esp
    cpu_delay();
c010858c:	e8 a9 ff ff ff       	call   c010853a <cpu_delay>
    io_outb(0xa1, 0x28);
c0108591:	6a 28                	push   $0x28
c0108593:	68 a1 00 00 00       	push   $0xa1
c0108598:	e8 86 ff ff ff       	call   c0108523 <io_outb>
c010859d:	83 c4 08             	add    $0x8,%esp
    cpu_delay();
c01085a0:	e8 95 ff ff ff       	call   c010853a <cpu_delay>

    //ICW3
    io_outb(0x21, 0x04);
c01085a5:	6a 04                	push   $0x4
c01085a7:	6a 21                	push   $0x21
c01085a9:	e8 75 ff ff ff       	call   c0108523 <io_outb>
c01085ae:	83 c4 08             	add    $0x8,%esp
    cpu_delay();
c01085b1:	e8 84 ff ff ff       	call   c010853a <cpu_delay>
    io_outb(0xa1, 0x02);
c01085b6:	6a 02                	push   $0x2
c01085b8:	68 a1 00 00 00       	push   $0xa1
c01085bd:	e8 61 ff ff ff       	call   c0108523 <io_outb>
c01085c2:	83 c4 08             	add    $0x8,%esp
    cpu_delay();
c01085c5:	e8 70 ff ff ff       	call   c010853a <cpu_delay>

    //ICW4
    io_outb(0x21, 0x01);
c01085ca:	6a 01                	push   $0x1
c01085cc:	6a 21                	push   $0x21
c01085ce:	e8 50 ff ff ff       	call   c0108523 <io_outb>
c01085d3:	83 c4 08             	add    $0x8,%esp
    cpu_delay();
c01085d6:	e8 5f ff ff ff       	call   c010853a <cpu_delay>
    io_outb(0xa1, 0x01);
c01085db:	6a 01                	push   $0x1
c01085dd:	68 a1 00 00 00       	push   $0xa1
c01085e2:	e8 3c ff ff ff       	call   c0108523 <io_outb>
c01085e7:	83 c4 08             	add    $0x8,%esp
    cpu_delay();
c01085ea:	e8 4b ff ff ff       	call   c010853a <cpu_delay>

    //OCW1
    io_outb(0x21, 0xff);
c01085ef:	68 ff 00 00 00       	push   $0xff
c01085f4:	6a 21                	push   $0x21
c01085f6:	e8 28 ff ff ff       	call   c0108523 <io_outb>
c01085fb:	83 c4 08             	add    $0x8,%esp
    cpu_delay();
c01085fe:	e8 37 ff ff ff       	call   c010853a <cpu_delay>
    io_outb(0xa1, 0xff);
c0108603:	68 ff 00 00 00       	push   $0xff
c0108608:	68 a1 00 00 00       	push   $0xa1
c010860d:	e8 11 ff ff ff       	call   c0108523 <io_outb>
c0108612:	83 c4 08             	add    $0x8,%esp

    asm volatile("sti");
c0108615:	fb                   	sti    
}
c0108616:	90                   	nop
c0108617:	c9                   	leave  
c0108618:	c3                   	ret    

c0108619 <ps2_post_cmd>:


static void ps2_post_cmd(uint8_t port, char cmd, uint16_t arg) {
c0108619:	55                   	push   %ebp
c010861a:	89 e5                	mov    %esp,%ebp
c010861c:	83 ec 1c             	sub    $0x1c,%esp
c010861f:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0108622:	8b 55 0c             	mov    0xc(%ebp),%edx
c0108625:	8b 45 10             	mov    0x10(%ebp),%eax
c0108628:	88 4d ec             	mov    %cl,-0x14(%ebp)
c010862b:	88 55 e8             	mov    %dl,-0x18(%ebp)
c010862e:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    char result;
    // 等待PS/2输入缓冲区清空，这样我们才可以写入命令
    while((result = io_inb(PS2_PORT_CTRL_STATUS)) & PS2_STATUS_IFULL);
c0108632:	90                   	nop
c0108633:	6a 64                	push   $0x64
c0108635:	e8 d4 fe ff ff       	call   c010850e <io_inb>
c010863a:	83 c4 04             	add    $0x4,%esp
c010863d:	88 45 ff             	mov    %al,-0x1(%ebp)
c0108640:	0f be 45 ff          	movsbl -0x1(%ebp),%eax
c0108644:	83 e0 02             	and    $0x2,%eax
c0108647:	85 c0                	test   %eax,%eax
c0108649:	75 e8                	jne    c0108633 <ps2_post_cmd+0x1a>

    io_outb(port, cmd);
c010864b:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c010864f:	0f b6 d0             	movzbl %al,%edx
c0108652:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0108656:	52                   	push   %edx
c0108657:	50                   	push   %eax
c0108658:	e8 c6 fe ff ff       	call   c0108523 <io_outb>
c010865d:	83 c4 08             	add    $0x8,%esp
    if (!(arg & PS2_NO_ARG)) {
c0108660:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
c0108664:	25 00 ff 00 00       	and    $0xff00,%eax
c0108669:	85 c0                	test   %eax,%eax
c010866b:	75 12                	jne    c010867f <ps2_post_cmd+0x66>
        // 所有参数一律通过0x60传入。
        io_outb(PS2_PORT_ENC_CMDREG, (uint8_t)(arg & 0x00ff));
c010866d:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
c0108671:	0f b6 c0             	movzbl %al,%eax
c0108674:	50                   	push   %eax
c0108675:	6a 60                	push   $0x60
c0108677:	e8 a7 fe ff ff       	call   c0108523 <io_outb>
c010867c:	83 c4 08             	add    $0x8,%esp
    }
}
c010867f:	90                   	nop
c0108680:	c9                   	leave  
c0108681:	c3                   	ret    

c0108682 <ps2_issue_cmd>:

static uint8_t ps2_issue_cmd(char cmd, uint16_t arg) {
c0108682:	55                   	push   %ebp
c0108683:	89 e5                	mov    %esp,%ebp
c0108685:	83 ec 18             	sub    $0x18,%esp
c0108688:	8b 55 08             	mov    0x8(%ebp),%edx
c010868b:	8b 45 0c             	mov    0xc(%ebp),%eax
c010868e:	88 55 ec             	mov    %dl,-0x14(%ebp)
c0108691:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
    ps2_post_cmd(PS2_PORT_CTRL_CMDREG, cmd, arg);
c0108695:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
c0108699:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
c010869d:	52                   	push   %edx
c010869e:	50                   	push   %eax
c010869f:	6a 64                	push   $0x64
c01086a1:	e8 73 ff ff ff       	call   c0108619 <ps2_post_cmd>
c01086a6:	83 c4 0c             	add    $0xc,%esp

    char result;
    
    // 等待PS/2控制器返回。通过轮询（polling）状态寄存器的 bit 0
    // 如置位，则表明返回代码此时就在 0x60 IO口上等待读取。
    while(!((result = io_inb(PS2_PORT_CTRL_STATUS)) & PS2_STATUS_OFULL));
c01086a9:	90                   	nop
c01086aa:	6a 64                	push   $0x64
c01086ac:	e8 5d fe ff ff       	call   c010850e <io_inb>
c01086b1:	83 c4 04             	add    $0x4,%esp
c01086b4:	88 45 ff             	mov    %al,-0x1(%ebp)
c01086b7:	0f be 45 ff          	movsbl -0x1(%ebp),%eax
c01086bb:	83 e0 01             	and    $0x1,%eax
c01086be:	85 c0                	test   %eax,%eax
c01086c0:	74 e8                	je     c01086aa <ps2_issue_cmd+0x28>

    return io_inb(PS2_PORT_ENC_CMDREG);
c01086c2:	6a 60                	push   $0x60
c01086c4:	e8 45 fe ff ff       	call   c010850e <io_inb>
c01086c9:	83 c4 04             	add    $0x4,%esp
}
c01086cc:	c9                   	leave  
c01086cd:	c3                   	ret    

c01086ce <ps2_issue_dev_cmd>:

static uint8_t ps2_issue_dev_cmd(char cmd, uint16_t arg) {
c01086ce:	55                   	push   %ebp
c01086cf:	89 e5                	mov    %esp,%ebp
c01086d1:	83 ec 18             	sub    $0x18,%esp
c01086d4:	8b 55 08             	mov    0x8(%ebp),%edx
c01086d7:	8b 45 0c             	mov    0xc(%ebp),%eax
c01086da:	88 55 ec             	mov    %dl,-0x14(%ebp)
c01086dd:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
    ps2_post_cmd(PS2_PORT_ENC_CMDREG, cmd, arg);
c01086e1:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
c01086e5:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
c01086e9:	52                   	push   %edx
c01086ea:	50                   	push   %eax
c01086eb:	6a 60                	push   $0x60
c01086ed:	e8 27 ff ff ff       	call   c0108619 <ps2_post_cmd>
c01086f2:	83 c4 0c             	add    $0xc,%esp

    char result;
    
    // 等待PS/2控制器返回。通过轮询（polling）状态寄存器的 bit 0
    // 如置位，则表明返回代码此时就在 0x60 IO口上等待读取。
    while(!((result = io_inb(PS2_PORT_CTRL_STATUS)) & PS2_STATUS_OFULL));
c01086f5:	90                   	nop
c01086f6:	6a 64                	push   $0x64
c01086f8:	e8 11 fe ff ff       	call   c010850e <io_inb>
c01086fd:	83 c4 04             	add    $0x4,%esp
c0108700:	88 45 ff             	mov    %al,-0x1(%ebp)
c0108703:	0f be 45 ff          	movsbl -0x1(%ebp),%eax
c0108707:	83 e0 01             	and    $0x1,%eax
c010870a:	85 c0                	test   %eax,%eax
c010870c:	74 e8                	je     c01086f6 <ps2_issue_dev_cmd+0x28>

    return io_inb(PS2_PORT_ENC_CMDREG);
c010870e:	6a 60                	push   $0x60
c0108710:	e8 f9 fd ff ff       	call   c010850e <io_inb>
c0108715:	83 c4 04             	add    $0x4,%esp
}
c0108718:	c9                   	leave  
c0108719:	c3                   	ret    

c010871a <init_ps2k>:

void init_ps2k()
{
c010871a:	55                   	push   %ebp
c010871b:	89 e5                	mov    %esp,%ebp
c010871d:	83 ec 18             	sub    $0x18,%esp
    asm volatile("cli");
c0108720:	fa                   	cli    

     // 1、禁用任何的PS/2设备
    ps2_post_cmd(PS2_PORT_CTRL_CMDREG, PS2_CMD_PORT1_DISABLE, PS2_NO_ARG);
c0108721:	68 00 ff 00 00       	push   $0xff00
c0108726:	6a ad                	push   $0xffffffad
c0108728:	6a 64                	push   $0x64
c010872a:	e8 ea fe ff ff       	call   c0108619 <ps2_post_cmd>
c010872f:	83 c4 0c             	add    $0xc,%esp
    ps2_post_cmd(PS2_PORT_CTRL_CMDREG, PS2_CMD_PORT2_DISABLE, PS2_NO_ARG);
c0108732:	68 00 ff 00 00       	push   $0xff00
c0108737:	6a a7                	push   $0xffffffa7
c0108739:	6a 64                	push   $0x64
c010873b:	e8 d9 fe ff ff       	call   c0108619 <ps2_post_cmd>
c0108740:	83 c4 0c             	add    $0xc,%esp
    
    // 2、清空控制器缓冲区
    io_inb(PS2_PORT_ENC_DATA);
c0108743:	6a 60                	push   $0x60
c0108745:	e8 c4 fd ff ff       	call   c010850e <io_inb>
c010874a:	83 c4 04             	add    $0x4,%esp

    char result;

    // 3、屏蔽所有PS/2设备（端口1&2）IRQ，并且禁用键盘键码转换功能
    result = ps2_issue_cmd(PS2_CMD_READ_CFG, PS2_NO_ARG);
c010874d:	68 00 ff 00 00       	push   $0xff00
c0108752:	6a 20                	push   $0x20
c0108754:	e8 29 ff ff ff       	call   c0108682 <ps2_issue_cmd>
c0108759:	83 c4 08             	add    $0x8,%esp
c010875c:	88 45 f7             	mov    %al,-0x9(%ebp)
    result = result & ~(PS2_CFG_P1INT | PS2_CFG_P2INT | PS2_CFG_TRANSLATION);
c010875f:	80 65 f7 bc          	andb   $0xbc,-0x9(%ebp)
    ps2_post_cmd(PS2_PORT_CTRL_CMDREG, PS2_CMD_WRITE_CFG, result);
c0108763:	66 0f be 45 f7       	movsbw -0x9(%ebp),%ax
c0108768:	0f b7 c0             	movzwl %ax,%eax
c010876b:	50                   	push   %eax
c010876c:	6a 60                	push   $0x60
c010876e:	6a 64                	push   $0x64
c0108770:	e8 a4 fe ff ff       	call   c0108619 <ps2_post_cmd>
c0108775:	83 c4 0c             	add    $0xc,%esp

    // 4、控制器自检
    result = ps2_issue_cmd(PS2_CMD_SELFTEST, PS2_NO_ARG);
c0108778:	68 00 ff 00 00       	push   $0xff00
c010877d:	6a aa                	push   $0xffffffaa
c010877f:	e8 fe fe ff ff       	call   c0108682 <ps2_issue_cmd>
c0108784:	83 c4 08             	add    $0x8,%esp
c0108787:	88 45 f7             	mov    %al,-0x9(%ebp)
    if (result != PS2_RESULT_TEST_OK) {
c010878a:	80 7d f7 55          	cmpb   $0x55,-0x9(%ebp)
c010878e:	74 12                	je     c01087a2 <init_ps2k+0x88>
        kprintf("Controller self-test failed.");
c0108790:	83 ec 0c             	sub    $0xc,%esp
c0108793:	68 78 c5 28 c0       	push   $0xc028c578
c0108798:	e8 34 08 00 00       	call   c0108fd1 <kprintf>
c010879d:	83 c4 10             	add    $0x10,%esp
        goto done;
c01087a0:	eb 72                	jmp    c0108814 <init_ps2k+0xfa>
    }

    // 5、设备自检（端口1自检，通常是我们的键盘）
    result = ps2_issue_cmd(PS2_CMD_SELFTEST_PORT1, PS2_NO_ARG);
c01087a2:	83 ec 08             	sub    $0x8,%esp
c01087a5:	68 00 ff 00 00       	push   $0xff00
c01087aa:	6a ab                	push   $0xffffffab
c01087ac:	e8 d1 fe ff ff       	call   c0108682 <ps2_issue_cmd>
c01087b1:	83 c4 10             	add    $0x10,%esp
c01087b4:	88 45 f7             	mov    %al,-0x9(%ebp)
    if (result != 0) {
c01087b7:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
c01087bb:	74 12                	je     c01087cf <init_ps2k+0xb5>
        kprintf("Interface test on port 1 failed.");
c01087bd:	83 ec 0c             	sub    $0xc,%esp
c01087c0:	68 98 c5 28 c0       	push   $0xc028c598
c01087c5:	e8 07 08 00 00       	call   c0108fd1 <kprintf>
c01087ca:	83 c4 10             	add    $0x10,%esp
        goto done;
c01087cd:	eb 45                	jmp    c0108814 <init_ps2k+0xfa>
    }

    // 6、开启位于端口1的 IRQ，并启用端口1。不用理会端口2，那儿一般是鼠标。
    ps2_post_cmd(PS2_PORT_CTRL_CMDREG, PS2_CMD_PORT1_ENABLE, PS2_NO_ARG);
c01087cf:	83 ec 04             	sub    $0x4,%esp
c01087d2:	68 00 ff 00 00       	push   $0xff00
c01087d7:	6a ae                	push   $0xffffffae
c01087d9:	6a 64                	push   $0x64
c01087db:	e8 39 fe ff ff       	call   c0108619 <ps2_post_cmd>
c01087e0:	83 c4 10             	add    $0x10,%esp
    result = ps2_issue_cmd(PS2_CMD_READ_CFG, PS2_NO_ARG);
c01087e3:	83 ec 08             	sub    $0x8,%esp
c01087e6:	68 00 ff 00 00       	push   $0xff00
c01087eb:	6a 20                	push   $0x20
c01087ed:	e8 90 fe ff ff       	call   c0108682 <ps2_issue_cmd>
c01087f2:	83 c4 10             	add    $0x10,%esp
c01087f5:	88 45 f7             	mov    %al,-0x9(%ebp)
    result = result | PS2_CFG_P1INT;
c01087f8:	80 4d f7 01          	orb    $0x1,-0x9(%ebp)
    ps2_post_cmd(PS2_PORT_CTRL_CMDREG, PS2_CMD_WRITE_CFG, result);
c01087fc:	66 0f be 45 f7       	movsbw -0x9(%ebp),%ax
c0108801:	0f b7 c0             	movzwl %ax,%eax
c0108804:	83 ec 04             	sub    $0x4,%esp
c0108807:	50                   	push   %eax
c0108808:	6a 60                	push   $0x60
c010880a:	6a 64                	push   $0x64
c010880c:	e8 08 fe ff ff       	call   c0108619 <ps2_post_cmd>
c0108811:	83 c4 10             	add    $0x10,%esp

    // 至此，PS/2控制器和设备已完成初始化，可以正常使用。

done:
    asm volatile("sti");
c0108814:	fb                   	sti    
}
c0108815:	90                   	nop
c0108816:	c9                   	leave  
c0108817:	c3                   	ret    

c0108818 <init_keyboard>:



void init_keyboard()
{
c0108818:	55                   	push   %ebp
c0108819:	89 e5                	mov    %esp,%ebp
c010881b:	83 ec 18             	sub    $0x18,%esp
    init_8259();
c010881e:	e8 34 fd ff ff       	call   c0108557 <init_8259>

    uint8_t result = io_inb(0x21);
c0108823:	6a 21                	push   $0x21
c0108825:	e8 e4 fc ff ff       	call   c010850e <io_inb>
c010882a:	83 c4 04             	add    $0x4,%esp
c010882d:	88 45 f7             	mov    %al,-0x9(%ebp)
    io_outb(0x21, result & 0xfd);
c0108830:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0108834:	25 fd 00 00 00       	and    $0xfd,%eax
c0108839:	50                   	push   %eax
c010883a:	6a 21                	push   $0x21
c010883c:	e8 e2 fc ff ff       	call   c0108523 <io_outb>
c0108841:	83 c4 08             	add    $0x8,%esp
    cpu_delay();
c0108844:	e8 f1 fc ff ff       	call   c010853a <cpu_delay>
    result = io_inb(0x21);
c0108849:	6a 21                	push   $0x21
c010884b:	e8 be fc ff ff       	call   c010850e <io_inb>
c0108850:	83 c4 04             	add    $0x4,%esp
c0108853:	88 45 f7             	mov    %al,-0x9(%ebp)

    init_ps2k();
c0108856:	e8 bf fe ff ff       	call   c010871a <init_ps2k>
    
    _set_idt_entry(0x21, 0x08, &handle_keywords, 0);
c010885b:	6a 00                	push   $0x0
c010885d:	68 71 88 10 c0       	push   $0xc0108871
c0108862:	6a 08                	push   $0x8
c0108864:	6a 21                	push   $0x21
c0108866:	e8 4b fa ff ff       	call   c01082b6 <_set_idt_entry>
c010886b:	83 c4 10             	add    $0x10,%esp
}
c010886e:	90                   	nop
c010886f:	c9                   	leave  
c0108870:	c3                   	ret    

c0108871 <handle_keywords>:

static void handle_keywords()
{
c0108871:	55                   	push   %ebp
c0108872:	89 e5                	mov    %esp,%ebp
c0108874:	83 ec 18             	sub    $0x18,%esp
    crtl_status, shift_status, alt_status, caps_lock_status, ext_scancode = 0;
c0108877:	c6 05 24 a3 28 c0 00 	movb   $0x0,0xc028a324
    asm volatile("cli");
c010887e:	fa                   	cli    
    io_outb(0x61, 0x20);
c010887f:	6a 20                	push   $0x20
c0108881:	6a 61                	push   $0x61
c0108883:	e8 9b fc ff ff       	call   c0108523 <io_outb>
c0108888:	83 c4 08             	add    $0x8,%esp
    uint8_t ctrl_down_last = crtl_status;
c010888b:	0f b6 05 20 a3 28 c0 	movzbl 0xc028a320,%eax
c0108892:	88 45 f4             	mov    %al,-0xc(%ebp)
    uint8_t shift_down_last = shift_status;
c0108895:	0f b6 05 21 a3 28 c0 	movzbl 0xc028a321,%eax
c010889c:	88 45 f3             	mov    %al,-0xd(%ebp)
    uint8_t caps_lock_last = caps_lock_status;
c010889f:	0f b6 05 23 a3 28 c0 	movzbl 0xc028a323,%eax
c01088a6:	88 45 f2             	mov    %al,-0xe(%ebp)

    uint8_t break_code;
    uint16_t scancode = io_inb(0x60);
c01088a9:	6a 60                	push   $0x60
c01088ab:	e8 5e fc ff ff       	call   c010850e <io_inb>
c01088b0:	83 c4 04             	add    $0x4,%esp
c01088b3:	0f b6 c0             	movzbl %al,%eax
c01088b6:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
    
    if(scancode == 0xe0){
c01088ba:	66 81 7d f6 e0 00    	cmpw   $0xe0,-0xa(%ebp)
c01088c0:	75 25                	jne    c01088e7 <handle_keywords+0x76>
        ext_scancode = 1;
c01088c2:	c6 05 24 a3 28 c0 01 	movb   $0x1,0xc028a324
        io_outb(0x20, 0x20);
c01088c9:	6a 20                	push   $0x20
c01088cb:	6a 20                	push   $0x20
c01088cd:	e8 51 fc ff ff       	call   c0108523 <io_outb>
c01088d2:	83 c4 08             	add    $0x8,%esp
        io_outb(0x20, 0x20);
c01088d5:	6a 20                	push   $0x20
c01088d7:	6a 20                	push   $0x20
c01088d9:	e8 45 fc ff ff       	call   c0108523 <io_outb>
c01088de:	83 c4 08             	add    $0x8,%esp
        asm volatile("sti");
c01088e1:	fb                   	sti    
        return;
c01088e2:	e9 1a 02 00 00       	jmp    c0108b01 <handle_keywords+0x290>
    }
    if(ext_scancode){
c01088e7:	0f b6 05 24 a3 28 c0 	movzbl 0xc028a324,%eax
c01088ee:	84 c0                	test   %al,%al
c01088f0:	74 0d                	je     c01088ff <handle_keywords+0x8e>
        scancode = ((0xe000) | scancode);
c01088f2:	66 81 4d f6 00 e0    	orw    $0xe000,-0xa(%ebp)
        ext_scancode = 0;
c01088f8:	c6 05 24 a3 28 c0 00 	movb   $0x0,0xc028a324
    }

    break_code = ((0x0080 & scancode) != 0);
c01088ff:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c0108903:	66 25 80 00          	and    $0x80,%ax
c0108907:	66 85 c0             	test   %ax,%ax
c010890a:	0f 95 c0             	setne  %al
c010890d:	88 45 f1             	mov    %al,-0xf(%ebp)

    if(break_code)//tan qi ma
c0108910:	80 7d f1 00          	cmpb   $0x0,-0xf(%ebp)
c0108914:	74 6d                	je     c0108983 <handle_keywords+0x112>
    {
        uint16_t make_code = (scancode & 0xff7f);
c0108916:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c010891a:	24 7f                	and    $0x7f,%al
c010891c:	66 89 45 ec          	mov    %ax,-0x14(%ebp)

        if(make_code == crtl_l_make || make_code == crtl_r_make)
c0108920:	66 83 7d ec 1d       	cmpw   $0x1d,-0x14(%ebp)
c0108925:	74 08                	je     c010892f <handle_keywords+0xbe>
c0108927:	66 81 7d ec 1d e0    	cmpw   $0xe01d,-0x14(%ebp)
c010892d:	75 09                	jne    c0108938 <handle_keywords+0xc7>
        {
            crtl_status = 0;
c010892f:	c6 05 20 a3 28 c0 00 	movb   $0x0,0xc028a320
c0108936:	eb 2d                	jmp    c0108965 <handle_keywords+0xf4>
        }else if(make_code == shift_l_make || make_code == shift_r_make){
c0108938:	66 83 7d ec 2a       	cmpw   $0x2a,-0x14(%ebp)
c010893d:	74 07                	je     c0108946 <handle_keywords+0xd5>
c010893f:	66 83 7d ec 36       	cmpw   $0x36,-0x14(%ebp)
c0108944:	75 09                	jne    c010894f <handle_keywords+0xde>
            shift_status = 0;
c0108946:	c6 05 21 a3 28 c0 00 	movb   $0x0,0xc028a321
c010894d:	eb 16                	jmp    c0108965 <handle_keywords+0xf4>
        }else if(make_code == alt_l_make || make_code == alt_r_make){
c010894f:	66 83 7d ec 38       	cmpw   $0x38,-0x14(%ebp)
c0108954:	74 08                	je     c010895e <handle_keywords+0xed>
c0108956:	66 81 7d ec 38 e0    	cmpw   $0xe038,-0x14(%ebp)
c010895c:	75 07                	jne    c0108965 <handle_keywords+0xf4>
            alt_status = 0;
c010895e:	c6 05 22 a3 28 c0 00 	movb   $0x0,0xc028a322
        }
        io_outb(0x20, 0x20);
c0108965:	6a 20                	push   $0x20
c0108967:	6a 20                	push   $0x20
c0108969:	e8 b5 fb ff ff       	call   c0108523 <io_outb>
c010896e:	83 c4 08             	add    $0x8,%esp
        io_outb(0x20, 0x20);
c0108971:	6a 20                	push   $0x20
c0108973:	6a 20                	push   $0x20
c0108975:	e8 a9 fb ff ff       	call   c0108523 <io_outb>
c010897a:	83 c4 08             	add    $0x8,%esp
        asm volatile("sti");
c010897d:	fb                   	sti    
        return;
c010897e:	e9 7e 01 00 00       	jmp    c0108b01 <handle_keywords+0x290>
    }//if is common word, hand
    else if((scancode > 0x00 && scancode < 0x3b) ||\
c0108983:	66 83 7d f6 00       	cmpw   $0x0,-0xa(%ebp)
c0108988:	74 07                	je     c0108991 <handle_keywords+0x120>
c010898a:	66 83 7d f6 3a       	cmpw   $0x3a,-0xa(%ebp)
c010898f:	76 14                	jbe    c01089a5 <handle_keywords+0x134>
c0108991:	66 81 7d f6 38 e0    	cmpw   $0xe038,-0xa(%ebp)
c0108997:	74 0c                	je     c01089a5 <handle_keywords+0x134>
            (scancode == alt_r_make) || \
c0108999:	66 81 7d f6 1d e0    	cmpw   $0xe01d,-0xa(%ebp)
c010899f:	0f 85 20 01 00 00    	jne    c0108ac5 <handle_keywords+0x254>
            (scancode == crtl_r_make)){
        uint8_t shift = 0;
c01089a5:	c6 45 f5 00          	movb   $0x0,-0xb(%ebp)
        if((scancode < 0x0e) || (scancode == 0x29) || \
c01089a9:	66 83 7d f6 0d       	cmpw   $0xd,-0xa(%ebp)
c01089ae:	76 3f                	jbe    c01089ef <handle_keywords+0x17e>
c01089b0:	66 83 7d f6 29       	cmpw   $0x29,-0xa(%ebp)
c01089b5:	74 38                	je     c01089ef <handle_keywords+0x17e>
c01089b7:	66 83 7d f6 1a       	cmpw   $0x1a,-0xa(%ebp)
c01089bc:	74 31                	je     c01089ef <handle_keywords+0x17e>
           (scancode == 0x1a) || (scancode == 0x1b) ||\
c01089be:	66 83 7d f6 1b       	cmpw   $0x1b,-0xa(%ebp)
c01089c3:	74 2a                	je     c01089ef <handle_keywords+0x17e>
c01089c5:	66 83 7d f6 2b       	cmpw   $0x2b,-0xa(%ebp)
c01089ca:	74 23                	je     c01089ef <handle_keywords+0x17e>
           (scancode == 0x2b) || (scancode == 0x27) ||\
c01089cc:	66 83 7d f6 27       	cmpw   $0x27,-0xa(%ebp)
c01089d1:	74 1c                	je     c01089ef <handle_keywords+0x17e>
c01089d3:	66 83 7d f6 28       	cmpw   $0x28,-0xa(%ebp)
c01089d8:	74 15                	je     c01089ef <handle_keywords+0x17e>
           (scancode == 0x28) || (scancode == 0x33) ||\
c01089da:	66 83 7d f6 33       	cmpw   $0x33,-0xa(%ebp)
c01089df:	74 0e                	je     c01089ef <handle_keywords+0x17e>
c01089e1:	66 83 7d f6 34       	cmpw   $0x34,-0xa(%ebp)
c01089e6:	74 07                	je     c01089ef <handle_keywords+0x17e>
           (scancode == 0x34) || (scancode == 0x35)){
c01089e8:	66 83 7d f6 35       	cmpw   $0x35,-0xa(%ebp)
c01089ed:	75 34                	jne    c0108a23 <handle_keywords+0x1b2>
            if(shift_down_last)
c01089ef:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
c01089f3:	74 06                	je     c01089fb <handle_keywords+0x18a>
                shift = 1;
c01089f5:	c6 45 f5 01          	movb   $0x1,-0xb(%ebp)
c01089f9:	eb 28                	jmp    c0108a23 <handle_keywords+0x1b2>
            else{
                if(shift_down_last && caps_lock_last)
c01089fb:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
c01089ff:	74 0c                	je     c0108a0d <handle_keywords+0x19c>
c0108a01:	80 7d f2 00          	cmpb   $0x0,-0xe(%ebp)
c0108a05:	74 06                	je     c0108a0d <handle_keywords+0x19c>
                    shift = 0;
c0108a07:	c6 45 f5 00          	movb   $0x0,-0xb(%ebp)
c0108a0b:	eb 16                	jmp    c0108a23 <handle_keywords+0x1b2>
                else if(shift_down_last || caps_lock_last)
c0108a0d:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
c0108a11:	75 06                	jne    c0108a19 <handle_keywords+0x1a8>
c0108a13:	80 7d f2 00          	cmpb   $0x0,-0xe(%ebp)
c0108a17:	74 06                	je     c0108a1f <handle_keywords+0x1ae>
                    shift = 1;
c0108a19:	c6 45 f5 01          	movb   $0x1,-0xb(%ebp)
c0108a1d:	eb 04                	jmp    c0108a23 <handle_keywords+0x1b2>
                else
                    shift = 0;
c0108a1f:	c6 45 f5 00          	movb   $0x0,-0xb(%ebp)
                }
           }
        uint8_t index = (scancode &= 0x00ff);
c0108a23:	66 81 65 f6 ff 00    	andw   $0xff,-0xa(%ebp)
c0108a29:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c0108a2d:	88 45 f0             	mov    %al,-0x10(%ebp)
        char cur_char = key_map[index][shift];
c0108a30:	0f b6 55 f0          	movzbl -0x10(%ebp),%edx
c0108a34:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
c0108a38:	0f b6 84 50 20 b0 28 	movzbl -0x3fd74fe0(%eax,%edx,2),%eax
c0108a3f:	c0 
c0108a40:	88 45 ef             	mov    %al,-0x11(%ebp)

        if(cur_char){
c0108a43:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
c0108a47:	74 34                	je     c0108a7d <handle_keywords+0x20c>
            vga_put_char(cur_char);
c0108a49:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
c0108a4d:	83 ec 0c             	sub    $0xc,%esp
c0108a50:	50                   	push   %eax
c0108a51:	e8 c8 d5 ff ff       	call   c010601e <vga_put_char>
c0108a56:	83 c4 10             	add    $0x10,%esp
            io_outb(0x20, 0x20);
c0108a59:	83 ec 08             	sub    $0x8,%esp
c0108a5c:	6a 20                	push   $0x20
c0108a5e:	6a 20                	push   $0x20
c0108a60:	e8 be fa ff ff       	call   c0108523 <io_outb>
c0108a65:	83 c4 10             	add    $0x10,%esp
            io_outb(0x20, 0x20);
c0108a68:	83 ec 08             	sub    $0x8,%esp
c0108a6b:	6a 20                	push   $0x20
c0108a6d:	6a 20                	push   $0x20
c0108a6f:	e8 af fa ff ff       	call   c0108523 <io_outb>
c0108a74:	83 c4 10             	add    $0x10,%esp
            asm volatile("sti");
c0108a77:	fb                   	sti    
            return;
c0108a78:	e9 84 00 00 00       	jmp    c0108b01 <handle_keywords+0x290>
        }

        if(scancode == crtl_l_make || scancode == crtl_r_make)
c0108a7d:	66 83 7d f6 1d       	cmpw   $0x1d,-0xa(%ebp)
c0108a82:	74 08                	je     c0108a8c <handle_keywords+0x21b>
c0108a84:	66 81 7d f6 1d e0    	cmpw   $0xe01d,-0xa(%ebp)
c0108a8a:	75 09                	jne    c0108a95 <handle_keywords+0x224>
            crtl_status = 1;
c0108a8c:	c6 05 20 a3 28 c0 01 	movb   $0x1,0xc028a320
c0108a93:	eb 2e                	jmp    c0108ac3 <handle_keywords+0x252>
        else if(scancode == shift_l_make || scancode == shift_r_make)
c0108a95:	66 83 7d f6 2a       	cmpw   $0x2a,-0xa(%ebp)
c0108a9a:	74 07                	je     c0108aa3 <handle_keywords+0x232>
c0108a9c:	66 83 7d f6 36       	cmpw   $0x36,-0xa(%ebp)
c0108aa1:	75 09                	jne    c0108aac <handle_keywords+0x23b>
            shift_status = 1;
c0108aa3:	c6 05 21 a3 28 c0 01 	movb   $0x1,0xc028a321
c0108aaa:	eb 17                	jmp    c0108ac3 <handle_keywords+0x252>
        else if(scancode == caps_lock_make)
c0108aac:	66 83 7d f6 3a       	cmpw   $0x3a,-0xa(%ebp)
c0108ab1:	75 4d                	jne    c0108b00 <handle_keywords+0x28f>
            caps_lock_status = ~caps_lock_status;
c0108ab3:	0f b6 05 23 a3 28 c0 	movzbl 0xc028a323,%eax
c0108aba:	f7 d0                	not    %eax
c0108abc:	a2 23 a3 28 c0       	mov    %al,0xc028a323
            (scancode == crtl_r_make)){
c0108ac1:	eb 3d                	jmp    c0108b00 <handle_keywords+0x28f>
c0108ac3:	eb 3b                	jmp    c0108b00 <handle_keywords+0x28f>
    }else{
        vga_put_char((char)(scancode && 0x00ff));
c0108ac5:	66 83 7d f6 00       	cmpw   $0x0,-0xa(%ebp)
c0108aca:	0f 95 c0             	setne  %al
c0108acd:	0f b6 c0             	movzbl %al,%eax
c0108ad0:	0f be c0             	movsbl %al,%eax
c0108ad3:	83 ec 0c             	sub    $0xc,%esp
c0108ad6:	50                   	push   %eax
c0108ad7:	e8 42 d5 ff ff       	call   c010601e <vga_put_char>
c0108adc:	83 c4 10             	add    $0x10,%esp
        io_outb(0x20, 0x20);
c0108adf:	83 ec 08             	sub    $0x8,%esp
c0108ae2:	6a 20                	push   $0x20
c0108ae4:	6a 20                	push   $0x20
c0108ae6:	e8 38 fa ff ff       	call   c0108523 <io_outb>
c0108aeb:	83 c4 10             	add    $0x10,%esp
        io_outb(0x20, 0x20);
c0108aee:	83 ec 08             	sub    $0x8,%esp
c0108af1:	6a 20                	push   $0x20
c0108af3:	6a 20                	push   $0x20
c0108af5:	e8 29 fa ff ff       	call   c0108523 <io_outb>
c0108afa:	83 c4 10             	add    $0x10,%esp
        asm volatile("sti");
c0108afd:	fb                   	sti    
c0108afe:	eb 01                	jmp    c0108b01 <handle_keywords+0x290>
            (scancode == crtl_r_make)){
c0108b00:	90                   	nop
    }
c0108b01:	c9                   	leave  
c0108b02:	c3                   	ret    

c0108b03 <spin>:
    if (!(cond)) {                                    \
        __assert_fail(#cond, __FILE__, __LINE__);     \
    }


inline static void spin() {
c0108b03:	55                   	push   %ebp
c0108b04:	89 e5                	mov    %esp,%ebp
    while(1);
c0108b06:	eb fe                	jmp    c0108b06 <spin+0x3>

c0108b08 <__assert_fail>:
#include <common.h>
#include <libs/mstdio.h>

static char buffer[1024];

void __assert_fail(const char* expr, const char* file, unsigned int line) {
c0108b08:	55                   	push   %ebp
c0108b09:	89 e5                	mov    %esp,%ebp
c0108b0b:	57                   	push   %edi
c0108b0c:	83 ec 04             	sub    $0x4,%esp
    kprintf(buffer, "%s (%s:%u)", expr, file, line);
c0108b0f:	83 ec 0c             	sub    $0xc,%esp
c0108b12:	ff 75 10             	push   0x10(%ebp)
c0108b15:	ff 75 0c             	push   0xc(%ebp)
c0108b18:	ff 75 08             	push   0x8(%ebp)
c0108b1b:	68 b9 c5 28 c0       	push   $0xc028c5b9
c0108b20:	68 40 a3 28 c0       	push   $0xc028a340
c0108b25:	e8 a7 04 00 00       	call   c0108fd1 <kprintf>
c0108b2a:	83 c4 20             	add    $0x20,%esp

    // Here we load the buffer's address into %edi ("D" constraint)
    //  This is a convention we made that the LUNAIX_SYS_PANIC syscall will
    //  print the panic message passed via %edi. (see kernel/asm/x86/interrupts.c)
    asm(
c0108b2d:	b8 40 a3 28 c0       	mov    $0xc028a340,%eax
c0108b32:	89 c7                	mov    %eax,%edi
c0108b34:	cd 20                	int    $0x20
        "int %0"
        ::"i"(32), "D"(buffer)
    );

    spin();     // never reach
c0108b36:	e8 c8 ff ff ff       	call   c0108b03 <spin>
c0108b3b:	90                   	nop
c0108b3c:	8b 7d fc             	mov    -0x4(%ebp),%edi
c0108b3f:	c9                   	leave  
c0108b40:	c3                   	ret    

c0108b41 <cpu_invplg>:
{
c0108b41:	55                   	push   %ebp
c0108b42:	89 e5                	mov    %esp,%ebp
    asm volatile("invlpg (%0)" ::"r"((unsigned int)va) : "memory");
c0108b44:	8b 45 08             	mov    0x8(%ebp),%eax
c0108b47:	0f 01 38             	invlpg (%eax)
};
c0108b4a:	90                   	nop
c0108b4b:	5d                   	pop    %ebp
c0108b4c:	c3                   	ret    

c0108b4d <llist_init_head>:
static inline void llist_init_head(struct llist_header* head) {
c0108b4d:	55                   	push   %ebp
c0108b4e:	89 e5                	mov    %esp,%ebp
    head->next = head;
c0108b50:	8b 45 08             	mov    0x8(%ebp),%eax
c0108b53:	8b 55 08             	mov    0x8(%ebp),%edx
c0108b56:	89 50 04             	mov    %edx,0x4(%eax)
    head->prev = head;
c0108b59:	8b 45 08             	mov    0x8(%ebp),%eax
c0108b5c:	8b 55 08             	mov    0x8(%ebp),%edx
c0108b5f:	89 10                	mov    %edx,(%eax)
}
c0108b61:	90                   	nop
c0108b62:	5d                   	pop    %ebp
c0108b63:	c3                   	ret    

c0108b64 <init_proc>:
#include <kernel/memory/vir_mem.h>
#include <libs/mstring.h>
#include <kernel/memory/region.h>
volatile struct m_pcb* __current;
void init_proc(struct m_pcb* pcb)
{
c0108b64:	55                   	push   %ebp
c0108b65:	89 e5                	mov    %esp,%ebp
c0108b67:	83 ec 08             	sub    $0x8,%esp
    memset(pcb, 0, sizeof(*pcb));
c0108b6a:	83 ec 04             	sub    $0x4,%esp
c0108b6d:	6a 50                	push   $0x50
c0108b6f:	6a 00                	push   $0x0
c0108b71:	ff 75 08             	push   0x8(%ebp)
c0108b74:	e8 ef 06 00 00       	call   c0109268 <memset>
c0108b79:	83 c4 10             	add    $0x10,%esp

    //pcb->pid = alloc_pid();
    pcb->state = PROC_CREATED;
c0108b7c:	8b 45 08             	mov    0x8(%ebp),%eax
c0108b7f:	c6 40 44 00          	movb   $0x0,0x44(%eax)
}
c0108b83:	90                   	nop
c0108b84:	c9                   	leave  
c0108b85:	c3                   	ret    

c0108b86 <copy_page>:

void* copy_page(pid_t pid, uintptr_t mount_point)
{
c0108b86:	55                   	push   %ebp
c0108b87:	89 e5                	mov    %esp,%ebp
c0108b89:	83 ec 38             	sub    $0x38,%esp
    void* pid_ptd = pmm_alloc_page(pid, PP_FGPERSIST);
c0108b8c:	83 ec 08             	sub    $0x8,%esp
c0108b8f:	6a 01                	push   $0x1
c0108b91:	ff 75 08             	push   0x8(%ebp)
c0108b94:	e8 8b dc ff ff       	call   c0106824 <pmm_alloc_page>
c0108b99:	83 c4 10             	add    $0x10,%esp
c0108b9c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    ptd_t* vpid_ptd = vmm_cover_map_page(pid, PD_MOUNT_1, pid_ptd, PG_PREM_RW, PG_PREM_RW);
c0108b9f:	83 ec 0c             	sub    $0xc,%esp
c0108ba2:	6a 03                	push   $0x3
c0108ba4:	6a 03                	push   $0x3
c0108ba6:	ff 75 ec             	push   -0x14(%ebp)
c0108ba9:	68 00 00 c0 af       	push   $0xafc00000
c0108bae:	ff 75 08             	push   0x8(%ebp)
c0108bb1:	e8 0b e9 ff ff       	call   c01074c1 <vmm_cover_map_page>
c0108bb6:	83 c4 20             	add    $0x20,%esp
c0108bb9:	89 45 e8             	mov    %eax,-0x18(%ebp)
    ptd_t* mount_ptd = (ptd_t*)(mount_point | (0x3FFU << 12));
c0108bbc:	8b 45 0c             	mov    0xc(%ebp),%eax
c0108bbf:	0d 00 f0 3f 00       	or     $0x3ff000,%eax
c0108bc4:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    for(size_t i = 0; i < PG_MAX_ENTRIES - 1; i++)
c0108bc7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0108bce:	e9 e9 00 00 00       	jmp    c0108cbc <copy_page+0x136>
    {
        ptd_t mount_ptde = mount_ptd[i];
c0108bd3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108bd6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0108bdd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0108be0:	01 d0                	add    %edx,%eax
c0108be2:	8b 00                	mov    (%eax),%eax
c0108be4:	89 45 e0             	mov    %eax,-0x20(%ebp)
        if(!mount_point || !(mount_ptde & PG_PRESENT))
c0108be7:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0108beb:	74 0a                	je     c0108bf7 <copy_page+0x71>
c0108bed:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0108bf0:	83 e0 01             	and    $0x1,%eax
c0108bf3:	85 c0                	test   %eax,%eax
c0108bf5:	75 19                	jne    c0108c10 <copy_page+0x8a>
        {
            vpid_ptd[i] = mount_ptde;
c0108bf7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108bfa:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0108c01:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0108c04:	01 c2                	add    %eax,%edx
c0108c06:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0108c09:	89 02                	mov    %eax,(%edx)
            continue;
c0108c0b:	e9 a8 00 00 00       	jmp    c0108cb8 <copy_page+0x132>
        }

        void* pid_pt = pmm_alloc_page(pid, PP_FGPERSIST);
c0108c10:	83 ec 08             	sub    $0x8,%esp
c0108c13:	6a 01                	push   $0x1
c0108c15:	ff 75 08             	push   0x8(%ebp)
c0108c18:	e8 07 dc ff ff       	call   c0106824 <pmm_alloc_page>
c0108c1d:	83 c4 10             	add    $0x10,%esp
c0108c20:	89 45 dc             	mov    %eax,-0x24(%ebp)
        pt_t* vpid_pt = vmm_cover_map_page(pid, PG_MOUNT_2, pid_pt, PG_PREM_RW, PG_PREM_RW);
c0108c23:	83 ec 0c             	sub    $0xc,%esp
c0108c26:	6a 03                	push   $0x3
c0108c28:	6a 03                	push   $0x3
c0108c2a:	ff 75 dc             	push   -0x24(%ebp)
c0108c2d:	68 00 e0 7f af       	push   $0xaf7fe000
c0108c32:	ff 75 08             	push   0x8(%ebp)
c0108c35:	e8 87 e8 ff ff       	call   c01074c1 <vmm_cover_map_page>
c0108c3a:	83 c4 20             	add    $0x20,%esp
c0108c3d:	89 45 d8             	mov    %eax,-0x28(%ebp)
        pt_t* mount_pt = (ptd_t*)(mount_point | (i << 12));
c0108c40:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108c43:	c1 e0 0c             	shl    $0xc,%eax
c0108c46:	0b 45 0c             	or     0xc(%ebp),%eax
c0108c49:	89 45 d4             	mov    %eax,-0x2c(%ebp)

        for(size_t j = 0; j < PG_MAX_ENTRIES; j++)
c0108c4c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0108c53:	eb 43                	jmp    c0108c98 <copy_page+0x112>
        {
            pt_t mount_pte = mount_pt[j];
c0108c55:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0108c58:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0108c5f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0108c62:	01 d0                	add    %edx,%eax
c0108c64:	8b 00                	mov    (%eax),%eax
c0108c66:	89 45 d0             	mov    %eax,-0x30(%ebp)
            pmm_ref_page(pid, PG_ENTRY_ADDR(mount_pte));
c0108c69:	8b 45 d0             	mov    -0x30(%ebp),%eax
c0108c6c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0108c71:	83 ec 08             	sub    $0x8,%esp
c0108c74:	50                   	push   %eax
c0108c75:	ff 75 08             	push   0x8(%ebp)
c0108c78:	e8 6e dd ff ff       	call   c01069eb <pmm_ref_page>
c0108c7d:	83 c4 10             	add    $0x10,%esp
            vpid_pt[j] = mount_pte;
c0108c80:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0108c83:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0108c8a:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0108c8d:	01 c2                	add    %eax,%edx
c0108c8f:	8b 45 d0             	mov    -0x30(%ebp),%eax
c0108c92:	89 02                	mov    %eax,(%edx)
        for(size_t j = 0; j < PG_MAX_ENTRIES; j++)
c0108c94:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0108c98:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
c0108c9f:	76 b4                	jbe    c0108c55 <copy_page+0xcf>
        }

        vpid_ptd[i] = (uintptr_t)pid_pt | PG_PREM_RW;
c0108ca1:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0108ca4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108ca7:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
c0108cae:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0108cb1:	01 c8                	add    %ecx,%eax
c0108cb3:	83 ca 03             	or     $0x3,%edx
c0108cb6:	89 10                	mov    %edx,(%eax)
    for(size_t i = 0; i < PG_MAX_ENTRIES - 1; i++)
c0108cb8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0108cbc:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
c0108cc3:	0f 86 0a ff ff ff    	jbe    c0108bd3 <copy_page+0x4d>
    }

    vpid_ptd[PG_MAX_ENTRIES - 1] = PDE(T_SELF_REF_PERM, pid_ptd);
c0108cc9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0108ccc:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0108cd1:	89 c2                	mov    %eax,%edx
c0108cd3:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0108cd6:	05 fc 0f 00 00       	add    $0xffc,%eax
c0108cdb:	83 ca 1b             	or     $0x1b,%edx
c0108cde:	89 10                	mov    %edx,(%eax)

    return pid_ptd;
c0108ce0:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
c0108ce3:	c9                   	leave  
c0108ce4:	c3                   	ret    

c0108ce5 <copy_all_page>:

void* copy_all_page(struct m_pcb* proc, uintptr_t usedMnt)
{
c0108ce5:	55                   	push   %ebp
c0108ce6:	89 e5                	mov    %esp,%ebp
c0108ce8:	83 ec 28             	sub    $0x28,%esp
        // copy the entire kernel page table
    pid_t pid = proc->pid;
c0108ceb:	8b 45 08             	mov    0x8(%ebp),%eax
c0108cee:	8b 00                	mov    (%eax),%eax
c0108cf0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    void* pt_copy = copy_page(pid, usedMnt);
c0108cf3:	83 ec 08             	sub    $0x8,%esp
c0108cf6:	ff 75 0c             	push   0xc(%ebp)
c0108cf9:	ff 75 f0             	push   -0x10(%ebp)
c0108cfc:	e8 85 fe ff ff       	call   c0108b86 <copy_page>
c0108d01:	83 c4 10             	add    $0x10,%esp
c0108d04:	89 45 ec             	mov    %eax,-0x14(%ebp)

    vmm_mount_pd(PD_MOUNT_2, pt_copy); // 将新进程的页表挂载到挂载点#2
c0108d07:	83 ec 08             	sub    $0x8,%esp
c0108d0a:	ff 75 ec             	push   -0x14(%ebp)
c0108d0d:	68 00 00 80 af       	push   $0xaf800000
c0108d12:	e8 ee ed ff ff       	call   c0107b05 <vmm_mount_pd>
c0108d17:	83 c4 10             	add    $0x10,%esp

    // copy the kernel stack
    for (size_t i = KSTACK_START >> 12; i <= KSTACK_TOP >> 12; i++) {
c0108d1a:	c7 45 f4 f0 fb 0f 00 	movl   $0xffbf0,-0xc(%ebp)
c0108d21:	eb 6c                	jmp    c0108d8f <copy_all_page+0xaa>
        volatile pt_t* ppte = &PTE_MOUNTED(PD_MOUNT_2, i);
c0108d23:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108d26:	25 ff 03 00 00       	and    $0x3ff,%eax
c0108d2b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0108d32:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108d35:	c1 e0 02             	shl    $0x2,%eax
c0108d38:	25 00 f0 3f 00       	and    $0x3ff000,%eax
c0108d3d:	0d 00 00 80 af       	or     $0xaf800000,%eax
c0108d42:	01 d0                	add    %edx,%eax
c0108d44:	89 45 e8             	mov    %eax,-0x18(%ebp)

        /*
            The TLB caching keep the rewrite to PTE
            from updating. 
        */
        cpu_invplg(ppte);
c0108d47:	83 ec 0c             	sub    $0xc,%esp
c0108d4a:	ff 75 e8             	push   -0x18(%ebp)
c0108d4d:	e8 ef fd ff ff       	call   c0108b41 <cpu_invplg>
c0108d52:	83 c4 10             	add    $0x10,%esp

        pt_t p = *ppte;
c0108d55:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0108d58:	8b 00                	mov    (%eax),%eax
c0108d5a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        void* ppa = vmm_dup_page(pid, PG_ENTRY_ADDR(p));
c0108d5d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0108d60:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0108d65:	83 ec 08             	sub    $0x8,%esp
c0108d68:	50                   	push   %eax
c0108d69:	ff 75 f0             	push   -0x10(%ebp)
c0108d6c:	e8 02 ed ff ff       	call   c0107a73 <vmm_dup_page>
c0108d71:	83 c4 10             	add    $0x10,%esp
c0108d74:	89 45 e0             	mov    %eax,-0x20(%ebp)
        *ppte = (p & 0xfff) | (uintptr_t)ppa;
c0108d77:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0108d7a:	25 ff 0f 00 00       	and    $0xfff,%eax
c0108d7f:	89 c2                	mov    %eax,%edx
c0108d81:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0108d84:	09 c2                	or     %eax,%edx
c0108d86:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0108d89:	89 10                	mov    %edx,(%eax)
    for (size_t i = KSTACK_START >> 12; i <= KSTACK_TOP >> 12; i++) {
c0108d8b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0108d8f:	81 7d f4 ff fb 0f 00 	cmpl   $0xffbff,-0xc(%ebp)
c0108d96:	76 8b                	jbe    c0108d23 <copy_all_page+0x3e>
    // FIXME: 这里应该放到spawn_proc里面。
    // region_add(proc, USTACK_END, USTACK_SIZE, REGION_PRIVATE | REGION_RW);

    // 至于其他的区域我们暂时没有办法知道，因为那需要知道用户程序的信息。我们留到之后在处理。

    proc->page_table = pt_copy;
c0108d98:	8b 45 08             	mov    0x8(%ebp),%eax
c0108d9b:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0108d9e:	89 50 4c             	mov    %edx,0x4c(%eax)
}
c0108da1:	90                   	nop
c0108da2:	c9                   	leave  
c0108da3:	c3                   	ret    

c0108da4 <m_fork>:

pid_t m_fork()
{
c0108da4:	55                   	push   %ebp
c0108da5:	89 e5                	mov    %esp,%ebp
c0108da7:	81 ec 88 00 00 00    	sub    $0x88,%esp
    struct m_pcb curr_pcb;
    init_proc(&curr_pcb);
c0108dad:	83 ec 0c             	sub    $0xc,%esp
c0108db0:	8d 45 80             	lea    -0x80(%ebp),%eax
c0108db3:	50                   	push   %eax
c0108db4:	e8 ab fd ff ff       	call   c0108b64 <init_proc>
c0108db9:	83 c4 10             	add    $0x10,%esp

    curr_pcb.process_mm = __current->process_mm;
c0108dbc:	a1 40 a7 28 c0       	mov    0xc028a740,%eax
c0108dc1:	8b 40 48             	mov    0x48(%eax),%eax
c0108dc4:	89 45 c8             	mov    %eax,-0x38(%ebp)
    curr_pcb.intr_contxt = __current->intr_contxt;
c0108dc7:	a1 40 a7 28 c0       	mov    0xc028a740,%eax
c0108dcc:	8b 50 08             	mov    0x8(%eax),%edx
c0108dcf:	89 55 88             	mov    %edx,-0x78(%ebp)
c0108dd2:	8b 50 0c             	mov    0xc(%eax),%edx
c0108dd5:	89 55 8c             	mov    %edx,-0x74(%ebp)
c0108dd8:	8b 50 10             	mov    0x10(%eax),%edx
c0108ddb:	89 55 90             	mov    %edx,-0x70(%ebp)
c0108dde:	8b 50 14             	mov    0x14(%eax),%edx
c0108de1:	89 55 94             	mov    %edx,-0x6c(%ebp)
c0108de4:	8b 50 18             	mov    0x18(%eax),%edx
c0108de7:	89 55 98             	mov    %edx,-0x68(%ebp)
c0108dea:	8b 50 1c             	mov    0x1c(%eax),%edx
c0108ded:	89 55 9c             	mov    %edx,-0x64(%ebp)
c0108df0:	8b 50 20             	mov    0x20(%eax),%edx
c0108df3:	89 55 a0             	mov    %edx,-0x60(%ebp)
c0108df6:	8b 50 24             	mov    0x24(%eax),%edx
c0108df9:	89 55 a4             	mov    %edx,-0x5c(%ebp)
c0108dfc:	8b 50 28             	mov    0x28(%eax),%edx
c0108dff:	89 55 a8             	mov    %edx,-0x58(%ebp)
c0108e02:	8b 50 2c             	mov    0x2c(%eax),%edx
c0108e05:	89 55 ac             	mov    %edx,-0x54(%ebp)
c0108e08:	8b 50 30             	mov    0x30(%eax),%edx
c0108e0b:	89 55 b0             	mov    %edx,-0x50(%ebp)
c0108e0e:	8b 50 34             	mov    0x34(%eax),%edx
c0108e11:	89 55 b4             	mov    %edx,-0x4c(%ebp)
c0108e14:	8b 50 38             	mov    0x38(%eax),%edx
c0108e17:	89 55 b8             	mov    %edx,-0x48(%ebp)
c0108e1a:	8b 50 3c             	mov    0x3c(%eax),%edx
c0108e1d:	89 55 bc             	mov    %edx,-0x44(%ebp)
c0108e20:	8b 40 40             	mov    0x40(%eax),%eax
c0108e23:	89 45 c0             	mov    %eax,-0x40(%ebp)
    curr_pcb.parent = __current;
c0108e26:	a1 40 a7 28 c0       	mov    0xc028a740,%eax
c0108e2b:	89 45 84             	mov    %eax,-0x7c(%ebp)

#ifdef USE_KERNEL_PG
    copy_all_page(&pcb, PD_MOUNT_1); //挂载点#1是当前进程的页表
#else
    copy_all_page(&curr_pcb, PD_REFERENCED);
c0108e2e:	83 ec 08             	sub    $0x8,%esp
c0108e31:	68 00 00 c0 ff       	push   $0xffc00000
c0108e36:	8d 45 80             	lea    -0x80(%ebp),%eax
c0108e39:	50                   	push   %eax
c0108e3a:	e8 a6 fe ff ff       	call   c0108ce5 <copy_all_page>
c0108e3f:	83 c4 10             	add    $0x10,%esp
#endif

        // 根据 mm_region 进一步配置页表
    if (!__current->process_mm) {
c0108e42:	a1 40 a7 28 c0       	mov    0xc028a740,%eax
c0108e47:	8b 40 48             	mov    0x48(%eax),%eax
c0108e4a:	85 c0                	test   %eax,%eax
c0108e4c:	0f 84 62 01 00 00    	je     c0108fb4 <m_fork+0x210>
        goto not_copy;
    }

    llist_init_head(&curr_pcb.process_mm);
c0108e52:	83 ec 0c             	sub    $0xc,%esp
c0108e55:	8d 45 80             	lea    -0x80(%ebp),%eax
c0108e58:	83 c0 48             	add    $0x48,%eax
c0108e5b:	50                   	push   %eax
c0108e5c:	e8 ec fc ff ff       	call   c0108b4d <llist_init_head>
c0108e61:	83 c4 10             	add    $0x10,%esp
    struct mm_region *pos, *n;
    llist_for_each(pos, n, &__current->process_mm->head, head)
c0108e64:	a1 40 a7 28 c0       	mov    0xc028a740,%eax
c0108e69:	8b 40 48             	mov    0x48(%eax),%eax
c0108e6c:	8b 40 04             	mov    0x4(%eax),%eax
c0108e6f:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0108e72:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0108e75:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0108e78:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108e7b:	8b 40 04             	mov    0x4(%eax),%eax
c0108e7e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c0108e81:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0108e84:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0108e87:	e9 15 01 00 00       	jmp    c0108fa1 <m_fork+0x1fd>
    {
        region_add(&curr_pcb, pos->start, pos->end, pos->attr);
c0108e8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108e8f:	8b 48 10             	mov    0x10(%eax),%ecx
c0108e92:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108e95:	8b 50 0c             	mov    0xc(%eax),%edx
c0108e98:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108e9b:	8b 40 08             	mov    0x8(%eax),%eax
c0108e9e:	51                   	push   %ecx
c0108e9f:	52                   	push   %edx
c0108ea0:	50                   	push   %eax
c0108ea1:	8d 45 80             	lea    -0x80(%ebp),%eax
c0108ea4:	50                   	push   %eax
c0108ea5:	e8 be e1 ff ff       	call   c0107068 <region_add>
c0108eaa:	83 c4 10             	add    $0x10,%esp

        // 如果写共享，则不作处理。
        if ((pos->attr & REGION_WSHARED)) {
c0108ead:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108eb0:	8b 40 10             	mov    0x10(%eax),%eax
c0108eb3:	83 e0 02             	and    $0x2,%eax
c0108eb6:	85 c0                	test   %eax,%eax
c0108eb8:	0f 85 cd 00 00 00    	jne    c0108f8b <m_fork+0x1e7>
            continue;
        }

        uintptr_t start_vpn = PG_ALIGN(pos->start) >> 12;
c0108ebe:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108ec1:	8b 40 08             	mov    0x8(%eax),%eax
c0108ec4:	c1 e8 0c             	shr    $0xc,%eax
c0108ec7:	89 45 e0             	mov    %eax,-0x20(%ebp)
        uintptr_t end_vpn = PG_ALIGN(pos->end) >> 12;
c0108eca:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108ecd:	8b 40 0c             	mov    0xc(%eax),%eax
c0108ed0:	c1 e8 0c             	shr    $0xc,%eax
c0108ed3:	89 45 dc             	mov    %eax,-0x24(%ebp)
        for (size_t i = start_vpn; i < end_vpn; i++) {
c0108ed6:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0108ed9:	89 45 ec             	mov    %eax,-0x14(%ebp)
c0108edc:	e9 9c 00 00 00       	jmp    c0108f7d <m_fork+0x1d9>
            pt_t* curproc = &PTE_MOUNTED(PD_MOUNT_1, i);
c0108ee1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0108ee4:	25 ff 03 00 00       	and    $0x3ff,%eax
c0108ee9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0108ef0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0108ef3:	c1 e0 02             	shl    $0x2,%eax
c0108ef6:	25 00 f0 3f 00       	and    $0x3ff000,%eax
c0108efb:	0d 00 00 c0 af       	or     $0xafc00000,%eax
c0108f00:	01 d0                	add    %edx,%eax
c0108f02:	89 45 d8             	mov    %eax,-0x28(%ebp)
            pt_t* newproc = &PTE_MOUNTED(PD_MOUNT_2, i);
c0108f05:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0108f08:	25 ff 03 00 00       	and    $0x3ff,%eax
c0108f0d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0108f14:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0108f17:	c1 e0 02             	shl    $0x2,%eax
c0108f1a:	25 00 f0 3f 00       	and    $0x3ff000,%eax
c0108f1f:	0d 00 00 80 af       	or     $0xaf800000,%eax
c0108f24:	01 d0                	add    %edx,%eax
c0108f26:	89 45 d4             	mov    %eax,-0x2c(%ebp)
            cpu_invplg(newproc);
c0108f29:	83 ec 0c             	sub    $0xc,%esp
c0108f2c:	ff 75 d4             	push   -0x2c(%ebp)
c0108f2f:	e8 0d fc ff ff       	call   c0108b41 <cpu_invplg>
c0108f34:	83 c4 10             	add    $0x10,%esp

            if (pos->attr == REGION_RSHARED) {
c0108f37:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108f3a:	8b 40 10             	mov    0x10(%eax),%eax
c0108f3d:	83 f8 01             	cmp    $0x1,%eax
c0108f40:	75 2e                	jne    c0108f70 <m_fork+0x1cc>
                // 如果读共享，则将两者的都标注为只读，那么任何写入都将会应用COW策略。
                cpu_invplg(curproc);
c0108f42:	83 ec 0c             	sub    $0xc,%esp
c0108f45:	ff 75 d8             	push   -0x28(%ebp)
c0108f48:	e8 f4 fb ff ff       	call   c0108b41 <cpu_invplg>
c0108f4d:	83 c4 10             	add    $0x10,%esp
                *curproc = *curproc & ~PG_WRITE;
c0108f50:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0108f53:	8b 00                	mov    (%eax),%eax
c0108f55:	83 e0 fd             	and    $0xfffffffd,%eax
c0108f58:	89 c2                	mov    %eax,%edx
c0108f5a:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0108f5d:	89 10                	mov    %edx,(%eax)
                *newproc = *newproc & ~PG_WRITE;
c0108f5f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0108f62:	8b 00                	mov    (%eax),%eax
c0108f64:	83 e0 fd             	and    $0xfffffffd,%eax
c0108f67:	89 c2                	mov    %eax,%edx
c0108f69:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0108f6c:	89 10                	mov    %edx,(%eax)
c0108f6e:	eb 09                	jmp    c0108f79 <m_fork+0x1d5>
            } else {
                // 如果是私有页，则将该页从新进程中移除。
                *newproc = 0;
c0108f70:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0108f73:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        for (size_t i = start_vpn; i < end_vpn; i++) {
c0108f79:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0108f7d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0108f80:	3b 45 dc             	cmp    -0x24(%ebp),%eax
c0108f83:	0f 82 58 ff ff ff    	jb     c0108ee1 <m_fork+0x13d>
c0108f89:	eb 01                	jmp    c0108f8c <m_fork+0x1e8>
            continue;
c0108f8b:	90                   	nop
    llist_for_each(pos, n, &__current->process_mm->head, head)
c0108f8c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0108f8f:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0108f92:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0108f95:	8b 40 04             	mov    0x4(%eax),%eax
c0108f98:	89 45 d0             	mov    %eax,-0x30(%ebp)
c0108f9b:	8b 45 d0             	mov    -0x30(%ebp),%eax
c0108f9e:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0108fa1:	a1 40 a7 28 c0       	mov    0xc028a740,%eax
c0108fa6:	8b 40 48             	mov    0x48(%eax),%eax
c0108fa9:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0108fac:	0f 85 da fe ff ff    	jne    c0108e8c <m_fork+0xe8>
            }
        }
    }

not_copy:
c0108fb2:	eb 01                	jmp    c0108fb5 <m_fork+0x211>
        goto not_copy;
c0108fb4:	90                   	nop
    vmm_unmount_pd(PD_MOUNT_2);
c0108fb5:	83 ec 0c             	sub    $0xc,%esp
c0108fb8:	68 00 00 80 af       	push   $0xaf800000
c0108fbd:	e8 82 eb ff ff       	call   c0107b44 <vmm_unmount_pd>
c0108fc2:	83 c4 10             	add    $0x10,%esp

    // 正如同fork，返回两次。
    curr_pcb.intr_contxt.registers.eax = 0;
c0108fc5:	c7 45 88 00 00 00 00 	movl   $0x0,-0x78(%ebp)

    //push_process(&curr_pcb);

    return curr_pcb.pid;
c0108fcc:	8b 45 80             	mov    -0x80(%ebp),%eax
c0108fcf:	c9                   	leave  
c0108fd0:	c3                   	ret    

c0108fd1 <kprintf>:
#include <libs/mstdio.h>
#include <vga/vga.h>
void kprintf (const char *format, ...)
{
c0108fd1:	55                   	push   %ebp
c0108fd2:	89 e5                	mov    %esp,%ebp
c0108fd4:	83 ec 38             	sub    $0x38,%esp
  char **arg = (char **) &format;
c0108fd7:	8d 45 08             	lea    0x8(%ebp),%eax
c0108fda:	89 45 f4             	mov    %eax,-0xc(%ebp)
  int c;
  char buf[20];

  arg++;
c0108fdd:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
  while ((c = *format++) != 0)
c0108fe1:	e9 83 01 00 00       	jmp    c0109169 <kprintf+0x198>
    {
      if (c != '%')
c0108fe6:	83 7d f0 25          	cmpl   $0x25,-0x10(%ebp)
c0108fea:	74 17                	je     c0109003 <kprintf+0x32>
        vga_put_char (c);
c0108fec:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0108fef:	0f be c0             	movsbl %al,%eax
c0108ff2:	83 ec 0c             	sub    $0xc,%esp
c0108ff5:	50                   	push   %eax
c0108ff6:	e8 23 d0 ff ff       	call   c010601e <vga_put_char>
c0108ffb:	83 c4 10             	add    $0x10,%esp
c0108ffe:	e9 66 01 00 00       	jmp    c0109169 <kprintf+0x198>
      else
        {
          char *p, *p2;
          int pad0 = 0, pad = 0;
c0109003:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
c010900a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
          
          c = *format++;
c0109011:	8b 45 08             	mov    0x8(%ebp),%eax
c0109014:	8d 50 01             	lea    0x1(%eax),%edx
c0109017:	89 55 08             	mov    %edx,0x8(%ebp)
c010901a:	0f b6 00             	movzbl (%eax),%eax
c010901d:	0f be c0             	movsbl %al,%eax
c0109020:	89 45 f0             	mov    %eax,-0x10(%ebp)
          if (c == '0')
c0109023:	83 7d f0 30          	cmpl   $0x30,-0x10(%ebp)
c0109027:	75 19                	jne    c0109042 <kprintf+0x71>
            {
              pad0 = 1;
c0109029:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
              c = *format++;
c0109030:	8b 45 08             	mov    0x8(%ebp),%eax
c0109033:	8d 50 01             	lea    0x1(%eax),%edx
c0109036:	89 55 08             	mov    %edx,0x8(%ebp)
c0109039:	0f b6 00             	movzbl (%eax),%eax
c010903c:	0f be c0             	movsbl %al,%eax
c010903f:	89 45 f0             	mov    %eax,-0x10(%ebp)
            }

          if (c >= '0' && c <= '9')
c0109042:	83 7d f0 2f          	cmpl   $0x2f,-0x10(%ebp)
c0109046:	7e 21                	jle    c0109069 <kprintf+0x98>
c0109048:	83 7d f0 39          	cmpl   $0x39,-0x10(%ebp)
c010904c:	7f 1b                	jg     c0109069 <kprintf+0x98>
            {
              pad = c - '0';
c010904e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109051:	83 e8 30             	sub    $0x30,%eax
c0109054:	89 45 e0             	mov    %eax,-0x20(%ebp)
              c = *format++;
c0109057:	8b 45 08             	mov    0x8(%ebp),%eax
c010905a:	8d 50 01             	lea    0x1(%eax),%edx
c010905d:	89 55 08             	mov    %edx,0x8(%ebp)
c0109060:	0f b6 00             	movzbl (%eax),%eax
c0109063:	0f be c0             	movsbl %al,%eax
c0109066:	89 45 f0             	mov    %eax,-0x10(%ebp)
            }

          switch (c)
c0109069:	83 7d f0 78          	cmpl   $0x78,-0x10(%ebp)
c010906d:	74 2b                	je     c010909a <kprintf+0xc9>
c010906f:	83 7d f0 78          	cmpl   $0x78,-0x10(%ebp)
c0109073:	0f 8f d5 00 00 00    	jg     c010914e <kprintf+0x17d>
c0109079:	83 7d f0 75          	cmpl   $0x75,-0x10(%ebp)
c010907d:	74 1b                	je     c010909a <kprintf+0xc9>
c010907f:	83 7d f0 75          	cmpl   $0x75,-0x10(%ebp)
c0109083:	0f 8f c5 00 00 00    	jg     c010914e <kprintf+0x17d>
c0109089:	83 7d f0 64          	cmpl   $0x64,-0x10(%ebp)
c010908d:	74 0b                	je     c010909a <kprintf+0xc9>
c010908f:	83 7d f0 73          	cmpl   $0x73,-0x10(%ebp)
c0109093:	74 2b                	je     c01090c0 <kprintf+0xef>
c0109095:	e9 b4 00 00 00       	jmp    c010914e <kprintf+0x17d>
            {
            case 'd':
            case 'u':
            case 'x':
              itoa (buf, c, *((int *) arg++));
c010909a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010909d:	8d 50 04             	lea    0x4(%eax),%edx
c01090a0:	89 55 f4             	mov    %edx,-0xc(%ebp)
c01090a3:	8b 00                	mov    (%eax),%eax
c01090a5:	83 ec 04             	sub    $0x4,%esp
c01090a8:	50                   	push   %eax
c01090a9:	ff 75 f0             	push   -0x10(%ebp)
c01090ac:	8d 45 cc             	lea    -0x34(%ebp),%eax
c01090af:	50                   	push   %eax
c01090b0:	e8 d4 00 00 00       	call   c0109189 <itoa>
c01090b5:	83 c4 10             	add    $0x10,%esp
              p = buf;
c01090b8:	8d 45 cc             	lea    -0x34(%ebp),%eax
c01090bb:	89 45 ec             	mov    %eax,-0x14(%ebp)
              goto string;
c01090be:	eb 1e                	jmp    c01090de <kprintf+0x10d>
              break;

            case 's':
              p = *arg++;
c01090c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01090c3:	8d 50 04             	lea    0x4(%eax),%edx
c01090c6:	89 55 f4             	mov    %edx,-0xc(%ebp)
c01090c9:	8b 00                	mov    (%eax),%eax
c01090cb:	89 45 ec             	mov    %eax,-0x14(%ebp)
              if (! p)
c01090ce:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c01090d2:	75 09                	jne    c01090dd <kprintf+0x10c>
                p = "(null)";
c01090d4:	c7 45 ec c4 c5 28 c0 	movl   $0xc028c5c4,-0x14(%ebp)
c01090db:	eb 01                	jmp    c01090de <kprintf+0x10d>

            string:
c01090dd:	90                   	nop
              for (p2 = p; *p2; p2++);
c01090de:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01090e1:	89 45 e8             	mov    %eax,-0x18(%ebp)
c01090e4:	eb 04                	jmp    c01090ea <kprintf+0x119>
c01090e6:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
c01090ea:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01090ed:	0f b6 00             	movzbl (%eax),%eax
c01090f0:	84 c0                	test   %al,%al
c01090f2:	75 f2                	jne    c01090e6 <kprintf+0x115>
              for (; p2 < p + pad; p2++)
c01090f4:	eb 22                	jmp    c0109118 <kprintf+0x147>
                vga_put_char (pad0 ? '0' : ' ');
c01090f6:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c01090fa:	74 07                	je     c0109103 <kprintf+0x132>
c01090fc:	b8 30 00 00 00       	mov    $0x30,%eax
c0109101:	eb 05                	jmp    c0109108 <kprintf+0x137>
c0109103:	b8 20 00 00 00       	mov    $0x20,%eax
c0109108:	83 ec 0c             	sub    $0xc,%esp
c010910b:	50                   	push   %eax
c010910c:	e8 0d cf ff ff       	call   c010601e <vga_put_char>
c0109111:	83 c4 10             	add    $0x10,%esp
              for (; p2 < p + pad; p2++)
c0109114:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
c0109118:	8b 55 e0             	mov    -0x20(%ebp),%edx
c010911b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010911e:	01 d0                	add    %edx,%eax
c0109120:	39 45 e8             	cmp    %eax,-0x18(%ebp)
c0109123:	72 d1                	jb     c01090f6 <kprintf+0x125>
              while (*p)
c0109125:	eb 1b                	jmp    c0109142 <kprintf+0x171>
                vga_put_char (*p++);
c0109127:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010912a:	8d 50 01             	lea    0x1(%eax),%edx
c010912d:	89 55 ec             	mov    %edx,-0x14(%ebp)
c0109130:	0f b6 00             	movzbl (%eax),%eax
c0109133:	0f be c0             	movsbl %al,%eax
c0109136:	83 ec 0c             	sub    $0xc,%esp
c0109139:	50                   	push   %eax
c010913a:	e8 df ce ff ff       	call   c010601e <vga_put_char>
c010913f:	83 c4 10             	add    $0x10,%esp
              while (*p)
c0109142:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0109145:	0f b6 00             	movzbl (%eax),%eax
c0109148:	84 c0                	test   %al,%al
c010914a:	75 db                	jne    c0109127 <kprintf+0x156>
              break;
c010914c:	eb 1b                	jmp    c0109169 <kprintf+0x198>

            default:
              vga_put_char (*((int *) arg++));
c010914e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109151:	8d 50 04             	lea    0x4(%eax),%edx
c0109154:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0109157:	8b 00                	mov    (%eax),%eax
c0109159:	0f be c0             	movsbl %al,%eax
c010915c:	83 ec 0c             	sub    $0xc,%esp
c010915f:	50                   	push   %eax
c0109160:	e8 b9 ce ff ff       	call   c010601e <vga_put_char>
c0109165:	83 c4 10             	add    $0x10,%esp
              break;
c0109168:	90                   	nop
  while ((c = *format++) != 0)
c0109169:	8b 45 08             	mov    0x8(%ebp),%eax
c010916c:	8d 50 01             	lea    0x1(%eax),%edx
c010916f:	89 55 08             	mov    %edx,0x8(%ebp)
c0109172:	0f b6 00             	movzbl (%eax),%eax
c0109175:	0f be c0             	movsbl %al,%eax
c0109178:	89 45 f0             	mov    %eax,-0x10(%ebp)
c010917b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c010917f:	0f 85 61 fe ff ff    	jne    c0108fe6 <kprintf+0x15>
            }
        }
    }
}
c0109185:	90                   	nop
c0109186:	90                   	nop
c0109187:	c9                   	leave  
c0109188:	c3                   	ret    

c0109189 <itoa>:
#include <libs/mstdlib.h>

void
itoa (char *buf, int base, int d)
{
c0109189:	55                   	push   %ebp
c010918a:	89 e5                	mov    %esp,%ebp
c010918c:	83 ec 20             	sub    $0x20,%esp
  char *p = buf;
c010918f:	8b 45 08             	mov    0x8(%ebp),%eax
c0109192:	89 45 fc             	mov    %eax,-0x4(%ebp)
  char *p1, *p2;
  unsigned long ud = d;
c0109195:	8b 45 10             	mov    0x10(%ebp),%eax
c0109198:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int divisor = 10;
c010919b:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
  
  /* If %d is specified and D is minus, put ‘-’ in the head. */
  if (base == 'd' && d < 0)
c01091a2:	83 7d 0c 64          	cmpl   $0x64,0xc(%ebp)
c01091a6:	75 20                	jne    c01091c8 <itoa+0x3f>
c01091a8:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c01091ac:	79 1a                	jns    c01091c8 <itoa+0x3f>
    {
      *p++ = '-';
c01091ae:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01091b1:	8d 50 01             	lea    0x1(%eax),%edx
c01091b4:	89 55 fc             	mov    %edx,-0x4(%ebp)
c01091b7:	c6 00 2d             	movb   $0x2d,(%eax)
      buf++;
c01091ba:	83 45 08 01          	addl   $0x1,0x8(%ebp)
      ud = -d;
c01091be:	8b 45 10             	mov    0x10(%ebp),%eax
c01091c1:	f7 d8                	neg    %eax
c01091c3:	89 45 f0             	mov    %eax,-0x10(%ebp)
c01091c6:	eb 0d                	jmp    c01091d5 <itoa+0x4c>
    }
  else if (base == 'x')
c01091c8:	83 7d 0c 78          	cmpl   $0x78,0xc(%ebp)
c01091cc:	75 07                	jne    c01091d5 <itoa+0x4c>
    divisor = 16;
c01091ce:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)

  /* Divide UD by DIVISOR until UD == 0. */
  do
    {
      int remainder = ud % divisor;
c01091d5:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c01091d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01091db:	ba 00 00 00 00       	mov    $0x0,%edx
c01091e0:	f7 f1                	div    %ecx
c01091e2:	89 d0                	mov    %edx,%eax
c01091e4:	89 45 e8             	mov    %eax,-0x18(%ebp)
      
      *p++ = (remainder < 10) ? remainder + '0' : remainder + 'a' - 10;
c01091e7:	83 7d e8 09          	cmpl   $0x9,-0x18(%ebp)
c01091eb:	7f 0a                	jg     c01091f7 <itoa+0x6e>
c01091ed:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01091f0:	83 c0 30             	add    $0x30,%eax
c01091f3:	89 c1                	mov    %eax,%ecx
c01091f5:	eb 08                	jmp    c01091ff <itoa+0x76>
c01091f7:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01091fa:	83 c0 57             	add    $0x57,%eax
c01091fd:	89 c1                	mov    %eax,%ecx
c01091ff:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0109202:	8d 50 01             	lea    0x1(%eax),%edx
c0109205:	89 55 fc             	mov    %edx,-0x4(%ebp)
c0109208:	88 08                	mov    %cl,(%eax)
    }
  while (ud /= divisor);
c010920a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c010920d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109210:	ba 00 00 00 00       	mov    $0x0,%edx
c0109215:	f7 f1                	div    %ecx
c0109217:	89 45 f0             	mov    %eax,-0x10(%ebp)
c010921a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c010921e:	75 b5                	jne    c01091d5 <itoa+0x4c>

  /* Terminate BUF. */
  *p = 0;
c0109220:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0109223:	c6 00 00             	movb   $0x0,(%eax)
  
  /* Reverse BUF. */
  p1 = buf;
c0109226:	8b 45 08             	mov    0x8(%ebp),%eax
c0109229:	89 45 f8             	mov    %eax,-0x8(%ebp)
  p2 = p - 1;
c010922c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010922f:	83 e8 01             	sub    $0x1,%eax
c0109232:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (p1 < p2)
c0109235:	eb 25                	jmp    c010925c <itoa+0xd3>
    {
      char tmp = *p1;
c0109237:	8b 45 f8             	mov    -0x8(%ebp),%eax
c010923a:	0f b6 00             	movzbl (%eax),%eax
c010923d:	88 45 e7             	mov    %al,-0x19(%ebp)
      *p1 = *p2;
c0109240:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109243:	0f b6 10             	movzbl (%eax),%edx
c0109246:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0109249:	88 10                	mov    %dl,(%eax)
      *p2 = tmp;
c010924b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010924e:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
c0109252:	88 10                	mov    %dl,(%eax)
      p1++;
c0109254:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
      p2--;
c0109258:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
  while (p1 < p2)
c010925c:	8b 45 f8             	mov    -0x8(%ebp),%eax
c010925f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0109262:	72 d3                	jb     c0109237 <itoa+0xae>
    }
c0109264:	90                   	nop
c0109265:	90                   	nop
c0109266:	c9                   	leave  
c0109267:	c3                   	ret    

c0109268 <memset>:
#include <libs/mstring.h>
#include <stdint.h>

void* memset(void* ptr, int value, size_t num)
{
c0109268:	55                   	push   %ebp
c0109269:	89 e5                	mov    %esp,%ebp
c010926b:	83 ec 10             	sub    $0x10,%esp
    uint8_t* c_ptr = (uint8_t*)ptr;
c010926e:	8b 45 08             	mov    0x8(%ebp),%eax
c0109271:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for (size_t i = 0; i < num; i++) {
c0109274:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c010927b:	eb 11                	jmp    c010928e <memset+0x26>
        *(c_ptr + i) = (uint8_t)value;
c010927d:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0109280:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0109283:	01 d0                	add    %edx,%eax
c0109285:	8b 55 0c             	mov    0xc(%ebp),%edx
c0109288:	88 10                	mov    %dl,(%eax)
    for (size_t i = 0; i < num; i++) {
c010928a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c010928e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0109291:	3b 45 10             	cmp    0x10(%ebp),%eax
c0109294:	72 e7                	jb     c010927d <memset+0x15>
    }
    return ptr;
c0109296:	8b 45 08             	mov    0x8(%ebp),%eax
c0109299:	c9                   	leave  
c010929a:	c3                   	ret    
