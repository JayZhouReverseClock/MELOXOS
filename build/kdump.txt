
build/bin/melox.bin:     file format elf32-i386


Disassembly of section .virk_init_text:

00100000 <start-0xc>:
  100000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
  100006:	00 00                	add    %al,(%eax)
  100008:	fb                   	sti    
  100009:	4f                   	dec    %edi
  10000a:	52                   	push   %edx
  10000b:	e4                   	.byte 0xe4

0010000c <start>:
  10000c:	bc 00 60 10 00       	mov    $0x106000,%esp
  100011:	68 00 10 10 00       	push   $0x101000
  100016:	53                   	push   %ebx
  100017:	e8 64 00 00 00       	call   100080 <save_multiboot_info>
  10001c:	58                   	pop    %eax
  10001d:	58                   	pop    %eax
  10001e:	68 00 60 00 00       	push   $0x6000
  100023:	68 00 b0 12 00       	push   $0x12b000
  100028:	e8 a4 02 00 00       	call   1002d1 <kerner_init>
  10002d:	8b 04 24             	mov    (%esp),%eax
  100030:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  100035:	0f 22 d8             	mov    %eax,%cr3
  100038:	0f 20 c0             	mov    %cr0,%eax
  10003b:	0d 00 00 00 80       	or     $0x80000000,%eax
  100040:	0f 22 c0             	mov    %eax,%cr0
  100043:	58                   	pop    %eax
  100044:	58                   	pop    %eax
  100045:	68 f7 73 10 c0       	push   $0xc01073f7
  10004a:	c3                   	ret    

0010004b <_save_>:
extern uint8_t virkernel_start;
extern uint8_t virkernel_end ;
extern uint8_t __init_phykernel_end;
extern uint8_t _kernel_stack;

uint32_t _save_(uint8_t* destination, uint8_t* base, multiboot_uint32_t size) {
  10004b:	55                   	push   %ebp
  10004c:	89 e5                	mov    %esp,%ebp
  10004e:	83 ec 10             	sub    $0x10,%esp
    multiboot_uint32_t i = 0;
  100051:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    for (; i < size; i++)
  100058:	eb 19                	jmp    100073 <_save_+0x28>
    {
        *(destination + i) = *(base + i);
  10005a:	8b 55 0c             	mov    0xc(%ebp),%edx
  10005d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100060:	01 d0                	add    %edx,%eax
  100062:	8b 4d 08             	mov    0x8(%ebp),%ecx
  100065:	8b 55 fc             	mov    -0x4(%ebp),%edx
  100068:	01 ca                	add    %ecx,%edx
  10006a:	0f b6 00             	movzbl (%eax),%eax
  10006d:	88 02                	mov    %al,(%edx)
    for (; i < size; i++)
  10006f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  100073:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100076:	3b 45 10             	cmp    0x10(%ebp),%eax
  100079:	72 df                	jb     10005a <_save_+0xf>
    }
    return i;
  10007b:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  10007e:	c9                   	leave  
  10007f:	c3                   	ret    

00100080 <save_multiboot_info>:

void save_multiboot_info(multiboot_info_t* mb_info, multiboot_uint8_t* dest)
{
  100080:	55                   	push   %ebp
  100081:	89 e5                	mov    %esp,%ebp
  100083:	53                   	push   %ebx
  100084:	83 ec 10             	sub    $0x10,%esp
    uint32_t current = 0;
  100087:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    uint8_t* info_b = (uint8_t*) mb_info;
  10008e:	8b 45 08             	mov    0x8(%ebp),%eax
  100091:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for (; current < sizeof(multiboot_info_t); current++)
  100094:	eb 19                	jmp    1000af <save_multiboot_info+0x2f>
    {
        *(dest + current) = *(info_b + current);
  100096:	8b 55 f4             	mov    -0xc(%ebp),%edx
  100099:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10009c:	01 d0                	add    %edx,%eax
  10009e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1000a1:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1000a4:	01 ca                	add    %ecx,%edx
  1000a6:	0f b6 00             	movzbl (%eax),%eax
  1000a9:	88 02                	mov    %al,(%edx)
    for (; current < sizeof(multiboot_info_t); current++)
  1000ab:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  1000af:	83 7d f8 77          	cmpl   $0x77,-0x8(%ebp)
  1000b3:	76 e1                	jbe    100096 <save_multiboot_info+0x16>
    }

    ((multiboot_info_t*) dest)->mmap_addr = (uintptr_t)dest + current;
  1000b5:	8b 55 0c             	mov    0xc(%ebp),%edx
  1000b8:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1000bb:	01 c2                	add    %eax,%edx
  1000bd:	8b 45 0c             	mov    0xc(%ebp),%eax
  1000c0:	89 50 30             	mov    %edx,0x30(%eax)
    current += _save_(dest + current, (uint8_t*)mb_info->mmap_addr, mb_info->mmap_length);
  1000c3:	8b 45 08             	mov    0x8(%ebp),%eax
  1000c6:	8b 40 2c             	mov    0x2c(%eax),%eax
  1000c9:	8b 55 08             	mov    0x8(%ebp),%edx
  1000cc:	8b 52 30             	mov    0x30(%edx),%edx
  1000cf:	89 d1                	mov    %edx,%ecx
  1000d1:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  1000d4:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1000d7:	01 da                	add    %ebx,%edx
  1000d9:	50                   	push   %eax
  1000da:	51                   	push   %ecx
  1000db:	52                   	push   %edx
  1000dc:	e8 6a ff ff ff       	call   10004b <_save_>
  1000e1:	83 c4 0c             	add    $0xc,%esp
  1000e4:	01 45 f8             	add    %eax,-0x8(%ebp)

    if (present(mb_info->flags, MULTIBOOT_INFO_DRIVE_INFO)) {
  1000e7:	8b 45 08             	mov    0x8(%ebp),%eax
  1000ea:	8b 00                	mov    (%eax),%eax
  1000ec:	25 80 00 00 00       	and    $0x80,%eax
  1000f1:	85 c0                	test   %eax,%eax
  1000f3:	74 32                	je     100127 <save_multiboot_info+0xa7>
        ((multiboot_info_t*) dest)->drives_addr = (uintptr_t)dest + current;
  1000f5:	8b 55 0c             	mov    0xc(%ebp),%edx
  1000f8:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1000fb:	01 c2                	add    %eax,%edx
  1000fd:	8b 45 0c             	mov    0xc(%ebp),%eax
  100100:	89 50 38             	mov    %edx,0x38(%eax)
        current += _save_(dest + current, (uint8_t*)mb_info->drives_addr, mb_info->drives_length);
  100103:	8b 45 08             	mov    0x8(%ebp),%eax
  100106:	8b 40 34             	mov    0x34(%eax),%eax
  100109:	8b 55 08             	mov    0x8(%ebp),%edx
  10010c:	8b 52 38             	mov    0x38(%edx),%edx
  10010f:	89 d1                	mov    %edx,%ecx
  100111:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  100114:	8b 55 f8             	mov    -0x8(%ebp),%edx
  100117:	01 da                	add    %ebx,%edx
  100119:	50                   	push   %eax
  10011a:	51                   	push   %ecx
  10011b:	52                   	push   %edx
  10011c:	e8 2a ff ff ff       	call   10004b <_save_>
  100121:	83 c4 0c             	add    $0xc,%esp
  100124:	01 45 f8             	add    %eax,-0x8(%ebp)
    }
    multiboot_info_t* test = (multiboot_info_t*) dest;
  100127:	8b 45 0c             	mov    0xc(%ebp),%eax
  10012a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    multiboot_memory_map_t* testmap = (multiboot_memory_map_t*)mb_info->mmap_addr;
  10012d:	8b 45 08             	mov    0x8(%ebp),%eax
  100130:	8b 40 30             	mov    0x30(%eax),%eax
  100133:	89 45 ec             	mov    %eax,-0x14(%ebp)
}
  100136:	90                   	nop
  100137:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  10013a:	c9                   	leave  
  10013b:	c3                   	ret    

0010013c <init_page>:

void init_page(ptd_t* pt)
{
  10013c:	55                   	push   %ebp
  10013d:	89 e5                	mov    %esp,%ebp
  10013f:	83 ec 30             	sub    $0x30,%esp
    SET_PDE(pt, 0, PDE(PG_PRESENT, pt + PG_MAX_ENTRIES));
  100142:	8b 45 08             	mov    0x8(%ebp),%eax
  100145:	05 00 10 00 00       	add    $0x1000,%eax
  10014a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  10014f:	83 c8 01             	or     $0x1,%eax
  100152:	89 c2                	mov    %eax,%edx
  100154:	8b 45 08             	mov    0x8(%ebp),%eax
  100157:	89 10                	mov    %edx,(%eax)
    ptd_t * tmp_paged_phy_addr = pt;
  100159:	8b 45 08             	mov    0x8(%ebp),%eax
  10015c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    ptd_t * tmp_paget_phy_addr = pt + 1024;
  10015f:	8b 45 08             	mov    0x8(%ebp),%eax
  100162:	05 00 10 00 00       	add    $0x1000,%eax
  100167:	89 45 e8             	mov    %eax,-0x18(%ebp)
    //identity map 1M memory
    for(uint32_t i = 0; i < 256; i++)
  10016a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  100171:	eb 20                	jmp    100193 <init_page+0x57>
        *(tmp_paget_phy_addr + i) = ((i << 12) & 0xFFFFF000UL) | (PG_PREM_RW & 0xfff);
  100173:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100176:	c1 e0 0c             	shl    $0xc,%eax
  100179:	89 c2                	mov    %eax,%edx
  10017b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10017e:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
  100185:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100188:	01 c8                	add    %ecx,%eax
  10018a:	83 ca 03             	or     $0x3,%edx
  10018d:	89 10                	mov    %edx,(%eax)
    for(uint32_t i = 0; i < 256; i++)
  10018f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  100193:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%ebp)
  10019a:	76 d7                	jbe    100173 <init_page+0x37>

    //identity map virkernel_init memory
    for(uint32_t i = 0; i < LOADOS_PAGE_COUNT; i++)
  10019c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  1001a3:	eb 29                	jmp    1001ce <init_page+0x92>
        *(tmp_paget_phy_addr + i + 256) = (((i << 12) + MEM_1M) & 0xFFFFF000UL) | (PG_PREM_RW & 0xfff);
  1001a5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1001a8:	c1 e0 0c             	shl    $0xc,%eax
  1001ab:	8d 90 00 00 10 00    	lea    0x100000(%eax),%edx
  1001b1:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1001b4:	05 00 01 00 00       	add    $0x100,%eax
  1001b9:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
  1001c0:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1001c3:	01 c8                	add    %ecx,%eax
  1001c5:	83 ca 03             	or     $0x3,%edx
  1001c8:	89 10                	mov    %edx,(%eax)
    for(uint32_t i = 0; i < LOADOS_PAGE_COUNT; i++)
  1001ca:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  1001ce:	b8 00 60 10 00       	mov    $0x106000,%eax
  1001d3:	2d 01 f0 0f 00       	sub    $0xff001,%eax
  1001d8:	c1 e8 0c             	shr    $0xc,%eax
  1001db:	39 45 f8             	cmp    %eax,-0x8(%ebp)
  1001de:	72 c5                	jb     1001a5 <init_page+0x69>

    //now we map the kernel
    //calculate the virtrue kernrl page index
    uint32_t virk_pde_index = PD_INDEX(sym_val(virkernel_start));
  1001e0:	b8 00 60 10 c0       	mov    $0xc0106000,%eax
  1001e5:	c1 e8 16             	shr    $0x16,%eax
  1001e8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uint32_t virk_pte_index = PT_INDEX(sym_val(virkernel_start));
  1001eb:	b8 00 60 10 c0       	mov    $0xc0106000,%eax
  1001f0:	c1 e8 0c             	shr    $0xc,%eax
  1001f3:	25 ff 03 00 00       	and    $0x3ff,%eax
  1001f8:	89 45 e0             	mov    %eax,-0x20(%ebp)
    uint32_t virk_pg_counts = KERNEL_PAGE_COUNT;
  1001fb:	b8 00 10 13 c0       	mov    $0xc0131000,%eax
  100200:	05 00 10 00 00       	add    $0x1000,%eax
  100205:	83 e8 01             	sub    $0x1,%eax
  100208:	ba 00 60 10 c0       	mov    $0xc0106000,%edx
  10020d:	29 d0                	sub    %edx,%eax
  10020f:	c1 e8 0c             	shr    $0xc,%eax
  100212:	89 45 dc             	mov    %eax,-0x24(%ebp)

    //regist the vir_kernel page to page direction
    //we give 3 pagetable to virkel, is 3 * 4 = 12 mib size
    for(uint32_t i = 0; i < PG_TABLE_STACK - PG_TABLE_KERNEL; i++)
  100215:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  10021c:	eb 34                	jmp    100252 <init_page+0x116>
    {
        *(tmp_paged_phy_addr + virk_pde_index + i) = PDE(PG_PREM_RW, PT_ADDR(pt, PG_TABLE_KERNEL + i));
  10021e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100221:	83 c0 02             	add    $0x2,%eax
  100224:	c1 e0 0c             	shl    $0xc,%eax
  100227:	89 c2                	mov    %eax,%edx
  100229:	8b 45 08             	mov    0x8(%ebp),%eax
  10022c:	01 d0                	add    %edx,%eax
  10022e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  100233:	89 c2                	mov    %eax,%edx
  100235:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  100238:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10023b:	01 c8                	add    %ecx,%eax
  10023d:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
  100244:	8b 45 ec             	mov    -0x14(%ebp),%eax
  100247:	01 c8                	add    %ecx,%eax
  100249:	83 ca 03             	or     $0x3,%edx
  10024c:	89 10                	mov    %edx,(%eax)
    for(uint32_t i = 0; i < PG_TABLE_STACK - PG_TABLE_KERNEL; i++)
  10024e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  100252:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
  100256:	76 c6                	jbe    10021e <init_page+0xe2>
    }

    //avoid kernel size > prepared page count
    if(virk_pg_counts > (PG_TABLE_STACK - PG_TABLE_KERNEL) * 1024)
  100258:	81 7d dc 00 0c 00 00 	cmpl   $0xc00,-0x24(%ebp)
  10025f:	76 02                	jbe    100263 <init_page+0x127>
    {
        while(1);
  100261:	eb fe                	jmp    100261 <init_page+0x125>
    }

    //calcul the phy address
    uint32_t virk_phy_addr = V2P(&virkernel_start);
  100263:	b8 00 60 10 c0       	mov    $0xc0106000,%eax
  100268:	05 00 00 00 40       	add    $0x40000000,%eax
  10026d:	89 45 d8             	mov    %eax,-0x28(%ebp)
    //map virtrue kernel page
    for(uint32_t i = 0; i < virk_pg_counts; i++)
  100270:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  100277:	eb 36                	jmp    1002af <init_page+0x173>
    {
        *(tmp_paget_phy_addr + 1024 + virk_pte_index + i) = (((virk_phy_addr + (i << 12)) & 0xFFFFF000UL) | (PG_PREM_RW & 0xfff));
  100279:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10027c:	c1 e0 0c             	shl    $0xc,%eax
  10027f:	89 c2                	mov    %eax,%edx
  100281:	8b 45 d8             	mov    -0x28(%ebp),%eax
  100284:	01 d0                	add    %edx,%eax
  100286:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  10028b:	89 c2                	mov    %eax,%edx
  10028d:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  100290:	8b 45 f0             	mov    -0x10(%ebp),%eax
  100293:	01 c8                	add    %ecx,%eax
  100295:	05 00 04 00 00       	add    $0x400,%eax
  10029a:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
  1002a1:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1002a4:	01 c8                	add    %ecx,%eax
  1002a6:	83 ca 03             	or     $0x3,%edx
  1002a9:	89 10                	mov    %edx,(%eax)
    for(uint32_t i = 0; i < virk_pg_counts; i++)
  1002ab:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
  1002af:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1002b2:	3b 45 dc             	cmp    -0x24(%ebp),%eax
  1002b5:	72 c2                	jb     100279 <init_page+0x13d>
    }

    //self map pd, to give the pd virture address
    SET_PDE(pt, 1023, PDE(T_SELF_REF_PERM, pt));
  1002b7:	8b 45 08             	mov    0x8(%ebp),%eax
  1002ba:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  1002bf:	89 c2                	mov    %eax,%edx
  1002c1:	8b 45 08             	mov    0x8(%ebp),%eax
  1002c4:	05 fc 0f 00 00       	add    $0xffc,%eax
  1002c9:	83 ca 13             	or     $0x13,%edx
  1002cc:	89 10                	mov    %edx,(%eax)
}
  1002ce:	90                   	nop
  1002cf:	c9                   	leave  
  1002d0:	c3                   	ret    

001002d1 <kerner_init>:

void kerner_init(ptd_t* pt, uint32_t pt_size)
{
  1002d1:	55                   	push   %ebp
  1002d2:	89 e5                	mov    %esp,%ebp
  1002d4:	83 ec 10             	sub    $0x10,%esp
    uint8_t* kpg = (uint8_t*) pt;
  1002d7:	8b 45 08             	mov    0x8(%ebp),%eax
  1002da:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for (uint32_t i = 0; i < pt_size; i++)
  1002dd:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1002e4:	eb 0f                	jmp    1002f5 <kerner_init+0x24>
    {
        *(kpg + i) = 0;
  1002e6:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1002e9:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1002ec:	01 d0                	add    %edx,%eax
  1002ee:	c6 00 00             	movb   $0x0,(%eax)
    for (uint32_t i = 0; i < pt_size; i++)
  1002f1:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  1002f5:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1002f8:	3b 45 0c             	cmp    0xc(%ebp),%eax
  1002fb:	72 e9                	jb     1002e6 <kerner_init+0x15>
    }
    init_page(pt);
  1002fd:	ff 75 08             	push   0x8(%ebp)
  100300:	e8 37 fe ff ff       	call   10013c <init_page>
  100305:	83 c4 04             	add    $0x4,%esp
  100308:	90                   	nop
  100309:	c9                   	leave  
  10030a:	c3                   	ret    

Disassembly of section .text:

c0106000 <init_vga_buffer>:
int XPOS = 0;

vga_attr *video;

void init_vga_buffer()
{
c0106000:	55                   	push   %ebp
c0106001:	89 e5                	mov    %esp,%ebp
    video = (vga_attr *) VIDEO;
c0106003:	c7 05 0c 80 10 c0 00 	movl   $0xb8000,0xc010800c
c010600a:	80 0b 00 
}
c010600d:	90                   	nop
c010600e:	5d                   	pop    %ebp
c010600f:	c3                   	ret    

c0106010 <set_vga_buffer>:

void set_vga_buffer(void* vga_buf)
{
c0106010:	55                   	push   %ebp
c0106011:	89 e5                	mov    %esp,%ebp
    video = (vga_attr*)vga_buf;
c0106013:	8b 45 08             	mov    0x8(%ebp),%eax
c0106016:	a3 0c 80 10 c0       	mov    %eax,0xc010800c
}
c010601b:	90                   	nop
c010601c:	5d                   	pop    %ebp
c010601d:	c3                   	ret    

c010601e <vga_put_char>:

void vga_put_char(char c)
{
c010601e:	55                   	push   %ebp
c010601f:	89 e5                	mov    %esp,%ebp
c0106021:	53                   	push   %ebx
c0106022:	83 ec 04             	sub    $0x4,%esp
c0106025:	8b 45 08             	mov    0x8(%ebp),%eax
c0106028:	88 45 f8             	mov    %al,-0x8(%ebp)
    if(c == '\n')
c010602b:	80 7d f8 0a          	cmpb   $0xa,-0x8(%ebp)
c010602f:	75 19                	jne    c010604a <vga_put_char+0x2c>
    {
        YPOS++;
c0106031:	a1 04 80 10 c0       	mov    0xc0108004,%eax
c0106036:	83 c0 01             	add    $0x1,%eax
c0106039:	a3 04 80 10 c0       	mov    %eax,0xc0108004
        XPOS = 0;
c010603e:	c7 05 08 80 10 c0 00 	movl   $0x0,0xc0108008
c0106045:	00 00 00 
c0106048:	eb 54                	jmp    c010609e <vga_put_char+0x80>
    }else if(c == '\r')
c010604a:	80 7d f8 0d          	cmpb   $0xd,-0x8(%ebp)
c010604e:	75 0c                	jne    c010605c <vga_put_char+0x3e>
        XPOS = 0;
c0106050:	c7 05 08 80 10 c0 00 	movl   $0x0,0xc0108008
c0106057:	00 00 00 
c010605a:	eb 42                	jmp    c010609e <vga_put_char+0x80>
    else{
        *(video + XPOS + YPOS * WIDTH) = (theme_color | c);
c010605c:	66 0f be 55 f8       	movsbw -0x8(%ebp),%dx
c0106061:	0f b7 05 00 80 10 c0 	movzwl 0xc0108000,%eax
c0106068:	09 c2                	or     %eax,%edx
c010606a:	8b 0d 0c 80 10 c0    	mov    0xc010800c,%ecx
c0106070:	a1 04 80 10 c0       	mov    0xc0108004,%eax
c0106075:	89 c3                	mov    %eax,%ebx
c0106077:	89 d8                	mov    %ebx,%eax
c0106079:	c1 e0 02             	shl    $0x2,%eax
c010607c:	01 d8                	add    %ebx,%eax
c010607e:	c1 e0 04             	shl    $0x4,%eax
c0106081:	89 c3                	mov    %eax,%ebx
c0106083:	a1 08 80 10 c0       	mov    0xc0108008,%eax
c0106088:	01 d8                	add    %ebx,%eax
c010608a:	01 c0                	add    %eax,%eax
c010608c:	01 c8                	add    %ecx,%eax
c010608e:	66 89 10             	mov    %dx,(%eax)
        XPOS++;
c0106091:	a1 08 80 10 c0       	mov    0xc0108008,%eax
c0106096:	83 c0 01             	add    $0x1,%eax
c0106099:	a3 08 80 10 c0       	mov    %eax,0xc0108008
    }
    if (XPOS >= WIDTH)
c010609e:	a1 08 80 10 c0       	mov    0xc0108008,%eax
c01060a3:	83 f8 4f             	cmp    $0x4f,%eax
c01060a6:	7e 17                	jle    c01060bf <vga_put_char+0xa1>
    {
        YPOS++;
c01060a8:	a1 04 80 10 c0       	mov    0xc0108004,%eax
c01060ad:	83 c0 01             	add    $0x1,%eax
c01060b0:	a3 04 80 10 c0       	mov    %eax,0xc0108004
        XPOS = 0;
c01060b5:	c7 05 08 80 10 c0 00 	movl   $0x0,0xc0108008
c01060bc:	00 00 00 
    }
}
c01060bf:	90                   	nop
c01060c0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c01060c3:	c9                   	leave  
c01060c4:	c3                   	ret    

c01060c5 <vga_set_show>:

void vga_set_show(vga_attr flashing, vga_attr backgroud, vga_attr frontcolor)
{
c01060c5:	55                   	push   %ebp
c01060c6:	89 e5                	mov    %esp,%ebp
c01060c8:	83 ec 0c             	sub    $0xc,%esp
c01060cb:	8b 4d 08             	mov    0x8(%ebp),%ecx
c01060ce:	8b 55 0c             	mov    0xc(%ebp),%edx
c01060d1:	8b 45 10             	mov    0x10(%ebp),%eax
c01060d4:	66 89 4d fc          	mov    %cx,-0x4(%ebp)
c01060d8:	66 89 55 f8          	mov    %dx,-0x8(%ebp)
c01060dc:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
    theme_color = (flashing << 7 | backgroud << 4 | frontcolor) << 8;
c01060e0:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
c01060e4:	c1 e0 07             	shl    $0x7,%eax
c01060e7:	89 c2                	mov    %eax,%edx
c01060e9:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
c01060ed:	c1 e0 04             	shl    $0x4,%eax
c01060f0:	09 c2                	or     %eax,%edx
c01060f2:	0f b7 45 f4          	movzwl -0xc(%ebp),%eax
c01060f6:	09 d0                	or     %edx,%eax
c01060f8:	c1 e0 08             	shl    $0x8,%eax
c01060fb:	66 a3 00 80 10 c0    	mov    %ax,0xc0108000
}
c0106101:	90                   	nop
c0106102:	c9                   	leave  
c0106103:	c3                   	ret    

c0106104 <vga_put_str>:

void vga_put_str(char* str)
{
c0106104:	55                   	push   %ebp
c0106105:	89 e5                	mov    %esp,%ebp
    while (*str != '\0')
c0106107:	eb 16                	jmp    c010611f <vga_put_str+0x1b>
    {
        vga_put_char(*str);
c0106109:	8b 45 08             	mov    0x8(%ebp),%eax
c010610c:	0f b6 00             	movzbl (%eax),%eax
c010610f:	0f be c0             	movsbl %al,%eax
c0106112:	50                   	push   %eax
c0106113:	e8 06 ff ff ff       	call   c010601e <vga_put_char>
c0106118:	83 c4 04             	add    $0x4,%esp
        str++;
c010611b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    while (*str != '\0')
c010611f:	8b 45 08             	mov    0x8(%ebp),%eax
c0106122:	0f b6 00             	movzbl (%eax),%eax
c0106125:	84 c0                	test   %al,%al
c0106127:	75 e0                	jne    c0106109 <vga_put_str+0x5>
    }
}
c0106129:	90                   	nop
c010612a:	90                   	nop
c010612b:	c9                   	leave  
c010612c:	c3                   	ret    

c010612d <vga_clear>:

void vga_clear()
{
c010612d:	55                   	push   %ebp
c010612e:	89 e5                	mov    %esp,%ebp
c0106130:	83 ec 10             	sub    $0x10,%esp
  
    for(int i = 0; i < WIDTH * HIGHT; i++)
c0106133:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c010613a:	eb 1b                	jmp    c0106157 <vga_clear+0x2a>
        *(video + i) = theme_color;
c010613c:	8b 15 0c 80 10 c0    	mov    0xc010800c,%edx
c0106142:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106145:	01 c0                	add    %eax,%eax
c0106147:	01 c2                	add    %eax,%edx
c0106149:	0f b7 05 00 80 10 c0 	movzwl 0xc0108000,%eax
c0106150:	66 89 02             	mov    %ax,(%edx)
    for(int i = 0; i < WIDTH * HIGHT; i++)
c0106153:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0106157:	81 7d fc cf 07 00 00 	cmpl   $0x7cf,-0x4(%ebp)
c010615e:	7e dc                	jle    c010613c <vga_clear+0xf>

    XPOS = 0;
c0106160:	c7 05 08 80 10 c0 00 	movl   $0x0,0xc0108008
c0106167:	00 00 00 
    YPOS = 0;
c010616a:	c7 05 04 80 10 c0 00 	movl   $0x0,0xc0108004
c0106171:	00 00 00 
c0106174:	90                   	nop
c0106175:	c9                   	leave  
c0106176:	c3                   	ret    

c0106177 <_kernel_init>:

/* Forward declarations. */
void _kernel_init (unsigned long addr);

void _kernel_init(unsigned long addr)
{
c0106177:	55                   	push   %ebp
c0106178:	89 e5                	mov    %esp,%ebp
c010617a:	53                   	push   %ebx
c010617b:	83 ec 44             	sub    $0x44,%esp
    multiboot_info_t *mbi;
    mbi = (multiboot_info_t *) addr;
c010617e:	8b 45 08             	mov    0x8(%ebp),%eax
c0106181:	89 45 e8             	mov    %eax,-0x18(%ebp)
    multiboot_memory_map_t* map = (multiboot_memory_map_t*)mbi->mmap_addr;
c0106184:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0106187:	8b 40 30             	mov    0x30(%eax),%eax
c010618a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    _init_idt();
c010618d:	e8 3c 11 00 00       	call   c01072ce <_init_idt>
    pmm_init(MEM_1MB + (mbi->mem_upper << 10));
c0106192:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0106195:	8b 40 08             	mov    0x8(%eax),%eax
c0106198:	c1 e0 0a             	shl    $0xa,%eax
c010619b:	05 00 00 10 00       	add    $0x100000,%eax
c01061a0:	83 ec 0c             	sub    $0xc,%esp
c01061a3:	50                   	push   %eax
c01061a4:	e8 d0 03 00 00       	call   c0106579 <pmm_init>
c01061a9:	83 c4 10             	add    $0x10,%esp
    vmm_init();
c01061ac:	e8 60 06 00 00       	call   c0106811 <vmm_init>

    init_vga_buffer();
c01061b1:	e8 4a fe ff ff       	call   c0106000 <init_vga_buffer>
    vga_set_show(0,VGA_COLOR_BLACK,VGA_COLOR_LIGHT_WHITE);
c01061b6:	83 ec 04             	sub    $0x4,%esp
c01061b9:	6a 0f                	push   $0xf
c01061bb:	6a 00                	push   $0x0
c01061bd:	6a 00                	push   $0x0
c01061bf:	e8 01 ff ff ff       	call   c01060c5 <vga_set_show>
c01061c4:	83 c4 10             	add    $0x10,%esp
    /* Clear the screen. */
    vga_clear();
c01061c7:	e8 61 ff ff ff       	call   c010612d <vga_clear>
    // }

    /* Set MBI to the address of the Multiboot information structure. */

    /* Print out the flags. */
    kprintf("flags = 0x%x\n", (unsigned) mbi->flags);
c01061cc:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01061cf:	8b 00                	mov    (%eax),%eax
c01061d1:	83 ec 08             	sub    $0x8,%esp
c01061d4:	50                   	push   %eax
c01061d5:	68 00 a0 12 c0       	push   $0xc012a000
c01061da:	e8 7f 12 00 00       	call   c010745e <kprintf>
c01061df:	83 c4 10             	add    $0x10,%esp

    /* Are mem_* valid? */
    if (CHECK_FLAG(mbi->flags, 0))
c01061e2:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01061e5:	8b 00                	mov    (%eax),%eax
c01061e7:	83 e0 01             	and    $0x1,%eax
c01061ea:	85 c0                	test   %eax,%eax
c01061ec:	74 1e                	je     c010620c <_kernel_init+0x95>
        kprintf("mem_lower = %uKB, mem_upper = %uKB\n",(unsigned) mbi->mem_lower, (unsigned) mbi->mem_upper);
c01061ee:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01061f1:	8b 50 08             	mov    0x8(%eax),%edx
c01061f4:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01061f7:	8b 40 04             	mov    0x4(%eax),%eax
c01061fa:	83 ec 04             	sub    $0x4,%esp
c01061fd:	52                   	push   %edx
c01061fe:	50                   	push   %eax
c01061ff:	68 10 a0 12 c0       	push   $0xc012a010
c0106204:	e8 55 12 00 00       	call   c010745e <kprintf>
c0106209:	83 c4 10             	add    $0x10,%esp
    
    unsigned int map_size = mbi->mmap_length / sizeof(multiboot_memory_map_t);
c010620c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010620f:	8b 40 2c             	mov    0x2c(%eax),%eax
c0106212:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
c0106217:	f7 e2                	mul    %edx
c0106219:	89 d0                	mov    %edx,%eax
c010621b:	c1 e8 04             	shr    $0x4,%eax
c010621e:	89 45 e0             	mov    %eax,-0x20(%ebp)
    for (unsigned int i = 0; i < map_size; i++) {
c0106221:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0106228:	e9 1e 01 00 00       	jmp    c010634b <_kernel_init+0x1d4>
        multiboot_memory_map_t mmap = map[i];
c010622d:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0106230:	89 d0                	mov    %edx,%eax
c0106232:	01 c0                	add    %eax,%eax
c0106234:	01 d0                	add    %edx,%eax
c0106236:	c1 e0 03             	shl    $0x3,%eax
c0106239:	89 c2                	mov    %eax,%edx
c010623b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010623e:	01 d0                	add    %edx,%eax
c0106240:	8b 10                	mov    (%eax),%edx
c0106242:	89 55 bc             	mov    %edx,-0x44(%ebp)
c0106245:	8b 50 04             	mov    0x4(%eax),%edx
c0106248:	89 55 c0             	mov    %edx,-0x40(%ebp)
c010624b:	8b 50 08             	mov    0x8(%eax),%edx
c010624e:	89 55 c4             	mov    %edx,-0x3c(%ebp)
c0106251:	8b 50 0c             	mov    0xc(%eax),%edx
c0106254:	89 55 c8             	mov    %edx,-0x38(%ebp)
c0106257:	8b 50 10             	mov    0x10(%eax),%edx
c010625a:	89 55 cc             	mov    %edx,-0x34(%ebp)
c010625d:	8b 40 14             	mov    0x14(%eax),%eax
c0106260:	89 45 d0             	mov    %eax,-0x30(%ebp)
        kprintf("[MM] Base: 0x%x, len: %u KiB, type: %u\n",
               map[i].addr_low,
               map[i].len_low >> 10,
               map[i].type);
c0106263:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0106266:	89 d0                	mov    %edx,%eax
c0106268:	01 c0                	add    %eax,%eax
c010626a:	01 d0                	add    %edx,%eax
c010626c:	c1 e0 03             	shl    $0x3,%eax
c010626f:	89 c2                	mov    %eax,%edx
c0106271:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0106274:	01 d0                	add    %edx,%eax
        kprintf("[MM] Base: 0x%x, len: %u KiB, type: %u\n",
c0106276:	8b 50 14             	mov    0x14(%eax),%edx
               map[i].len_low >> 10,
c0106279:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c010627c:	89 c8                	mov    %ecx,%eax
c010627e:	01 c0                	add    %eax,%eax
c0106280:	01 c8                	add    %ecx,%eax
c0106282:	c1 e0 03             	shl    $0x3,%eax
c0106285:	89 c1                	mov    %eax,%ecx
c0106287:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010628a:	01 c8                	add    %ecx,%eax
c010628c:	8b 40 0c             	mov    0xc(%eax),%eax
        kprintf("[MM] Base: 0x%x, len: %u KiB, type: %u\n",
c010628f:	c1 e8 0a             	shr    $0xa,%eax
c0106292:	89 c3                	mov    %eax,%ebx
               map[i].addr_low,
c0106294:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c0106297:	89 c8                	mov    %ecx,%eax
c0106299:	01 c0                	add    %eax,%eax
c010629b:	01 c8                	add    %ecx,%eax
c010629d:	c1 e0 03             	shl    $0x3,%eax
c01062a0:	89 c1                	mov    %eax,%ecx
c01062a2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01062a5:	01 c8                	add    %ecx,%eax
        kprintf("[MM] Base: 0x%x, len: %u KiB, type: %u\n",
c01062a7:	8b 40 04             	mov    0x4(%eax),%eax
c01062aa:	52                   	push   %edx
c01062ab:	53                   	push   %ebx
c01062ac:	50                   	push   %eax
c01062ad:	68 34 a0 12 c0       	push   $0xc012a034
c01062b2:	e8 a7 11 00 00       	call   c010745e <kprintf>
c01062b7:	83 c4 10             	add    $0x10,%esp
        if (mmap.type == MULTIBOOT_MEMORY_AVAILABLE) {
c01062ba:	8b 45 d0             	mov    -0x30(%ebp),%eax
c01062bd:	83 f8 01             	cmp    $0x1,%eax
c01062c0:	0f 85 81 00 00 00    	jne    c0106347 <_kernel_init+0x1d0>
            // 整数向上取整除法
            uintptr_t pg = map[i].addr_low + 0x0fffU;
c01062c6:	8b 55 f4             	mov    -0xc(%ebp),%edx
c01062c9:	89 d0                	mov    %edx,%eax
c01062cb:	01 c0                	add    %eax,%eax
c01062cd:	01 d0                	add    %edx,%eax
c01062cf:	c1 e0 03             	shl    $0x3,%eax
c01062d2:	89 c2                	mov    %eax,%edx
c01062d4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01062d7:	01 d0                	add    %edx,%eax
c01062d9:	8b 40 04             	mov    0x4(%eax),%eax
c01062dc:	05 ff 0f 00 00       	add    $0xfff,%eax
c01062e1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
            pmm_mark_chunk_free(pg >> 12, map[i].len_low >> 12);
c01062e4:	8b 55 f4             	mov    -0xc(%ebp),%edx
c01062e7:	89 d0                	mov    %edx,%eax
c01062e9:	01 c0                	add    %eax,%eax
c01062eb:	01 d0                	add    %edx,%eax
c01062ed:	c1 e0 03             	shl    $0x3,%eax
c01062f0:	89 c2                	mov    %eax,%edx
c01062f2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01062f5:	01 d0                	add    %edx,%eax
c01062f7:	8b 40 0c             	mov    0xc(%eax),%eax
c01062fa:	c1 e8 0c             	shr    $0xc,%eax
c01062fd:	89 c2                	mov    %eax,%edx
c01062ff:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0106302:	c1 e8 0c             	shr    $0xc,%eax
c0106305:	83 ec 08             	sub    $0x8,%esp
c0106308:	52                   	push   %edx
c0106309:	50                   	push   %eax
c010630a:	e8 1a 03 00 00       	call   c0106629 <pmm_mark_chunk_free>
c010630f:	83 c4 10             	add    $0x10,%esp
            kprintf("[MM] Freed %u pages start from 0x%x\n",
c0106312:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0106315:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010631a:	89 c1                	mov    %eax,%ecx
                   map[i].len_low >> 12,
c010631c:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010631f:	89 d0                	mov    %edx,%eax
c0106321:	01 c0                	add    %eax,%eax
c0106323:	01 d0                	add    %edx,%eax
c0106325:	c1 e0 03             	shl    $0x3,%eax
c0106328:	89 c2                	mov    %eax,%edx
c010632a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010632d:	01 d0                	add    %edx,%eax
c010632f:	8b 40 0c             	mov    0xc(%eax),%eax
            kprintf("[MM] Freed %u pages start from 0x%x\n",
c0106332:	c1 e8 0c             	shr    $0xc,%eax
c0106335:	83 ec 04             	sub    $0x4,%esp
c0106338:	51                   	push   %ecx
c0106339:	50                   	push   %eax
c010633a:	68 5c a0 12 c0       	push   $0xc012a05c
c010633f:	e8 1a 11 00 00       	call   c010745e <kprintf>
c0106344:	83 c4 10             	add    $0x10,%esp
    for (unsigned int i = 0; i < map_size; i++) {
c0106347:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010634b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010634e:	3b 45 e0             	cmp    -0x20(%ebp),%eax
c0106351:	0f 82 d6 fe ff ff    	jb     c010622d <_kernel_init+0xb6>
                   pg & ~0x0fffU);
        }
    }

    // 将内核占据的页设为已占用
    size_t pg_count = (uintptr_t)(&virkernel_end  - &virkernel_start) >> 12;
c0106357:	b8 00 10 13 c0       	mov    $0xc0131000,%eax
c010635c:	2d 00 60 10 c0       	sub    $0xc0106000,%eax
c0106361:	c1 e8 0c             	shr    $0xc,%eax
c0106364:	89 45 dc             	mov    %eax,-0x24(%ebp)
    pmm_mark_chunk_occupied(V2P(&virkernel_start) >> 12, pg_count);
c0106367:	b8 00 60 10 c0       	mov    $0xc0106000,%eax
c010636c:	05 00 00 00 40       	add    $0x40000000,%eax
c0106371:	c1 e8 0c             	shr    $0xc,%eax
c0106374:	83 ec 08             	sub    $0x8,%esp
c0106377:	ff 75 dc             	push   -0x24(%ebp)
c010637a:	50                   	push   %eax
c010637b:	e8 0d 03 00 00       	call   c010668d <pmm_mark_chunk_occupied>
c0106380:	83 c4 10             	add    $0x10,%esp
    kprintf("[MM] Allocated %d pages for kernel.\n", pg_count);
c0106383:	83 ec 08             	sub    $0x8,%esp
c0106386:	ff 75 dc             	push   -0x24(%ebp)
c0106389:	68 84 a0 12 c0       	push   $0xc012a084
c010638e:	e8 cb 10 00 00       	call   c010745e <kprintf>
c0106393:	83 c4 10             	add    $0x10,%esp

    size_t vga_buf_pgs = VGA_BUFFER_SIZE >> 12;
c0106396:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
    
    // 首先，标记VGA部分为已占用
    pmm_mark_chunk_occupied(VIDEO >> 12, vga_buf_pgs);
c010639d:	83 ec 08             	sub    $0x8,%esp
c01063a0:	ff 75 d8             	push   -0x28(%ebp)
c01063a3:	68 b8 00 00 00       	push   $0xb8
c01063a8:	e8 e0 02 00 00       	call   c010668d <pmm_mark_chunk_occupied>
c01063ad:	83 c4 10             	add    $0x10,%esp
    
    // 重映射VGA文本缓冲区（以后会变成显存，i.e., framebuffer）
    for (size_t i = 0; i < vga_buf_pgs; i++)
c01063b0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c01063b7:	eb 2a                	jmp    c01063e3 <_kernel_init+0x26c>
    {
        vmm_map_page(VGA_BUFFER_VADDR + (i << 12), VIDEO + (i << 12), PG_PREM_RW, PG_PREM_RW);
c01063b9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01063bc:	c1 e0 0c             	shl    $0xc,%eax
c01063bf:	05 00 80 0b 00       	add    $0xb8000,%eax
c01063c4:	89 c2                	mov    %eax,%edx
c01063c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01063c9:	c1 e0 0c             	shl    $0xc,%eax
c01063cc:	2d 00 00 00 50       	sub    $0x50000000,%eax
c01063d1:	6a 03                	push   $0x3
c01063d3:	6a 03                	push   $0x3
c01063d5:	52                   	push   %edx
c01063d6:	50                   	push   %eax
c01063d7:	e8 be 04 00 00       	call   c010689a <vmm_map_page>
c01063dc:	83 c4 10             	add    $0x10,%esp
    for (size_t i = 0; i < vga_buf_pgs; i++)
c01063df:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c01063e3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01063e6:	3b 45 d8             	cmp    -0x28(%ebp),%eax
c01063e9:	72 ce                	jb     c01063b9 <_kernel_init+0x242>
    }
    set_vga_buffer(VGA_BUFFER_VADDR);
c01063eb:	83 ec 0c             	sub    $0xc,%esp
c01063ee:	68 00 00 00 b0       	push   $0xb0000000
c01063f3:	e8 18 fc ff ff       	call   c0106010 <set_vga_buffer>
c01063f8:	83 c4 10             	add    $0x10,%esp
    kprintf("[MM] Mapped VGA to %x.\n", VGA_BUFFER_VADDR);
c01063fb:	83 ec 08             	sub    $0x8,%esp
c01063fe:	68 00 00 00 b0       	push   $0xb0000000
c0106403:	68 a9 a0 12 c0       	push   $0xc012a0a9
c0106408:	e8 51 10 00 00       	call   c010745e <kprintf>
c010640d:	83 c4 10             	add    $0x10,%esp

    // 为内核创建一个专属栈空间。
    for (size_t i = 0; i < (K_STACK_SIZE >> 12); i++) {
c0106410:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0106417:	eb 1f                	jmp    c0106438 <_kernel_init+0x2c1>
        vmm_alloc_page(K_STACK_START + (i << 12), PG_PREM_RW, PG_PREM_RW);
c0106419:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010641c:	c1 e0 0c             	shl    $0xc,%eax
c010641f:	2d 00 00 50 00       	sub    $0x500000,%eax
c0106424:	83 ec 04             	sub    $0x4,%esp
c0106427:	6a 03                	push   $0x3
c0106429:	6a 03                	push   $0x3
c010642b:	50                   	push   %eax
c010642c:	e8 2f 06 00 00       	call   c0106a60 <vmm_alloc_page>
c0106431:	83 c4 10             	add    $0x10,%esp
    for (size_t i = 0; i < (K_STACK_SIZE >> 12); i++) {
c0106434:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0106438:	81 7d ec ff 00 00 00 	cmpl   $0xff,-0x14(%ebp)
c010643f:	76 d8                	jbe    c0106419 <_kernel_init+0x2a2>
    }
    kprintf("[MM] Allocated %d pages for stack start at %p\n", K_STACK_SIZE>>12, K_STACK_START);
c0106441:	83 ec 04             	sub    $0x4,%esp
c0106444:	68 00 00 b0 ff       	push   $0xffb00000
c0106449:	68 00 01 00 00       	push   $0x100
c010644e:	68 c4 a0 12 c0       	push   $0xc012a0c4
c0106453:	e8 06 10 00 00       	call   c010745e <kprintf>
c0106458:	83 c4 10             	add    $0x10,%esp

    kprintf("[KERNEL] === Initialization Done === \n\n");
c010645b:	83 ec 0c             	sub    $0xc,%esp
c010645e:	68 f4 a0 12 c0       	push   $0xc012a0f4
c0106463:	e8 f6 0f 00 00       	call   c010745e <kprintf>
c0106468:	83 c4 10             	add    $0x10,%esp

    vga_put_str("MELOX OS\n");
c010646b:	83 ec 0c             	sub    $0xc,%esp
c010646e:	68 1c a1 12 c0       	push   $0xc012a11c
c0106473:	e8 8c fc ff ff       	call   c0106104 <vga_put_str>
c0106478:	83 c4 10             	add    $0x10,%esp
    // __asm__("int $1");
}
c010647b:	90                   	nop
c010647c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010647f:	c9                   	leave  
c0106480:	c3                   	ret    

c0106481 <_kernel_finnal_init>:

void _kernel_finnal_init() {
c0106481:	55                   	push   %ebp
c0106482:	89 e5                	mov    %esp,%ebp
c0106484:	83 ec 18             	sub    $0x18,%esp
    //kprintf("[KERNEL] === Post Initialization === \n");
    size_t virk_init_pg_count = ((uintptr_t)(&__init_phykernel_end)) >> 12;
c0106487:	b8 00 60 10 00       	mov    $0x106000,%eax
c010648c:	c1 e8 0c             	shr    $0xc,%eax
c010648f:	89 45 ec             	mov    %eax,-0x14(%ebp)
    kprintf("[MM] Releaseing %d pages from 0x0.\n", virk_init_pg_count);
c0106492:	83 ec 08             	sub    $0x8,%esp
c0106495:	ff 75 ec             	push   -0x14(%ebp)
c0106498:	68 28 a1 12 c0       	push   $0xc012a128
c010649d:	e8 bc 0f 00 00       	call   c010745e <kprintf>
c01064a2:	83 c4 10             	add    $0x10,%esp

    // 清除 hhk_init 与前1MiB的映射
    for (size_t i = 0; i < 256; i++) {
c01064a5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c01064ac:	eb 16                	jmp    c01064c4 <_kernel_finnal_init+0x43>

        vmm_unmap_page((i << 12));
c01064ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01064b1:	c1 e0 0c             	shl    $0xc,%eax
c01064b4:	83 ec 0c             	sub    $0xc,%esp
c01064b7:	50                   	push   %eax
c01064b8:	e8 e1 05 00 00       	call   c0106a9e <vmm_unmap_page>
c01064bd:	83 c4 10             	add    $0x10,%esp
    for (size_t i = 0; i < 256; i++) {
c01064c0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c01064c4:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
c01064cb:	76 e1                	jbe    c01064ae <_kernel_finnal_init+0x2d>
    }
    for (size_t i = 256; i < virk_init_pg_count; i++) {
c01064cd:	c7 45 f0 00 01 00 00 	movl   $0x100,-0x10(%ebp)
c01064d4:	eb 16                	jmp    c01064ec <_kernel_finnal_init+0x6b>

        vmm_unmap_page((i << 12));
c01064d6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01064d9:	c1 e0 0c             	shl    $0xc,%eax
c01064dc:	83 ec 0c             	sub    $0xc,%esp
c01064df:	50                   	push   %eax
c01064e0:	e8 b9 05 00 00       	call   c0106a9e <vmm_unmap_page>
c01064e5:	83 c4 10             	add    $0x10,%esp
    for (size_t i = 256; i < virk_init_pg_count; i++) {
c01064e8:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c01064ec:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01064ef:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c01064f2:	72 e2                	jb     c01064d6 <_kernel_finnal_init+0x55>
    }
    kprintf("[KERNEL] === Post Initialization Done === \n\n");
c01064f4:	83 ec 0c             	sub    $0xc,%esp
c01064f7:	68 4c a1 12 c0       	push   $0xc012a14c
c01064fc:	e8 5d 0f 00 00       	call   c010745e <kprintf>
c0106501:	83 c4 10             	add    $0x10,%esp
}
c0106504:	90                   	nop
c0106505:	c9                   	leave  
c0106506:	c3                   	ret    

c0106507 <_kernel_main>:

void _kernel_main()
{
c0106507:	55                   	push   %ebp
c0106508:	89 e5                	mov    %esp,%ebp
c010650a:	81 ec 18 01 00 00    	sub    $0x118,%esp
    char* buf[64];
    
    kprintf("We are now running in virtual address space!\n\n");
c0106510:	83 ec 0c             	sub    $0xc,%esp
c0106513:	68 7c a1 12 c0       	push   $0xc012a17c
c0106518:	e8 41 0f 00 00       	call   c010745e <kprintf>
c010651d:	83 c4 10             	add    $0x10,%esp
    
    cpu_get_brand(buf);
c0106520:	83 ec 0c             	sub    $0xc,%esp
c0106523:	8d 85 f4 fe ff ff    	lea    -0x10c(%ebp),%eax
c0106529:	50                   	push   %eax
c010652a:	e8 9e 0a 00 00       	call   c0106fcd <cpu_get_brand>
c010652f:	83 c4 10             	add    $0x10,%esp
    kprintf("CPU: %s\n\n", buf);
c0106532:	83 ec 08             	sub    $0x8,%esp
c0106535:	8d 85 f4 fe ff ff    	lea    -0x10c(%ebp),%eax
c010653b:	50                   	push   %eax
c010653c:	68 ab a1 12 c0       	push   $0xc012a1ab
c0106541:	e8 18 0f 00 00       	call   c010745e <kprintf>
c0106546:	83 c4 10             	add    $0x10,%esp

    uintptr_t k_start = vmm_v2p(&virkernel_start);
c0106549:	83 ec 0c             	sub    $0xc,%esp
c010654c:	68 00 60 10 c0       	push   $0xc0106000
c0106551:	e8 e3 05 00 00       	call   c0106b39 <vmm_v2p>
c0106556:	83 c4 10             	add    $0x10,%esp
c0106559:	89 45 f4             	mov    %eax,-0xc(%ebp)
    kprintf("The kernel's base address mapping: %x->%x\n", &virkernel_start, k_start);
c010655c:	83 ec 04             	sub    $0x4,%esp
c010655f:	ff 75 f4             	push   -0xc(%ebp)
c0106562:	68 00 60 10 c0       	push   $0xc0106000
c0106567:	68 b8 a1 12 c0       	push   $0xc012a1b8
c010656c:	e8 ed 0e 00 00       	call   c010745e <kprintf>
c0106571:	83 c4 10             	add    $0x10,%esp
    __asm__("int $0");
c0106574:	cd 00                	int    $0x0
c0106576:	90                   	nop
c0106577:	c9                   	leave  
c0106578:	c3                   	ret    

c0106579 <pmm_init>:
#include <kernel/memory/page.h>
size_t pg_lookup_ptr;
uint8_t pm_bitmap[PM_BMP_MAX_SIZE];
uintptr_t max_pg;
void pmm_init(uintptr_t mem_upper_lim)
{
c0106579:	55                   	push   %ebp
c010657a:	89 e5                	mov    %esp,%ebp
c010657c:	83 ec 10             	sub    $0x10,%esp
    pg_lookup_ptr = LOOKUP_START;
c010657f:	c7 05 20 80 10 c0 01 	movl   $0x1,0xc0108020
c0106586:	00 00 00 
    max_pg = (PG_ALIGN(mem_upper_lim) >> 12);
c0106589:	8b 45 08             	mov    0x8(%ebp),%eax
c010658c:	c1 e8 0c             	shr    $0xc,%eax
c010658f:	a3 40 80 12 c0       	mov    %eax,0xc0128040

    for(int i = 0; i < PM_BMP_MAX_SIZE; i++)
c0106594:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c010659b:	eb 0f                	jmp    c01065ac <pmm_init+0x33>
    {
        pm_bitmap[i] = 0xffU;
c010659d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01065a0:	05 40 80 10 c0       	add    $0xc0108040,%eax
c01065a5:	c6 00 ff             	movb   $0xff,(%eax)
    for(int i = 0; i < PM_BMP_MAX_SIZE; i++)
c01065a8:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c01065ac:	81 7d fc ff ff 01 00 	cmpl   $0x1ffff,-0x4(%ebp)
c01065b3:	7e e8                	jle    c010659d <pmm_init+0x24>
    }
}
c01065b5:	90                   	nop
c01065b6:	90                   	nop
c01065b7:	c9                   	leave  
c01065b8:	c3                   	ret    

c01065b9 <pmm_mark_page_free>:

void pmm_mark_page_free(uintptr_t ppn)
{
c01065b9:	55                   	push   %ebp
c01065ba:	89 e5                	mov    %esp,%ebp
c01065bc:	53                   	push   %ebx
    pm_bitmap[ppn / 8] = pm_bitmap[ppn / 8] & (0xff7fU >> (ppn % 8));
c01065bd:	8b 45 08             	mov    0x8(%ebp),%eax
c01065c0:	c1 e8 03             	shr    $0x3,%eax
c01065c3:	0f b6 90 40 80 10 c0 	movzbl -0x3fef7fc0(%eax),%edx
c01065ca:	8b 45 08             	mov    0x8(%ebp),%eax
c01065cd:	83 e0 07             	and    $0x7,%eax
c01065d0:	bb 7f ff 00 00       	mov    $0xff7f,%ebx
c01065d5:	89 c1                	mov    %eax,%ecx
c01065d7:	d3 eb                	shr    %cl,%ebx
c01065d9:	89 d8                	mov    %ebx,%eax
c01065db:	89 c1                	mov    %eax,%ecx
c01065dd:	8b 45 08             	mov    0x8(%ebp),%eax
c01065e0:	c1 e8 03             	shr    $0x3,%eax
c01065e3:	21 ca                	and    %ecx,%edx
c01065e5:	88 90 40 80 10 c0    	mov    %dl,-0x3fef7fc0(%eax)
}
c01065eb:	90                   	nop
c01065ec:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c01065ef:	c9                   	leave  
c01065f0:	c3                   	ret    

c01065f1 <pmm_mark_page_occupied>:

void pmm_mark_page_occupied(uintptr_t ppn)
{
c01065f1:	55                   	push   %ebp
c01065f2:	89 e5                	mov    %esp,%ebp
c01065f4:	53                   	push   %ebx
    pm_bitmap[ppn / 8] = pm_bitmap[ppn / 8] | (0x80U >> (ppn % 8));
c01065f5:	8b 45 08             	mov    0x8(%ebp),%eax
c01065f8:	c1 e8 03             	shr    $0x3,%eax
c01065fb:	0f b6 90 40 80 10 c0 	movzbl -0x3fef7fc0(%eax),%edx
c0106602:	8b 45 08             	mov    0x8(%ebp),%eax
c0106605:	83 e0 07             	and    $0x7,%eax
c0106608:	bb 80 00 00 00       	mov    $0x80,%ebx
c010660d:	89 c1                	mov    %eax,%ecx
c010660f:	d3 eb                	shr    %cl,%ebx
c0106611:	89 d8                	mov    %ebx,%eax
c0106613:	89 c1                	mov    %eax,%ecx
c0106615:	8b 45 08             	mov    0x8(%ebp),%eax
c0106618:	c1 e8 03             	shr    $0x3,%eax
c010661b:	09 ca                	or     %ecx,%edx
c010661d:	88 90 40 80 10 c0    	mov    %dl,-0x3fef7fc0(%eax)
}
c0106623:	90                   	nop
c0106624:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0106627:	c9                   	leave  
c0106628:	c3                   	ret    

c0106629 <pmm_mark_chunk_free>:

void pmm_mark_chunk_free(uintptr_t start_ppn, size_t page_count)
{
c0106629:	55                   	push   %ebp
c010662a:	89 e5                	mov    %esp,%ebp
c010662c:	53                   	push   %ebx
c010662d:	83 ec 10             	sub    $0x10,%esp
    for(int i = start_ppn; i < page_count; i++)
c0106630:	8b 45 08             	mov    0x8(%ebp),%eax
c0106633:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0106636:	eb 46                	jmp    c010667e <pmm_mark_chunk_free+0x55>
        pm_bitmap[i / 8] = pm_bitmap[i / 8] & (0xff7fU >> (i % 8));
c0106638:	8b 45 f8             	mov    -0x8(%ebp),%eax
c010663b:	8d 50 07             	lea    0x7(%eax),%edx
c010663e:	85 c0                	test   %eax,%eax
c0106640:	0f 48 c2             	cmovs  %edx,%eax
c0106643:	c1 f8 03             	sar    $0x3,%eax
c0106646:	0f b6 98 40 80 10 c0 	movzbl -0x3fef7fc0(%eax),%ebx
c010664d:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0106650:	83 e0 07             	and    $0x7,%eax
c0106653:	ba 7f ff 00 00       	mov    $0xff7f,%edx
c0106658:	89 c1                	mov    %eax,%ecx
c010665a:	d3 ea                	shr    %cl,%edx
c010665c:	89 d0                	mov    %edx,%eax
c010665e:	89 c1                	mov    %eax,%ecx
c0106660:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0106663:	8d 50 07             	lea    0x7(%eax),%edx
c0106666:	85 c0                	test   %eax,%eax
c0106668:	0f 48 c2             	cmovs  %edx,%eax
c010666b:	c1 f8 03             	sar    $0x3,%eax
c010666e:	89 c2                	mov    %eax,%edx
c0106670:	89 d8                	mov    %ebx,%eax
c0106672:	21 c8                	and    %ecx,%eax
c0106674:	88 82 40 80 10 c0    	mov    %al,-0x3fef7fc0(%edx)
    for(int i = start_ppn; i < page_count; i++)
c010667a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c010667e:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0106681:	39 45 0c             	cmp    %eax,0xc(%ebp)
c0106684:	77 b2                	ja     c0106638 <pmm_mark_chunk_free+0xf>
}
c0106686:	90                   	nop
c0106687:	90                   	nop
c0106688:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010668b:	c9                   	leave  
c010668c:	c3                   	ret    

c010668d <pmm_mark_chunk_occupied>:

void pmm_mark_chunk_occupied(uintptr_t start_ppn, size_t page_count)
{
c010668d:	55                   	push   %ebp
c010668e:	89 e5                	mov    %esp,%ebp
c0106690:	53                   	push   %ebx
c0106691:	83 ec 10             	sub    $0x10,%esp
    for(int i = start_ppn; i < page_count; i++)
c0106694:	8b 45 08             	mov    0x8(%ebp),%eax
c0106697:	89 45 f8             	mov    %eax,-0x8(%ebp)
c010669a:	eb 46                	jmp    c01066e2 <pmm_mark_chunk_occupied+0x55>
        pm_bitmap[i / 8] = pm_bitmap[i / 8] | (0x80U >> (i % 8));
c010669c:	8b 45 f8             	mov    -0x8(%ebp),%eax
c010669f:	8d 50 07             	lea    0x7(%eax),%edx
c01066a2:	85 c0                	test   %eax,%eax
c01066a4:	0f 48 c2             	cmovs  %edx,%eax
c01066a7:	c1 f8 03             	sar    $0x3,%eax
c01066aa:	0f b6 98 40 80 10 c0 	movzbl -0x3fef7fc0(%eax),%ebx
c01066b1:	8b 45 f8             	mov    -0x8(%ebp),%eax
c01066b4:	83 e0 07             	and    $0x7,%eax
c01066b7:	ba 80 00 00 00       	mov    $0x80,%edx
c01066bc:	89 c1                	mov    %eax,%ecx
c01066be:	d3 ea                	shr    %cl,%edx
c01066c0:	89 d0                	mov    %edx,%eax
c01066c2:	89 c1                	mov    %eax,%ecx
c01066c4:	8b 45 f8             	mov    -0x8(%ebp),%eax
c01066c7:	8d 50 07             	lea    0x7(%eax),%edx
c01066ca:	85 c0                	test   %eax,%eax
c01066cc:	0f 48 c2             	cmovs  %edx,%eax
c01066cf:	c1 f8 03             	sar    $0x3,%eax
c01066d2:	89 c2                	mov    %eax,%edx
c01066d4:	89 d8                	mov    %ebx,%eax
c01066d6:	09 c8                	or     %ecx,%eax
c01066d8:	88 82 40 80 10 c0    	mov    %al,-0x3fef7fc0(%edx)
    for(int i = start_ppn; i < page_count; i++)
c01066de:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c01066e2:	8b 45 f8             	mov    -0x8(%ebp),%eax
c01066e5:	39 45 0c             	cmp    %eax,0xc(%ebp)
c01066e8:	77 b2                	ja     c010669c <pmm_mark_chunk_occupied+0xf>
}
c01066ea:	90                   	nop
c01066eb:	90                   	nop
c01066ec:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c01066ef:	c9                   	leave  
c01066f0:	c3                   	ret    

c01066f1 <pmm_alloc_page>:

void* pmm_alloc_page()
{
c01066f1:	55                   	push   %ebp
c01066f2:	89 e5                	mov    %esp,%ebp
c01066f4:	53                   	push   %ebx
c01066f5:	83 ec 20             	sub    $0x20,%esp
    // Next fit approach. Maximize the throughput!
    uintptr_t good_page_found = NULL;
c01066f8:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    size_t old_pg_ptr = pg_lookup_ptr;
c01066ff:	a1 20 80 10 c0       	mov    0xc0108020,%eax
c0106704:	89 45 f4             	mov    %eax,-0xc(%ebp)
    size_t upper_lim = max_pg;
c0106707:	a1 40 80 12 c0       	mov    0xc0128040,%eax
c010670c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    uint8_t chunk = 0;
c010670f:	c6 45 eb 00          	movb   $0x0,-0x15(%ebp)
    while (!good_page_found && pg_lookup_ptr < upper_lim) {
c0106713:	e9 a5 00 00 00       	jmp    c01067bd <pmm_alloc_page+0xcc>
        chunk = pm_bitmap[pg_lookup_ptr >> 3];
c0106718:	a1 20 80 10 c0       	mov    0xc0108020,%eax
c010671d:	c1 e8 03             	shr    $0x3,%eax
c0106720:	0f b6 80 40 80 10 c0 	movzbl -0x3fef7fc0(%eax),%eax
c0106727:	88 45 eb             	mov    %al,-0x15(%ebp)

        // skip the fully occupied chunk, reduce # of iterations
        if (chunk != 0xFFU) {
c010672a:	80 7d eb ff          	cmpb   $0xff,-0x15(%ebp)
c010672e:	74 59                	je     c0106789 <pmm_alloc_page+0x98>
            for (size_t i = pg_lookup_ptr % 8; i < 8; i++, pg_lookup_ptr++) {
c0106730:	a1 20 80 10 c0       	mov    0xc0108020,%eax
c0106735:	83 e0 07             	and    $0x7,%eax
c0106738:	89 45 ec             	mov    %eax,-0x14(%ebp)
c010673b:	eb 44                	jmp    c0106781 <pmm_alloc_page+0x90>
                if (!(chunk & (0x80U >> i))) {
c010673d:	0f b6 55 eb          	movzbl -0x15(%ebp),%edx
c0106741:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0106744:	bb 80 00 00 00       	mov    $0x80,%ebx
c0106749:	89 c1                	mov    %eax,%ecx
c010674b:	d3 eb                	shr    %cl,%ebx
c010674d:	89 d8                	mov    %ebx,%eax
c010674f:	21 d0                	and    %edx,%eax
c0106751:	85 c0                	test   %eax,%eax
c0106753:	75 1b                	jne    c0106770 <pmm_alloc_page+0x7f>
                    pmm_mark_page_occupied(pg_lookup_ptr);
c0106755:	a1 20 80 10 c0       	mov    0xc0108020,%eax
c010675a:	50                   	push   %eax
c010675b:	e8 91 fe ff ff       	call   c01065f1 <pmm_mark_page_occupied>
c0106760:	83 c4 04             	add    $0x4,%esp
                    good_page_found = pg_lookup_ptr << 12;
c0106763:	a1 20 80 10 c0       	mov    0xc0108020,%eax
c0106768:	c1 e0 0c             	shl    $0xc,%eax
c010676b:	89 45 f8             	mov    %eax,-0x8(%ebp)
                    break;
c010676e:	eb 4d                	jmp    c01067bd <pmm_alloc_page+0xcc>
            for (size_t i = pg_lookup_ptr % 8; i < 8; i++, pg_lookup_ptr++) {
c0106770:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0106774:	a1 20 80 10 c0       	mov    0xc0108020,%eax
c0106779:	83 c0 01             	add    $0x1,%eax
c010677c:	a3 20 80 10 c0       	mov    %eax,0xc0108020
c0106781:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
c0106785:	76 b6                	jbe    c010673d <pmm_alloc_page+0x4c>
c0106787:	eb 34                	jmp    c01067bd <pmm_alloc_page+0xcc>
                }
            }
        } else {
            pg_lookup_ptr += 8;
c0106789:	a1 20 80 10 c0       	mov    0xc0108020,%eax
c010678e:	83 c0 08             	add    $0x8,%eax
c0106791:	a3 20 80 10 c0       	mov    %eax,0xc0108020

            // We've searched the interval [old_pg_ptr, max_pg) but failed
            //   may be chances in [1, old_pg_ptr) ?
            // Let's find out!
            if (pg_lookup_ptr >= upper_lim && old_pg_ptr != LOOKUP_START) {
c0106796:	a1 20 80 10 c0       	mov    0xc0108020,%eax
c010679b:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c010679e:	77 1d                	ja     c01067bd <pmm_alloc_page+0xcc>
c01067a0:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c01067a4:	74 17                	je     c01067bd <pmm_alloc_page+0xcc>
                upper_lim = old_pg_ptr;
c01067a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01067a9:	89 45 f0             	mov    %eax,-0x10(%ebp)
                pg_lookup_ptr = LOOKUP_START;
c01067ac:	c7 05 20 80 10 c0 01 	movl   $0x1,0xc0108020
c01067b3:	00 00 00 
                old_pg_ptr = LOOKUP_START;
c01067b6:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
    while (!good_page_found && pg_lookup_ptr < upper_lim) {
c01067bd:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c01067c1:	75 0e                	jne    c01067d1 <pmm_alloc_page+0xe0>
c01067c3:	a1 20 80 10 c0       	mov    0xc0108020,%eax
c01067c8:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c01067cb:	0f 87 47 ff ff ff    	ja     c0106718 <pmm_alloc_page+0x27>
            }
        }
    }
    return (void*)good_page_found;
c01067d1:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
c01067d4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c01067d7:	c9                   	leave  
c01067d8:	c3                   	ret    

c01067d9 <pmm_free_page>:

int
pmm_free_page(void* page)
{
c01067d9:	55                   	push   %ebp
c01067da:	89 e5                	mov    %esp,%ebp
c01067dc:	83 ec 10             	sub    $0x10,%esp
    // TODO: Add kernel reserved memory page check
    uint32_t pg = (uintptr_t)page >> 12;
c01067df:	8b 45 08             	mov    0x8(%ebp),%eax
c01067e2:	c1 e8 0c             	shr    $0xc,%eax
c01067e5:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if (pg && pg < max_pg)
c01067e8:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c01067ec:	74 1c                	je     c010680a <pmm_free_page+0x31>
c01067ee:	a1 40 80 12 c0       	mov    0xc0128040,%eax
c01067f3:	39 45 fc             	cmp    %eax,-0x4(%ebp)
c01067f6:	73 12                	jae    c010680a <pmm_free_page+0x31>
    {
        pmm_mark_page_free(pg);
c01067f8:	ff 75 fc             	push   -0x4(%ebp)
c01067fb:	e8 b9 fd ff ff       	call   c01065b9 <pmm_mark_page_free>
c0106800:	83 c4 04             	add    $0x4,%esp
        return 1;
c0106803:	b8 01 00 00 00       	mov    $0x1,%eax
c0106808:	eb 05                	jmp    c010680f <pmm_free_page+0x36>
    }
    return 0;
c010680a:	b8 00 00 00 00       	mov    $0x0,%eax
c010680f:	c9                   	leave  
c0106810:	c3                   	ret    

c0106811 <vmm_init>:
#include <kernel/memory/vir_mem.h>
#include <libs/string.h>

void vmm_init() {
c0106811:	55                   	push   %ebp
c0106812:	89 e5                	mov    %esp,%ebp
    // TODO: something here?
}
c0106814:	90                   	nop
c0106815:	5d                   	pop    %ebp
c0106816:	c3                   	ret    

c0106817 <get_pd>:

// TODO: Move these nasty inline asm stuff into hal
//      These should be arch dependent
ptd_t* get_pd() {
c0106817:	55                   	push   %ebp
c0106818:	89 e5                	mov    %esp,%ebp
c010681a:	83 ec 10             	sub    $0x10,%esp
    ptd_t* pd;
    #ifdef __ARCH_IA32
    __asm__(
c010681d:	0f 20 d8             	mov    %cr3,%eax
c0106820:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0106825:	89 45 fc             	mov    %eax,-0x4(%ebp)
        "movl %%cr3, %0\n"
        "andl $0xfffff000, %0"
        : "=r"(pd)
    );
    #endif
    return P2V(pd);
c0106828:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010682b:	2d 00 00 00 40       	sub    $0x40000000,%eax
}
c0106830:	c9                   	leave  
c0106831:	c3                   	ret    

c0106832 <set_pd>:

void set_pd(ptd_t* pd) {
c0106832:	55                   	push   %ebp
c0106833:	89 e5                	mov    %esp,%ebp
    #ifdef __ARCH_IA32
    __asm__(
c0106835:	8b 45 08             	mov    0x8(%ebp),%eax
c0106838:	89 c0                	mov    %eax,%eax
c010683a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010683f:	0f 22 d8             	mov    %eax,%cr3
        "movl %%eax, %%cr3\n"
        :
        : "r" (pd)
    );
    #endif
}
c0106842:	90                   	nop
c0106843:	5d                   	pop    %ebp
c0106844:	c3                   	ret    

c0106845 <vmm_init_pd>:

ptd_t* vmm_init_pd() {
c0106845:	55                   	push   %ebp
c0106846:	89 e5                	mov    %esp,%ebp
c0106848:	83 ec 18             	sub    $0x18,%esp
    ptd_t* dir = pmm_alloc_page();
c010684b:	e8 a1 fe ff ff       	call   c01066f1 <pmm_alloc_page>
c0106850:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for (size_t i = 0; i < 1024; i++)
c0106853:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c010685a:	eb 19                	jmp    c0106875 <vmm_init_pd+0x30>
    {
        dir[i] = 0;
c010685c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010685f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0106866:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106869:	01 d0                	add    %edx,%eax
c010686b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    for (size_t i = 0; i < 1024; i++)
c0106871:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0106875:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
c010687c:	76 de                	jbe    c010685c <vmm_init_pd+0x17>
    }
    
    // 自己映射自己，方便我们在软件层面进行查表地址转换
    dir[1023] = PDE(T_SELF_REF_PERM, dir);
c010687e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106881:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0106886:	89 c2                	mov    %eax,%edx
c0106888:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010688b:	05 fc 0f 00 00       	add    $0xffc,%eax
c0106890:	83 ca 13             	or     $0x13,%edx
c0106893:	89 10                	mov    %edx,(%eax)

    return dir;
c0106895:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0106898:	c9                   	leave  
c0106899:	c3                   	ret    

c010689a <vmm_map_page>:

void* vmm_map_page(void* va, void* pa, pt_attr dattr, pt_attr tattr) {
c010689a:	55                   	push   %ebp
c010689b:	89 e5                	mov    %esp,%ebp
c010689d:	53                   	push   %ebx
c010689e:	83 ec 24             	sub    $0x24,%esp
    // 显然，对空指针进行映射没有意义。
    if (!pa || !va) {
c01068a1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c01068a5:	74 06                	je     c01068ad <vmm_map_page+0x13>
c01068a7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c01068ab:	75 0a                	jne    c01068b7 <vmm_map_page+0x1d>
        return NULL;
c01068ad:	b8 00 00 00 00       	mov    $0x0,%eax
c01068b2:	e9 a4 01 00 00       	jmp    c0106a5b <vmm_map_page+0x1c1>
    }

    uintptr_t pd_offset = PD_INDEX(va);
c01068b7:	8b 45 08             	mov    0x8(%ebp),%eax
c01068ba:	c1 e8 16             	shr    $0x16,%eax
c01068bd:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uintptr_t pt_offset = PT_INDEX(va);
c01068c0:	8b 45 08             	mov    0x8(%ebp),%eax
c01068c3:	c1 e8 0c             	shr    $0xc,%eax
c01068c6:	25 ff 03 00 00       	and    $0x3ff,%eax
c01068cb:	89 45 f0             	mov    %eax,-0x10(%ebp)
    ptd_t* ptd = (ptd_t*)PTD_BASE_VADDR;
c01068ce:	c7 45 e4 00 f0 ff ff 	movl   $0xfffff000,-0x1c(%ebp)

    // 在页表与页目录中找到一个可用的空位进行映射（位于va或其附近）
    ptd_t* pde = ptd[pd_offset];
c01068d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01068d8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c01068df:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01068e2:	01 d0                	add    %edx,%eax
c01068e4:	8b 00                	mov    (%eax),%eax
c01068e6:	89 45 ec             	mov    %eax,-0x14(%ebp)
    pt_t* pt = (uintptr_t)PT_VADDR(pd_offset);
c01068e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01068ec:	c1 e0 0c             	shl    $0xc,%eax
c01068ef:	0d 00 00 c0 ff       	or     $0xffc00000,%eax
c01068f4:	89 45 e8             	mov    %eax,-0x18(%ebp)
    while (pde && pd_offset < 1024) {
c01068f7:	e9 9b 00 00 00       	jmp    c0106997 <vmm_map_page+0xfd>
        if (pt_offset == 1024) {
c01068fc:	81 7d f0 00 04 00 00 	cmpl   $0x400,-0x10(%ebp)
c0106903:	75 2d                	jne    c0106932 <vmm_map_page+0x98>
            pd_offset++;
c0106905:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
            pt_offset = 0;
c0106909:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            pde = ptd[pd_offset];
c0106910:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106913:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010691a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010691d:	01 d0                	add    %edx,%eax
c010691f:	8b 00                	mov    (%eax),%eax
c0106921:	89 45 ec             	mov    %eax,-0x14(%ebp)
            pt = (pt_t*)PT_VADDR(pd_offset);
c0106924:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106927:	c1 e0 0c             	shl    $0xc,%eax
c010692a:	0d 00 00 c0 ff       	or     $0xffc00000,%eax
c010692f:	89 45 e8             	mov    %eax,-0x18(%ebp)
        }
        // 页表有空位，只需要开辟一个新的 PTE
        if (pt && !pt[pt_offset]) {
c0106932:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0106936:	74 5b                	je     c0106993 <vmm_map_page+0xf9>
c0106938:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010693b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0106942:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0106945:	01 d0                	add    %edx,%eax
c0106947:	8b 00                	mov    (%eax),%eax
c0106949:	85 c0                	test   %eax,%eax
c010694b:	75 46                	jne    c0106993 <vmm_map_page+0xf9>
            pt[pt_offset] = PTE(tattr, pa);
c010694d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0106950:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0106955:	89 c1                	mov    %eax,%ecx
c0106957:	8b 45 14             	mov    0x14(%ebp),%eax
c010695a:	25 ff 0f 00 00       	and    $0xfff,%eax
c010695f:	89 c2                	mov    %eax,%edx
c0106961:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106964:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
c010696b:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010696e:	01 d8                	add    %ebx,%eax
c0106970:	09 ca                	or     %ecx,%edx
c0106972:	89 10                	mov    %edx,(%eax)
            return V_ADDR(pd_offset, pt_offset, PG_OFFSET(va));
c0106974:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106977:	c1 e0 16             	shl    $0x16,%eax
c010697a:	89 c2                	mov    %eax,%edx
c010697c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010697f:	c1 e0 0c             	shl    $0xc,%eax
c0106982:	09 c2                	or     %eax,%edx
c0106984:	8b 45 08             	mov    0x8(%ebp),%eax
c0106987:	25 ff 0f 00 00       	and    $0xfff,%eax
c010698c:	09 d0                	or     %edx,%eax
c010698e:	e9 c8 00 00 00       	jmp    c0106a5b <vmm_map_page+0x1c1>
        }
        pt_offset++;
c0106993:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    while (pde && pd_offset < 1024) {
c0106997:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c010699b:	74 0d                	je     c01069aa <vmm_map_page+0x110>
c010699d:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
c01069a4:	0f 86 52 ff ff ff    	jbe    c01068fc <vmm_map_page+0x62>
    }
    
    // 页目录与所有页表已满！
    if (pd_offset > 1024) {
c01069aa:	81 7d f4 00 04 00 00 	cmpl   $0x400,-0xc(%ebp)
c01069b1:	76 0a                	jbe    c01069bd <vmm_map_page+0x123>
        return NULL;
c01069b3:	b8 00 00 00 00       	mov    $0x0,%eax
c01069b8:	e9 9e 00 00 00       	jmp    c0106a5b <vmm_map_page+0x1c1>
    }

    // 页目录有空位，需要开辟一个新的 PDE
    uint8_t* new_pt_pa = pmm_alloc_page();
c01069bd:	e8 2f fd ff ff       	call   c01066f1 <pmm_alloc_page>
c01069c2:	89 45 e0             	mov    %eax,-0x20(%ebp)
    
    // 物理内存已满！
    if (!new_pt_pa) {
c01069c5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c01069c9:	75 0a                	jne    c01069d5 <vmm_map_page+0x13b>
        return NULL;
c01069cb:	b8 00 00 00 00       	mov    $0x0,%eax
c01069d0:	e9 86 00 00 00       	jmp    c0106a5b <vmm_map_page+0x1c1>
    }
    
    ptd[pd_offset] = PDE(dattr, new_pt_pa);
c01069d5:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01069d8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c01069dd:	89 c1                	mov    %eax,%ecx
c01069df:	8b 45 10             	mov    0x10(%ebp),%eax
c01069e2:	25 ff 0f 00 00       	and    $0xfff,%eax
c01069e7:	89 c2                	mov    %eax,%edx
c01069e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01069ec:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
c01069f3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01069f6:	01 d8                	add    %ebx,%eax
c01069f8:	09 ca                	or     %ecx,%edx
c01069fa:	89 10                	mov    %edx,(%eax)
    
    memset((void*)PT_VADDR(pd_offset), 0, PM_PAGE_SIZE);
c01069fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01069ff:	c1 e0 0c             	shl    $0xc,%eax
c0106a02:	0d 00 00 c0 ff       	or     $0xffc00000,%eax
c0106a07:	83 ec 04             	sub    $0x4,%esp
c0106a0a:	68 00 10 00 00       	push   $0x1000
c0106a0f:	6a 00                	push   $0x0
c0106a11:	50                   	push   %eax
c0106a12:	e8 de 0c 00 00       	call   c01076f5 <memset>
c0106a17:	83 c4 10             	add    $0x10,%esp
    pt[pt_offset] = PTE(tattr, pa);
c0106a1a:	8b 45 0c             	mov    0xc(%ebp),%eax
c0106a1d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0106a22:	89 c1                	mov    %eax,%ecx
c0106a24:	8b 45 14             	mov    0x14(%ebp),%eax
c0106a27:	25 ff 0f 00 00       	and    $0xfff,%eax
c0106a2c:	89 c2                	mov    %eax,%edx
c0106a2e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106a31:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
c0106a38:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0106a3b:	01 d8                	add    %ebx,%eax
c0106a3d:	09 ca                	or     %ecx,%edx
c0106a3f:	89 10                	mov    %edx,(%eax)

    return V_ADDR(pd_offset, pt_offset, PG_OFFSET(va));
c0106a41:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106a44:	c1 e0 16             	shl    $0x16,%eax
c0106a47:	89 c2                	mov    %eax,%edx
c0106a49:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106a4c:	c1 e0 0c             	shl    $0xc,%eax
c0106a4f:	09 c2                	or     %eax,%edx
c0106a51:	8b 45 08             	mov    0x8(%ebp),%eax
c0106a54:	25 ff 0f 00 00       	and    $0xfff,%eax
c0106a59:	09 d0                	or     %edx,%eax
}
c0106a5b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0106a5e:	c9                   	leave  
c0106a5f:	c3                   	ret    

c0106a60 <vmm_alloc_page>:

void* vmm_alloc_page(void* vpn, pt_attr dattr, pt_attr tattr) {
c0106a60:	55                   	push   %ebp
c0106a61:	89 e5                	mov    %esp,%ebp
c0106a63:	83 ec 18             	sub    $0x18,%esp
    void* pp = pmm_alloc_page();
c0106a66:	e8 86 fc ff ff       	call   c01066f1 <pmm_alloc_page>
c0106a6b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    void* result = vmm_map_page(vpn, pp, dattr, tattr);
c0106a6e:	ff 75 10             	push   0x10(%ebp)
c0106a71:	ff 75 0c             	push   0xc(%ebp)
c0106a74:	ff 75 f4             	push   -0xc(%ebp)
c0106a77:	ff 75 08             	push   0x8(%ebp)
c0106a7a:	e8 1b fe ff ff       	call   c010689a <vmm_map_page>
c0106a7f:	83 c4 10             	add    $0x10,%esp
c0106a82:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (!result) {
c0106a85:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0106a89:	75 0e                	jne    c0106a99 <vmm_alloc_page+0x39>
        pmm_free_page(pp);
c0106a8b:	83 ec 0c             	sub    $0xc,%esp
c0106a8e:	ff 75 f4             	push   -0xc(%ebp)
c0106a91:	e8 43 fd ff ff       	call   c01067d9 <pmm_free_page>
c0106a96:	83 c4 10             	add    $0x10,%esp
    }
    return result;
c0106a99:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0106a9c:	c9                   	leave  
c0106a9d:	c3                   	ret    

c0106a9e <vmm_unmap_page>:

void vmm_unmap_page(void* vpn) {
c0106a9e:	55                   	push   %ebp
c0106a9f:	89 e5                	mov    %esp,%ebp
c0106aa1:	83 ec 28             	sub    $0x28,%esp
    uintptr_t pd_offset = PD_INDEX(vpn);
c0106aa4:	8b 45 08             	mov    0x8(%ebp),%eax
c0106aa7:	c1 e8 16             	shr    $0x16,%eax
c0106aaa:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uintptr_t pt_offset = PT_INDEX(vpn);
c0106aad:	8b 45 08             	mov    0x8(%ebp),%eax
c0106ab0:	c1 e8 0c             	shr    $0xc,%eax
c0106ab3:	25 ff 03 00 00       	and    $0x3ff,%eax
c0106ab8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    ptd_t* self_pde = PTD_BASE_VADDR;
c0106abb:	c7 45 ec 00 f0 ff ff 	movl   $0xfffff000,-0x14(%ebp)

    ptd_t pde = self_pde[pd_offset];
c0106ac2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106ac5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0106acc:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0106acf:	01 d0                	add    %edx,%eax
c0106ad1:	8b 00                	mov    (%eax),%eax
c0106ad3:	89 45 e8             	mov    %eax,-0x18(%ebp)

    if (pde) {
c0106ad6:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0106ada:	74 5a                	je     c0106b36 <vmm_unmap_page+0x98>
        pt_t* pt = (pt_t*)PT_VADDR(pd_offset);
c0106adc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106adf:	c1 e0 0c             	shl    $0xc,%eax
c0106ae2:	0d 00 00 c0 ff       	or     $0xffc00000,%eax
c0106ae7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        uint32_t pte = pt[pt_offset];
c0106aea:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106aed:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0106af4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0106af7:	01 d0                	add    %edx,%eax
c0106af9:	8b 00                	mov    (%eax),%eax
c0106afb:	89 45 e0             	mov    %eax,-0x20(%ebp)
        if (IS_CACHED(pte) && pmm_free_page(pte)) {
c0106afe:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0106b01:	83 e0 01             	and    $0x1,%eax
c0106b04:	85 c0                	test   %eax,%eax
c0106b06:	74 19                	je     c0106b21 <vmm_unmap_page+0x83>
c0106b08:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0106b0b:	83 ec 0c             	sub    $0xc,%esp
c0106b0e:	50                   	push   %eax
c0106b0f:	e8 c5 fc ff ff       	call   c01067d9 <pmm_free_page>
c0106b14:	83 c4 10             	add    $0x10,%esp
c0106b17:	85 c0                	test   %eax,%eax
c0106b19:	74 06                	je     c0106b21 <vmm_unmap_page+0x83>
            // 刷新TLB
            #ifdef __ARCH_IA32
            __asm__("invlpg (%0)" :: "r"((uintptr_t)vpn) : "memory");
c0106b1b:	8b 45 08             	mov    0x8(%ebp),%eax
c0106b1e:	0f 01 38             	invlpg (%eax)
            #endif
        }
        //if(pt_offset != 8)
        pt[pt_offset] = 0;
c0106b21:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106b24:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0106b2b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0106b2e:	01 d0                	add    %edx,%eax
c0106b30:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
}
c0106b36:	90                   	nop
c0106b37:	c9                   	leave  
c0106b38:	c3                   	ret    

c0106b39 <vmm_v2p>:

void* vmm_v2p(void* va) {
c0106b39:	55                   	push   %ebp
c0106b3a:	89 e5                	mov    %esp,%ebp
c0106b3c:	83 ec 20             	sub    $0x20,%esp
    uintptr_t pd_offset = PD_INDEX(va);
c0106b3f:	8b 45 08             	mov    0x8(%ebp),%eax
c0106b42:	c1 e8 16             	shr    $0x16,%eax
c0106b45:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uintptr_t pt_offset = PT_INDEX(va);
c0106b48:	8b 45 08             	mov    0x8(%ebp),%eax
c0106b4b:	c1 e8 0c             	shr    $0xc,%eax
c0106b4e:	25 ff 03 00 00       	and    $0x3ff,%eax
c0106b53:	89 45 f8             	mov    %eax,-0x8(%ebp)
    uintptr_t po = PG_OFFSET(va);
c0106b56:	8b 45 08             	mov    0x8(%ebp),%eax
c0106b59:	25 ff 0f 00 00       	and    $0xfff,%eax
c0106b5e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    ptd_t* self_pde = PTD_BASE_VADDR;
c0106b61:	c7 45 f0 00 f0 ff ff 	movl   $0xfffff000,-0x10(%ebp)

    ptd_t pde = self_pde[pd_offset];
c0106b68:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106b6b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0106b72:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106b75:	01 d0                	add    %edx,%eax
c0106b77:	8b 00                	mov    (%eax),%eax
c0106b79:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (pde) {
c0106b7c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0106b80:	74 36                	je     c0106bb8 <vmm_v2p+0x7f>
        pt_t pte = ((pt_t*)PT_VADDR(pd_offset))[pt_offset];
c0106b82:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0106b85:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0106b8c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106b8f:	c1 e0 0c             	shl    $0xc,%eax
c0106b92:	0d 00 00 c0 ff       	or     $0xffc00000,%eax
c0106b97:	01 d0                	add    %edx,%eax
c0106b99:	8b 00                	mov    (%eax),%eax
c0106b9b:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if (pte) {
c0106b9e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0106ba2:	74 14                	je     c0106bb8 <vmm_v2p+0x7f>
            uintptr_t ppn = pte >> 12;
c0106ba4:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0106ba7:	c1 e8 0c             	shr    $0xc,%eax
c0106baa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            return (void*)P_ADDR(ppn, po);
c0106bad:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0106bb0:	c1 e0 0c             	shl    $0xc,%eax
c0106bb3:	0b 45 f4             	or     -0xc(%ebp),%eax
c0106bb6:	eb 05                	jmp    c0106bbd <vmm_v2p+0x84>
        }
    }

    return NULL;
c0106bb8:	b8 00 00 00 00       	mov    $0x0,%eax
c0106bbd:	c9                   	leave  
c0106bbe:	c3                   	ret    

c0106bbf <_divide_err>:
#include <libs/mstdio.h>
#include <kernel/interrupt/interupt_fun.h>
#include <vga/vga.h>
void _divide_err(unsigned long addr, int err_code)
{
c0106bbf:	55                   	push   %ebp
c0106bc0:	89 e5                	mov    %esp,%ebp
c0106bc2:	83 ec 08             	sub    $0x8,%esp
    vga_set_show(1,VGA_COLOR_BLACK,VGA_COLOR_BLUE);
c0106bc5:	83 ec 04             	sub    $0x4,%esp
c0106bc8:	6a 01                	push   $0x1
c0106bca:	6a 00                	push   $0x0
c0106bcc:	6a 01                	push   $0x1
c0106bce:	e8 f2 f4 ff ff       	call   c01060c5 <vga_set_show>
c0106bd3:	83 c4 10             	add    $0x10,%esp
    kprintf("divide err addr = 0x%x,err code = %d\n", addr,err_code);
c0106bd6:	83 ec 04             	sub    $0x4,%esp
c0106bd9:	ff 75 0c             	push   0xc(%ebp)
c0106bdc:	ff 75 08             	push   0x8(%ebp)
c0106bdf:	68 e4 a1 12 c0       	push   $0xc012a1e4
c0106be4:	e8 75 08 00 00       	call   c010745e <kprintf>
c0106be9:	83 c4 10             	add    $0x10,%esp
}
c0106bec:	90                   	nop
c0106bed:	c9                   	leave  
c0106bee:	c3                   	ret    

c0106bef <do_double_fault>:

void do_double_fault(unsigned long addr, int err_code)
{
c0106bef:	55                   	push   %ebp
c0106bf0:	89 e5                	mov    %esp,%ebp
c0106bf2:	83 ec 08             	sub    $0x8,%esp
	kprintf("double_fault addr = 0x%x,err code = %d\n", addr,err_code);
c0106bf5:	83 ec 04             	sub    $0x4,%esp
c0106bf8:	ff 75 0c             	push   0xc(%ebp)
c0106bfb:	ff 75 08             	push   0x8(%ebp)
c0106bfe:	68 0c a2 12 c0       	push   $0xc012a20c
c0106c03:	e8 56 08 00 00       	call   c010745e <kprintf>
c0106c08:	83 c4 10             	add    $0x10,%esp
}
c0106c0b:	90                   	nop
c0106c0c:	c9                   	leave  
c0106c0d:	c3                   	ret    

c0106c0e <do_general_protection>:

void do_general_protection(unsigned long addr, int err_code)
{
c0106c0e:	55                   	push   %ebp
c0106c0f:	89 e5                	mov    %esp,%ebp
c0106c11:	83 ec 08             	sub    $0x8,%esp
	kprintf("general_protection addr = 0x%x,err code = %d\n", addr,err_code);
c0106c14:	83 ec 04             	sub    $0x4,%esp
c0106c17:	ff 75 0c             	push   0xc(%ebp)
c0106c1a:	ff 75 08             	push   0x8(%ebp)
c0106c1d:	68 34 a2 12 c0       	push   $0xc012a234
c0106c22:	e8 37 08 00 00       	call   c010745e <kprintf>
c0106c27:	83 c4 10             	add    $0x10,%esp
}
c0106c2a:	90                   	nop
c0106c2b:	c9                   	leave  
c0106c2c:	c3                   	ret    

c0106c2d <do_int3>:


void do_int3(unsigned long addr, int err_code)
{
c0106c2d:	55                   	push   %ebp
c0106c2e:	89 e5                	mov    %esp,%ebp
c0106c30:	83 ec 08             	sub    $0x8,%esp
    kprintf("int3 addr = 0x%x,err code = %d\n", addr,err_code);
c0106c33:	83 ec 04             	sub    $0x4,%esp
c0106c36:	ff 75 0c             	push   0xc(%ebp)
c0106c39:	ff 75 08             	push   0x8(%ebp)
c0106c3c:	68 64 a2 12 c0       	push   $0xc012a264
c0106c41:	e8 18 08 00 00       	call   c010745e <kprintf>
c0106c46:	83 c4 10             	add    $0x10,%esp
}
c0106c49:	90                   	nop
c0106c4a:	c9                   	leave  
c0106c4b:	c3                   	ret    

c0106c4c <do_nmi>:

void do_nmi(unsigned long addr, int err_code)
{
c0106c4c:	55                   	push   %ebp
c0106c4d:	89 e5                	mov    %esp,%ebp
c0106c4f:	83 ec 08             	sub    $0x8,%esp
	kprintf("nmi addr = 0x%x,err code = %d\n", addr,err_code);
c0106c52:	83 ec 04             	sub    $0x4,%esp
c0106c55:	ff 75 0c             	push   0xc(%ebp)
c0106c58:	ff 75 08             	push   0x8(%ebp)
c0106c5b:	68 84 a2 12 c0       	push   $0xc012a284
c0106c60:	e8 f9 07 00 00       	call   c010745e <kprintf>
c0106c65:	83 c4 10             	add    $0x10,%esp
}
c0106c68:	90                   	nop
c0106c69:	c9                   	leave  
c0106c6a:	c3                   	ret    

c0106c6b <do_debug>:

void do_debug(unsigned long addr, int err_code)
{
c0106c6b:	55                   	push   %ebp
c0106c6c:	89 e5                	mov    %esp,%ebp
c0106c6e:	83 ec 08             	sub    $0x8,%esp
	kprintf("debug addr = 0x%x,err code = %d\n", addr,err_code);
c0106c71:	83 ec 04             	sub    $0x4,%esp
c0106c74:	ff 75 0c             	push   0xc(%ebp)
c0106c77:	ff 75 08             	push   0x8(%ebp)
c0106c7a:	68 a4 a2 12 c0       	push   $0xc012a2a4
c0106c7f:	e8 da 07 00 00       	call   c010745e <kprintf>
c0106c84:	83 c4 10             	add    $0x10,%esp
}
c0106c87:	90                   	nop
c0106c88:	c9                   	leave  
c0106c89:	c3                   	ret    

c0106c8a <do_overflow>:

void do_overflow(unsigned long addr, int err_code)
{
c0106c8a:	55                   	push   %ebp
c0106c8b:	89 e5                	mov    %esp,%ebp
c0106c8d:	83 ec 08             	sub    $0x8,%esp
	kprintf("overflow addr = 0x%x,err code = %d\n", addr,err_code);
c0106c90:	83 ec 04             	sub    $0x4,%esp
c0106c93:	ff 75 0c             	push   0xc(%ebp)
c0106c96:	ff 75 08             	push   0x8(%ebp)
c0106c99:	68 c8 a2 12 c0       	push   $0xc012a2c8
c0106c9e:	e8 bb 07 00 00       	call   c010745e <kprintf>
c0106ca3:	83 c4 10             	add    $0x10,%esp
}
c0106ca6:	90                   	nop
c0106ca7:	c9                   	leave  
c0106ca8:	c3                   	ret    

c0106ca9 <do_bounds>:

void do_bounds(unsigned long addr, int err_code)
{
c0106ca9:	55                   	push   %ebp
c0106caa:	89 e5                	mov    %esp,%ebp
c0106cac:	83 ec 08             	sub    $0x8,%esp
	kprintf("bounds addr = 0x%x,err code = %d\n", addr,err_code);
c0106caf:	83 ec 04             	sub    $0x4,%esp
c0106cb2:	ff 75 0c             	push   0xc(%ebp)
c0106cb5:	ff 75 08             	push   0x8(%ebp)
c0106cb8:	68 ec a2 12 c0       	push   $0xc012a2ec
c0106cbd:	e8 9c 07 00 00       	call   c010745e <kprintf>
c0106cc2:	83 c4 10             	add    $0x10,%esp
}
c0106cc5:	90                   	nop
c0106cc6:	c9                   	leave  
c0106cc7:	c3                   	ret    

c0106cc8 <do_invalid_op>:

void do_invalid_op(unsigned long addr, int err_code)
{
c0106cc8:	55                   	push   %ebp
c0106cc9:	89 e5                	mov    %esp,%ebp
c0106ccb:	83 ec 08             	sub    $0x8,%esp
	kprintf("invalid_op addr = 0x%x,err code = %d\n", addr,err_code);
c0106cce:	83 ec 04             	sub    $0x4,%esp
c0106cd1:	ff 75 0c             	push   0xc(%ebp)
c0106cd4:	ff 75 08             	push   0x8(%ebp)
c0106cd7:	68 10 a3 12 c0       	push   $0xc012a310
c0106cdc:	e8 7d 07 00 00       	call   c010745e <kprintf>
c0106ce1:	83 c4 10             	add    $0x10,%esp
}
c0106ce4:	90                   	nop
c0106ce5:	c9                   	leave  
c0106ce6:	c3                   	ret    

c0106ce7 <do_device_not_available>:

void do_device_not_available(unsigned long addr, int err_code)
{
c0106ce7:	55                   	push   %ebp
c0106ce8:	89 e5                	mov    %esp,%ebp
c0106cea:	83 ec 08             	sub    $0x8,%esp
	kprintf("device_not_availabel addr = 0x%x,err code = %d\n", addr,err_code);
c0106ced:	83 ec 04             	sub    $0x4,%esp
c0106cf0:	ff 75 0c             	push   0xc(%ebp)
c0106cf3:	ff 75 08             	push   0x8(%ebp)
c0106cf6:	68 38 a3 12 c0       	push   $0xc012a338
c0106cfb:	e8 5e 07 00 00       	call   c010745e <kprintf>
c0106d00:	83 c4 10             	add    $0x10,%esp
}
c0106d03:	90                   	nop
c0106d04:	c9                   	leave  
c0106d05:	c3                   	ret    

c0106d06 <do_coprocessor_segment_overrun>:

void do_coprocessor_segment_overrun(unsigned long addr, int err_code)
{
c0106d06:	55                   	push   %ebp
c0106d07:	89 e5                	mov    %esp,%ebp
c0106d09:	83 ec 08             	sub    $0x8,%esp
	kprintf("coprprocessor_segment_overrun addr = 0x%x,err code = %d\n", addr,err_code);
c0106d0c:	83 ec 04             	sub    $0x4,%esp
c0106d0f:	ff 75 0c             	push   0xc(%ebp)
c0106d12:	ff 75 08             	push   0x8(%ebp)
c0106d15:	68 68 a3 12 c0       	push   $0xc012a368
c0106d1a:	e8 3f 07 00 00       	call   c010745e <kprintf>
c0106d1f:	83 c4 10             	add    $0x10,%esp
}
c0106d22:	90                   	nop
c0106d23:	c9                   	leave  
c0106d24:	c3                   	ret    

c0106d25 <do_invalid_TSS>:

void do_invalid_TSS(unsigned long addr, int err_code)
{
c0106d25:	55                   	push   %ebp
c0106d26:	89 e5                	mov    %esp,%ebp
c0106d28:	83 ec 08             	sub    $0x8,%esp
	kprintf("invalid_TSS addr = 0x%x,err code = %d\n", addr,err_code);
c0106d2b:	83 ec 04             	sub    $0x4,%esp
c0106d2e:	ff 75 0c             	push   0xc(%ebp)
c0106d31:	ff 75 08             	push   0x8(%ebp)
c0106d34:	68 a4 a3 12 c0       	push   $0xc012a3a4
c0106d39:	e8 20 07 00 00       	call   c010745e <kprintf>
c0106d3e:	83 c4 10             	add    $0x10,%esp
}
c0106d41:	90                   	nop
c0106d42:	c9                   	leave  
c0106d43:	c3                   	ret    

c0106d44 <do_segment_not_present>:

void do_segment_not_present(unsigned long addr, int err_code)
{
c0106d44:	55                   	push   %ebp
c0106d45:	89 e5                	mov    %esp,%ebp
c0106d47:	83 ec 08             	sub    $0x8,%esp
	kprintf("segment not present addr = 0x%x,err code = %d\n", addr,err_code);
c0106d4a:	83 ec 04             	sub    $0x4,%esp
c0106d4d:	ff 75 0c             	push   0xc(%ebp)
c0106d50:	ff 75 08             	push   0x8(%ebp)
c0106d53:	68 cc a3 12 c0       	push   $0xc012a3cc
c0106d58:	e8 01 07 00 00       	call   c010745e <kprintf>
c0106d5d:	83 c4 10             	add    $0x10,%esp
}
c0106d60:	90                   	nop
c0106d61:	c9                   	leave  
c0106d62:	c3                   	ret    

c0106d63 <do_stack_segment>:

void do_stack_segment(unsigned long addr, int err_code)
{
c0106d63:	55                   	push   %ebp
c0106d64:	89 e5                	mov    %esp,%ebp
c0106d66:	83 ec 08             	sub    $0x8,%esp
	kprintf("stack_segment addr = 0x%x,err code = %d\n", addr,err_code);
c0106d69:	83 ec 04             	sub    $0x4,%esp
c0106d6c:	ff 75 0c             	push   0xc(%ebp)
c0106d6f:	ff 75 08             	push   0x8(%ebp)
c0106d72:	68 fc a3 12 c0       	push   $0xc012a3fc
c0106d77:	e8 e2 06 00 00       	call   c010745e <kprintf>
c0106d7c:	83 c4 10             	add    $0x10,%esp
}
c0106d7f:	90                   	nop
c0106d80:	c9                   	leave  
c0106d81:	c3                   	ret    

c0106d82 <do_coprocessor_error>:

void do_coprocessor_error(unsigned long addr, int err_code)
{
c0106d82:	55                   	push   %ebp
c0106d83:	89 e5                	mov    %esp,%ebp
c0106d85:	83 ec 08             	sub    $0x8,%esp
    kprintf("coprocessor_err addr = 0x%x,err code = %d\n", addr,err_code);
c0106d88:	83 ec 04             	sub    $0x4,%esp
c0106d8b:	ff 75 0c             	push   0xc(%ebp)
c0106d8e:	ff 75 08             	push   0x8(%ebp)
c0106d91:	68 28 a4 12 c0       	push   $0xc012a428
c0106d96:	e8 c3 06 00 00       	call   c010745e <kprintf>
c0106d9b:	83 c4 10             	add    $0x10,%esp
}
c0106d9e:	90                   	nop
c0106d9f:	c9                   	leave  
c0106da0:	c3                   	ret    

c0106da1 <do_reserved>:

void do_reserved(unsigned long addr, int err_code)
{
c0106da1:	55                   	push   %ebp
c0106da2:	89 e5                	mov    %esp,%ebp
c0106da4:	83 ec 08             	sub    $0x8,%esp
	kprintf("reserved addr = 0x%x,err code = %d\n", addr,err_code);
c0106da7:	83 ec 04             	sub    $0x4,%esp
c0106daa:	ff 75 0c             	push   0xc(%ebp)
c0106dad:	ff 75 08             	push   0x8(%ebp)
c0106db0:	68 54 a4 12 c0       	push   $0xc012a454
c0106db5:	e8 a4 06 00 00       	call   c010745e <kprintf>
c0106dba:	83 c4 10             	add    $0x10,%esp
c0106dbd:	90                   	nop
c0106dbe:	c9                   	leave  
c0106dbf:	c3                   	ret    

c0106dc0 <_no_err_code>:
c0106dc0:	87 04 24             	xchg   %eax,(%esp)
c0106dc3:	53                   	push   %ebx
c0106dc4:	52                   	push   %edx
c0106dc5:	55                   	push   %ebp
c0106dc6:	1e                   	push   %ds
c0106dc7:	06                   	push   %es
c0106dc8:	0f a0                	push   %fs
c0106dca:	6a 00                	push   $0x0
c0106dcc:	8d 54 24 20          	lea    0x20(%esp),%edx
c0106dd0:	52                   	push   %edx
c0106dd1:	ba 10 00 00 00       	mov    $0x10,%edx
c0106dd6:	8e da                	mov    %edx,%ds
c0106dd8:	8e c2                	mov    %edx,%es
c0106dda:	8e e2                	mov    %edx,%fs
c0106ddc:	ff d0                	call   *%eax
c0106dde:	83 c4 08             	add    $0x8,%esp
c0106de1:	0f a1                	pop    %fs
c0106de3:	07                   	pop    %es
c0106de4:	1f                   	pop    %ds
c0106de5:	5d                   	pop    %ebp
c0106de6:	5a                   	pop    %edx
c0106de7:	5b                   	pop    %ebx
c0106de8:	58                   	pop    %eax
c0106de9:	cf                   	iret   

c0106dea <_err_code>:
c0106dea:	87 44 24 04          	xchg   %eax,0x4(%esp)
c0106dee:	87 1c 24             	xchg   %ebx,(%esp)
c0106df1:	52                   	push   %edx
c0106df2:	55                   	push   %ebp
c0106df3:	1e                   	push   %ds
c0106df4:	06                   	push   %es
c0106df5:	0f a0                	push   %fs
c0106df7:	50                   	push   %eax
c0106df8:	8d 44 24 20          	lea    0x20(%esp),%eax
c0106dfc:	50                   	push   %eax
c0106dfd:	b8 10 00 00 00       	mov    $0x10,%eax
c0106e02:	8e d8                	mov    %eax,%ds
c0106e04:	8e c0                	mov    %eax,%es
c0106e06:	8e e0                	mov    %eax,%fs
c0106e08:	ff d3                	call   *%ebx
c0106e0a:	83 c4 08             	add    $0x8,%esp
c0106e0d:	0f a1                	pop    %fs
c0106e0f:	07                   	pop    %es
c0106e10:	1f                   	pop    %ds
c0106e11:	5d                   	pop    %ebp
c0106e12:	5a                   	pop    %edx
c0106e13:	5b                   	pop    %ebx
c0106e14:	58                   	pop    %eax
c0106e15:	cf                   	iret   

c0106e16 <divide_error>:
c0106e16:	68 bf 6b 10 c0       	push   $0xc0106bbf
c0106e1b:	eb a3                	jmp    c0106dc0 <_no_err_code>

c0106e1d <debug>:
c0106e1d:	68 2d 6c 10 c0       	push   $0xc0106c2d
c0106e22:	eb 9c                	jmp    c0106dc0 <_no_err_code>

c0106e24 <nmi>:
c0106e24:	68 4c 6c 10 c0       	push   $0xc0106c4c
c0106e29:	eb 95                	jmp    c0106dc0 <_no_err_code>

c0106e2b <int3>:
c0106e2b:	68 2d 6c 10 c0       	push   $0xc0106c2d
c0106e30:	eb 8e                	jmp    c0106dc0 <_no_err_code>

c0106e32 <overflow>:
c0106e32:	68 8a 6c 10 c0       	push   $0xc0106c8a
c0106e37:	eb 87                	jmp    c0106dc0 <_no_err_code>

c0106e39 <bounds>:
c0106e39:	68 a9 6c 10 c0       	push   $0xc0106ca9
c0106e3e:	eb 80                	jmp    c0106dc0 <_no_err_code>

c0106e40 <invalid_op>:
c0106e40:	68 c8 6c 10 c0       	push   $0xc0106cc8
c0106e45:	e9 76 ff ff ff       	jmp    c0106dc0 <_no_err_code>

c0106e4a <coprocessor_segment_overrun>:
c0106e4a:	68 06 6d 10 c0       	push   $0xc0106d06
c0106e4f:	e9 6c ff ff ff       	jmp    c0106dc0 <_no_err_code>

c0106e54 <reserved>:
c0106e54:	68 a1 6d 10 c0       	push   $0xc0106da1
c0106e59:	e9 62 ff ff ff       	jmp    c0106dc0 <_no_err_code>

c0106e5e <invalid_TSS>:
c0106e5e:	68 25 6d 10 c0       	push   $0xc0106d25
c0106e63:	eb 85                	jmp    c0106dea <_err_code>

c0106e65 <segment_not_present>:
c0106e65:	68 44 6d 10 c0       	push   $0xc0106d44
c0106e6a:	e9 7b ff ff ff       	jmp    c0106dea <_err_code>

c0106e6f <stack_segment>:
c0106e6f:	68 63 6d 10 c0       	push   $0xc0106d63
c0106e74:	e9 71 ff ff ff       	jmp    c0106dea <_err_code>

c0106e79 <general_protection>:
c0106e79:	68 0e 6c 10 c0       	push   $0xc0106c0e
c0106e7e:	e9 67 ff ff ff       	jmp    c0106dea <_err_code>

c0106e83 <__get_cpuid_max>:
   pointer is non-null, then first four bytes of the signature
   (as found in ebx register) are returned in location pointed by sig.  */

static __inline unsigned int
__get_cpuid_max (unsigned int __ext, unsigned int *__sig)
{
c0106e83:	55                   	push   %ebp
c0106e84:	89 e5                	mov    %esp,%ebp
c0106e86:	53                   	push   %ebx
c0106e87:	83 ec 10             	sub    $0x10,%esp
  unsigned int __eax, __ebx, __ecx, __edx;

#ifndef __x86_64__
  /* See if we can use cpuid.  On AMD64 we always can.  */
#if __GNUC__ >= 3
  __asm__ ("pushf{l|d}\n\t"
c0106e8a:	9c                   	pushf  
c0106e8b:	9c                   	pushf  
c0106e8c:	5a                   	pop    %edx
c0106e8d:	89 d0                	mov    %edx,%eax
c0106e8f:	81 f2 00 00 20 00    	xor    $0x200000,%edx
c0106e95:	52                   	push   %edx
c0106e96:	9d                   	popf   
c0106e97:	9c                   	pushf  
c0106e98:	5a                   	pop    %edx
c0106e99:	9d                   	popf   
c0106e9a:	89 55 f8             	mov    %edx,-0x8(%ebp)
c0106e9d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	   "popfl\n\t"
	   : "=&r" (__eax), "=&r" (__ebx)
	   : "i" (0x00200000));
#endif

  if (!((__eax ^ __ebx) & 0x00200000))
c0106ea0:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0106ea3:	33 45 f4             	xor    -0xc(%ebp),%eax
c0106ea6:	25 00 00 20 00       	and    $0x200000,%eax
c0106eab:	85 c0                	test   %eax,%eax
c0106ead:	75 07                	jne    c0106eb6 <__get_cpuid_max+0x33>
    return 0;
c0106eaf:	b8 00 00 00 00       	mov    $0x0,%eax
c0106eb4:	eb 30                	jmp    c0106ee6 <__get_cpuid_max+0x63>
#endif

  /* Host supports cpuid.  Return highest supported cpuid input value.  */
  __cpuid (__ext, __eax, __ebx, __ecx, __edx);
c0106eb6:	8b 45 08             	mov    0x8(%ebp),%eax
c0106eb9:	b9 00 00 00 00       	mov    $0x0,%ecx
c0106ebe:	ba 00 00 00 00       	mov    $0x0,%edx
c0106ec3:	89 cb                	mov    %ecx,%ebx
c0106ec5:	89 d1                	mov    %edx,%ecx
c0106ec7:	0f a2                	cpuid  
c0106ec9:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0106ecc:	89 5d f4             	mov    %ebx,-0xc(%ebp)
c0106ecf:	89 4d f0             	mov    %ecx,-0x10(%ebp)
c0106ed2:	89 55 ec             	mov    %edx,-0x14(%ebp)

  if (__sig)
c0106ed5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0106ed9:	74 08                	je     c0106ee3 <__get_cpuid_max+0x60>
    *__sig = __ebx;
c0106edb:	8b 45 0c             	mov    0xc(%ebp),%eax
c0106ede:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0106ee1:	89 10                	mov    %edx,(%eax)

  return __eax;
c0106ee3:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
c0106ee6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0106ee9:	c9                   	leave  
c0106eea:	c3                   	ret    

c0106eeb <__get_cpuid>:

static __inline int
__get_cpuid (unsigned int __leaf,
	     unsigned int *__eax, unsigned int *__ebx,
	     unsigned int *__ecx, unsigned int *__edx)
{
c0106eeb:	55                   	push   %ebp
c0106eec:	89 e5                	mov    %esp,%ebp
c0106eee:	56                   	push   %esi
c0106eef:	53                   	push   %ebx
c0106ef0:	83 ec 10             	sub    $0x10,%esp
  unsigned int __ext = __leaf & 0x80000000;
c0106ef3:	8b 45 08             	mov    0x8(%ebp),%eax
c0106ef6:	25 00 00 00 80       	and    $0x80000000,%eax
c0106efb:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned int __maxlevel = __get_cpuid_max (__ext, 0);
c0106efe:	6a 00                	push   $0x0
c0106f00:	ff 75 f4             	push   -0xc(%ebp)
c0106f03:	e8 7b ff ff ff       	call   c0106e83 <__get_cpuid_max>
c0106f08:	83 c4 08             	add    $0x8,%esp
c0106f0b:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if (__maxlevel == 0 || __maxlevel < __leaf)
c0106f0e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0106f12:	74 08                	je     c0106f1c <__get_cpuid+0x31>
c0106f14:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106f17:	3b 45 08             	cmp    0x8(%ebp),%eax
c0106f1a:	73 07                	jae    c0106f23 <__get_cpuid+0x38>
    return 0;
c0106f1c:	b8 00 00 00 00       	mov    $0x0,%eax
c0106f21:	eb 2c                	jmp    c0106f4f <__get_cpuid+0x64>

  __cpuid (__leaf, *__eax, *__ebx, *__ecx, *__edx);
c0106f23:	8b 45 08             	mov    0x8(%ebp),%eax
c0106f26:	b9 00 00 00 00       	mov    $0x0,%ecx
c0106f2b:	ba 00 00 00 00       	mov    $0x0,%edx
c0106f30:	89 cb                	mov    %ecx,%ebx
c0106f32:	89 d1                	mov    %edx,%ecx
c0106f34:	0f a2                	cpuid  
c0106f36:	8b 75 0c             	mov    0xc(%ebp),%esi
c0106f39:	89 06                	mov    %eax,(%esi)
c0106f3b:	8b 45 10             	mov    0x10(%ebp),%eax
c0106f3e:	89 18                	mov    %ebx,(%eax)
c0106f40:	8b 45 14             	mov    0x14(%ebp),%eax
c0106f43:	89 08                	mov    %ecx,(%eax)
c0106f45:	8b 45 18             	mov    0x18(%ebp),%eax
c0106f48:	89 10                	mov    %edx,(%eax)
  return 1;
c0106f4a:	b8 01 00 00 00       	mov    $0x1,%eax
}
c0106f4f:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0106f52:	5b                   	pop    %ebx
c0106f53:	5e                   	pop    %esi
c0106f54:	5d                   	pop    %ebp
c0106f55:	c3                   	ret    

c0106f56 <cpu_get_model>:
#include <kernel/cpu/cpu.h>
#include <stdint.h>
#include <cpuid.h>

void cpu_get_model(char* model_out) {
c0106f56:	55                   	push   %ebp
c0106f57:	89 e5                	mov    %esp,%ebp
c0106f59:	83 ec 20             	sub    $0x20,%esp
    uint32_t* out = (uint32_t*)model_out;
c0106f5c:	8b 45 08             	mov    0x8(%ebp),%eax
c0106f5f:	89 45 fc             	mov    %eax,-0x4(%ebp)
    reg32 eax, ebx, edx, ecx;
    
    __get_cpuid(0, &eax, &ebx, &ecx, &edx);
c0106f62:	8d 45 f0             	lea    -0x10(%ebp),%eax
c0106f65:	50                   	push   %eax
c0106f66:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0106f69:	50                   	push   %eax
c0106f6a:	8d 45 f4             	lea    -0xc(%ebp),%eax
c0106f6d:	50                   	push   %eax
c0106f6e:	8d 45 f8             	lea    -0x8(%ebp),%eax
c0106f71:	50                   	push   %eax
c0106f72:	6a 00                	push   $0x0
c0106f74:	e8 72 ff ff ff       	call   c0106eeb <__get_cpuid>
c0106f79:	83 c4 14             	add    $0x14,%esp

    out[0] = ebx;
c0106f7c:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0106f7f:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106f82:	89 10                	mov    %edx,(%eax)
    out[1] = edx;
c0106f84:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106f87:	8d 50 04             	lea    0x4(%eax),%edx
c0106f8a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106f8d:	89 02                	mov    %eax,(%edx)
    out[2] = ecx;
c0106f8f:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106f92:	8d 50 08             	lea    0x8(%eax),%edx
c0106f95:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0106f98:	89 02                	mov    %eax,(%edx)
    model_out[12] = '\0';
c0106f9a:	8b 45 08             	mov    0x8(%ebp),%eax
c0106f9d:	83 c0 0c             	add    $0xc,%eax
c0106fa0:	c6 00 00             	movb   $0x0,(%eax)
}
c0106fa3:	90                   	nop
c0106fa4:	c9                   	leave  
c0106fa5:	c3                   	ret    

c0106fa6 <cpu_brand_string_supported>:

#define BRAND_LEAF 0x80000000UL

int cpu_brand_string_supported() {
c0106fa6:	55                   	push   %ebp
c0106fa7:	89 e5                	mov    %esp,%ebp
c0106fa9:	83 ec 10             	sub    $0x10,%esp
    reg32 supported = __get_cpuid_max(BRAND_LEAF, 0);
c0106fac:	6a 00                	push   $0x0
c0106fae:	68 00 00 00 80       	push   $0x80000000
c0106fb3:	e8 cb fe ff ff       	call   c0106e83 <__get_cpuid_max>
c0106fb8:	83 c4 08             	add    $0x8,%esp
c0106fbb:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return (supported >= 0x80000004UL);
c0106fbe:	81 7d fc 03 00 00 80 	cmpl   $0x80000003,-0x4(%ebp)
c0106fc5:	0f 97 c0             	seta   %al
c0106fc8:	0f b6 c0             	movzbl %al,%eax
}
c0106fcb:	c9                   	leave  
c0106fcc:	c3                   	ret    

c0106fcd <cpu_get_brand>:

void cpu_get_brand(char* brand_out) {
c0106fcd:	55                   	push   %ebp
c0106fce:	89 e5                	mov    %esp,%ebp
c0106fd0:	83 ec 20             	sub    $0x20,%esp
    if(!cpu_brand_string_supported()) {
c0106fd3:	e8 ce ff ff ff       	call   c0106fa6 <cpu_brand_string_supported>
c0106fd8:	85 c0                	test   %eax,%eax
c0106fda:	75 0f                	jne    c0106feb <cpu_get_brand+0x1e>
        brand_out[0] = '?';
c0106fdc:	8b 45 08             	mov    0x8(%ebp),%eax
c0106fdf:	c6 00 3f             	movb   $0x3f,(%eax)
        brand_out[1] = '\0';
c0106fe2:	8b 45 08             	mov    0x8(%ebp),%eax
c0106fe5:	83 c0 01             	add    $0x1,%eax
c0106fe8:	c6 00 00             	movb   $0x0,(%eax)
    }
    uint32_t* out = (uint32_t*) brand_out;
c0106feb:	8b 45 08             	mov    0x8(%ebp),%eax
c0106fee:	89 45 f4             	mov    %eax,-0xc(%ebp)
    reg32 eax, ebx, edx, ecx;
    for (uint32_t i = 2, j = 0; i < 5; i++)
c0106ff1:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
c0106ff8:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c0106fff:	e9 83 00 00 00       	jmp    c0107087 <cpu_get_brand+0xba>
    {
        __get_cpuid(BRAND_LEAF + i, &eax, &ebx, &ecx, &edx);
c0107004:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0107007:	8d 90 00 00 00 80    	lea    -0x80000000(%eax),%edx
c010700d:	8d 45 e8             	lea    -0x18(%ebp),%eax
c0107010:	50                   	push   %eax
c0107011:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0107014:	50                   	push   %eax
c0107015:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0107018:	50                   	push   %eax
c0107019:	8d 45 f0             	lea    -0x10(%ebp),%eax
c010701c:	50                   	push   %eax
c010701d:	52                   	push   %edx
c010701e:	e8 c8 fe ff ff       	call   c0106eeb <__get_cpuid>
c0107023:	83 c4 14             	add    $0x14,%esp
        out[j] = eax;
c0107026:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0107029:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0107030:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107033:	01 c2                	add    %eax,%edx
c0107035:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107038:	89 02                	mov    %eax,(%edx)
        out[j + 1] = ebx;
c010703a:	8b 45 f8             	mov    -0x8(%ebp),%eax
c010703d:	83 c0 01             	add    $0x1,%eax
c0107040:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0107047:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010704a:	01 c2                	add    %eax,%edx
c010704c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010704f:	89 02                	mov    %eax,(%edx)
        out[j + 2] = ecx;
c0107051:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0107054:	83 c0 02             	add    $0x2,%eax
c0107057:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010705e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107061:	01 c2                	add    %eax,%edx
c0107063:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0107066:	89 02                	mov    %eax,(%edx)
        out[j + 3] = edx;
c0107068:	8b 45 f8             	mov    -0x8(%ebp),%eax
c010706b:	83 c0 03             	add    $0x3,%eax
c010706e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0107075:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107078:	01 c2                	add    %eax,%edx
c010707a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010707d:	89 02                	mov    %eax,(%edx)
        j+=4;
c010707f:	83 45 f8 04          	addl   $0x4,-0x8(%ebp)
    for (uint32_t i = 2, j = 0; i < 5; i++)
c0107083:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0107087:	83 7d fc 04          	cmpl   $0x4,-0x4(%ebp)
c010708b:	0f 86 73 ff ff ff    	jbe    c0107004 <cpu_get_brand+0x37>
    }
    brand_out[48] = '\0';
c0107091:	8b 45 08             	mov    0x8(%ebp),%eax
c0107094:	83 c0 30             	add    $0x30,%eax
c0107097:	c6 00 00             	movb   $0x0,(%eax)
}
c010709a:	90                   	nop
c010709b:	c9                   	leave  
c010709c:	c3                   	ret    

c010709d <cpu_r_cr0>:

reg32 cpu_r_cr0() {
c010709d:	55                   	push   %ebp
c010709e:	89 e5                	mov    %esp,%ebp
    asm volatile ("mov %cr0, %eax");
c01070a0:	0f 20 c0             	mov    %cr0,%eax
}
c01070a3:	90                   	nop
c01070a4:	5d                   	pop    %ebp
c01070a5:	c3                   	ret    

c01070a6 <cpu_r_cr2>:

reg32 cpu_r_cr2() {
c01070a6:	55                   	push   %ebp
c01070a7:	89 e5                	mov    %esp,%ebp
    asm volatile ("mov %cr2, %eax");
c01070a9:	0f 20 d0             	mov    %cr2,%eax
}
c01070ac:	90                   	nop
c01070ad:	5d                   	pop    %ebp
c01070ae:	c3                   	ret    

c01070af <cpu_r_cr3>:

reg32 cpu_r_cr3() {
c01070af:	55                   	push   %ebp
c01070b0:	89 e5                	mov    %esp,%ebp
    asm volatile ("mov %cr3, %eax");
c01070b2:	0f 20 d8             	mov    %cr3,%eax
}
c01070b5:	90                   	nop
c01070b6:	5d                   	pop    %ebp
c01070b7:	c3                   	ret    

c01070b8 <cpu_w_cr0>:

void cpu_w_cr0(reg32 v) {
c01070b8:	55                   	push   %ebp
c01070b9:	89 e5                	mov    %esp,%ebp
    asm volatile (
c01070bb:	8b 45 08             	mov    0x8(%ebp),%eax
c01070be:	0f 22 c0             	mov    %eax,%cr0
        "mov %0, %%cr0"
        :: "r"(v)
    );
}
c01070c1:	90                   	nop
c01070c2:	5d                   	pop    %ebp
c01070c3:	c3                   	ret    

c01070c4 <cpu_w_cr2>:

void cpu_w_cr2(reg32 v) {
c01070c4:	55                   	push   %ebp
c01070c5:	89 e5                	mov    %esp,%ebp
    asm volatile (
c01070c7:	8b 45 08             	mov    0x8(%ebp),%eax
c01070ca:	0f 22 d0             	mov    %eax,%cr2
        "mov %0, %%cr2"
        :: "r"(v)
    );
}
c01070cd:	90                   	nop
c01070ce:	5d                   	pop    %ebp
c01070cf:	c3                   	ret    

c01070d0 <cpu_w_cr3>:

void cpu_w_cr3(reg32 v) {
c01070d0:	55                   	push   %ebp
c01070d1:	89 e5                	mov    %esp,%ebp
    asm volatile (
c01070d3:	8b 45 08             	mov    0x8(%ebp),%eax
c01070d6:	0f 22 d8             	mov    %eax,%cr3
        "mov %0, %%cr3"
        :: "r"(v)
    );
}
c01070d9:	90                   	nop
c01070da:	5d                   	pop    %ebp
c01070db:	c3                   	ret    

c01070dc <_set_gdt_entry>:
#define GDT_ENTRY 5

uint64_t _gdt[5];
uint16_t _gdt_limit = sizeof(_gdt) - 1;

void _set_gdt_entry(uint32_t index, uint32_t base, uint32_t limit, uint32_t flags) {
c01070dc:	55                   	push   %ebp
c01070dd:	89 e5                	mov    %esp,%ebp
c01070df:	57                   	push   %edi
c01070e0:	56                   	push   %esi
c01070e1:	53                   	push   %ebx
c01070e2:	83 ec 0c             	sub    $0xc,%esp
    _gdt[index] = SEG_BASE_H(base) | flags | SEG_LIM_H(limit) | SEG_BASE_M(base);
c01070e5:	8b 45 0c             	mov    0xc(%ebp),%eax
c01070e8:	25 00 00 00 ff       	and    $0xff000000,%eax
c01070ed:	0b 45 14             	or     0x14(%ebp),%eax
c01070f0:	89 c2                	mov    %eax,%edx
c01070f2:	8b 45 10             	mov    0x10(%ebp),%eax
c01070f5:	25 00 00 0f 00       	and    $0xf0000,%eax
c01070fa:	09 c2                	or     %eax,%edx
c01070fc:	8b 45 0c             	mov    0xc(%ebp),%eax
c01070ff:	c1 e8 10             	shr    $0x10,%eax
c0107102:	0f b6 c0             	movzbl %al,%eax
c0107105:	09 d0                	or     %edx,%eax
c0107107:	ba 00 00 00 00       	mov    $0x0,%edx
c010710c:	8b 75 08             	mov    0x8(%ebp),%esi
c010710f:	89 04 f5 60 80 12 c0 	mov    %eax,-0x3fed7fa0(,%esi,8)
c0107116:	89 14 f5 64 80 12 c0 	mov    %edx,-0x3fed7f9c(,%esi,8)
    _gdt[index] <<= 32;
c010711d:	8b 45 08             	mov    0x8(%ebp),%eax
c0107120:	8b 14 c5 64 80 12 c0 	mov    -0x3fed7f9c(,%eax,8),%edx
c0107127:	8b 04 c5 60 80 12 c0 	mov    -0x3fed7fa0(,%eax,8),%eax
c010712e:	89 c2                	mov    %eax,%edx
c0107130:	b8 00 00 00 00       	mov    $0x0,%eax
c0107135:	8b 75 08             	mov    0x8(%ebp),%esi
c0107138:	89 04 f5 60 80 12 c0 	mov    %eax,-0x3fed7fa0(,%esi,8)
c010713f:	89 14 f5 64 80 12 c0 	mov    %edx,-0x3fed7f9c(,%esi,8)
    _gdt[index] |= SEG_BASE_L(base) | SEG_LIM_L(limit);
c0107146:	8b 45 08             	mov    0x8(%ebp),%eax
c0107149:	8b 14 c5 64 80 12 c0 	mov    -0x3fed7f9c(,%eax,8),%edx
c0107150:	8b 04 c5 60 80 12 c0 	mov    -0x3fed7fa0(,%eax,8),%eax
c0107157:	8b 75 0c             	mov    0xc(%ebp),%esi
c010715a:	89 f7                	mov    %esi,%edi
c010715c:	c1 e7 10             	shl    $0x10,%edi
c010715f:	8b 75 10             	mov    0x10(%ebp),%esi
c0107162:	0f b7 f6             	movzwl %si,%esi
c0107165:	09 fe                	or     %edi,%esi
c0107167:	bf 00 00 00 00       	mov    $0x0,%edi
c010716c:	89 45 e8             	mov    %eax,-0x18(%ebp)
c010716f:	89 55 ec             	mov    %edx,-0x14(%ebp)
c0107172:	09 f0                	or     %esi,%eax
c0107174:	89 c1                	mov    %eax,%ecx
c0107176:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0107179:	09 f8                	or     %edi,%eax
c010717b:	89 c3                	mov    %eax,%ebx
c010717d:	8b 45 08             	mov    0x8(%ebp),%eax
c0107180:	89 0c c5 60 80 12 c0 	mov    %ecx,-0x3fed7fa0(,%eax,8)
c0107187:	89 1c c5 64 80 12 c0 	mov    %ebx,-0x3fed7f9c(,%eax,8)
}
c010718e:	90                   	nop
c010718f:	83 c4 0c             	add    $0xc,%esp
c0107192:	5b                   	pop    %ebx
c0107193:	5e                   	pop    %esi
c0107194:	5f                   	pop    %edi
c0107195:	5d                   	pop    %ebp
c0107196:	c3                   	ret    

c0107197 <_init_gdt>:
// 
void
_init_gdt() {
c0107197:	55                   	push   %ebp
c0107198:	89 e5                	mov    %esp,%ebp
    _set_gdt_entry(0, 0, 0, 0);
c010719a:	6a 00                	push   $0x0
c010719c:	6a 00                	push   $0x0
c010719e:	6a 00                	push   $0x0
c01071a0:	6a 00                	push   $0x0
c01071a2:	e8 35 ff ff ff       	call   c01070dc <_set_gdt_entry>
c01071a7:	83 c4 10             	add    $0x10,%esp
    _set_gdt_entry(1, 0, 0xfffff, SEG_R0_CODE);
c01071aa:	68 00 9a c0 00       	push   $0xc09a00
c01071af:	68 ff ff 0f 00       	push   $0xfffff
c01071b4:	6a 00                	push   $0x0
c01071b6:	6a 01                	push   $0x1
c01071b8:	e8 1f ff ff ff       	call   c01070dc <_set_gdt_entry>
c01071bd:	83 c4 10             	add    $0x10,%esp
    _set_gdt_entry(2, 0, 0xfffff, SEG_R0_DATA);
c01071c0:	68 00 92 c0 00       	push   $0xc09200
c01071c5:	68 ff ff 0f 00       	push   $0xfffff
c01071ca:	6a 00                	push   $0x0
c01071cc:	6a 02                	push   $0x2
c01071ce:	e8 09 ff ff ff       	call   c01070dc <_set_gdt_entry>
c01071d3:	83 c4 10             	add    $0x10,%esp
    _set_gdt_entry(3, 0, 0xfffff, SEG_R3_CODE);
c01071d6:	68 00 fa c0 00       	push   $0xc0fa00
c01071db:	68 ff ff 0f 00       	push   $0xfffff
c01071e0:	6a 00                	push   $0x0
c01071e2:	6a 03                	push   $0x3
c01071e4:	e8 f3 fe ff ff       	call   c01070dc <_set_gdt_entry>
c01071e9:	83 c4 10             	add    $0x10,%esp
    _set_gdt_entry(4, 0, 0xfffff, SEG_R3_DATA);
c01071ec:	68 00 f2 c0 00       	push   $0xc0f200
c01071f1:	68 ff ff 0f 00       	push   $0xfffff
c01071f6:	6a 00                	push   $0x0
c01071f8:	6a 04                	push   $0x4
c01071fa:	e8 dd fe ff ff       	call   c01070dc <_set_gdt_entry>
c01071ff:	83 c4 10             	add    $0x10,%esp
c0107202:	90                   	nop
c0107203:	c9                   	leave  
c0107204:	c3                   	ret    

c0107205 <_set_idt_entry>:
#define IDT_ENTRY 80

uint64_t _idt[IDT_ENTRY];
uint16_t _idt_limit = sizeof(_idt) - 1;

void _set_idt_entry(uint32_t vector, uint16_t seg_selector, void (*isr)(), uint8_t dpl) {
c0107205:	55                   	push   %ebp
c0107206:	89 e5                	mov    %esp,%ebp
c0107208:	57                   	push   %edi
c0107209:	56                   	push   %esi
c010720a:	53                   	push   %ebx
c010720b:	83 ec 24             	sub    $0x24,%esp
c010720e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107211:	8b 55 14             	mov    0x14(%ebp),%edx
c0107214:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
c0107218:	89 d0                	mov    %edx,%eax
c010721a:	88 45 d8             	mov    %al,-0x28(%ebp)
    uintptr_t offset = (uintptr_t)isr;
c010721d:	8b 45 10             	mov    0x10(%ebp),%eax
c0107220:	89 45 ec             	mov    %eax,-0x14(%ebp)
    _idt[vector] = (offset & 0xffff0000) | IDT_ATTR(dpl);
c0107223:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0107226:	66 b8 00 00          	mov    $0x0,%ax
c010722a:	89 c2                	mov    %eax,%edx
c010722c:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
c0107230:	c1 e0 0d             	shl    $0xd,%eax
c0107233:	25 00 60 00 00       	and    $0x6000,%eax
c0107238:	09 d0                	or     %edx,%eax
c010723a:	80 cc 8e             	or     $0x8e,%ah
c010723d:	ba 00 00 00 00       	mov    $0x0,%edx
c0107242:	8b 75 08             	mov    0x8(%ebp),%esi
c0107245:	89 04 f5 a0 80 12 c0 	mov    %eax,-0x3fed7f60(,%esi,8)
c010724c:	89 14 f5 a4 80 12 c0 	mov    %edx,-0x3fed7f5c(,%esi,8)
    _idt[vector] <<= 32;
c0107253:	8b 45 08             	mov    0x8(%ebp),%eax
c0107256:	8b 14 c5 a4 80 12 c0 	mov    -0x3fed7f5c(,%eax,8),%edx
c010725d:	8b 04 c5 a0 80 12 c0 	mov    -0x3fed7f60(,%eax,8),%eax
c0107264:	89 c2                	mov    %eax,%edx
c0107266:	b8 00 00 00 00       	mov    $0x0,%eax
c010726b:	8b 75 08             	mov    0x8(%ebp),%esi
c010726e:	89 04 f5 a0 80 12 c0 	mov    %eax,-0x3fed7f60(,%esi,8)
c0107275:	89 14 f5 a4 80 12 c0 	mov    %edx,-0x3fed7f5c(,%esi,8)
    _idt[vector] |= (seg_selector << 16) | (offset & 0x0000ffff);
c010727c:	8b 45 08             	mov    0x8(%ebp),%eax
c010727f:	8b 14 c5 a4 80 12 c0 	mov    -0x3fed7f5c(,%eax,8),%edx
c0107286:	8b 04 c5 a0 80 12 c0 	mov    -0x3fed7f60(,%eax,8),%eax
c010728d:	0f b7 75 dc          	movzwl -0x24(%ebp),%esi
c0107291:	c1 e6 10             	shl    $0x10,%esi
c0107294:	89 f7                	mov    %esi,%edi
c0107296:	8b 75 ec             	mov    -0x14(%ebp),%esi
c0107299:	0f b7 f6             	movzwl %si,%esi
c010729c:	09 fe                	or     %edi,%esi
c010729e:	bf 00 00 00 00       	mov    $0x0,%edi
c01072a3:	89 45 d0             	mov    %eax,-0x30(%ebp)
c01072a6:	89 55 d4             	mov    %edx,-0x2c(%ebp)
c01072a9:	09 f0                	or     %esi,%eax
c01072ab:	89 c1                	mov    %eax,%ecx
c01072ad:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c01072b0:	09 f8                	or     %edi,%eax
c01072b2:	89 c3                	mov    %eax,%ebx
c01072b4:	8b 45 08             	mov    0x8(%ebp),%eax
c01072b7:	89 0c c5 a0 80 12 c0 	mov    %ecx,-0x3fed7f60(,%eax,8)
c01072be:	89 1c c5 a4 80 12 c0 	mov    %ebx,-0x3fed7f5c(,%eax,8)
}
c01072c5:	90                   	nop
c01072c6:	83 c4 24             	add    $0x24,%esp
c01072c9:	5b                   	pop    %ebx
c01072ca:	5e                   	pop    %esi
c01072cb:	5f                   	pop    %edi
c01072cc:	5d                   	pop    %ebp
c01072cd:	c3                   	ret    

c01072ce <_init_idt>:

void _init_idt()
{
c01072ce:	55                   	push   %ebp
c01072cf:	89 e5                	mov    %esp,%ebp
c01072d1:	83 ec 10             	sub    $0x10,%esp
    _set_idt_entry(FAULT_DIVISION_ERROR, 0x08, divide_error, 0);
c01072d4:	6a 00                	push   $0x0
c01072d6:	68 16 6e 10 c0       	push   $0xc0106e16
c01072db:	6a 08                	push   $0x8
c01072dd:	6a 00                	push   $0x0
c01072df:	e8 21 ff ff ff       	call   c0107205 <_set_idt_entry>
c01072e4:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(FAULT_TRAP_DEBUG_EXCEPTION, 0x08, debug, 0);
c01072e7:	6a 00                	push   $0x0
c01072e9:	68 1d 6e 10 c0       	push   $0xc0106e1d
c01072ee:	6a 08                	push   $0x8
c01072f0:	6a 01                	push   $0x1
c01072f2:	e8 0e ff ff ff       	call   c0107205 <_set_idt_entry>
c01072f7:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(INT_NMI, 0x08, nmi, 0);
c01072fa:	6a 00                	push   $0x0
c01072fc:	68 24 6e 10 c0       	push   $0xc0106e24
c0107301:	6a 08                	push   $0x8
c0107303:	6a 02                	push   $0x2
c0107305:	e8 fb fe ff ff       	call   c0107205 <_set_idt_entry>
c010730a:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(TRAP_BREAKPOINT, 0x08, int3, 0);
c010730d:	6a 00                	push   $0x0
c010730f:	68 2b 6e 10 c0       	push   $0xc0106e2b
c0107314:	6a 08                	push   $0x8
c0107316:	6a 03                	push   $0x3
c0107318:	e8 e8 fe ff ff       	call   c0107205 <_set_idt_entry>
c010731d:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(TRAP_OVERFLOW, 0x08, overflow, 0);
c0107320:	6a 00                	push   $0x0
c0107322:	68 32 6e 10 c0       	push   $0xc0106e32
c0107327:	6a 08                	push   $0x8
c0107329:	6a 04                	push   $0x4
c010732b:	e8 d5 fe ff ff       	call   c0107205 <_set_idt_entry>
c0107330:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(FAULT_BOUND_EXCEED, 0x08, bounds, 0);
c0107333:	6a 00                	push   $0x0
c0107335:	68 39 6e 10 c0       	push   $0xc0106e39
c010733a:	6a 08                	push   $0x8
c010733c:	6a 05                	push   $0x5
c010733e:	e8 c2 fe ff ff       	call   c0107205 <_set_idt_entry>
c0107343:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(FAULT_INVALID_OPCODE, 0x08, invalid_op, 0);
c0107346:	6a 00                	push   $0x0
c0107348:	68 40 6e 10 c0       	push   $0xc0106e40
c010734d:	6a 08                	push   $0x8
c010734f:	6a 06                	push   $0x6
c0107351:	e8 af fe ff ff       	call   c0107205 <_set_idt_entry>
c0107356:	83 c4 10             	add    $0x10,%esp
    //_set_idt_entry(FAULT_NO_MATH_PROCESSOR, 0x08, device_not_available, 0);
    //_set_idt_entry(ABORT_DOUBLE_FAULT, 0x08, double_fault, 0);
    _set_idt_entry(FAULT_RESERVED_0, 0x08, coprocessor_segment_overrun, 0);
c0107359:	6a 00                	push   $0x0
c010735b:	68 4a 6e 10 c0       	push   $0xc0106e4a
c0107360:	6a 08                	push   $0x8
c0107362:	6a 09                	push   $0x9
c0107364:	e8 9c fe ff ff       	call   c0107205 <_set_idt_entry>
c0107369:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(FAULT_INVALID_TSS, 0x08, invalid_TSS, 0);
c010736c:	6a 00                	push   $0x0
c010736e:	68 5e 6e 10 c0       	push   $0xc0106e5e
c0107373:	6a 08                	push   $0x8
c0107375:	6a 0a                	push   $0xa
c0107377:	e8 89 fe ff ff       	call   c0107205 <_set_idt_entry>
c010737c:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(FAULT_SEG_NOT_PRESENT, 0x08, segment_not_present, 0);
c010737f:	6a 00                	push   $0x0
c0107381:	68 65 6e 10 c0       	push   $0xc0106e65
c0107386:	6a 08                	push   $0x8
c0107388:	6a 0b                	push   $0xb
c010738a:	e8 76 fe ff ff       	call   c0107205 <_set_idt_entry>
c010738f:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(FAULT_STACK_SEG_FAULT, 0x08, stack_segment, 0);
c0107392:	6a 00                	push   $0x0
c0107394:	68 6f 6e 10 c0       	push   $0xc0106e6f
c0107399:	6a 08                	push   $0x8
c010739b:	6a 0c                	push   $0xc
c010739d:	e8 63 fe ff ff       	call   c0107205 <_set_idt_entry>
c01073a2:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(FAULT_GENERAL_PROTECTION, 0x08, general_protection, 0);
c01073a5:	6a 00                	push   $0x0
c01073a7:	68 79 6e 10 c0       	push   $0xc0106e79
c01073ac:	6a 08                	push   $0x8
c01073ae:	6a 0d                	push   $0xd
c01073b0:	e8 50 fe ff ff       	call   c0107205 <_set_idt_entry>
c01073b5:	83 c4 10             	add    $0x10,%esp
    //_set_idt_entry(FAULT_PAGE_FAULT, 0x08, page_fault, 0);
    _set_idt_entry(FAULT_RESERVED_1, 0x08, reserved, 0);
c01073b8:	6a 00                	push   $0x0
c01073ba:	68 54 6e 10 c0       	push   $0xc0106e54
c01073bf:	6a 08                	push   $0x8
c01073c1:	6a 0f                	push   $0xf
c01073c3:	e8 3d fe ff ff       	call   c0107205 <_set_idt_entry>
c01073c8:	83 c4 10             	add    $0x10,%esp
    //_set_idt_entry(FAULT_X87_FAULT, 0x08, coprocessor_error, 0);
    for (int i=17;i<48;i++)
c01073cb:	c7 45 fc 11 00 00 00 	movl   $0x11,-0x4(%ebp)
c01073d2:	eb 19                	jmp    c01073ed <_init_idt+0x11f>
		_set_idt_entry(i, 0x08, reserved, 0);
c01073d4:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01073d7:	6a 00                	push   $0x0
c01073d9:	68 54 6e 10 c0       	push   $0xc0106e54
c01073de:	6a 08                	push   $0x8
c01073e0:	50                   	push   %eax
c01073e1:	e8 1f fe ff ff       	call   c0107205 <_set_idt_entry>
c01073e6:	83 c4 10             	add    $0x10,%esp
    for (int i=17;i<48;i++)
c01073e9:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c01073ed:	83 7d fc 2f          	cmpl   $0x2f,-0x4(%ebp)
c01073f1:	7e e1                	jle    c01073d4 <_init_idt+0x106>
    //_set_idt_entry(45, 0x08, irq13, 0);
c01073f3:	90                   	nop
c01073f4:	90                   	nop
c01073f5:	c9                   	leave  
c01073f6:	c3                   	ret    

c01073f7 <_kernel_start>:
c01073f7:	e8 9b fd ff ff       	call   c0107197 <_init_gdt>
c01073fc:	68 60 80 12 c0       	push   $0xc0128060
c0107401:	66 ff 35 00 90 12 c0 	pushw  0xc0129000
c0107408:	0f 01 14 24          	lgdtl  (%esp)
c010740c:	66 b9 10 00          	mov    $0x10,%cx
c0107410:	8e c1                	mov    %ecx,%es
c0107412:	8e d9                	mov    %ecx,%ds
c0107414:	8e e1                	mov    %ecx,%fs
c0107416:	8e e9                	mov    %ecx,%gs
c0107418:	8e d1                	mov    %ecx,%ss
c010741a:	66 6a 08             	pushw  $0x8
c010741d:	68 23 74 10 c0       	push   $0xc0107423
c0107422:	cb                   	lret   

c0107423 <_after_gdt>:
c0107423:	c7 04 24 00 10 10 00 	movl   $0x101000,(%esp)
c010742a:	e8 48 ed ff ff       	call   c0106177 <_kernel_init>
c010742f:	bc f0 ff bf ff       	mov    $0xffbffff0,%esp
c0107434:	e8 48 f0 ff ff       	call   c0106481 <_kernel_finnal_init>
c0107439:	83 ec 06             	sub    $0x6,%esp
c010743c:	c7 44 24 02 a0 80 12 	movl   $0xc01280a0,0x2(%esp)
c0107443:	c0 
c0107444:	66 a1 02 90 12 c0    	mov    0xc0129002,%ax
c010744a:	66 89 04 24          	mov    %ax,(%esp)
c010744e:	0f 01 1c 24          	lidtl  (%esp)
c0107452:	83 c4 06             	add    $0x6,%esp
c0107455:	e8 ad f0 ff ff       	call   c0106507 <_kernel_main>
c010745a:	fa                   	cli    

c010745b <j_>:
c010745b:	f4                   	hlt    
c010745c:	eb fd                	jmp    c010745b <j_>

c010745e <kprintf>:
#include <libs/mstdio.h>
#include <vga/vga.h>
void kprintf (const char *format, ...)
{
c010745e:	55                   	push   %ebp
c010745f:	89 e5                	mov    %esp,%ebp
c0107461:	83 ec 38             	sub    $0x38,%esp
  char **arg = (char **) &format;
c0107464:	8d 45 08             	lea    0x8(%ebp),%eax
c0107467:	89 45 f4             	mov    %eax,-0xc(%ebp)
  int c;
  char buf[20];

  arg++;
c010746a:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
  while ((c = *format++) != 0)
c010746e:	e9 83 01 00 00       	jmp    c01075f6 <kprintf+0x198>
    {
      if (c != '%')
c0107473:	83 7d f0 25          	cmpl   $0x25,-0x10(%ebp)
c0107477:	74 17                	je     c0107490 <kprintf+0x32>
        vga_put_char (c);
c0107479:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010747c:	0f be c0             	movsbl %al,%eax
c010747f:	83 ec 0c             	sub    $0xc,%esp
c0107482:	50                   	push   %eax
c0107483:	e8 96 eb ff ff       	call   c010601e <vga_put_char>
c0107488:	83 c4 10             	add    $0x10,%esp
c010748b:	e9 66 01 00 00       	jmp    c01075f6 <kprintf+0x198>
      else
        {
          char *p, *p2;
          int pad0 = 0, pad = 0;
c0107490:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
c0107497:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
          
          c = *format++;
c010749e:	8b 45 08             	mov    0x8(%ebp),%eax
c01074a1:	8d 50 01             	lea    0x1(%eax),%edx
c01074a4:	89 55 08             	mov    %edx,0x8(%ebp)
c01074a7:	0f b6 00             	movzbl (%eax),%eax
c01074aa:	0f be c0             	movsbl %al,%eax
c01074ad:	89 45 f0             	mov    %eax,-0x10(%ebp)
          if (c == '0')
c01074b0:	83 7d f0 30          	cmpl   $0x30,-0x10(%ebp)
c01074b4:	75 19                	jne    c01074cf <kprintf+0x71>
            {
              pad0 = 1;
c01074b6:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
              c = *format++;
c01074bd:	8b 45 08             	mov    0x8(%ebp),%eax
c01074c0:	8d 50 01             	lea    0x1(%eax),%edx
c01074c3:	89 55 08             	mov    %edx,0x8(%ebp)
c01074c6:	0f b6 00             	movzbl (%eax),%eax
c01074c9:	0f be c0             	movsbl %al,%eax
c01074cc:	89 45 f0             	mov    %eax,-0x10(%ebp)
            }

          if (c >= '0' && c <= '9')
c01074cf:	83 7d f0 2f          	cmpl   $0x2f,-0x10(%ebp)
c01074d3:	7e 21                	jle    c01074f6 <kprintf+0x98>
c01074d5:	83 7d f0 39          	cmpl   $0x39,-0x10(%ebp)
c01074d9:	7f 1b                	jg     c01074f6 <kprintf+0x98>
            {
              pad = c - '0';
c01074db:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01074de:	83 e8 30             	sub    $0x30,%eax
c01074e1:	89 45 e0             	mov    %eax,-0x20(%ebp)
              c = *format++;
c01074e4:	8b 45 08             	mov    0x8(%ebp),%eax
c01074e7:	8d 50 01             	lea    0x1(%eax),%edx
c01074ea:	89 55 08             	mov    %edx,0x8(%ebp)
c01074ed:	0f b6 00             	movzbl (%eax),%eax
c01074f0:	0f be c0             	movsbl %al,%eax
c01074f3:	89 45 f0             	mov    %eax,-0x10(%ebp)
            }

          switch (c)
c01074f6:	83 7d f0 78          	cmpl   $0x78,-0x10(%ebp)
c01074fa:	74 2b                	je     c0107527 <kprintf+0xc9>
c01074fc:	83 7d f0 78          	cmpl   $0x78,-0x10(%ebp)
c0107500:	0f 8f d5 00 00 00    	jg     c01075db <kprintf+0x17d>
c0107506:	83 7d f0 75          	cmpl   $0x75,-0x10(%ebp)
c010750a:	74 1b                	je     c0107527 <kprintf+0xc9>
c010750c:	83 7d f0 75          	cmpl   $0x75,-0x10(%ebp)
c0107510:	0f 8f c5 00 00 00    	jg     c01075db <kprintf+0x17d>
c0107516:	83 7d f0 64          	cmpl   $0x64,-0x10(%ebp)
c010751a:	74 0b                	je     c0107527 <kprintf+0xc9>
c010751c:	83 7d f0 73          	cmpl   $0x73,-0x10(%ebp)
c0107520:	74 2b                	je     c010754d <kprintf+0xef>
c0107522:	e9 b4 00 00 00       	jmp    c01075db <kprintf+0x17d>
            {
            case 'd':
            case 'u':
            case 'x':
              itoa (buf, c, *((int *) arg++));
c0107527:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010752a:	8d 50 04             	lea    0x4(%eax),%edx
c010752d:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0107530:	8b 00                	mov    (%eax),%eax
c0107532:	83 ec 04             	sub    $0x4,%esp
c0107535:	50                   	push   %eax
c0107536:	ff 75 f0             	push   -0x10(%ebp)
c0107539:	8d 45 cc             	lea    -0x34(%ebp),%eax
c010753c:	50                   	push   %eax
c010753d:	e8 d4 00 00 00       	call   c0107616 <itoa>
c0107542:	83 c4 10             	add    $0x10,%esp
              p = buf;
c0107545:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0107548:	89 45 ec             	mov    %eax,-0x14(%ebp)
              goto string;
c010754b:	eb 1e                	jmp    c010756b <kprintf+0x10d>
              break;

            case 's':
              p = *arg++;
c010754d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107550:	8d 50 04             	lea    0x4(%eax),%edx
c0107553:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0107556:	8b 00                	mov    (%eax),%eax
c0107558:	89 45 ec             	mov    %eax,-0x14(%ebp)
              if (! p)
c010755b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c010755f:	75 09                	jne    c010756a <kprintf+0x10c>
                p = "(null)";
c0107561:	c7 45 ec 78 a4 12 c0 	movl   $0xc012a478,-0x14(%ebp)
c0107568:	eb 01                	jmp    c010756b <kprintf+0x10d>

            string:
c010756a:	90                   	nop
              for (p2 = p; *p2; p2++);
c010756b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010756e:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0107571:	eb 04                	jmp    c0107577 <kprintf+0x119>
c0107573:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
c0107577:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010757a:	0f b6 00             	movzbl (%eax),%eax
c010757d:	84 c0                	test   %al,%al
c010757f:	75 f2                	jne    c0107573 <kprintf+0x115>
              for (; p2 < p + pad; p2++)
c0107581:	eb 22                	jmp    c01075a5 <kprintf+0x147>
                vga_put_char (pad0 ? '0' : ' ');
c0107583:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0107587:	74 07                	je     c0107590 <kprintf+0x132>
c0107589:	b8 30 00 00 00       	mov    $0x30,%eax
c010758e:	eb 05                	jmp    c0107595 <kprintf+0x137>
c0107590:	b8 20 00 00 00       	mov    $0x20,%eax
c0107595:	83 ec 0c             	sub    $0xc,%esp
c0107598:	50                   	push   %eax
c0107599:	e8 80 ea ff ff       	call   c010601e <vga_put_char>
c010759e:	83 c4 10             	add    $0x10,%esp
              for (; p2 < p + pad; p2++)
c01075a1:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
c01075a5:	8b 55 e0             	mov    -0x20(%ebp),%edx
c01075a8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01075ab:	01 d0                	add    %edx,%eax
c01075ad:	39 45 e8             	cmp    %eax,-0x18(%ebp)
c01075b0:	72 d1                	jb     c0107583 <kprintf+0x125>
              while (*p)
c01075b2:	eb 1b                	jmp    c01075cf <kprintf+0x171>
                vga_put_char (*p++);
c01075b4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01075b7:	8d 50 01             	lea    0x1(%eax),%edx
c01075ba:	89 55 ec             	mov    %edx,-0x14(%ebp)
c01075bd:	0f b6 00             	movzbl (%eax),%eax
c01075c0:	0f be c0             	movsbl %al,%eax
c01075c3:	83 ec 0c             	sub    $0xc,%esp
c01075c6:	50                   	push   %eax
c01075c7:	e8 52 ea ff ff       	call   c010601e <vga_put_char>
c01075cc:	83 c4 10             	add    $0x10,%esp
              while (*p)
c01075cf:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01075d2:	0f b6 00             	movzbl (%eax),%eax
c01075d5:	84 c0                	test   %al,%al
c01075d7:	75 db                	jne    c01075b4 <kprintf+0x156>
              break;
c01075d9:	eb 1b                	jmp    c01075f6 <kprintf+0x198>

            default:
              vga_put_char (*((int *) arg++));
c01075db:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01075de:	8d 50 04             	lea    0x4(%eax),%edx
c01075e1:	89 55 f4             	mov    %edx,-0xc(%ebp)
c01075e4:	8b 00                	mov    (%eax),%eax
c01075e6:	0f be c0             	movsbl %al,%eax
c01075e9:	83 ec 0c             	sub    $0xc,%esp
c01075ec:	50                   	push   %eax
c01075ed:	e8 2c ea ff ff       	call   c010601e <vga_put_char>
c01075f2:	83 c4 10             	add    $0x10,%esp
              break;
c01075f5:	90                   	nop
  while ((c = *format++) != 0)
c01075f6:	8b 45 08             	mov    0x8(%ebp),%eax
c01075f9:	8d 50 01             	lea    0x1(%eax),%edx
c01075fc:	89 55 08             	mov    %edx,0x8(%ebp)
c01075ff:	0f b6 00             	movzbl (%eax),%eax
c0107602:	0f be c0             	movsbl %al,%eax
c0107605:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0107608:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c010760c:	0f 85 61 fe ff ff    	jne    c0107473 <kprintf+0x15>
            }
        }
    }
}
c0107612:	90                   	nop
c0107613:	90                   	nop
c0107614:	c9                   	leave  
c0107615:	c3                   	ret    

c0107616 <itoa>:
#include <libs/mstdlib.h>

void
itoa (char *buf, int base, int d)
{
c0107616:	55                   	push   %ebp
c0107617:	89 e5                	mov    %esp,%ebp
c0107619:	83 ec 20             	sub    $0x20,%esp
  char *p = buf;
c010761c:	8b 45 08             	mov    0x8(%ebp),%eax
c010761f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  char *p1, *p2;
  unsigned long ud = d;
c0107622:	8b 45 10             	mov    0x10(%ebp),%eax
c0107625:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int divisor = 10;
c0107628:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
  
  /* If %d is specified and D is minus, put ‘-’ in the head. */
  if (base == 'd' && d < 0)
c010762f:	83 7d 0c 64          	cmpl   $0x64,0xc(%ebp)
c0107633:	75 20                	jne    c0107655 <itoa+0x3f>
c0107635:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0107639:	79 1a                	jns    c0107655 <itoa+0x3f>
    {
      *p++ = '-';
c010763b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010763e:	8d 50 01             	lea    0x1(%eax),%edx
c0107641:	89 55 fc             	mov    %edx,-0x4(%ebp)
c0107644:	c6 00 2d             	movb   $0x2d,(%eax)
      buf++;
c0107647:	83 45 08 01          	addl   $0x1,0x8(%ebp)
      ud = -d;
c010764b:	8b 45 10             	mov    0x10(%ebp),%eax
c010764e:	f7 d8                	neg    %eax
c0107650:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0107653:	eb 0d                	jmp    c0107662 <itoa+0x4c>
    }
  else if (base == 'x')
c0107655:	83 7d 0c 78          	cmpl   $0x78,0xc(%ebp)
c0107659:	75 07                	jne    c0107662 <itoa+0x4c>
    divisor = 16;
c010765b:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)

  /* Divide UD by DIVISOR until UD == 0. */
  do
    {
      int remainder = ud % divisor;
c0107662:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c0107665:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107668:	ba 00 00 00 00       	mov    $0x0,%edx
c010766d:	f7 f1                	div    %ecx
c010766f:	89 d0                	mov    %edx,%eax
c0107671:	89 45 e8             	mov    %eax,-0x18(%ebp)
      
      *p++ = (remainder < 10) ? remainder + '0' : remainder + 'a' - 10;
c0107674:	83 7d e8 09          	cmpl   $0x9,-0x18(%ebp)
c0107678:	7f 0a                	jg     c0107684 <itoa+0x6e>
c010767a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010767d:	83 c0 30             	add    $0x30,%eax
c0107680:	89 c1                	mov    %eax,%ecx
c0107682:	eb 08                	jmp    c010768c <itoa+0x76>
c0107684:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0107687:	83 c0 57             	add    $0x57,%eax
c010768a:	89 c1                	mov    %eax,%ecx
c010768c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010768f:	8d 50 01             	lea    0x1(%eax),%edx
c0107692:	89 55 fc             	mov    %edx,-0x4(%ebp)
c0107695:	88 08                	mov    %cl,(%eax)
    }
  while (ud /= divisor);
c0107697:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c010769a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010769d:	ba 00 00 00 00       	mov    $0x0,%edx
c01076a2:	f7 f1                	div    %ecx
c01076a4:	89 45 f0             	mov    %eax,-0x10(%ebp)
c01076a7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c01076ab:	75 b5                	jne    c0107662 <itoa+0x4c>

  /* Terminate BUF. */
  *p = 0;
c01076ad:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01076b0:	c6 00 00             	movb   $0x0,(%eax)
  
  /* Reverse BUF. */
  p1 = buf;
c01076b3:	8b 45 08             	mov    0x8(%ebp),%eax
c01076b6:	89 45 f8             	mov    %eax,-0x8(%ebp)
  p2 = p - 1;
c01076b9:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01076bc:	83 e8 01             	sub    $0x1,%eax
c01076bf:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (p1 < p2)
c01076c2:	eb 25                	jmp    c01076e9 <itoa+0xd3>
    {
      char tmp = *p1;
c01076c4:	8b 45 f8             	mov    -0x8(%ebp),%eax
c01076c7:	0f b6 00             	movzbl (%eax),%eax
c01076ca:	88 45 e7             	mov    %al,-0x19(%ebp)
      *p1 = *p2;
c01076cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01076d0:	0f b6 10             	movzbl (%eax),%edx
c01076d3:	8b 45 f8             	mov    -0x8(%ebp),%eax
c01076d6:	88 10                	mov    %dl,(%eax)
      *p2 = tmp;
c01076d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01076db:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
c01076df:	88 10                	mov    %dl,(%eax)
      p1++;
c01076e1:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
      p2--;
c01076e5:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
  while (p1 < p2)
c01076e9:	8b 45 f8             	mov    -0x8(%ebp),%eax
c01076ec:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c01076ef:	72 d3                	jb     c01076c4 <itoa+0xae>
    }
c01076f1:	90                   	nop
c01076f2:	90                   	nop
c01076f3:	c9                   	leave  
c01076f4:	c3                   	ret    

c01076f5 <memset>:
#include <libs/string.h>
#include <stdint.h>

void* memset(void* ptr, int value, size_t num)
{
c01076f5:	55                   	push   %ebp
c01076f6:	89 e5                	mov    %esp,%ebp
c01076f8:	83 ec 10             	sub    $0x10,%esp
    uint8_t* c_ptr = (uint8_t*)ptr;
c01076fb:	8b 45 08             	mov    0x8(%ebp),%eax
c01076fe:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for (size_t i = 0; i < num; i++) {
c0107701:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0107708:	eb 11                	jmp    c010771b <memset+0x26>
        *(c_ptr + i) = (uint8_t)value;
c010770a:	8b 55 f8             	mov    -0x8(%ebp),%edx
c010770d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0107710:	01 d0                	add    %edx,%eax
c0107712:	8b 55 0c             	mov    0xc(%ebp),%edx
c0107715:	88 10                	mov    %dl,(%eax)
    for (size_t i = 0; i < num; i++) {
c0107717:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c010771b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010771e:	3b 45 10             	cmp    0x10(%ebp),%eax
c0107721:	72 e7                	jb     c010770a <memset+0x15>
    }
    return ptr;
c0107723:	8b 45 08             	mov    0x8(%ebp),%eax
c0107726:	c9                   	leave  
c0107727:	c3                   	ret    
