
build/bin/melox.bin:     file format elf32-i386


Disassembly of section .virk_init_text:

00100000 <start-0xc>:
  100000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
  100006:	00 00                	add    %al,(%eax)
  100008:	fb                   	sti    
  100009:	4f                   	dec    %edi
  10000a:	52                   	push   %edx
  10000b:	e4                   	.byte 0xe4

0010000c <start>:
  10000c:	fa                   	cli    
  10000d:	bc 00 60 10 00       	mov    $0x106000,%esp
  100012:	68 00 10 10 00       	push   $0x101000
  100017:	53                   	push   %ebx
  100018:	e8 62 00 00 00       	call   10007f <save_multiboot_info>
  10001d:	68 00 60 00 00       	push   $0x6000
  100022:	68 00 e0 28 00       	push   $0x28e000
  100027:	e8 a4 02 00 00       	call   1002d0 <kerner_init>
  10002c:	8b 04 24             	mov    (%esp),%eax
  10002f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  100034:	0f 22 d8             	mov    %eax,%cr3
  100037:	0f 20 c0             	mov    %cr0,%eax
  10003a:	0d 00 00 01 80       	or     $0x80010000,%eax
  10003f:	0f 22 c0             	mov    %eax,%cr0
  100042:	58                   	pop    %eax
  100043:	58                   	pop    %eax
  100044:	68 69 8c 10 c0       	push   $0xc0108c69
  100049:	c3                   	ret    

0010004a <_save_>:
extern uint8_t virkernel_start;
extern uint8_t virkernel_end ;
extern uint8_t __init_phykernel_end;
extern uint8_t _kernel_stack;

uint32_t _save_(uint8_t* destination, uint8_t* base, multiboot_uint32_t size) {
  10004a:	55                   	push   %ebp
  10004b:	89 e5                	mov    %esp,%ebp
  10004d:	83 ec 10             	sub    $0x10,%esp
    multiboot_uint32_t i = 0;
  100050:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    for (; i < size; i++)
  100057:	eb 19                	jmp    100072 <_save_+0x28>
    {
        *(destination + i) = *(base + i);
  100059:	8b 55 0c             	mov    0xc(%ebp),%edx
  10005c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10005f:	01 d0                	add    %edx,%eax
  100061:	8b 4d 08             	mov    0x8(%ebp),%ecx
  100064:	8b 55 fc             	mov    -0x4(%ebp),%edx
  100067:	01 ca                	add    %ecx,%edx
  100069:	0f b6 00             	movzbl (%eax),%eax
  10006c:	88 02                	mov    %al,(%edx)
    for (; i < size; i++)
  10006e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  100072:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100075:	3b 45 10             	cmp    0x10(%ebp),%eax
  100078:	72 df                	jb     100059 <_save_+0xf>
    }
    return i;
  10007a:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  10007d:	c9                   	leave  
  10007e:	c3                   	ret    

0010007f <save_multiboot_info>:

void save_multiboot_info(multiboot_info_t* mb_info, multiboot_uint8_t* dest)
{
  10007f:	55                   	push   %ebp
  100080:	89 e5                	mov    %esp,%ebp
  100082:	53                   	push   %ebx
  100083:	83 ec 10             	sub    $0x10,%esp
    uint32_t current = 0;
  100086:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    uint8_t* info_b = (uint8_t*) mb_info;
  10008d:	8b 45 08             	mov    0x8(%ebp),%eax
  100090:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for (; current < sizeof(multiboot_info_t); current++)
  100093:	eb 19                	jmp    1000ae <save_multiboot_info+0x2f>
    {
        *(dest + current) = *(info_b + current);
  100095:	8b 55 f4             	mov    -0xc(%ebp),%edx
  100098:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10009b:	01 d0                	add    %edx,%eax
  10009d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1000a0:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1000a3:	01 ca                	add    %ecx,%edx
  1000a5:	0f b6 00             	movzbl (%eax),%eax
  1000a8:	88 02                	mov    %al,(%edx)
    for (; current < sizeof(multiboot_info_t); current++)
  1000aa:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  1000ae:	83 7d f8 77          	cmpl   $0x77,-0x8(%ebp)
  1000b2:	76 e1                	jbe    100095 <save_multiboot_info+0x16>
    }

    ((multiboot_info_t*) dest)->mmap_addr = (uintptr_t)dest + current;
  1000b4:	8b 55 0c             	mov    0xc(%ebp),%edx
  1000b7:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1000ba:	01 c2                	add    %eax,%edx
  1000bc:	8b 45 0c             	mov    0xc(%ebp),%eax
  1000bf:	89 50 30             	mov    %edx,0x30(%eax)
    current += _save_(dest + current, (uint8_t*)mb_info->mmap_addr, mb_info->mmap_length);
  1000c2:	8b 45 08             	mov    0x8(%ebp),%eax
  1000c5:	8b 40 2c             	mov    0x2c(%eax),%eax
  1000c8:	8b 55 08             	mov    0x8(%ebp),%edx
  1000cb:	8b 52 30             	mov    0x30(%edx),%edx
  1000ce:	89 d1                	mov    %edx,%ecx
  1000d0:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  1000d3:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1000d6:	01 da                	add    %ebx,%edx
  1000d8:	50                   	push   %eax
  1000d9:	51                   	push   %ecx
  1000da:	52                   	push   %edx
  1000db:	e8 6a ff ff ff       	call   10004a <_save_>
  1000e0:	83 c4 0c             	add    $0xc,%esp
  1000e3:	01 45 f8             	add    %eax,-0x8(%ebp)

    if (present(mb_info->flags, MULTIBOOT_INFO_DRIVE_INFO)) {
  1000e6:	8b 45 08             	mov    0x8(%ebp),%eax
  1000e9:	8b 00                	mov    (%eax),%eax
  1000eb:	25 80 00 00 00       	and    $0x80,%eax
  1000f0:	85 c0                	test   %eax,%eax
  1000f2:	74 32                	je     100126 <save_multiboot_info+0xa7>
        ((multiboot_info_t*) dest)->drives_addr = (uintptr_t)dest + current;
  1000f4:	8b 55 0c             	mov    0xc(%ebp),%edx
  1000f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1000fa:	01 c2                	add    %eax,%edx
  1000fc:	8b 45 0c             	mov    0xc(%ebp),%eax
  1000ff:	89 50 38             	mov    %edx,0x38(%eax)
        current += _save_(dest + current, (uint8_t*)mb_info->drives_addr, mb_info->drives_length);
  100102:	8b 45 08             	mov    0x8(%ebp),%eax
  100105:	8b 40 34             	mov    0x34(%eax),%eax
  100108:	8b 55 08             	mov    0x8(%ebp),%edx
  10010b:	8b 52 38             	mov    0x38(%edx),%edx
  10010e:	89 d1                	mov    %edx,%ecx
  100110:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  100113:	8b 55 f8             	mov    -0x8(%ebp),%edx
  100116:	01 da                	add    %ebx,%edx
  100118:	50                   	push   %eax
  100119:	51                   	push   %ecx
  10011a:	52                   	push   %edx
  10011b:	e8 2a ff ff ff       	call   10004a <_save_>
  100120:	83 c4 0c             	add    $0xc,%esp
  100123:	01 45 f8             	add    %eax,-0x8(%ebp)
    }
    multiboot_info_t* test = (multiboot_info_t*) dest;
  100126:	8b 45 0c             	mov    0xc(%ebp),%eax
  100129:	89 45 f0             	mov    %eax,-0x10(%ebp)
    multiboot_memory_map_t* testmap = (multiboot_memory_map_t*)mb_info->mmap_addr;
  10012c:	8b 45 08             	mov    0x8(%ebp),%eax
  10012f:	8b 40 30             	mov    0x30(%eax),%eax
  100132:	89 45 ec             	mov    %eax,-0x14(%ebp)
}
  100135:	90                   	nop
  100136:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  100139:	c9                   	leave  
  10013a:	c3                   	ret    

0010013b <init_page>:

void init_page(ptd_t* pt)
{
  10013b:	55                   	push   %ebp
  10013c:	89 e5                	mov    %esp,%ebp
  10013e:	83 ec 30             	sub    $0x30,%esp
    SET_PDE(pt, 0, PDE(PG_PRESENT, pt + PG_MAX_ENTRIES));
  100141:	8b 45 08             	mov    0x8(%ebp),%eax
  100144:	05 00 10 00 00       	add    $0x1000,%eax
  100149:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  10014e:	83 c8 09             	or     $0x9,%eax
  100151:	89 c2                	mov    %eax,%edx
  100153:	8b 45 08             	mov    0x8(%ebp),%eax
  100156:	89 10                	mov    %edx,(%eax)
    ptd_t * tmp_paged_phy_addr = pt;
  100158:	8b 45 08             	mov    0x8(%ebp),%eax
  10015b:	89 45 ec             	mov    %eax,-0x14(%ebp)
    ptd_t * tmp_paget_phy_addr = pt + 1024;
  10015e:	8b 45 08             	mov    0x8(%ebp),%eax
  100161:	05 00 10 00 00       	add    $0x1000,%eax
  100166:	89 45 e8             	mov    %eax,-0x18(%ebp)
    //identity map 1M memory
    for(uint32_t i = 0; i < 256; i++)
  100169:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  100170:	eb 20                	jmp    100192 <init_page+0x57>
        *(tmp_paget_phy_addr + i) = (((i << 12) & 0xFFFFF000UL) | (PG_PREM_RW & 0xfff));
  100172:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100175:	c1 e0 0c             	shl    $0xc,%eax
  100178:	89 c2                	mov    %eax,%edx
  10017a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10017d:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
  100184:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100187:	01 c8                	add    %ecx,%eax
  100189:	83 ca 03             	or     $0x3,%edx
  10018c:	89 10                	mov    %edx,(%eax)
    for(uint32_t i = 0; i < 256; i++)
  10018e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  100192:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%ebp)
  100199:	76 d7                	jbe    100172 <init_page+0x37>

    //identity map virkernel_init memory
    for(uint32_t i = 0; i < LOADOS_PAGE_COUNT; i++)
  10019b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  1001a2:	eb 29                	jmp    1001cd <init_page+0x92>
        *(tmp_paget_phy_addr + i + 256) = ((((i << 12) + MEM_1M) & 0xFFFFF000UL) | (PG_PREM_RW & 0xfff));
  1001a4:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1001a7:	c1 e0 0c             	shl    $0xc,%eax
  1001aa:	8d 90 00 00 10 00    	lea    0x100000(%eax),%edx
  1001b0:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1001b3:	05 00 01 00 00       	add    $0x100,%eax
  1001b8:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
  1001bf:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1001c2:	01 c8                	add    %ecx,%eax
  1001c4:	83 ca 03             	or     $0x3,%edx
  1001c7:	89 10                	mov    %edx,(%eax)
    for(uint32_t i = 0; i < LOADOS_PAGE_COUNT; i++)
  1001c9:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  1001cd:	b8 00 60 10 00       	mov    $0x106000,%eax
  1001d2:	2d 01 f0 0f 00       	sub    $0xff001,%eax
  1001d7:	c1 e8 0c             	shr    $0xc,%eax
  1001da:	39 45 f8             	cmp    %eax,-0x8(%ebp)
  1001dd:	72 c5                	jb     1001a4 <init_page+0x69>

    //now we map the kernel
    //calculate the virtrue kernrl page index
    uint32_t virk_pde_index = PD_INDEX(sym_val(virkernel_start));
  1001df:	b8 00 60 10 c0       	mov    $0xc0106000,%eax
  1001e4:	c1 e8 16             	shr    $0x16,%eax
  1001e7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uint32_t virk_pte_index = PT_INDEX(sym_val(virkernel_start));
  1001ea:	b8 00 60 10 c0       	mov    $0xc0106000,%eax
  1001ef:	c1 e8 0c             	shr    $0xc,%eax
  1001f2:	25 ff 03 00 00       	and    $0x3ff,%eax
  1001f7:	89 45 e0             	mov    %eax,-0x20(%ebp)
    uint32_t virk_pg_counts = KERNEL_PAGE_COUNT;
  1001fa:	b8 00 40 29 c0       	mov    $0xc0294000,%eax
  1001ff:	05 00 10 00 00       	add    $0x1000,%eax
  100204:	83 e8 01             	sub    $0x1,%eax
  100207:	ba 00 60 10 c0       	mov    $0xc0106000,%edx
  10020c:	29 d0                	sub    %edx,%eax
  10020e:	c1 e8 0c             	shr    $0xc,%eax
  100211:	89 45 dc             	mov    %eax,-0x24(%ebp)

    //regist the vir_kernel page to page direction
    //we give 3 pagetable to virkel, is 3 * 4 = 12 mib size
    for(uint32_t i = 0; i < PG_TABLE_STACK - PG_TABLE_KERNEL; i++)
  100214:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  10021b:	eb 34                	jmp    100251 <init_page+0x116>
    {
        *(pt + virk_pde_index + i) = PDE(PG_PREM_RW, PT_ADDR(pt, PG_TABLE_KERNEL + i));
  10021d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100220:	83 c0 02             	add    $0x2,%eax
  100223:	c1 e0 0c             	shl    $0xc,%eax
  100226:	89 c2                	mov    %eax,%edx
  100228:	8b 45 08             	mov    0x8(%ebp),%eax
  10022b:	01 d0                	add    %edx,%eax
  10022d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  100232:	89 c2                	mov    %eax,%edx
  100234:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  100237:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10023a:	01 c8                	add    %ecx,%eax
  10023c:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
  100243:	8b 45 08             	mov    0x8(%ebp),%eax
  100246:	01 c8                	add    %ecx,%eax
  100248:	83 ca 0b             	or     $0xb,%edx
  10024b:	89 10                	mov    %edx,(%eax)
    for(uint32_t i = 0; i < PG_TABLE_STACK - PG_TABLE_KERNEL; i++)
  10024d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  100251:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
  100255:	76 c6                	jbe    10021d <init_page+0xe2>
    }

    //avoid kernel size > prepared page count
    if(virk_pg_counts > (PG_TABLE_STACK - PG_TABLE_KERNEL) * 1024)
  100257:	81 7d dc 00 0c 00 00 	cmpl   $0xc00,-0x24(%ebp)
  10025e:	76 02                	jbe    100262 <init_page+0x127>
    {
        while(1);
  100260:	eb fe                	jmp    100260 <init_page+0x125>
    }

    //calcul the phy address
    uint32_t virk_phy_addr = V2P(&virkernel_start);
  100262:	b8 00 60 10 c0       	mov    $0xc0106000,%eax
  100267:	05 00 00 00 40       	add    $0x40000000,%eax
  10026c:	89 45 d8             	mov    %eax,-0x28(%ebp)
    //map virtrue kernel page
    for(uint32_t i = 0; i < virk_pg_counts; i++)
  10026f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  100276:	eb 36                	jmp    1002ae <init_page+0x173>
    {
        *(tmp_paget_phy_addr + 1024 + virk_pte_index + i) = (((virk_phy_addr + (i << 12)) & 0xFFFFF000UL) | (PG_PREM_RW & 0xfff));
  100278:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10027b:	c1 e0 0c             	shl    $0xc,%eax
  10027e:	89 c2                	mov    %eax,%edx
  100280:	8b 45 d8             	mov    -0x28(%ebp),%eax
  100283:	01 d0                	add    %edx,%eax
  100285:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  10028a:	89 c2                	mov    %eax,%edx
  10028c:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  10028f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  100292:	01 c8                	add    %ecx,%eax
  100294:	05 00 04 00 00       	add    $0x400,%eax
  100299:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
  1002a0:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1002a3:	01 c8                	add    %ecx,%eax
  1002a5:	83 ca 03             	or     $0x3,%edx
  1002a8:	89 10                	mov    %edx,(%eax)
    for(uint32_t i = 0; i < virk_pg_counts; i++)
  1002aa:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
  1002ae:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1002b1:	3b 45 dc             	cmp    -0x24(%ebp),%eax
  1002b4:	72 c2                	jb     100278 <init_page+0x13d>
    }

    //self map pd, to give the pd virture address
    SET_PDE(pt, 1023, PDE(T_SELF_REF_PERM, pt));
  1002b6:	8b 45 08             	mov    0x8(%ebp),%eax
  1002b9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  1002be:	89 c2                	mov    %eax,%edx
  1002c0:	8b 45 08             	mov    0x8(%ebp),%eax
  1002c3:	05 fc 0f 00 00       	add    $0xffc,%eax
  1002c8:	83 ca 1b             	or     $0x1b,%edx
  1002cb:	89 10                	mov    %edx,(%eax)
}
  1002cd:	90                   	nop
  1002ce:	c9                   	leave  
  1002cf:	c3                   	ret    

001002d0 <kerner_init>:

void kerner_init(ptd_t* pt, uint32_t pt_size)
{
  1002d0:	55                   	push   %ebp
  1002d1:	89 e5                	mov    %esp,%ebp
  1002d3:	83 ec 10             	sub    $0x10,%esp
    uint8_t* kpg = (uint8_t*) pt;
  1002d6:	8b 45 08             	mov    0x8(%ebp),%eax
  1002d9:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for (uint32_t i = 0; i < pt_size; i++)
  1002dc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1002e3:	eb 0f                	jmp    1002f4 <kerner_init+0x24>
    {
        *(kpg + i) = 0;
  1002e5:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1002e8:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1002eb:	01 d0                	add    %edx,%eax
  1002ed:	c6 00 00             	movb   $0x0,(%eax)
    for (uint32_t i = 0; i < pt_size; i++)
  1002f0:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  1002f4:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1002f7:	3b 45 0c             	cmp    0xc(%ebp),%eax
  1002fa:	72 e9                	jb     1002e5 <kerner_init+0x15>
    }
    init_page(pt);
  1002fc:	ff 75 08             	push   0x8(%ebp)
  1002ff:	e8 37 fe ff ff       	call   10013b <init_page>
  100304:	83 c4 04             	add    $0x4,%esp
  100307:	90                   	nop
  100308:	c9                   	leave  
  100309:	c3                   	ret    

Disassembly of section .text:

c0106000 <init_vga_buffer>:
int XPOS = 0;

vga_attr *video;

void init_vga_buffer()
{
c0106000:	55                   	push   %ebp
c0106001:	89 e5                	mov    %esp,%ebp
    video = (vga_attr *) VIDEO;
c0106003:	c7 05 0c b0 10 c0 00 	movl   $0xb8000,0xc010b00c
c010600a:	80 0b 00 
}
c010600d:	90                   	nop
c010600e:	5d                   	pop    %ebp
c010600f:	c3                   	ret    

c0106010 <set_vga_buffer>:

void set_vga_buffer(void* vga_buf)
{
c0106010:	55                   	push   %ebp
c0106011:	89 e5                	mov    %esp,%ebp
    video = (vga_attr*)vga_buf;
c0106013:	8b 45 08             	mov    0x8(%ebp),%eax
c0106016:	a3 0c b0 10 c0       	mov    %eax,0xc010b00c
}
c010601b:	90                   	nop
c010601c:	5d                   	pop    %ebp
c010601d:	c3                   	ret    

c010601e <vga_put_char>:

void vga_put_char(char c)
{
c010601e:	55                   	push   %ebp
c010601f:	89 e5                	mov    %esp,%ebp
c0106021:	53                   	push   %ebx
c0106022:	83 ec 14             	sub    $0x14,%esp
c0106025:	8b 45 08             	mov    0x8(%ebp),%eax
c0106028:	88 45 f4             	mov    %al,-0xc(%ebp)
    if(c == '\n')
c010602b:	80 7d f4 0a          	cmpb   $0xa,-0xc(%ebp)
c010602f:	75 19                	jne    c010604a <vga_put_char+0x2c>
    {
        YPOS++;
c0106031:	a1 04 b0 10 c0       	mov    0xc010b004,%eax
c0106036:	83 c0 01             	add    $0x1,%eax
c0106039:	a3 04 b0 10 c0       	mov    %eax,0xc010b004
        XPOS = 0;
c010603e:	c7 05 08 b0 10 c0 00 	movl   $0x0,0xc010b008
c0106045:	00 00 00 
c0106048:	eb 54                	jmp    c010609e <vga_put_char+0x80>
    }else if(c == '\r')
c010604a:	80 7d f4 0d          	cmpb   $0xd,-0xc(%ebp)
c010604e:	75 0c                	jne    c010605c <vga_put_char+0x3e>
        XPOS = 0;
c0106050:	c7 05 08 b0 10 c0 00 	movl   $0x0,0xc010b008
c0106057:	00 00 00 
c010605a:	eb 42                	jmp    c010609e <vga_put_char+0x80>
    else{
        *(video + XPOS + YPOS * WIDTH) = (theme_color | c);
c010605c:	66 0f be 55 f4       	movsbw -0xc(%ebp),%dx
c0106061:	0f b7 05 00 b0 10 c0 	movzwl 0xc010b000,%eax
c0106068:	09 c2                	or     %eax,%edx
c010606a:	8b 0d 0c b0 10 c0    	mov    0xc010b00c,%ecx
c0106070:	a1 04 b0 10 c0       	mov    0xc010b004,%eax
c0106075:	89 c3                	mov    %eax,%ebx
c0106077:	89 d8                	mov    %ebx,%eax
c0106079:	c1 e0 02             	shl    $0x2,%eax
c010607c:	01 d8                	add    %ebx,%eax
c010607e:	c1 e0 04             	shl    $0x4,%eax
c0106081:	89 c3                	mov    %eax,%ebx
c0106083:	a1 08 b0 10 c0       	mov    0xc010b008,%eax
c0106088:	01 d8                	add    %ebx,%eax
c010608a:	01 c0                	add    %eax,%eax
c010608c:	01 c8                	add    %ecx,%eax
c010608e:	66 89 10             	mov    %dx,(%eax)
        XPOS++;
c0106091:	a1 08 b0 10 c0       	mov    0xc010b008,%eax
c0106096:	83 c0 01             	add    $0x1,%eax
c0106099:	a3 08 b0 10 c0       	mov    %eax,0xc010b008
    }
    if (XPOS >= WIDTH)
c010609e:	a1 08 b0 10 c0       	mov    0xc010b008,%eax
c01060a3:	83 f8 4f             	cmp    $0x4f,%eax
c01060a6:	7e 17                	jle    c01060bf <vga_put_char+0xa1>
    {
        YPOS++;
c01060a8:	a1 04 b0 10 c0       	mov    0xc010b004,%eax
c01060ad:	83 c0 01             	add    $0x1,%eax
c01060b0:	a3 04 b0 10 c0       	mov    %eax,0xc010b004
        XPOS = 0;
c01060b5:	c7 05 08 b0 10 c0 00 	movl   $0x0,0xc010b008
c01060bc:	00 00 00 
    }
    if(YPOS >= HIGHT)
c01060bf:	a1 04 b0 10 c0       	mov    0xc010b004,%eax
c01060c4:	83 f8 18             	cmp    $0x18,%eax
c01060c7:	7e 05                	jle    c01060ce <vga_put_char+0xb0>
        vga_scrollup();
c01060c9:	e8 be 00 00 00       	call   c010618c <vga_scrollup>
}
c01060ce:	90                   	nop
c01060cf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c01060d2:	c9                   	leave  
c01060d3:	c3                   	ret    

c01060d4 <vga_set_show>:

void vga_set_show(vga_attr flashing, vga_attr backgroud, vga_attr frontcolor)
{
c01060d4:	55                   	push   %ebp
c01060d5:	89 e5                	mov    %esp,%ebp
c01060d7:	83 ec 0c             	sub    $0xc,%esp
c01060da:	8b 4d 08             	mov    0x8(%ebp),%ecx
c01060dd:	8b 55 0c             	mov    0xc(%ebp),%edx
c01060e0:	8b 45 10             	mov    0x10(%ebp),%eax
c01060e3:	66 89 4d fc          	mov    %cx,-0x4(%ebp)
c01060e7:	66 89 55 f8          	mov    %dx,-0x8(%ebp)
c01060eb:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
    theme_color = (flashing << 7 | backgroud << 4 | frontcolor) << 8;
c01060ef:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
c01060f3:	c1 e0 07             	shl    $0x7,%eax
c01060f6:	89 c2                	mov    %eax,%edx
c01060f8:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
c01060fc:	c1 e0 04             	shl    $0x4,%eax
c01060ff:	09 c2                	or     %eax,%edx
c0106101:	0f b7 45 f4          	movzwl -0xc(%ebp),%eax
c0106105:	09 d0                	or     %edx,%eax
c0106107:	c1 e0 08             	shl    $0x8,%eax
c010610a:	66 a3 00 b0 10 c0    	mov    %ax,0xc010b000
}
c0106110:	90                   	nop
c0106111:	c9                   	leave  
c0106112:	c3                   	ret    

c0106113 <vga_put_str>:

void vga_put_str(char* str)
{
c0106113:	55                   	push   %ebp
c0106114:	89 e5                	mov    %esp,%ebp
c0106116:	83 ec 08             	sub    $0x8,%esp
    while (*str != '\0')
c0106119:	eb 19                	jmp    c0106134 <vga_put_str+0x21>
    {
        vga_put_char(*str);
c010611b:	8b 45 08             	mov    0x8(%ebp),%eax
c010611e:	0f b6 00             	movzbl (%eax),%eax
c0106121:	0f be c0             	movsbl %al,%eax
c0106124:	83 ec 0c             	sub    $0xc,%esp
c0106127:	50                   	push   %eax
c0106128:	e8 f1 fe ff ff       	call   c010601e <vga_put_char>
c010612d:	83 c4 10             	add    $0x10,%esp
        str++;
c0106130:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    while (*str != '\0')
c0106134:	8b 45 08             	mov    0x8(%ebp),%eax
c0106137:	0f b6 00             	movzbl (%eax),%eax
c010613a:	84 c0                	test   %al,%al
c010613c:	75 dd                	jne    c010611b <vga_put_str+0x8>
    }
}
c010613e:	90                   	nop
c010613f:	90                   	nop
c0106140:	c9                   	leave  
c0106141:	c3                   	ret    

c0106142 <vga_clear>:

void vga_clear()
{
c0106142:	55                   	push   %ebp
c0106143:	89 e5                	mov    %esp,%ebp
c0106145:	83 ec 10             	sub    $0x10,%esp
  
    for(int i = 0; i < WIDTH * HIGHT; i++)
c0106148:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c010614f:	eb 1b                	jmp    c010616c <vga_clear+0x2a>
        *(video + i) = theme_color;
c0106151:	8b 15 0c b0 10 c0    	mov    0xc010b00c,%edx
c0106157:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010615a:	01 c0                	add    %eax,%eax
c010615c:	01 c2                	add    %eax,%edx
c010615e:	0f b7 05 00 b0 10 c0 	movzwl 0xc010b000,%eax
c0106165:	66 89 02             	mov    %ax,(%edx)
    for(int i = 0; i < WIDTH * HIGHT; i++)
c0106168:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c010616c:	81 7d fc cf 07 00 00 	cmpl   $0x7cf,-0x4(%ebp)
c0106173:	7e dc                	jle    c0106151 <vga_clear+0xf>

    XPOS = 0;
c0106175:	c7 05 08 b0 10 c0 00 	movl   $0x0,0xc010b008
c010617c:	00 00 00 
    YPOS = 0;
c010617f:	c7 05 04 b0 10 c0 00 	movl   $0x0,0xc010b004
c0106186:	00 00 00 
}
c0106189:	90                   	nop
c010618a:	c9                   	leave  
c010618b:	c3                   	ret    

c010618c <vga_scrollup>:

void vga_scrollup()
{
c010618c:	55                   	push   %ebp
c010618d:	89 e5                	mov    %esp,%ebp
c010618f:	83 ec 10             	sub    $0x10,%esp
    unsigned int last_line = WIDTH * (HIGHT - 1);
c0106192:	c7 45 f4 80 07 00 00 	movl   $0x780,-0xc(%ebp)
    for (unsigned int i = 0; i < last_line; i++) {
c0106199:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c01061a0:	eb 27                	jmp    c01061c9 <vga_scrollup+0x3d>
        *(video + i) = *(video + WIDTH + i);
c01061a2:	8b 15 0c b0 10 c0    	mov    0xc010b00c,%edx
c01061a8:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01061ab:	83 c0 50             	add    $0x50,%eax
c01061ae:	01 c0                	add    %eax,%eax
c01061b0:	01 d0                	add    %edx,%eax
c01061b2:	8b 0d 0c b0 10 c0    	mov    0xc010b00c,%ecx
c01061b8:	8b 55 fc             	mov    -0x4(%ebp),%edx
c01061bb:	01 d2                	add    %edx,%edx
c01061bd:	01 ca                	add    %ecx,%edx
c01061bf:	0f b7 00             	movzwl (%eax),%eax
c01061c2:	66 89 02             	mov    %ax,(%edx)
    for (unsigned int i = 0; i < last_line; i++) {
c01061c5:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c01061c9:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01061cc:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c01061cf:	72 d1                	jb     c01061a2 <vga_scrollup+0x16>
    }
    for (unsigned int i = 0; i < WIDTH; i++) {
c01061d1:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c01061d8:	eb 20                	jmp    c01061fa <vga_scrollup+0x6e>
        *(video + i + last_line) = theme_color;
c01061da:	8b 15 0c b0 10 c0    	mov    0xc010b00c,%edx
c01061e0:	8b 4d f8             	mov    -0x8(%ebp),%ecx
c01061e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01061e6:	01 c8                	add    %ecx,%eax
c01061e8:	01 c0                	add    %eax,%eax
c01061ea:	01 c2                	add    %eax,%edx
c01061ec:	0f b7 05 00 b0 10 c0 	movzwl 0xc010b000,%eax
c01061f3:	66 89 02             	mov    %ax,(%edx)
    for (unsigned int i = 0; i < WIDTH; i++) {
c01061f6:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c01061fa:	83 7d f8 4f          	cmpl   $0x4f,-0x8(%ebp)
c01061fe:	76 da                	jbe    c01061da <vga_scrollup+0x4e>
    }
    YPOS = YPOS == 0 ? 0 : HIGHT - 1;
c0106200:	a1 04 b0 10 c0       	mov    0xc010b004,%eax
c0106205:	85 c0                	test   %eax,%eax
c0106207:	75 07                	jne    c0106210 <vga_scrollup+0x84>
c0106209:	b8 00 00 00 00       	mov    $0x0,%eax
c010620e:	eb 05                	jmp    c0106215 <vga_scrollup+0x89>
c0106210:	b8 18 00 00 00       	mov    $0x18,%eax
c0106215:	a3 04 b0 10 c0       	mov    %eax,0xc010b004
c010621a:	90                   	nop
c010621b:	c9                   	leave  
c010621c:	c3                   	ret    

c010621d <cpu_rcr3>:
{
    asm("mov %0, %%cr3" ::"r"(v));
}

static inline reg32 cpu_rcr3()
{
c010621d:	55                   	push   %ebp
c010621e:	89 e5                	mov    %esp,%ebp
c0106220:	83 ec 10             	sub    $0x10,%esp
    uintptr_t val;
    asm volatile("movl %%cr3,%0" : "=r" (val));
c0106223:	0f 20 d8             	mov    %cr3,%eax
c0106226:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return val;
c0106229:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c010622c:	c9                   	leave  
c010622d:	c3                   	ret    

c010622e <cpu_reflags>:

static inline reg32 cpu_reflags()
{
c010622e:	55                   	push   %ebp
c010622f:	89 e5                	mov    %esp,%ebp
c0106231:	83 ec 10             	sub    $0x10,%esp
    uintptr_t val;
    asm volatile(
c0106234:	9c                   	pushf  
c0106235:	58                   	pop    %eax
c0106236:	89 45 fc             	mov    %eax,-0x4(%ebp)
        "pushf\n"
        "popl %0\n"
        :"=r"(val)::);
    return val;
c0106239:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c010623c:	c9                   	leave  
c010623d:	c3                   	ret    

c010623e <_kernel_init>:
/* Forward declarations. */
void _kernel_init (unsigned long addr);
extern void __proc0(); /* proc0.c */

void _kernel_init(unsigned long addr)
{
c010623e:	55                   	push   %ebp
c010623f:	89 e5                	mov    %esp,%ebp
c0106241:	57                   	push   %edi
c0106242:	56                   	push   %esi
c0106243:	53                   	push   %ebx
c0106244:	81 ec bc 00 00 00    	sub    $0xbc,%esp
    multiboot_info_t *mbi;
    mbi = (multiboot_info_t *) addr;
c010624a:	8b 45 08             	mov    0x8(%ebp),%eax
c010624d:	89 45 d8             	mov    %eax,-0x28(%ebp)
    multiboot_memory_map_t* map = (multiboot_memory_map_t*)mbi->mmap_addr;
c0106250:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0106253:	8b 40 30             	mov    0x30(%eax),%eax
c0106256:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    _init_idt();
c0106259:	e8 ba 28 00 00       	call   c0108b18 <_init_idt>
    pmm_init(MEM_1MB + (mbi->mem_upper << 10));
c010625e:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0106261:	8b 40 08             	mov    0x8(%eax),%eax
c0106264:	c1 e0 0a             	shl    $0xa,%eax
c0106267:	05 00 00 10 00       	add    $0x100000,%eax
c010626c:	83 ec 0c             	sub    $0xc,%esp
c010626f:	50                   	push   %eax
c0106270:	e8 d2 04 00 00       	call   c0106747 <pmm_init>
c0106275:	83 c4 10             	add    $0x10,%esp
    vmm_init();
c0106278:	e8 a2 11 00 00       	call   c010741f <vmm_init>

    init_vga_buffer();
c010627d:	e8 7e fd ff ff       	call   c0106000 <init_vga_buffer>
    vga_set_show(0,VGA_COLOR_BLACK,VGA_COLOR_LIGHT_WHITE);
c0106282:	83 ec 04             	sub    $0x4,%esp
c0106285:	6a 0f                	push   $0xf
c0106287:	6a 00                	push   $0x0
c0106289:	6a 00                	push   $0x0
c010628b:	e8 44 fe ff ff       	call   c01060d4 <vga_set_show>
c0106290:	83 c4 10             	add    $0x10,%esp
    /* Clear the screen. */
    vga_clear();
c0106293:	e8 aa fe ff ff       	call   c0106142 <vga_clear>

    __kernel_ptd = cpu_rcr3();
c0106298:	e8 80 ff ff ff       	call   c010621d <cpu_rcr3>
c010629d:	a3 20 b0 10 c0       	mov    %eax,0xc010b020

    tmp = (struct m_pcb){ .page_table = __kernel_ptd };
c01062a2:	8b 35 20 b0 10 c0    	mov    0xc010b020,%esi
c01062a8:	bb 40 b0 10 c0       	mov    $0xc010b040,%ebx
c01062ad:	b8 00 00 00 00       	mov    $0x0,%eax
c01062b2:	ba 1b 00 00 00       	mov    $0x1b,%edx
c01062b7:	89 df                	mov    %ebx,%edi
c01062b9:	89 d1                	mov    %edx,%ecx
c01062bb:	f3 ab                	rep stos %eax,%es:(%edi)
c01062bd:	89 35 a4 b0 10 c0    	mov    %esi,0xc010b0a4

    __current = &tmp;
c01062c3:	c7 05 e0 bb 28 c0 40 	movl   $0xc010b040,0xc028bbe0
c01062ca:	b0 10 c0 
    // }

    /* Set MBI to the address of the Multiboot information structure. */

    /* Print out the flags. */
    kprintf("flags = 0x%x\n", (unsigned) mbi->flags);
c01062cd:	8b 45 d8             	mov    -0x28(%ebp),%eax
c01062d0:	8b 00                	mov    (%eax),%eax
c01062d2:	83 ec 08             	sub    $0x8,%esp
c01062d5:	50                   	push   %eax
c01062d6:	68 00 d0 28 c0       	push   $0xc028d000
c01062db:	e8 c8 3b 00 00       	call   c0109ea8 <kprintf>
c01062e0:	83 c4 10             	add    $0x10,%esp

    /* Are mem_* valid? */
    if (CHECK_FLAG(mbi->flags, 0))
c01062e3:	8b 45 d8             	mov    -0x28(%ebp),%eax
c01062e6:	8b 00                	mov    (%eax),%eax
c01062e8:	83 e0 01             	and    $0x1,%eax
c01062eb:	85 c0                	test   %eax,%eax
c01062ed:	74 1e                	je     c010630d <_kernel_init+0xcf>
        kprintf("mem_lower = %uKB, mem_upper = %uKB\n",(unsigned) mbi->mem_lower, (unsigned) mbi->mem_upper);
c01062ef:	8b 45 d8             	mov    -0x28(%ebp),%eax
c01062f2:	8b 50 08             	mov    0x8(%eax),%edx
c01062f5:	8b 45 d8             	mov    -0x28(%ebp),%eax
c01062f8:	8b 40 04             	mov    0x4(%eax),%eax
c01062fb:	83 ec 04             	sub    $0x4,%esp
c01062fe:	52                   	push   %edx
c01062ff:	50                   	push   %eax
c0106300:	68 10 d0 28 c0       	push   $0xc028d010
c0106305:	e8 9e 3b 00 00       	call   c0109ea8 <kprintf>
c010630a:	83 c4 10             	add    $0x10,%esp
    
    unsigned int map_size = mbi->mmap_length / sizeof(multiboot_memory_map_t);
c010630d:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0106310:	8b 40 2c             	mov    0x2c(%eax),%eax
c0106313:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
c0106318:	f7 e2                	mul    %edx
c010631a:	89 d0                	mov    %edx,%eax
c010631c:	c1 e8 04             	shr    $0x4,%eax
c010631f:	89 45 d0             	mov    %eax,-0x30(%ebp)
    for (unsigned int i = 0; i < map_size; i++) {
c0106322:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
c0106329:	e9 33 01 00 00       	jmp    c0106461 <_kernel_init+0x223>
        multiboot_memory_map_t mmap = map[i];
c010632e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0106331:	89 d0                	mov    %edx,%eax
c0106333:	01 c0                	add    %eax,%eax
c0106335:	01 d0                	add    %edx,%eax
c0106337:	c1 e0 03             	shl    $0x3,%eax
c010633a:	89 c2                	mov    %eax,%edx
c010633c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c010633f:	01 d0                	add    %edx,%eax
c0106341:	8b 10                	mov    (%eax),%edx
c0106343:	89 95 40 ff ff ff    	mov    %edx,-0xc0(%ebp)
c0106349:	8b 50 04             	mov    0x4(%eax),%edx
c010634c:	89 95 44 ff ff ff    	mov    %edx,-0xbc(%ebp)
c0106352:	8b 50 08             	mov    0x8(%eax),%edx
c0106355:	89 95 48 ff ff ff    	mov    %edx,-0xb8(%ebp)
c010635b:	8b 50 0c             	mov    0xc(%eax),%edx
c010635e:	89 95 4c ff ff ff    	mov    %edx,-0xb4(%ebp)
c0106364:	8b 50 10             	mov    0x10(%eax),%edx
c0106367:	89 95 50 ff ff ff    	mov    %edx,-0xb0(%ebp)
c010636d:	8b 40 14             	mov    0x14(%eax),%eax
c0106370:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
        kprintf("[MM] Base: 0x%x, len: %u KiB, type: %u\n",
               map[i].addr_low,
               map[i].len_low >> 10,
               map[i].type);
c0106376:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0106379:	89 d0                	mov    %edx,%eax
c010637b:	01 c0                	add    %eax,%eax
c010637d:	01 d0                	add    %edx,%eax
c010637f:	c1 e0 03             	shl    $0x3,%eax
c0106382:	89 c2                	mov    %eax,%edx
c0106384:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0106387:	01 d0                	add    %edx,%eax
        kprintf("[MM] Base: 0x%x, len: %u KiB, type: %u\n",
c0106389:	8b 50 14             	mov    0x14(%eax),%edx
               map[i].len_low >> 10,
c010638c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c010638f:	89 c8                	mov    %ecx,%eax
c0106391:	01 c0                	add    %eax,%eax
c0106393:	01 c8                	add    %ecx,%eax
c0106395:	c1 e0 03             	shl    $0x3,%eax
c0106398:	89 c1                	mov    %eax,%ecx
c010639a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c010639d:	01 c8                	add    %ecx,%eax
c010639f:	8b 40 0c             	mov    0xc(%eax),%eax
        kprintf("[MM] Base: 0x%x, len: %u KiB, type: %u\n",
c01063a2:	c1 e8 0a             	shr    $0xa,%eax
c01063a5:	89 c3                	mov    %eax,%ebx
               map[i].addr_low,
c01063a7:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c01063aa:	89 c8                	mov    %ecx,%eax
c01063ac:	01 c0                	add    %eax,%eax
c01063ae:	01 c8                	add    %ecx,%eax
c01063b0:	c1 e0 03             	shl    $0x3,%eax
c01063b3:	89 c1                	mov    %eax,%ecx
c01063b5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c01063b8:	01 c8                	add    %ecx,%eax
        kprintf("[MM] Base: 0x%x, len: %u KiB, type: %u\n",
c01063ba:	8b 40 04             	mov    0x4(%eax),%eax
c01063bd:	52                   	push   %edx
c01063be:	53                   	push   %ebx
c01063bf:	50                   	push   %eax
c01063c0:	68 34 d0 28 c0       	push   $0xc028d034
c01063c5:	e8 de 3a 00 00       	call   c0109ea8 <kprintf>
c01063ca:	83 c4 10             	add    $0x10,%esp
        if (mmap.type == MULTIBOOT_MEMORY_AVAILABLE) {
c01063cd:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
c01063d3:	83 f8 01             	cmp    $0x1,%eax
c01063d6:	0f 85 81 00 00 00    	jne    c010645d <_kernel_init+0x21f>
            // 整数向上取整除法
            uintptr_t pg = map[i].addr_low + 0x0fffU;
c01063dc:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c01063df:	89 d0                	mov    %edx,%eax
c01063e1:	01 c0                	add    %eax,%eax
c01063e3:	01 d0                	add    %edx,%eax
c01063e5:	c1 e0 03             	shl    $0x3,%eax
c01063e8:	89 c2                	mov    %eax,%edx
c01063ea:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c01063ed:	01 d0                	add    %edx,%eax
c01063ef:	8b 40 04             	mov    0x4(%eax),%eax
c01063f2:	05 ff 0f 00 00       	add    $0xfff,%eax
c01063f7:	89 45 c4             	mov    %eax,-0x3c(%ebp)
            pmm_mark_chunk_free(pg >> 12, map[i].len_low >> 12);
c01063fa:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c01063fd:	89 d0                	mov    %edx,%eax
c01063ff:	01 c0                	add    %eax,%eax
c0106401:	01 d0                	add    %edx,%eax
c0106403:	c1 e0 03             	shl    $0x3,%eax
c0106406:	89 c2                	mov    %eax,%edx
c0106408:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c010640b:	01 d0                	add    %edx,%eax
c010640d:	8b 40 0c             	mov    0xc(%eax),%eax
c0106410:	c1 e8 0c             	shr    $0xc,%eax
c0106413:	89 c2                	mov    %eax,%edx
c0106415:	8b 45 c4             	mov    -0x3c(%ebp),%eax
c0106418:	c1 e8 0c             	shr    $0xc,%eax
c010641b:	83 ec 08             	sub    $0x8,%esp
c010641e:	52                   	push   %edx
c010641f:	50                   	push   %eax
c0106420:	e8 07 04 00 00       	call   c010682c <pmm_mark_chunk_free>
c0106425:	83 c4 10             	add    $0x10,%esp
            kprintf("[MM] Freed %u pages start from 0x%x\n",
c0106428:	8b 45 c4             	mov    -0x3c(%ebp),%eax
c010642b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0106430:	89 c1                	mov    %eax,%ecx
                   map[i].len_low >> 12,
c0106432:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0106435:	89 d0                	mov    %edx,%eax
c0106437:	01 c0                	add    %eax,%eax
c0106439:	01 d0                	add    %edx,%eax
c010643b:	c1 e0 03             	shl    $0x3,%eax
c010643e:	89 c2                	mov    %eax,%edx
c0106440:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0106443:	01 d0                	add    %edx,%eax
c0106445:	8b 40 0c             	mov    0xc(%eax),%eax
            kprintf("[MM] Freed %u pages start from 0x%x\n",
c0106448:	c1 e8 0c             	shr    $0xc,%eax
c010644b:	83 ec 04             	sub    $0x4,%esp
c010644e:	51                   	push   %ecx
c010644f:	50                   	push   %eax
c0106450:	68 5c d0 28 c0       	push   $0xc028d05c
c0106455:	e8 4e 3a 00 00       	call   c0109ea8 <kprintf>
c010645a:	83 c4 10             	add    $0x10,%esp
    for (unsigned int i = 0; i < map_size; i++) {
c010645d:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
c0106461:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0106464:	3b 45 d0             	cmp    -0x30(%ebp),%eax
c0106467:	0f 82 c1 fe ff ff    	jb     c010632e <_kernel_init+0xf0>
                   pg & ~0x0fffU);
        }
    }

    // 将内核占据的页设为已占用
    size_t pg_count = (uintptr_t)(&virkernel_end  - &virkernel_start) >> 12;
c010646d:	b8 00 40 29 c0       	mov    $0xc0294000,%eax
c0106472:	2d 00 60 10 c0       	sub    $0xc0106000,%eax
c0106477:	c1 e8 0c             	shr    $0xc,%eax
c010647a:	89 45 cc             	mov    %eax,-0x34(%ebp)
    pmm_mark_chunk_occupied(KERNEL_PID, V2P(&virkernel_start) >> 12, pg_count, 0);
c010647d:	b8 00 60 10 c0       	mov    $0xc0106000,%eax
c0106482:	05 00 00 00 40       	add    $0x40000000,%eax
c0106487:	c1 e8 0c             	shr    $0xc,%eax
c010648a:	6a 00                	push   $0x0
c010648c:	ff 75 cc             	push   -0x34(%ebp)
c010648f:	50                   	push   %eax
c0106490:	6a ff                	push   $0xffffffff
c0106492:	e8 d8 03 00 00       	call   c010686f <pmm_mark_chunk_occupied>
c0106497:	83 c4 10             	add    $0x10,%esp
    kprintf("[MM] Allocated %d pages for kernel.\n", pg_count);
c010649a:	83 ec 08             	sub    $0x8,%esp
c010649d:	ff 75 cc             	push   -0x34(%ebp)
c01064a0:	68 84 d0 28 c0       	push   $0xc028d084
c01064a5:	e8 fe 39 00 00       	call   c0109ea8 <kprintf>
c01064aa:	83 c4 10             	add    $0x10,%esp

    size_t vga_buf_pgs = VGA_BUFFER_SIZE >> 12;
c01064ad:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
    
    // 首先，标记VGA部分为已占用
    pmm_mark_chunk_occupied(KERNEL_PID, VIDEO >> 12, vga_buf_pgs, 0);
c01064b4:	6a 00                	push   $0x0
c01064b6:	ff 75 c8             	push   -0x38(%ebp)
c01064b9:	68 b8 00 00 00       	push   $0xb8
c01064be:	6a ff                	push   $0xffffffff
c01064c0:	e8 aa 03 00 00       	call   c010686f <pmm_mark_chunk_occupied>
c01064c5:	83 c4 10             	add    $0x10,%esp
    
    // 重映射VGA文本缓冲区（以后会变成显存，i.e., framebuffer）
    for (size_t i = 0; i < vga_buf_pgs; i++)
c01064c8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
c01064cf:	eb 2f                	jmp    c0106500 <_kernel_init+0x2c2>
    {
        vmm_map_page(KERNEL_PID, VGA_BUFFER_VADDR + (i << 12), VIDEO + (i << 12), PG_PREM_RW, PG_PREM_RW);
c01064d1:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01064d4:	c1 e0 0c             	shl    $0xc,%eax
c01064d7:	05 00 80 0b 00       	add    $0xb8000,%eax
c01064dc:	89 c2                	mov    %eax,%edx
c01064de:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01064e1:	c1 e0 0c             	shl    $0xc,%eax
c01064e4:	2d 00 00 00 50       	sub    $0x50000000,%eax
c01064e9:	83 ec 0c             	sub    $0xc,%esp
c01064ec:	6a 03                	push   $0x3
c01064ee:	6a 03                	push   $0x3
c01064f0:	52                   	push   %edx
c01064f1:	50                   	push   %eax
c01064f2:	6a ff                	push   $0xffffffff
c01064f4:	e8 e7 10 00 00       	call   c01075e0 <vmm_map_page>
c01064f9:	83 c4 20             	add    $0x20,%esp
    for (size_t i = 0; i < vga_buf_pgs; i++)
c01064fc:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
c0106500:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0106503:	3b 45 c8             	cmp    -0x38(%ebp),%eax
c0106506:	72 c9                	jb     c01064d1 <_kernel_init+0x293>
    }
    set_vga_buffer(VGA_BUFFER_VADDR);
c0106508:	83 ec 0c             	sub    $0xc,%esp
c010650b:	68 00 00 00 b0       	push   $0xb0000000
c0106510:	e8 fb fa ff ff       	call   c0106010 <set_vga_buffer>
c0106515:	83 c4 10             	add    $0x10,%esp
    kprintf("[MM] Mapped VGA to %x.\n", VGA_BUFFER_VADDR);
c0106518:	83 ec 08             	sub    $0x8,%esp
c010651b:	68 00 00 00 b0       	push   $0xb0000000
c0106520:	68 a9 d0 28 c0       	push   $0xc028d0a9
c0106525:	e8 7e 39 00 00       	call   c0109ea8 <kprintf>
c010652a:	83 c4 10             	add    $0x10,%esp

    // 为内核创建一个专属栈空间。
    for (size_t i = 0; i < (K_STACK_SIZE >> 12); i++) {
c010652d:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
c0106534:	eb 23                	jmp    c0106559 <_kernel_init+0x31b>
        vmm_alloc_page(KERNEL_PID, K_STACK_START + (i << 12), NULL, PG_PREM_RW, PG_PREM_RW);
c0106536:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0106539:	c1 e0 0c             	shl    $0xc,%eax
c010653c:	2d 00 00 50 00       	sub    $0x500000,%eax
c0106541:	83 ec 0c             	sub    $0xc,%esp
c0106544:	6a 03                	push   $0x3
c0106546:	6a 03                	push   $0x3
c0106548:	6a 00                	push   $0x0
c010654a:	50                   	push   %eax
c010654b:	6a ff                	push   $0xffffffff
c010654d:	e8 39 14 00 00       	call   c010798b <vmm_alloc_page>
c0106552:	83 c4 20             	add    $0x20,%esp
    for (size_t i = 0; i < (K_STACK_SIZE >> 12); i++) {
c0106555:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
c0106559:	81 7d dc ff 00 00 00 	cmpl   $0xff,-0x24(%ebp)
c0106560:	76 d4                	jbe    c0106536 <_kernel_init+0x2f8>
    }
    kprintf("[MM] Allocated %d pages for stack start at %p\n", K_STACK_SIZE>>12, K_STACK_START);
c0106562:	83 ec 04             	sub    $0x4,%esp
c0106565:	68 00 00 b0 ff       	push   $0xffb00000
c010656a:	68 00 01 00 00       	push   $0x100
c010656f:	68 c4 d0 28 c0       	push   $0xc028d0c4
c0106574:	e8 2f 39 00 00       	call   c0109ea8 <kprintf>
c0106579:	83 c4 10             	add    $0x10,%esp

    //give malloc init
    mem_init();
c010657c:	e8 b5 08 00 00       	call   c0106e36 <mem_init>
    kprintf("[MM] Malloc Init Success \n");
c0106581:	83 ec 0c             	sub    $0xc,%esp
c0106584:	68 f3 d0 28 c0       	push   $0xc028d0f3
c0106589:	e8 1a 39 00 00       	call   c0109ea8 <kprintf>
c010658e:	83 c4 10             	add    $0x10,%esp
    kprintf("[KERNEL] === Initialization Done === \n\n");
c0106591:	83 ec 0c             	sub    $0xc,%esp
c0106594:	68 10 d1 28 c0       	push   $0xc028d110
c0106599:	e8 0a 39 00 00       	call   c0109ea8 <kprintf>
c010659e:	83 c4 10             	add    $0x10,%esp

    vga_put_str("MELOX OS\n");
c01065a1:	83 ec 0c             	sub    $0xc,%esp
c01065a4:	68 38 d1 28 c0       	push   $0xc028d138
c01065a9:	e8 65 fb ff ff       	call   c0106113 <vga_put_str>
c01065ae:	83 c4 10             	add    $0x10,%esp
     //__asm__("int $1");
}
c01065b1:	90                   	nop
c01065b2:	8d 65 f4             	lea    -0xc(%ebp),%esp
c01065b5:	5b                   	pop    %ebx
c01065b6:	5e                   	pop    %esi
c01065b7:	5f                   	pop    %edi
c01065b8:	5d                   	pop    %ebp
c01065b9:	c3                   	ret    

c01065ba <_kernel_finnal_init>:

void _kernel_finnal_init() {
c01065ba:	55                   	push   %ebp
c01065bb:	89 e5                	mov    %esp,%ebp
c01065bd:	83 ec 18             	sub    $0x18,%esp
    //kprintf("[KERNEL] === Post Initialization === \n");
    size_t virk_init_pg_count = ((uintptr_t)(&__init_phykernel_end)) >> 12;
c01065c0:	b8 00 60 10 00       	mov    $0x106000,%eax
c01065c5:	c1 e8 0c             	shr    $0xc,%eax
c01065c8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    kprintf("[MM] Releaseing %d pages from 0x0.\n", virk_init_pg_count);
c01065cb:	83 ec 08             	sub    $0x8,%esp
c01065ce:	ff 75 f0             	push   -0x10(%ebp)
c01065d1:	68 44 d1 28 c0       	push   $0xc028d144
c01065d6:	e8 cd 38 00 00       	call   c0109ea8 <kprintf>
c01065db:	83 c4 10             	add    $0x10,%esp
    
    // // 清除 hhk_init 与前1MiB的映射
    for (size_t i = 0; i < virk_init_pg_count; i++) {
c01065de:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c01065e5:	eb 18                	jmp    c01065ff <_kernel_finnal_init+0x45>

        vmm_unmap_page(KERNEL_PID, (i << 12));
c01065e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01065ea:	c1 e0 0c             	shl    $0xc,%eax
c01065ed:	83 ec 08             	sub    $0x8,%esp
c01065f0:	50                   	push   %eax
c01065f1:	6a ff                	push   $0xffffffff
c01065f3:	e8 54 16 00 00       	call   c0107c4c <vmm_unmap_page>
c01065f8:	83 c4 10             	add    $0x10,%esp
    for (size_t i = 0; i < virk_init_pg_count; i++) {
c01065fb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c01065ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106602:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0106605:	72 e0                	jb     c01065e7 <_kernel_finnal_init+0x2d>
    // }
    // for (size_t i = 256; i < virk_init_pg_count; i++) {

    //     vmm_unmap_page((i << 12));
    // }
    kprintf("[KERNEL] === Post Initialization Done === \n\n");
c0106607:	83 ec 0c             	sub    $0xc,%esp
c010660a:	68 68 d1 28 c0       	push   $0xc028d168
c010660f:	e8 94 38 00 00       	call   c0109ea8 <kprintf>
c0106614:	83 c4 10             	add    $0x10,%esp
}
c0106617:	90                   	nop
c0106618:	c9                   	leave  
c0106619:	c3                   	ret    

c010661a <_kernel_main>:

void creat_proc0();
void _kernel_main()
{
c010661a:	55                   	push   %ebp
c010661b:	89 e5                	mov    %esp,%ebp
c010661d:	81 ec 18 01 00 00    	sub    $0x118,%esp
    char* buf[64];
    
    kprintf("We are now running in virtual address space!\n\n");
c0106623:	83 ec 0c             	sub    $0xc,%esp
c0106626:	68 98 d1 28 c0       	push   $0xc028d198
c010662b:	e8 78 38 00 00       	call   c0109ea8 <kprintf>
c0106630:	83 c4 10             	add    $0x10,%esp
    
    cpu_get_brand(buf);
c0106633:	83 ec 0c             	sub    $0xc,%esp
c0106636:	8d 85 f4 fe ff ff    	lea    -0x10c(%ebp),%eax
c010663c:	50                   	push   %eax
c010663d:	e8 b0 21 00 00       	call   c01087f2 <cpu_get_brand>
c0106642:	83 c4 10             	add    $0x10,%esp
    kprintf("CPU: %s\n\n", buf);
c0106645:	83 ec 08             	sub    $0x8,%esp
c0106648:	8d 85 f4 fe ff ff    	lea    -0x10c(%ebp),%eax
c010664e:	50                   	push   %eax
c010664f:	68 c7 d1 28 c0       	push   $0xc028d1c7
c0106654:	e8 4f 38 00 00       	call   c0109ea8 <kprintf>
c0106659:	83 c4 10             	add    $0x10,%esp

    uintptr_t k_start = vmm_v2p(&virkernel_start);
c010665c:	83 ec 0c             	sub    $0xc,%esp
c010665f:	68 00 60 10 c0       	push   $0xc0106000
c0106664:	e8 05 17 00 00       	call   c0107d6e <vmm_v2p>
c0106669:	83 c4 10             	add    $0x10,%esp
c010666c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    kprintf("The kernel's base address mapping: %x->%x\n", &virkernel_start, k_start);
c010666f:	83 ec 04             	sub    $0x4,%esp
c0106672:	ff 75 f4             	push   -0xc(%ebp)
c0106675:	68 00 60 10 c0       	push   $0xc0106000
c010667a:	68 d4 d1 28 c0       	push   $0xc028d1d4
c010667f:	e8 24 38 00 00       	call   c0109ea8 <kprintf>
c0106684:	83 c4 10             	add    $0x10,%esp

    // timer_init();
    // init_keyboard();

    //now we move ourself into proc0, and fork proc1
    sched_init();
c0106687:	e8 a1 33 00 00       	call   c0109a2d <sched_init>

    creat_proc0();
c010668c:	e8 03 00 00 00       	call   c0106694 <creat_proc0>
}
c0106691:	90                   	nop
c0106692:	c9                   	leave  
c0106693:	c3                   	ret    

c0106694 <creat_proc0>:


void creat_proc0()
{
c0106694:	55                   	push   %ebp
c0106695:	89 e5                	mov    %esp,%ebp
c0106697:	57                   	push   %edi
c0106698:	53                   	push   %ebx
c0106699:	81 ec b0 00 00 00    	sub    $0xb0,%esp
    /**
     *      1. 在创建proc0进程前关闭中断
     *
     */

    init_proc(&proc0);
c010669f:	83 ec 0c             	sub    $0xc,%esp
c01066a2:	8d 45 8c             	lea    -0x74(%ebp),%eax
c01066a5:	50                   	push   %eax
c01066a6:	e8 12 2d 00 00       	call   c01093bd <init_proc>
c01066ab:	83 c4 10             	add    $0x10,%esp
    proc0.intr_contxt = (isr_param){ .registers.esp = KSTACK_TOP - 20,
                                  .cs = KCODE_SEG,
                                  .eip = (void*)__proc0,
                                  .ss = KDATA_SEG,
                                  .eflags = cpu_reflags() };
c01066ae:	e8 7b fb ff ff       	call   c010622e <cpu_reflags>
c01066b3:	89 c3                	mov    %eax,%ebx
    proc0.intr_contxt = (isr_param){ .registers.esp = KSTACK_TOP - 20,
c01066b5:	8d 55 94             	lea    -0x6c(%ebp),%edx
c01066b8:	b8 00 00 00 00       	mov    $0x0,%eax
c01066bd:	b9 0f 00 00 00       	mov    $0xf,%ecx
c01066c2:	89 d7                	mov    %edx,%edi
c01066c4:	f3 ab                	rep stos %eax,%es:(%edi)
c01066c6:	c7 45 b0 dc ff bf ff 	movl   $0xffbfffdc,-0x50(%ebp)
c01066cd:	b8 a8 80 10 c0       	mov    $0xc01080a8,%eax
c01066d2:	89 45 bc             	mov    %eax,-0x44(%ebp)
c01066d5:	c7 45 c0 08 00 00 00 	movl   $0x8,-0x40(%ebp)
c01066dc:	89 5d c4             	mov    %ebx,-0x3c(%ebp)
c01066df:	c7 45 cc 10 00 00 00 	movl   $0x10,-0x34(%ebp)

    // 必须在读取eflags之后禁用。否则当进程被调度时，中断依然是关闭的！
    asm volatile("cli");
c01066e6:	fa                   	cli    
    copy_all_page(&proc0, PD_REFERENCED);
c01066e7:	83 ec 08             	sub    $0x8,%esp
c01066ea:	68 00 00 c0 ff       	push   $0xffc00000
c01066ef:	8d 45 8c             	lea    -0x74(%ebp),%eax
c01066f2:	50                   	push   %eax
c01066f3:	e8 5a 2e 00 00       	call   c0109552 <copy_all_page>
c01066f8:	83 c4 10             	add    $0x10,%esp
                 "pushl %2\n"
                 "pushl %3\n"
                 "pushl $0\n"
                 "pushl $0\n"
                 "movl %%eax, %%cr3\n"
                 "movl %%ebx, %%esp\n" ::"r"(proc0.page_table),
c01066fb:	8b 55 f0             	mov    -0x10(%ebp),%edx
                 "i"(KSTACK_TOP),
                 "i"(KCODE_SEG),
                 "r"(proc0.intr_contxt.eip)
c01066fe:	8b 4d bc             	mov    -0x44(%ebp),%ecx
    asm volatile("movl %%cr3, %%eax\n"
c0106701:	0f 20 d8             	mov    %cr3,%eax
c0106704:	89 e3                	mov    %esp,%ebx
c0106706:	0f 22 da             	mov    %edx,%cr3
c0106709:	bc f0 ff bf ff       	mov    $0xffbffff0,%esp
c010670e:	9c                   	pushf  
c010670f:	6a 08                	push   $0x8
c0106711:	51                   	push   %ecx
c0106712:	6a 00                	push   $0x0
c0106714:	6a 00                	push   $0x0
c0106716:	0f 22 d8             	mov    %eax,%cr3
c0106719:	89 dc                	mov    %ebx,%esp
                 : "%eax", "%ebx", "memory");

    // 向调度器注册进程。
    push_process(&proc0);
c010671b:	83 ec 0c             	sub    $0xc,%esp
c010671e:	8d 45 8c             	lea    -0x74(%ebp),%eax
c0106721:	50                   	push   %eax
c0106722:	e8 99 34 00 00       	call   c0109bc0 <push_process>
c0106727:	83 c4 10             	add    $0x10,%esp

    // 由于时钟中断未就绪，我们需要手动通知调度器进行第一次调度。这里也会同时隐式地恢复我们的eflags.IF位
    schedule();
c010672a:	e8 cc 33 00 00       	call   c0109afb <schedule>

    /* Should not return */
    kprintf("Unexpected Return");
c010672f:	83 ec 0c             	sub    $0xc,%esp
c0106732:	68 ff d1 28 c0       	push   $0xc028d1ff
c0106737:	e8 6c 37 00 00       	call   c0109ea8 <kprintf>
c010673c:	83 c4 10             	add    $0x10,%esp
c010673f:	90                   	nop
c0106740:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0106743:	5b                   	pop    %ebx
c0106744:	5f                   	pop    %edi
c0106745:	5d                   	pop    %ebp
c0106746:	c3                   	ret    

c0106747 <pmm_init>:

#ifdef MEMSTRUCT
static struct pp_struct pm_table[PM_BMP_MAX_SIZE];

void pmm_init(uintptr_t mem_upper_lim)
{
c0106747:	55                   	push   %ebp
c0106748:	89 e5                	mov    %esp,%ebp
c010674a:	83 ec 10             	sub    $0x10,%esp
    pg_lookup_ptr = LOOKUP_START;
c010674d:	c7 05 c0 b0 10 c0 01 	movl   $0x1,0xc010b0c0
c0106754:	00 00 00 
    max_pg = (PG_ALIGN(mem_upper_lim) >> 12);
c0106757:	8b 45 08             	mov    0x8(%ebp),%eax
c010675a:	c1 e8 0c             	shr    $0xc,%eax
c010675d:	a3 c4 b0 10 c0       	mov    %eax,0xc010b0c4

    for (size_t i = 0; i < PM_BMP_MAX_SIZE; i++) {
c0106762:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0106769:	eb 49                	jmp    c01067b4 <pmm_init+0x6d>
        pm_table[i] = (struct pp_struct) {
c010676b:	8b 55 fc             	mov    -0x4(%ebp),%edx
c010676e:	89 d0                	mov    %edx,%eax
c0106770:	01 c0                	add    %eax,%eax
c0106772:	01 d0                	add    %edx,%eax
c0106774:	c1 e0 02             	shl    $0x2,%eax
c0106777:	05 e0 b0 10 c0       	add    $0xc010b0e0,%eax
c010677c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c0106782:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0106785:	89 d0                	mov    %edx,%eax
c0106787:	01 c0                	add    %eax,%eax
c0106789:	01 d0                	add    %edx,%eax
c010678b:	c1 e0 02             	shl    $0x2,%eax
c010678e:	05 e4 b0 10 c0       	add    $0xc010b0e4,%eax
c0106793:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
c0106799:	8b 55 fc             	mov    -0x4(%ebp),%edx
c010679c:	89 d0                	mov    %edx,%eax
c010679e:	01 c0                	add    %eax,%eax
c01067a0:	01 d0                	add    %edx,%eax
c01067a2:	c1 e0 02             	shl    $0x2,%eax
c01067a5:	05 e8 b0 10 c0       	add    $0xc010b0e8,%eax
c01067aa:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    for (size_t i = 0; i < PM_BMP_MAX_SIZE; i++) {
c01067b0:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c01067b4:	81 7d fc ff ff 01 00 	cmpl   $0x1ffff,-0x4(%ebp)
c01067bb:	76 ae                	jbe    c010676b <pmm_init+0x24>
            .owner = 0,
            .attr = 0,
            .ref_counts = 1
        };
    }
}
c01067bd:	90                   	nop
c01067be:	90                   	nop
c01067bf:	c9                   	leave  
c01067c0:	c3                   	ret    

c01067c1 <pmm_mark_page_free>:

void pmm_mark_page_free(uintptr_t ppn)
{
c01067c1:	55                   	push   %ebp
c01067c2:	89 e5                	mov    %esp,%ebp
    pm_table[ppn].ref_counts = 0;
c01067c4:	8b 55 08             	mov    0x8(%ebp),%edx
c01067c7:	89 d0                	mov    %edx,%eax
c01067c9:	01 c0                	add    %eax,%eax
c01067cb:	01 d0                	add    %edx,%eax
c01067cd:	c1 e0 02             	shl    $0x2,%eax
c01067d0:	05 e4 b0 10 c0       	add    $0xc010b0e4,%eax
c01067d5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
c01067db:	90                   	nop
c01067dc:	5d                   	pop    %ebp
c01067dd:	c3                   	ret    

c01067de <pmm_mark_page_occupied>:

void pmm_mark_page_occupied(pid_t owner, uintptr_t ppn, pp_attr_t attr)
{
c01067de:	55                   	push   %ebp
c01067df:	89 e5                	mov    %esp,%ebp
c01067e1:	83 ec 10             	sub    $0x10,%esp
    pm_table[ppn] = (struct pp_struct) {
c01067e4:	8b 55 0c             	mov    0xc(%ebp),%edx
c01067e7:	89 d0                	mov    %edx,%eax
c01067e9:	01 c0                	add    %eax,%eax
c01067eb:	01 d0                	add    %edx,%eax
c01067ed:	c1 e0 02             	shl    $0x2,%eax
c01067f0:	8d 90 e0 b0 10 c0    	lea    -0x3fef4f20(%eax),%edx
c01067f6:	8b 45 08             	mov    0x8(%ebp),%eax
c01067f9:	89 02                	mov    %eax,(%edx)
c01067fb:	8b 55 0c             	mov    0xc(%ebp),%edx
c01067fe:	89 d0                	mov    %edx,%eax
c0106800:	01 c0                	add    %eax,%eax
c0106802:	01 d0                	add    %edx,%eax
c0106804:	c1 e0 02             	shl    $0x2,%eax
c0106807:	05 e4 b0 10 c0       	add    $0xc010b0e4,%eax
c010680c:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
c0106812:	8b 55 0c             	mov    0xc(%ebp),%edx
c0106815:	89 d0                	mov    %edx,%eax
c0106817:	01 c0                	add    %eax,%eax
c0106819:	01 d0                	add    %edx,%eax
c010681b:	c1 e0 02             	shl    $0x2,%eax
c010681e:	8d 90 e8 b0 10 c0    	lea    -0x3fef4f18(%eax),%edx
c0106824:	8b 45 10             	mov    0x10(%ebp),%eax
c0106827:	89 02                	mov    %eax,(%edx)
        .owner = owner,
        .ref_counts = 1,
        .attr = attr
    };
}
c0106829:	90                   	nop
c010682a:	c9                   	leave  
c010682b:	c3                   	ret    

c010682c <pmm_mark_chunk_free>:

void pmm_mark_chunk_free(uintptr_t start_ppn, size_t page_count)
{
c010682c:	55                   	push   %ebp
c010682d:	89 e5                	mov    %esp,%ebp
c010682f:	83 ec 10             	sub    $0x10,%esp
    for (size_t i = start_ppn; i < start_ppn + page_count && i < max_pg; i++)
c0106832:	8b 45 08             	mov    0x8(%ebp),%eax
c0106835:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0106838:	eb 1b                	jmp    c0106855 <pmm_mark_chunk_free+0x29>
    {
        pm_table[i].ref_counts = 0;
c010683a:	8b 55 fc             	mov    -0x4(%ebp),%edx
c010683d:	89 d0                	mov    %edx,%eax
c010683f:	01 c0                	add    %eax,%eax
c0106841:	01 d0                	add    %edx,%eax
c0106843:	c1 e0 02             	shl    $0x2,%eax
c0106846:	05 e4 b0 10 c0       	add    $0xc010b0e4,%eax
c010684b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    for (size_t i = start_ppn; i < start_ppn + page_count && i < max_pg; i++)
c0106851:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0106855:	8b 55 08             	mov    0x8(%ebp),%edx
c0106858:	8b 45 0c             	mov    0xc(%ebp),%eax
c010685b:	01 d0                	add    %edx,%eax
c010685d:	39 45 fc             	cmp    %eax,-0x4(%ebp)
c0106860:	73 0a                	jae    c010686c <pmm_mark_chunk_free+0x40>
c0106862:	a1 c4 b0 10 c0       	mov    0xc010b0c4,%eax
c0106867:	39 45 fc             	cmp    %eax,-0x4(%ebp)
c010686a:	72 ce                	jb     c010683a <pmm_mark_chunk_free+0xe>
    }
}
c010686c:	90                   	nop
c010686d:	c9                   	leave  
c010686e:	c3                   	ret    

c010686f <pmm_mark_chunk_occupied>:

void pmm_mark_chunk_occupied(pid_t owner, uint32_t start_ppn, size_t page_count, pp_attr_t attr)
{
c010686f:	55                   	push   %ebp
c0106870:	89 e5                	mov    %esp,%ebp
c0106872:	83 ec 10             	sub    $0x10,%esp
    for (size_t i = start_ppn; i < start_ppn + page_count && i < max_pg; i++)
c0106875:	8b 45 0c             	mov    0xc(%ebp),%eax
c0106878:	89 45 fc             	mov    %eax,-0x4(%ebp)
c010687b:	eb 49                	jmp    c01068c6 <pmm_mark_chunk_occupied+0x57>
    {
        pm_table[i] = (struct pp_struct) {
c010687d:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0106880:	89 d0                	mov    %edx,%eax
c0106882:	01 c0                	add    %eax,%eax
c0106884:	01 d0                	add    %edx,%eax
c0106886:	c1 e0 02             	shl    $0x2,%eax
c0106889:	8d 90 e0 b0 10 c0    	lea    -0x3fef4f20(%eax),%edx
c010688f:	8b 45 08             	mov    0x8(%ebp),%eax
c0106892:	89 02                	mov    %eax,(%edx)
c0106894:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0106897:	89 d0                	mov    %edx,%eax
c0106899:	01 c0                	add    %eax,%eax
c010689b:	01 d0                	add    %edx,%eax
c010689d:	c1 e0 02             	shl    $0x2,%eax
c01068a0:	05 e4 b0 10 c0       	add    $0xc010b0e4,%eax
c01068a5:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
c01068ab:	8b 55 fc             	mov    -0x4(%ebp),%edx
c01068ae:	89 d0                	mov    %edx,%eax
c01068b0:	01 c0                	add    %eax,%eax
c01068b2:	01 d0                	add    %edx,%eax
c01068b4:	c1 e0 02             	shl    $0x2,%eax
c01068b7:	8d 90 e8 b0 10 c0    	lea    -0x3fef4f18(%eax),%edx
c01068bd:	8b 45 14             	mov    0x14(%ebp),%eax
c01068c0:	89 02                	mov    %eax,(%edx)
    for (size_t i = start_ppn; i < start_ppn + page_count && i < max_pg; i++)
c01068c2:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c01068c6:	8b 55 0c             	mov    0xc(%ebp),%edx
c01068c9:	8b 45 10             	mov    0x10(%ebp),%eax
c01068cc:	01 d0                	add    %edx,%eax
c01068ce:	39 45 fc             	cmp    %eax,-0x4(%ebp)
c01068d1:	73 0a                	jae    c01068dd <pmm_mark_chunk_occupied+0x6e>
c01068d3:	a1 c4 b0 10 c0       	mov    0xc010b0c4,%eax
c01068d8:	39 45 fc             	cmp    %eax,-0x4(%ebp)
c01068db:	72 a0                	jb     c010687d <pmm_mark_chunk_occupied+0xe>
            .owner = owner,
            .ref_counts = 1,
            .attr = attr
        };
    }
}
c01068dd:	90                   	nop
c01068de:	c9                   	leave  
c01068df:	c3                   	ret    

c01068e0 <pmm_alloc_page>:

void* pmm_alloc_page(pid_t owner, pp_attr_t attr)
{
c01068e0:	55                   	push   %ebp
c01068e1:	89 e5                	mov    %esp,%ebp
c01068e3:	83 ec 20             	sub    $0x20,%esp
        // Next fit approach. Maximize the throughput!
    uintptr_t good_page_found = NULL;
c01068e6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    size_t old_pg_ptr = pg_lookup_ptr;
c01068ed:	a1 c0 b0 10 c0       	mov    0xc010b0c0,%eax
c01068f2:	89 45 f8             	mov    %eax,-0x8(%ebp)
    size_t upper_lim = max_pg;
c01068f5:	a1 c4 b0 10 c0       	mov    0xc010b0c4,%eax
c01068fa:	89 45 f4             	mov    %eax,-0xc(%ebp)
    struct pp_struct* pm;
    while (!good_page_found && pg_lookup_ptr < upper_lim) {
c01068fd:	eb 7d                	jmp    c010697c <pmm_alloc_page+0x9c>
        pm = &pm_table[pg_lookup_ptr];
c01068ff:	8b 15 c0 b0 10 c0    	mov    0xc010b0c0,%edx
c0106905:	89 d0                	mov    %edx,%eax
c0106907:	01 c0                	add    %eax,%eax
c0106909:	01 d0                	add    %edx,%eax
c010690b:	c1 e0 02             	shl    $0x2,%eax
c010690e:	05 e0 b0 10 c0       	add    $0xc010b0e0,%eax
c0106913:	89 45 f0             	mov    %eax,-0x10(%ebp)

        // skip the fully occupied chunk, reduce # of iterations
        if (!pm->ref_counts) {
c0106916:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106919:	8b 40 04             	mov    0x4(%eax),%eax
c010691c:	85 c0                	test   %eax,%eax
c010691e:	75 28                	jne    c0106948 <pmm_alloc_page+0x68>
                *pm = (struct pp_struct) {
c0106920:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106923:	8b 55 08             	mov    0x8(%ebp),%edx
c0106926:	89 10                	mov    %edx,(%eax)
c0106928:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010692b:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
c0106932:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106935:	8b 55 0c             	mov    0xc(%ebp),%edx
c0106938:	89 50 08             	mov    %edx,0x8(%eax)
                .attr = attr,
                .owner = owner,
                .ref_counts = 1
            };
            good_page_found = pg_lookup_ptr << 12;
c010693b:	a1 c0 b0 10 c0       	mov    0xc010b0c0,%eax
c0106940:	c1 e0 0c             	shl    $0xc,%eax
c0106943:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0106946:	eb 34                	jmp    c010697c <pmm_alloc_page+0x9c>
        } else {
            pg_lookup_ptr ++;
c0106948:	a1 c0 b0 10 c0       	mov    0xc010b0c0,%eax
c010694d:	83 c0 01             	add    $0x1,%eax
c0106950:	a3 c0 b0 10 c0       	mov    %eax,0xc010b0c0

            // We've searched the interval [old_pg_ptr, max_pg) but failed
            //   may be chances in [1, old_pg_ptr) ?
            // Let's find out!
            if (pg_lookup_ptr >= upper_lim && old_pg_ptr != LOOKUP_START) {
c0106955:	a1 c0 b0 10 c0       	mov    0xc010b0c0,%eax
c010695a:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c010695d:	77 1d                	ja     c010697c <pmm_alloc_page+0x9c>
c010695f:	83 7d f8 01          	cmpl   $0x1,-0x8(%ebp)
c0106963:	74 17                	je     c010697c <pmm_alloc_page+0x9c>
                upper_lim = old_pg_ptr;
c0106965:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0106968:	89 45 f4             	mov    %eax,-0xc(%ebp)
                pg_lookup_ptr = LOOKUP_START;
c010696b:	c7 05 c0 b0 10 c0 01 	movl   $0x1,0xc010b0c0
c0106972:	00 00 00 
                old_pg_ptr = LOOKUP_START;
c0106975:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
    while (!good_page_found && pg_lookup_ptr < upper_lim) {
c010697c:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0106980:	75 0e                	jne    c0106990 <pmm_alloc_page+0xb0>
c0106982:	a1 c0 b0 10 c0       	mov    0xc010b0c0,%eax
c0106987:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c010698a:	0f 87 6f ff ff ff    	ja     c01068ff <pmm_alloc_page+0x1f>
        }
    }
    // if (!good_page_found) {
    //     __current->k_status = LXOUTOFMEM;
    // }
    return (void*)good_page_found;
c0106990:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0106993:	c9                   	leave  
c0106994:	c3                   	ret    

c0106995 <pmm_alloc_cpage>:

void* pmm_alloc_cpage(pid_t owner, size_t num_pages, pp_attr_t attr) {
c0106995:	55                   	push   %ebp
c0106996:	89 e5                	mov    %esp,%ebp
c0106998:	83 ec 10             	sub    $0x10,%esp
    size_t p1 = 0;
c010699b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    size_t p2 = 0;
c01069a2:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

    while (p2 < max_pg && p2 - p1 < num_pages)
c01069a9:	eb 28                	jmp    c01069d3 <pmm_alloc_cpage+0x3e>
    {
        (!(&pm_table[p2])->ref_counts) ? (p2++) : (p1 = p2);
c01069ab:	8b 55 f8             	mov    -0x8(%ebp),%edx
c01069ae:	89 d0                	mov    %edx,%eax
c01069b0:	01 c0                	add    %eax,%eax
c01069b2:	01 d0                	add    %edx,%eax
c01069b4:	c1 e0 02             	shl    $0x2,%eax
c01069b7:	05 e4 b0 10 c0       	add    $0xc010b0e4,%eax
c01069bc:	8b 00                	mov    (%eax),%eax
c01069be:	85 c0                	test   %eax,%eax
c01069c0:	75 0b                	jne    c01069cd <pmm_alloc_cpage+0x38>
c01069c2:	8b 45 f8             	mov    -0x8(%ebp),%eax
c01069c5:	83 c0 01             	add    $0x1,%eax
c01069c8:	89 45 f8             	mov    %eax,-0x8(%ebp)
c01069cb:	eb 06                	jmp    c01069d3 <pmm_alloc_cpage+0x3e>
c01069cd:	8b 45 f8             	mov    -0x8(%ebp),%eax
c01069d0:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while (p2 < max_pg && p2 - p1 < num_pages)
c01069d3:	a1 c4 b0 10 c0       	mov    0xc010b0c4,%eax
c01069d8:	39 45 f8             	cmp    %eax,-0x8(%ebp)
c01069db:	73 0b                	jae    c01069e8 <pmm_alloc_cpage+0x53>
c01069dd:	8b 45 f8             	mov    -0x8(%ebp),%eax
c01069e0:	2b 45 fc             	sub    -0x4(%ebp),%eax
c01069e3:	39 45 0c             	cmp    %eax,0xc(%ebp)
c01069e6:	77 c3                	ja     c01069ab <pmm_alloc_cpage+0x16>
    }

    if (p2 < max_pg) {
c01069e8:	a1 c4 b0 10 c0       	mov    0xc010b0c4,%eax
c01069ed:	39 45 f8             	cmp    %eax,-0x8(%ebp)
c01069f0:	73 07                	jae    c01069f9 <pmm_alloc_cpage+0x64>
        return NULL;
c01069f2:	b8 00 00 00 00       	mov    $0x0,%eax
c01069f7:	eb 1a                	jmp    c0106a13 <pmm_alloc_cpage+0x7e>
    }

    pmm_mark_chunk_occupied(owner, p1, num_pages, attr);
c01069f9:	ff 75 10             	push   0x10(%ebp)
c01069fc:	ff 75 0c             	push   0xc(%ebp)
c01069ff:	ff 75 fc             	push   -0x4(%ebp)
c0106a02:	ff 75 08             	push   0x8(%ebp)
c0106a05:	e8 65 fe ff ff       	call   c010686f <pmm_mark_chunk_occupied>
c0106a0a:	83 c4 10             	add    $0x10,%esp

    return p1 << 12;
c0106a0d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106a10:	c1 e0 0c             	shl    $0xc,%eax
}
c0106a13:	c9                   	leave  
c0106a14:	c3                   	ret    

c0106a15 <pmm_free_page>:

int pmm_free_page(pid_t owner, void* page)
{
c0106a15:	55                   	push   %ebp
c0106a16:	89 e5                	mov    %esp,%ebp
c0106a18:	83 ec 10             	sub    $0x10,%esp
    struct pp_struct* pm = &pm_table[(intptr_t)page >> 12];
c0106a1b:	8b 45 0c             	mov    0xc(%ebp),%eax
c0106a1e:	c1 f8 0c             	sar    $0xc,%eax
c0106a21:	89 c2                	mov    %eax,%edx
c0106a23:	89 d0                	mov    %edx,%eax
c0106a25:	01 c0                	add    %eax,%eax
c0106a27:	01 d0                	add    %edx,%eax
c0106a29:	c1 e0 02             	shl    $0x2,%eax
c0106a2c:	05 e0 b0 10 c0       	add    $0xc010b0e0,%eax
c0106a31:	89 45 fc             	mov    %eax,-0x4(%ebp)
    
    // Oops, double free!
    if (!(pm->ref_counts)) {
c0106a34:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106a37:	8b 40 04             	mov    0x4(%eax),%eax
c0106a3a:	85 c0                	test   %eax,%eax
c0106a3c:	75 07                	jne    c0106a45 <pmm_free_page+0x30>
        return 0;
c0106a3e:	b8 00 00 00 00       	mov    $0x0,%eax
c0106a43:	eb 2e                	jmp    c0106a73 <pmm_free_page+0x5e>
    }

    // 检查权限，保证：1) 用户只能释放用户页； 2) 内核可释放所有页。
    if ((pm->owner & owner) == pm->owner) {
c0106a45:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106a48:	8b 00                	mov    (%eax),%eax
c0106a4a:	23 45 08             	and    0x8(%ebp),%eax
c0106a4d:	89 c2                	mov    %eax,%edx
c0106a4f:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106a52:	8b 00                	mov    (%eax),%eax
c0106a54:	39 c2                	cmp    %eax,%edx
c0106a56:	75 16                	jne    c0106a6e <pmm_free_page+0x59>
        pm->ref_counts--;
c0106a58:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106a5b:	8b 40 04             	mov    0x4(%eax),%eax
c0106a5e:	8d 50 ff             	lea    -0x1(%eax),%edx
c0106a61:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106a64:	89 50 04             	mov    %edx,0x4(%eax)
        return 1;
c0106a67:	b8 01 00 00 00       	mov    $0x1,%eax
c0106a6c:	eb 05                	jmp    c0106a73 <pmm_free_page+0x5e>
    }
    return 0;
c0106a6e:	b8 00 00 00 00       	mov    $0x0,%eax
    
}
c0106a73:	c9                   	leave  
c0106a74:	c3                   	ret    

c0106a75 <pmm_query>:

struct pp_struct* pmm_query(void* pa) {
c0106a75:	55                   	push   %ebp
c0106a76:	89 e5                	mov    %esp,%ebp
c0106a78:	83 ec 10             	sub    $0x10,%esp
    uint32_t ppn = (uintptr_t)pa >> 12;
c0106a7b:	8b 45 08             	mov    0x8(%ebp),%eax
c0106a7e:	c1 e8 0c             	shr    $0xc,%eax
c0106a81:	89 45 fc             	mov    %eax,-0x4(%ebp)
    
    if (ppn >= PM_BMP_MAX_SIZE) {
c0106a84:	81 7d fc ff ff 01 00 	cmpl   $0x1ffff,-0x4(%ebp)
c0106a8b:	76 07                	jbe    c0106a94 <pmm_query+0x1f>
        return NULL;
c0106a8d:	b8 00 00 00 00       	mov    $0x0,%eax
c0106a92:	eb 11                	jmp    c0106aa5 <pmm_query+0x30>
    }

    return &pm_table[ppn];
c0106a94:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0106a97:	89 d0                	mov    %edx,%eax
c0106a99:	01 c0                	add    %eax,%eax
c0106a9b:	01 d0                	add    %edx,%eax
c0106a9d:	c1 e0 02             	shl    $0x2,%eax
c0106aa0:	05 e0 b0 10 c0       	add    $0xc010b0e0,%eax
}
c0106aa5:	c9                   	leave  
c0106aa6:	c3                   	ret    

c0106aa7 <pmm_ref_page>:

int pmm_ref_page(pid_t owner, void* page) {
c0106aa7:	55                   	push   %ebp
c0106aa8:	89 e5                	mov    %esp,%ebp
c0106aaa:	83 ec 10             	sub    $0x10,%esp
    (void*) owner;      // TODO: do smth with owner
    
    uint32_t ppn = (uintptr_t)page >> 12;
c0106aad:	8b 45 0c             	mov    0xc(%ebp),%eax
c0106ab0:	c1 e8 0c             	shr    $0xc,%eax
c0106ab3:	89 45 fc             	mov    %eax,-0x4(%ebp)
    
    if (ppn >= PM_BMP_MAX_SIZE) {
c0106ab6:	81 7d fc ff ff 01 00 	cmpl   $0x1ffff,-0x4(%ebp)
c0106abd:	76 07                	jbe    c0106ac6 <pmm_ref_page+0x1f>
        return 0;
c0106abf:	b8 00 00 00 00       	mov    $0x0,%eax
c0106ac4:	eb 39                	jmp    c0106aff <pmm_ref_page+0x58>
    }

    struct pp_struct* pm = &pm_table[ppn];
c0106ac6:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0106ac9:	89 d0                	mov    %edx,%eax
c0106acb:	01 c0                	add    %eax,%eax
c0106acd:	01 d0                	add    %edx,%eax
c0106acf:	c1 e0 02             	shl    $0x2,%eax
c0106ad2:	05 e0 b0 10 c0       	add    $0xc010b0e0,%eax
c0106ad7:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if (!pm->ref_counts) {
c0106ada:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0106add:	8b 40 04             	mov    0x4(%eax),%eax
c0106ae0:	85 c0                	test   %eax,%eax
c0106ae2:	75 07                	jne    c0106aeb <pmm_ref_page+0x44>
        return 0;
c0106ae4:	b8 00 00 00 00       	mov    $0x0,%eax
c0106ae9:	eb 14                	jmp    c0106aff <pmm_ref_page+0x58>
    }

    pm->ref_counts++;
c0106aeb:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0106aee:	8b 40 04             	mov    0x4(%eax),%eax
c0106af1:	8d 50 01             	lea    0x1(%eax),%edx
c0106af4:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0106af7:	89 50 04             	mov    %edx,0x4(%eax)
    return 1;
c0106afa:	b8 01 00 00 00       	mov    $0x1,%eax
}
c0106aff:	c9                   	leave  
c0106b00:	c3                   	ret    

c0106b01 <extend_heap>:
 * @brief extend heap
 * 
 * @param extend size
 */
static void* extend_heap(size_t words)
{
c0106b01:	55                   	push   %ebp
c0106b02:	89 e5                	mov    %esp,%ebp
c0106b04:	83 ec 18             	sub    $0x18,%esp
    char* bp = mem_brk;
c0106b07:	a1 e8 b0 28 c0       	mov    0xc028b0e8,%eax
c0106b0c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    size_t size;
    //align
    size = (words % 2) ? words * WSIZE : (words + 1) * WSIZE;
c0106b0f:	8b 45 08             	mov    0x8(%ebp),%eax
c0106b12:	83 e0 01             	and    $0x1,%eax
c0106b15:	85 c0                	test   %eax,%eax
c0106b17:	74 08                	je     c0106b21 <extend_heap+0x20>
c0106b19:	8b 45 08             	mov    0x8(%ebp),%eax
c0106b1c:	c1 e0 02             	shl    $0x2,%eax
c0106b1f:	eb 09                	jmp    c0106b2a <extend_heap+0x29>
c0106b21:	8b 45 08             	mov    0x8(%ebp),%eax
c0106b24:	83 c0 01             	add    $0x1,%eax
c0106b27:	c1 e0 02             	shl    $0x2,%eax
c0106b2a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    mem_sbrk(size + WSIZE);
c0106b2d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106b30:	83 c0 04             	add    $0x4,%eax
c0106b33:	83 ec 0c             	sub    $0xc,%esp
c0106b36:	50                   	push   %eax
c0106b37:	e8 64 03 00 00       	call   c0106ea0 <mem_sbrk>
c0106b3c:	83 c4 10             	add    $0x10,%esp

    //initialize free block header/footer and the epilogue header
    PUT(HDRP(bp), PACK(size, 0)); // free block header
c0106b3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106b42:	8d 50 fc             	lea    -0x4(%eax),%edx
c0106b45:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106b48:	89 02                	mov    %eax,(%edx)
    PUT(FTRP(bp), PACK(size, 0)); // free block foot //TODO CRUSH HERE, ADD ONE PAGE OUT OF RANGE, WE ONLY GIVE ONE PAGE, MEYBE PAGE FAULT
c0106b4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106b4d:	83 e8 04             	sub    $0x4,%eax
c0106b50:	8b 00                	mov    (%eax),%eax
c0106b52:	83 e0 f8             	and    $0xfffffff8,%eax
c0106b55:	8d 50 f8             	lea    -0x8(%eax),%edx
c0106b58:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106b5b:	01 c2                	add    %eax,%edx
c0106b5d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106b60:	89 02                	mov    %eax,(%edx)
    PUT(HDRP(NEXT_BLKP(bp)), PACK(0, 1)); //NEW Epilogue header
c0106b62:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106b65:	83 e8 04             	sub    $0x4,%eax
c0106b68:	8b 00                	mov    (%eax),%eax
c0106b6a:	83 e0 f8             	and    $0xfffffff8,%eax
c0106b6d:	8d 50 fc             	lea    -0x4(%eax),%edx
c0106b70:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106b73:	01 d0                	add    %edx,%eax
c0106b75:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

    //Coalesce if previous block is free
    return coalesce(bp);
c0106b7b:	83 ec 0c             	sub    $0xc,%esp
c0106b7e:	ff 75 f4             	push   -0xc(%ebp)
c0106b81:	e8 05 00 00 00       	call   c0106b8b <coalesce>
c0106b86:	83 c4 10             	add    $0x10,%esp
}
c0106b89:	c9                   	leave  
c0106b8a:	c3                   	ret    

c0106b8b <coalesce>:
 * @brief Coalesce free blk
 * 
 * @param Coalesce bp pointer
 */
static void* coalesce(void* bp)
{
c0106b8b:	55                   	push   %ebp
c0106b8c:	89 e5                	mov    %esp,%ebp
c0106b8e:	83 ec 10             	sub    $0x10,%esp
    size_t prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));
c0106b91:	8b 45 08             	mov    0x8(%ebp),%eax
c0106b94:	83 e8 04             	sub    $0x4,%eax
c0106b97:	8b 00                	mov    (%eax),%eax
c0106b99:	83 e0 f8             	and    $0xfffffff8,%eax
c0106b9c:	8d 50 f8             	lea    -0x8(%eax),%edx
c0106b9f:	8b 45 08             	mov    0x8(%ebp),%eax
c0106ba2:	01 d0                	add    %edx,%eax
c0106ba4:	8b 00                	mov    (%eax),%eax
c0106ba6:	83 e0 01             	and    $0x1,%eax
c0106ba9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    size_t next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));
c0106bac:	8b 45 08             	mov    0x8(%ebp),%eax
c0106baf:	83 e8 04             	sub    $0x4,%eax
c0106bb2:	8b 00                	mov    (%eax),%eax
c0106bb4:	83 e0 f8             	and    $0xfffffff8,%eax
c0106bb7:	8d 50 fc             	lea    -0x4(%eax),%edx
c0106bba:	8b 45 08             	mov    0x8(%ebp),%eax
c0106bbd:	01 d0                	add    %edx,%eax
c0106bbf:	8b 00                	mov    (%eax),%eax
c0106bc1:	83 e0 01             	and    $0x1,%eax
c0106bc4:	89 45 f8             	mov    %eax,-0x8(%ebp)
    size_t size = GET_SIZE(HDRP(bp));
c0106bc7:	8b 45 08             	mov    0x8(%ebp),%eax
c0106bca:	83 e8 04             	sub    $0x4,%eax
c0106bcd:	8b 00                	mov    (%eax),%eax
c0106bcf:	83 e0 f8             	and    $0xfffffff8,%eax
c0106bd2:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(prev_alloc && next_alloc)
c0106bd5:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0106bd9:	74 0e                	je     c0106be9 <coalesce+0x5e>
c0106bdb:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0106bdf:	74 08                	je     c0106be9 <coalesce+0x5e>
        return bp;
c0106be1:	8b 45 08             	mov    0x8(%ebp),%eax
c0106be4:	e9 3e 01 00 00       	jmp    c0106d27 <coalesce+0x19c>

    else if(prev_alloc && !next_alloc)
c0106be9:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0106bed:	74 49                	je     c0106c38 <coalesce+0xad>
c0106bef:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0106bf3:	75 43                	jne    c0106c38 <coalesce+0xad>
    {
        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));
c0106bf5:	8b 45 08             	mov    0x8(%ebp),%eax
c0106bf8:	83 e8 04             	sub    $0x4,%eax
c0106bfb:	8b 00                	mov    (%eax),%eax
c0106bfd:	83 e0 f8             	and    $0xfffffff8,%eax
c0106c00:	8d 50 fc             	lea    -0x4(%eax),%edx
c0106c03:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c06:	01 d0                	add    %edx,%eax
c0106c08:	8b 00                	mov    (%eax),%eax
c0106c0a:	83 e0 f8             	and    $0xfffffff8,%eax
c0106c0d:	01 45 f4             	add    %eax,-0xc(%ebp)
        PUT(HDRP(bp), PACK(size, 0));
c0106c10:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c13:	8d 50 fc             	lea    -0x4(%eax),%edx
c0106c16:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106c19:	89 02                	mov    %eax,(%edx)
        PUT(FTRP(bp), PACK(size, 0));
c0106c1b:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c1e:	83 e8 04             	sub    $0x4,%eax
c0106c21:	8b 00                	mov    (%eax),%eax
c0106c23:	83 e0 f8             	and    $0xfffffff8,%eax
c0106c26:	8d 50 f8             	lea    -0x8(%eax),%edx
c0106c29:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c2c:	01 c2                	add    %eax,%edx
c0106c2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106c31:	89 02                	mov    %eax,(%edx)
c0106c33:	e9 ec 00 00 00       	jmp    c0106d24 <coalesce+0x199>
    }

    else if(!prev_alloc && next_alloc)
c0106c38:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0106c3c:	75 6b                	jne    c0106ca9 <coalesce+0x11e>
c0106c3e:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0106c42:	74 65                	je     c0106ca9 <coalesce+0x11e>
    {
        size += GET_SIZE(HDRP(PREV_BLKP(bp)));//TO DO ,THERE IS PEOBLEM, CRUSH HERE
c0106c44:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c47:	83 e8 08             	sub    $0x8,%eax
c0106c4a:	8b 00                	mov    (%eax),%eax
c0106c4c:	83 e0 f8             	and    $0xfffffff8,%eax
c0106c4f:	ba fc ff ff ff       	mov    $0xfffffffc,%edx
c0106c54:	29 c2                	sub    %eax,%edx
c0106c56:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c59:	01 d0                	add    %edx,%eax
c0106c5b:	8b 00                	mov    (%eax),%eax
c0106c5d:	83 e0 f8             	and    $0xfffffff8,%eax
c0106c60:	01 45 f4             	add    %eax,-0xc(%ebp)
        PUT(FTRP(bp), PACK(size, 0));
c0106c63:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c66:	83 e8 04             	sub    $0x4,%eax
c0106c69:	8b 00                	mov    (%eax),%eax
c0106c6b:	83 e0 f8             	and    $0xfffffff8,%eax
c0106c6e:	8d 50 f8             	lea    -0x8(%eax),%edx
c0106c71:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c74:	01 c2                	add    %eax,%edx
c0106c76:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106c79:	89 02                	mov    %eax,(%edx)
        PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0));
c0106c7b:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c7e:	83 e8 08             	sub    $0x8,%eax
c0106c81:	8b 00                	mov    (%eax),%eax
c0106c83:	83 e0 f8             	and    $0xfffffff8,%eax
c0106c86:	ba fc ff ff ff       	mov    $0xfffffffc,%edx
c0106c8b:	29 c2                	sub    %eax,%edx
c0106c8d:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c90:	01 c2                	add    %eax,%edx
c0106c92:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106c95:	89 02                	mov    %eax,(%edx)
        bp = PREV_BLKP(bp);
c0106c97:	8b 45 08             	mov    0x8(%ebp),%eax
c0106c9a:	83 e8 08             	sub    $0x8,%eax
c0106c9d:	8b 00                	mov    (%eax),%eax
c0106c9f:	83 e0 f8             	and    $0xfffffff8,%eax
c0106ca2:	f7 d8                	neg    %eax
c0106ca4:	01 45 08             	add    %eax,0x8(%ebp)
c0106ca7:	eb 7b                	jmp    c0106d24 <coalesce+0x199>
    }

    else{
        size += GET_SIZE(HDRP(PREV_BLKP(bp))) + GET_SIZE(FTRP(NEXT_BLKP(bp)));
c0106ca9:	8b 45 08             	mov    0x8(%ebp),%eax
c0106cac:	83 e8 08             	sub    $0x8,%eax
c0106caf:	8b 00                	mov    (%eax),%eax
c0106cb1:	83 e0 f8             	and    $0xfffffff8,%eax
c0106cb4:	ba fc ff ff ff       	mov    $0xfffffffc,%edx
c0106cb9:	29 c2                	sub    %eax,%edx
c0106cbb:	8b 45 08             	mov    0x8(%ebp),%eax
c0106cbe:	01 d0                	add    %edx,%eax
c0106cc0:	8b 00                	mov    (%eax),%eax
c0106cc2:	83 e0 f8             	and    $0xfffffff8,%eax
c0106cc5:	89 c2                	mov    %eax,%edx
c0106cc7:	8b 45 08             	mov    0x8(%ebp),%eax
c0106cca:	83 e8 04             	sub    $0x4,%eax
c0106ccd:	8b 00                	mov    (%eax),%eax
c0106ccf:	83 e0 f8             	and    $0xfffffff8,%eax
c0106cd2:	8d 48 f8             	lea    -0x8(%eax),%ecx
c0106cd5:	8b 45 08             	mov    0x8(%ebp),%eax
c0106cd8:	01 c8                	add    %ecx,%eax
c0106cda:	8b 00                	mov    (%eax),%eax
c0106cdc:	83 e0 f8             	and    $0xfffffff8,%eax
c0106cdf:	01 d0                	add    %edx,%eax
c0106ce1:	01 45 f4             	add    %eax,-0xc(%ebp)
        PUT(FTRP(PREV_BLKP(bp)), PACK(size, 0));
c0106ce4:	8b 45 08             	mov    0x8(%ebp),%eax
c0106ce7:	83 e8 04             	sub    $0x4,%eax
c0106cea:	8b 00                	mov    (%eax),%eax
c0106cec:	83 e0 f8             	and    $0xfffffff8,%eax
c0106cef:	8d 50 f8             	lea    -0x8(%eax),%edx
c0106cf2:	8b 45 08             	mov    0x8(%ebp),%eax
c0106cf5:	01 c2                	add    %eax,%edx
c0106cf7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106cfa:	89 02                	mov    %eax,(%edx)
        PUT(HDRP(NEXT_BLKP(bp)), PACK(size, 0));
c0106cfc:	8b 45 08             	mov    0x8(%ebp),%eax
c0106cff:	83 e8 04             	sub    $0x4,%eax
c0106d02:	8b 00                	mov    (%eax),%eax
c0106d04:	83 e0 f8             	and    $0xfffffff8,%eax
c0106d07:	8d 50 fc             	lea    -0x4(%eax),%edx
c0106d0a:	8b 45 08             	mov    0x8(%ebp),%eax
c0106d0d:	01 c2                	add    %eax,%edx
c0106d0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106d12:	89 02                	mov    %eax,(%edx)
        bp = PREV_BLKP(bp);
c0106d14:	8b 45 08             	mov    0x8(%ebp),%eax
c0106d17:	83 e8 08             	sub    $0x8,%eax
c0106d1a:	8b 00                	mov    (%eax),%eax
c0106d1c:	83 e0 f8             	and    $0xfffffff8,%eax
c0106d1f:	f7 d8                	neg    %eax
c0106d21:	01 45 08             	add    %eax,0x8(%ebp)
    }
    return bp;
c0106d24:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0106d27:	c9                   	leave  
c0106d28:	c3                   	ret    

c0106d29 <find_fit>:
 * @brief find free blk
 * 
 * @param find size
 */
static void* find_fit(size_t asize)// we just traverse heap
{
c0106d29:	55                   	push   %ebp
c0106d2a:	89 e5                	mov    %esp,%ebp
c0106d2c:	83 ec 10             	sub    $0x10,%esp
    void* bp = heap_listp;
c0106d2f:	a1 e0 b0 28 c0       	mov    0xc028b0e0,%eax
c0106d34:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while(GET_ALLOC(HDRP(bp)) || (GET_SIZE(HDRP(bp)) < asize))
c0106d37:	eb 2f                	jmp    c0106d68 <find_fit+0x3f>
    {
        if(GET_SIZE(bp) != 0 && GET_ALLOC(bp) != 1)
c0106d39:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106d3c:	8b 00                	mov    (%eax),%eax
c0106d3e:	83 e0 f8             	and    $0xfffffff8,%eax
c0106d41:	85 c0                	test   %eax,%eax
c0106d43:	74 1c                	je     c0106d61 <find_fit+0x38>
c0106d45:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106d48:	8b 00                	mov    (%eax),%eax
c0106d4a:	83 e0 01             	and    $0x1,%eax
c0106d4d:	85 c0                	test   %eax,%eax
c0106d4f:	75 10                	jne    c0106d61 <find_fit+0x38>
            bp = NEXT_BLKP(bp);
c0106d51:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106d54:	83 e8 04             	sub    $0x4,%eax
c0106d57:	8b 00                	mov    (%eax),%eax
c0106d59:	83 e0 f8             	and    $0xfffffff8,%eax
c0106d5c:	01 45 fc             	add    %eax,-0x4(%ebp)
c0106d5f:	eb 07                	jmp    c0106d68 <find_fit+0x3f>
        else
            return NULL;
c0106d61:	b8 00 00 00 00       	mov    $0x0,%eax
c0106d66:	eb 22                	jmp    c0106d8a <find_fit+0x61>
    while(GET_ALLOC(HDRP(bp)) || (GET_SIZE(HDRP(bp)) < asize))
c0106d68:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106d6b:	83 e8 04             	sub    $0x4,%eax
c0106d6e:	8b 00                	mov    (%eax),%eax
c0106d70:	83 e0 01             	and    $0x1,%eax
c0106d73:	85 c0                	test   %eax,%eax
c0106d75:	75 c2                	jne    c0106d39 <find_fit+0x10>
c0106d77:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106d7a:	83 e8 04             	sub    $0x4,%eax
c0106d7d:	8b 00                	mov    (%eax),%eax
c0106d7f:	83 e0 f8             	and    $0xfffffff8,%eax
c0106d82:	39 45 08             	cmp    %eax,0x8(%ebp)
c0106d85:	77 b2                	ja     c0106d39 <find_fit+0x10>
    }
    return bp;
c0106d87:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0106d8a:	c9                   	leave  
c0106d8b:	c3                   	ret    

c0106d8c <place>:
 * @brief place the blk
 * 
 * @param blk,size
 */
static void place(void* bp, size_t asize)
{
c0106d8c:	55                   	push   %ebp
c0106d8d:	89 e5                	mov    %esp,%ebp
c0106d8f:	83 ec 10             	sub    $0x10,%esp
    size_t bp_allsize = GET_SIZE(HDRP(bp));
c0106d92:	8b 45 08             	mov    0x8(%ebp),%eax
c0106d95:	83 e8 04             	sub    $0x4,%eax
c0106d98:	8b 00                	mov    (%eax),%eax
c0106d9a:	83 e0 f8             	and    $0xfffffff8,%eax
c0106d9d:	89 45 fc             	mov    %eax,-0x4(%ebp)
    size_t remain_size = bp_allsize - asize;
c0106da0:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0106da3:	2b 45 0c             	sub    0xc(%ebp),%eax
c0106da6:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if(remain_size >= 2*DSIZE)
c0106da9:	83 7d f8 0f          	cmpl   $0xf,-0x8(%ebp)
c0106dad:	76 5b                	jbe    c0106e0a <place+0x7e>
    {
        PUT(HDRP(bp), PACK(asize, 1));
c0106daf:	8b 45 08             	mov    0x8(%ebp),%eax
c0106db2:	83 e8 04             	sub    $0x4,%eax
c0106db5:	8b 55 0c             	mov    0xc(%ebp),%edx
c0106db8:	83 ca 01             	or     $0x1,%edx
c0106dbb:	89 10                	mov    %edx,(%eax)
        PUT(FTRP(bp), PACK(asize, 1));
c0106dbd:	8b 45 08             	mov    0x8(%ebp),%eax
c0106dc0:	83 e8 04             	sub    $0x4,%eax
c0106dc3:	8b 00                	mov    (%eax),%eax
c0106dc5:	83 e0 f8             	and    $0xfffffff8,%eax
c0106dc8:	8d 50 f8             	lea    -0x8(%eax),%edx
c0106dcb:	8b 45 08             	mov    0x8(%ebp),%eax
c0106dce:	01 d0                	add    %edx,%eax
c0106dd0:	8b 55 0c             	mov    0xc(%ebp),%edx
c0106dd3:	83 ca 01             	or     $0x1,%edx
c0106dd6:	89 10                	mov    %edx,(%eax)
        PUT(HDRP(NEXT_BLKP(bp)), PACK(remain_size, 0));
c0106dd8:	8b 45 08             	mov    0x8(%ebp),%eax
c0106ddb:	83 e8 04             	sub    $0x4,%eax
c0106dde:	8b 00                	mov    (%eax),%eax
c0106de0:	83 e0 f8             	and    $0xfffffff8,%eax
c0106de3:	8d 50 fc             	lea    -0x4(%eax),%edx
c0106de6:	8b 45 08             	mov    0x8(%ebp),%eax
c0106de9:	01 c2                	add    %eax,%edx
c0106deb:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0106dee:	89 02                	mov    %eax,(%edx)
        PUT(FTRP(NEXT_BLKP(bp)), PACK(remain_size, 0));
c0106df0:	8b 45 08             	mov    0x8(%ebp),%eax
c0106df3:	83 e8 04             	sub    $0x4,%eax
c0106df6:	8b 00                	mov    (%eax),%eax
c0106df8:	83 e0 f8             	and    $0xfffffff8,%eax
c0106dfb:	8d 50 f8             	lea    -0x8(%eax),%edx
c0106dfe:	8b 45 08             	mov    0x8(%ebp),%eax
c0106e01:	01 c2                	add    %eax,%edx
c0106e03:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0106e06:	89 02                	mov    %eax,(%edx)
    }else{
        PUT(HDRP(bp), PACK(bp_allsize, 1));
        PUT(FTRP(bp), PACK(bp_allsize, 1));
    }
}
c0106e08:	eb 29                	jmp    c0106e33 <place+0xa7>
        PUT(HDRP(bp), PACK(bp_allsize, 1));
c0106e0a:	8b 45 08             	mov    0x8(%ebp),%eax
c0106e0d:	83 e8 04             	sub    $0x4,%eax
c0106e10:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0106e13:	83 ca 01             	or     $0x1,%edx
c0106e16:	89 10                	mov    %edx,(%eax)
        PUT(FTRP(bp), PACK(bp_allsize, 1));
c0106e18:	8b 45 08             	mov    0x8(%ebp),%eax
c0106e1b:	83 e8 04             	sub    $0x4,%eax
c0106e1e:	8b 00                	mov    (%eax),%eax
c0106e20:	83 e0 f8             	and    $0xfffffff8,%eax
c0106e23:	8d 50 f8             	lea    -0x8(%eax),%edx
c0106e26:	8b 45 08             	mov    0x8(%ebp),%eax
c0106e29:	01 d0                	add    %edx,%eax
c0106e2b:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0106e2e:	83 ca 01             	or     $0x1,%edx
c0106e31:	89 10                	mov    %edx,(%eax)
}
c0106e33:	90                   	nop
c0106e34:	c9                   	leave  
c0106e35:	c3                   	ret    

c0106e36 <mem_init>:

//following is head file function

void mem_init()
{
c0106e36:	55                   	push   %ebp
c0106e37:	89 e5                	mov    %esp,%ebp
c0106e39:	83 ec 18             	sub    $0x18,%esp
    mem_heap = &__heap_start;
c0106e3c:	c7 05 e4 b0 28 c0 00 	movl   $0xc0694000,0xc028b0e4
c0106e43:	40 69 c0 
    //mem_heap = (char*)Malloc(MAX_HEAP);
    mem_brk = mem_heap;
c0106e46:	a1 e4 b0 28 c0       	mov    0xc028b0e4,%eax
c0106e4b:	a3 e8 b0 28 c0       	mov    %eax,0xc028b0e8
    //mem_max_addr = (char*)(mem_heap + MAX_HEAP);
    mem_max_addr = (char*)K_STACK_START;
c0106e50:	c7 05 ec b0 28 c0 00 	movl   $0xffb00000,0xc028b0ec
c0106e57:	00 b0 ff 
    uint8_t* pgaddr = 0;
c0106e5a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    if((pgaddr = vmm_alloc_page(KERNEL_PID, mem_brk, NULL, PG_PREM_RW, PG_PREM_RW)) == NULL)
c0106e61:	a1 e8 b0 28 c0       	mov    0xc028b0e8,%eax
c0106e66:	83 ec 0c             	sub    $0xc,%esp
c0106e69:	6a 03                	push   $0x3
c0106e6b:	6a 03                	push   $0x3
c0106e6d:	6a 00                	push   $0x0
c0106e6f:	50                   	push   %eax
c0106e70:	6a ff                	push   $0xffffffff
c0106e72:	e8 14 0b 00 00       	call   c010798b <vmm_alloc_page>
c0106e77:	83 c4 20             	add    $0x20,%esp
c0106e7a:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0106e7d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0106e81:	74 1a                	je     c0106e9d <mem_init+0x67>
        return;
    kprintf("malloc init phy address is 0x%x\n", pgaddr);
c0106e83:	83 ec 08             	sub    $0x8,%esp
c0106e86:	ff 75 f4             	push   -0xc(%ebp)
c0106e89:	68 14 d2 28 c0       	push   $0xc028d214
c0106e8e:	e8 15 30 00 00       	call   c0109ea8 <kprintf>
c0106e93:	83 c4 10             	add    $0x10,%esp
    malloc_init();
c0106e96:	e8 bb 00 00 00       	call   c0106f56 <malloc_init>
c0106e9b:	eb 01                	jmp    c0106e9e <mem_init+0x68>
        return;
c0106e9d:	90                   	nop
}
c0106e9e:	c9                   	leave  
c0106e9f:	c3                   	ret    

c0106ea0 <mem_sbrk>:

void* mem_sbrk(int incr)
{
c0106ea0:	55                   	push   %ebp
c0106ea1:	89 e5                	mov    %esp,%ebp
c0106ea3:	83 ec 18             	sub    $0x18,%esp
    char* old = mem_brk;
c0106ea6:	a1 e8 b0 28 c0       	mov    0xc028b0e8,%eax
c0106eab:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if((incr < 0) || ((mem_brk + incr) > mem_max_addr))
c0106eae:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0106eb2:	78 14                	js     c0106ec8 <mem_sbrk+0x28>
c0106eb4:	8b 15 e8 b0 28 c0    	mov    0xc028b0e8,%edx
c0106eba:	8b 45 08             	mov    0x8(%ebp),%eax
c0106ebd:	01 c2                	add    %eax,%edx
c0106ebf:	a1 ec b0 28 c0       	mov    0xc028b0ec,%eax
c0106ec4:	39 c2                	cmp    %eax,%edx
c0106ec6:	76 0a                	jbe    c0106ed2 <mem_sbrk+0x32>
    {
        return (void*)-1;
c0106ec8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0106ecd:	e9 82 00 00 00       	jmp    c0106f54 <mem_sbrk+0xb4>
    }
    char* new = mem_brk + incr;
c0106ed2:	8b 15 e8 b0 28 c0    	mov    0xc028b0e8,%edx
c0106ed8:	8b 45 08             	mov    0x8(%ebp),%eax
c0106edb:	01 d0                	add    %edx,%eax
c0106edd:	89 45 f0             	mov    %eax,-0x10(%ebp)
    unsigned int diff = PG_ALIGN(new) - PG_ALIGN(old);
c0106ee0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0106ee3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0106ee8:	89 c2                	mov    %eax,%edx
c0106eea:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0106eed:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0106ef2:	89 c1                	mov    %eax,%ecx
c0106ef4:	89 d0                	mov    %edx,%eax
c0106ef6:	29 c8                	sub    %ecx,%eax
c0106ef8:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(diff)
c0106efb:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0106eff:	74 40                	je     c0106f41 <mem_sbrk+0xa1>
    {
        uint8_t* pgaddr = -1;
c0106f01:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,-0x18(%ebp)
        if(!(pgaddr = vmm_alloc_page(KERNEL_PID, new, NULL, PG_PREM_RW,PG_PREM_RW)))
c0106f08:	83 ec 0c             	sub    $0xc,%esp
c0106f0b:	6a 03                	push   $0x3
c0106f0d:	6a 03                	push   $0x3
c0106f0f:	6a 00                	push   $0x0
c0106f11:	ff 75 f0             	push   -0x10(%ebp)
c0106f14:	6a ff                	push   $0xffffffff
c0106f16:	e8 70 0a 00 00       	call   c010798b <vmm_alloc_page>
c0106f1b:	83 c4 20             	add    $0x20,%esp
c0106f1e:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0106f21:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0106f25:	75 07                	jne    c0106f2e <mem_sbrk+0x8e>
        {
            return NULL;
c0106f27:	b8 00 00 00 00       	mov    $0x0,%eax
c0106f2c:	eb 26                	jmp    c0106f54 <mem_sbrk+0xb4>
        }
        kprintf("head new page is 0x%x\n", pgaddr);
c0106f2e:	83 ec 08             	sub    $0x8,%esp
c0106f31:	ff 75 e8             	push   -0x18(%ebp)
c0106f34:	68 35 d2 28 c0       	push   $0xc028d235
c0106f39:	e8 6a 2f 00 00       	call   c0109ea8 <kprintf>
c0106f3e:	83 c4 10             	add    $0x10,%esp
    }
    mem_brk += incr;
c0106f41:	8b 15 e8 b0 28 c0    	mov    0xc028b0e8,%edx
c0106f47:	8b 45 08             	mov    0x8(%ebp),%eax
c0106f4a:	01 d0                	add    %edx,%eax
c0106f4c:	a3 e8 b0 28 c0       	mov    %eax,0xc028b0e8
    return (void*)old;
c0106f51:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0106f54:	c9                   	leave  
c0106f55:	c3                   	ret    

c0106f56 <malloc_init>:

int malloc_init()
{
c0106f56:	55                   	push   %ebp
c0106f57:	89 e5                	mov    %esp,%ebp
c0106f59:	83 ec 08             	sub    $0x8,%esp
    if((heap_listp = mem_sbrk(4 * WSIZE)) == (void*) - 1)
c0106f5c:	83 ec 0c             	sub    $0xc,%esp
c0106f5f:	6a 10                	push   $0x10
c0106f61:	e8 3a ff ff ff       	call   c0106ea0 <mem_sbrk>
c0106f66:	83 c4 10             	add    $0x10,%esp
c0106f69:	a3 e0 b0 28 c0       	mov    %eax,0xc028b0e0
c0106f6e:	a1 e0 b0 28 c0       	mov    0xc028b0e0,%eax
c0106f73:	83 f8 ff             	cmp    $0xffffffff,%eax
c0106f76:	75 07                	jne    c0106f7f <malloc_init+0x29>
        return -1;
c0106f78:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0106f7d:	eb 62                	jmp    c0106fe1 <malloc_init+0x8b>
    PUT(heap_listp, 0);
c0106f7f:	a1 e0 b0 28 c0       	mov    0xc028b0e0,%eax
c0106f84:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    PUT(heap_listp + (1*WSIZE), PACK(DSIZE, 1));
c0106f8a:	a1 e0 b0 28 c0       	mov    0xc028b0e0,%eax
c0106f8f:	83 c0 04             	add    $0x4,%eax
c0106f92:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
    PUT(heap_listp + (2*WSIZE), PACK(DSIZE, 1));
c0106f98:	a1 e0 b0 28 c0       	mov    0xc028b0e0,%eax
c0106f9d:	83 c0 08             	add    $0x8,%eax
c0106fa0:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
    PUT(heap_listp + (3*WSIZE), PACK(0, 1));
c0106fa6:	a1 e0 b0 28 c0       	mov    0xc028b0e0,%eax
c0106fab:	83 c0 0c             	add    $0xc,%eax
c0106fae:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    heap_listp += (2*WSIZE);
c0106fb4:	a1 e0 b0 28 c0       	mov    0xc028b0e0,%eax
c0106fb9:	83 c0 08             	add    $0x8,%eax
c0106fbc:	a3 e0 b0 28 c0       	mov    %eax,0xc028b0e0

    //extend free heap with free blk og CHUNKSIZE size
    //mem_sbrk((CHUNKSIZE - WSIZE));
    if(extend_heap((CHUNKSIZE - WSIZE)  / WSIZE) == NULL)
c0106fc1:	83 ec 0c             	sub    $0xc,%esp
c0106fc4:	68 ff 03 00 00       	push   $0x3ff
c0106fc9:	e8 33 fb ff ff       	call   c0106b01 <extend_heap>
c0106fce:	83 c4 10             	add    $0x10,%esp
c0106fd1:	85 c0                	test   %eax,%eax
c0106fd3:	75 07                	jne    c0106fdc <malloc_init+0x86>
        return -1;
c0106fd5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0106fda:	eb 05                	jmp    c0106fe1 <malloc_init+0x8b>
    return 0;
c0106fdc:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0106fe1:	c9                   	leave  
c0106fe2:	c3                   	ret    

c0106fe3 <malloc_free>:

void malloc_free(void* bp)
{
c0106fe3:	55                   	push   %ebp
c0106fe4:	89 e5                	mov    %esp,%ebp
c0106fe6:	83 ec 10             	sub    $0x10,%esp
    size_t size = GET_SIZE(HDRP(bp));
c0106fe9:	8b 45 08             	mov    0x8(%ebp),%eax
c0106fec:	83 e8 04             	sub    $0x4,%eax
c0106fef:	8b 00                	mov    (%eax),%eax
c0106ff1:	83 e0 f8             	and    $0xfffffff8,%eax
c0106ff4:	89 45 fc             	mov    %eax,-0x4(%ebp)

    PUT(HDRP(bp), PACK(size, 0));
c0106ff7:	8b 45 08             	mov    0x8(%ebp),%eax
c0106ffa:	8d 50 fc             	lea    -0x4(%eax),%edx
c0106ffd:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0107000:	89 02                	mov    %eax,(%edx)
    PUT(FTRP(bp), PACK(size, 0));
c0107002:	8b 45 08             	mov    0x8(%ebp),%eax
c0107005:	83 e8 04             	sub    $0x4,%eax
c0107008:	8b 00                	mov    (%eax),%eax
c010700a:	83 e0 f8             	and    $0xfffffff8,%eax
c010700d:	8d 50 f8             	lea    -0x8(%eax),%edx
c0107010:	8b 45 08             	mov    0x8(%ebp),%eax
c0107013:	01 c2                	add    %eax,%edx
c0107015:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0107018:	89 02                	mov    %eax,(%edx)
    coalesce(bp);
c010701a:	ff 75 08             	push   0x8(%ebp)
c010701d:	e8 69 fb ff ff       	call   c0106b8b <coalesce>
c0107022:	83 c4 04             	add    $0x4,%esp
}
c0107025:	90                   	nop
c0107026:	c9                   	leave  
c0107027:	c3                   	ret    

c0107028 <k_malloc>:

void* k_malloc(size_t size)
{
c0107028:	55                   	push   %ebp
c0107029:	89 e5                	mov    %esp,%ebp
c010702b:	83 ec 18             	sub    $0x18,%esp
    size_t asize;
    size_t extendsize;
    char* bp;

    if(size == 0)
c010702e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0107032:	75 0a                	jne    c010703e <k_malloc+0x16>
        return NULL;
c0107034:	b8 00 00 00 00       	mov    $0x0,%eax
c0107039:	e9 8a 00 00 00       	jmp    c01070c8 <k_malloc+0xa0>
    
    //THE MIN blk is 2*DSIZE, ONE DSIZE means head and foot, one is align
    if(size <= DSIZE)
c010703e:	83 7d 08 08          	cmpl   $0x8,0x8(%ebp)
c0107042:	77 09                	ja     c010704d <k_malloc+0x25>
        asize = 2 * DSIZE;
c0107044:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
c010704b:	eb 0e                	jmp    c010705b <k_malloc+0x33>
    else
        asize = DSIZE * ((size + DSIZE) + (DSIZE - 1)) / DSIZE; // Round up 
c010704d:	8b 45 08             	mov    0x8(%ebp),%eax
c0107050:	83 c0 0f             	add    $0xf,%eax
c0107053:	25 ff ff ff 1f       	and    $0x1fffffff,%eax
c0107058:	89 45 f4             	mov    %eax,-0xc(%ebp)
    //search the free list of fit
    if((bp = find_fit(asize)) != NULL)
c010705b:	ff 75 f4             	push   -0xc(%ebp)
c010705e:	e8 c6 fc ff ff       	call   c0106d29 <find_fit>
c0107063:	83 c4 04             	add    $0x4,%esp
c0107066:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0107069:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c010706d:	74 13                	je     c0107082 <k_malloc+0x5a>
    {
        place(bp, asize);
c010706f:	ff 75 f4             	push   -0xc(%ebp)
c0107072:	ff 75 f0             	push   -0x10(%ebp)
c0107075:	e8 12 fd ff ff       	call   c0106d8c <place>
c010707a:	83 c4 08             	add    $0x8,%esp
        return bp;
c010707d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107080:	eb 46                	jmp    c01070c8 <k_malloc+0xa0>
    }

    //no fit found try to extend head mem
    extendsize = MAX(asize, CHUNKSIZE);
c0107082:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107085:	ba 00 10 00 00       	mov    $0x1000,%edx
c010708a:	39 d0                	cmp    %edx,%eax
c010708c:	0f 42 c2             	cmovb  %edx,%eax
c010708f:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if((bp = extend_heap(extendsize / WSIZE)) == NULL)
c0107092:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0107095:	c1 e8 02             	shr    $0x2,%eax
c0107098:	83 ec 0c             	sub    $0xc,%esp
c010709b:	50                   	push   %eax
c010709c:	e8 60 fa ff ff       	call   c0106b01 <extend_heap>
c01070a1:	83 c4 10             	add    $0x10,%esp
c01070a4:	89 45 f0             	mov    %eax,-0x10(%ebp)
c01070a7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c01070ab:	75 07                	jne    c01070b4 <k_malloc+0x8c>
        return NULL;
c01070ad:	b8 00 00 00 00       	mov    $0x0,%eax
c01070b2:	eb 14                	jmp    c01070c8 <k_malloc+0xa0>
    place(bp, asize);
c01070b4:	83 ec 08             	sub    $0x8,%esp
c01070b7:	ff 75 f4             	push   -0xc(%ebp)
c01070ba:	ff 75 f0             	push   -0x10(%ebp)
c01070bd:	e8 ca fc ff ff       	call   c0106d8c <place>
c01070c2:	83 c4 10             	add    $0x10,%esp
    return bp;
c01070c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01070c8:	c9                   	leave  
c01070c9:	c3                   	ret    

c01070ca <cpu_rcr2>:
{
c01070ca:	55                   	push   %ebp
c01070cb:	89 e5                	mov    %esp,%ebp
c01070cd:	83 ec 10             	sub    $0x10,%esp
    asm volatile("movl %%cr2,%0" : "=r" (val));
c01070d0:	0f 20 d0             	mov    %cr2,%eax
c01070d3:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return val;
c01070d6:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c01070d9:	c9                   	leave  
c01070da:	c3                   	ret    

c01070db <cpu_invplg>:

reg32 cpu_r_cr3();


static inline void cpu_invplg(void* va)
{
c01070db:	55                   	push   %ebp
c01070dc:	89 e5                	mov    %esp,%ebp
    asm volatile("invlpg (%0)" ::"r"((unsigned int)va) : "memory");
c01070de:	8b 45 08             	mov    0x8(%ebp),%eax
c01070e1:	0f 01 38             	invlpg (%eax)
};
c01070e4:	90                   	nop
c01070e5:	5d                   	pop    %ebp
c01070e6:	c3                   	ret    

c01070e7 <do_page_fault>:
#include <kernel/memory/phy_mem.h>
#include <libs/mstdio.h>
#include <status.h>

void do_page_fault(unsigned long err_code, unsigned long address)
{
c01070e7:	55                   	push   %ebp
c01070e8:	89 e5                	mov    %esp,%ebp
c01070ea:	83 ec 28             	sub    $0x28,%esp
    uintptr_t ptr = cpu_rcr2();
c01070ed:	e8 d8 ff ff ff       	call   c01070ca <cpu_rcr2>
c01070f2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (!ptr) {
c01070f5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c01070f9:	0f 84 ea 00 00 00    	je     c01071e9 <do_page_fault+0x102>
        goto segv_term;
    }

    struct mm_region* hit_region = region_get(__current, ptr);
c01070ff:	a1 e0 bb 28 c0       	mov    0xc028bbe0,%eax
c0107104:	83 ec 08             	sub    $0x8,%esp
c0107107:	ff 75 f4             	push   -0xc(%ebp)
c010710a:	50                   	push   %eax
c010710b:	e8 88 02 00 00       	call   c0107398 <region_get>
c0107110:	83 c4 10             	add    $0x10,%esp
c0107113:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if (!hit_region) {
c0107116:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c010711a:	0f 84 cc 00 00 00    	je     c01071ec <do_page_fault+0x105>
        // Into the void...
        goto segv_term;
    }

    ptd_t* pte = PTE_MOUNTED(PD_REFERENCED, ptr >> 12);
c0107120:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107123:	c1 e8 0c             	shr    $0xc,%eax
c0107126:	25 ff 03 00 00       	and    $0x3ff,%eax
c010712b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0107132:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107135:	c1 e8 0c             	shr    $0xc,%eax
c0107138:	c1 e0 02             	shl    $0x2,%eax
c010713b:	25 00 f0 3f 00       	and    $0x3ff000,%eax
c0107140:	0d 00 00 c0 ff       	or     $0xffc00000,%eax
c0107145:	01 d0                	add    %edx,%eax
c0107147:	8b 00                	mov    (%eax),%eax
c0107149:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (*pte & PG_PRESENT) {
c010714c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010714f:	8b 00                	mov    (%eax),%eax
c0107151:	83 e0 01             	and    $0x1,%eax
c0107154:	85 c0                	test   %eax,%eax
c0107156:	0f 85 93 00 00 00    	jne    c01071ef <do_page_fault+0x108>
        }
        // impossible cases or accessing privileged page
        goto segv_term;
    }

    if (!(*pte)) {
c010715c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010715f:	8b 00                	mov    (%eax),%eax
c0107161:	85 c0                	test   %eax,%eax
c0107163:	0f 84 89 00 00 00    	je     c01071f2 <do_page_fault+0x10b>
        // Invalid location
        goto segv_term;
    }
    uintptr_t loc = *pte & ~0xfff;
c0107169:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010716c:	8b 00                	mov    (%eax),%eax
c010716e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0107173:	89 45 e8             	mov    %eax,-0x18(%ebp)
    // a writable page, not present, pte attr is not null
    //   and no indication of cached page -> a new page need to be alloc
    if ((hit_region->attr & REGION_WRITE) && (*pte & 0xfff) && !loc) {
c0107176:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107179:	8b 40 10             	mov    0x10(%eax),%eax
c010717c:	83 e0 08             	and    $0x8,%eax
c010717f:	85 c0                	test   %eax,%eax
c0107181:	74 4e                	je     c01071d1 <do_page_fault+0xea>
c0107183:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0107186:	8b 00                	mov    (%eax),%eax
c0107188:	25 ff 0f 00 00       	and    $0xfff,%eax
c010718d:	85 c0                	test   %eax,%eax
c010718f:	74 40                	je     c01071d1 <do_page_fault+0xea>
c0107191:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0107195:	75 3a                	jne    c01071d1 <do_page_fault+0xea>
        cpu_invplg(pte);
c0107197:	83 ec 0c             	sub    $0xc,%esp
c010719a:	ff 75 ec             	push   -0x14(%ebp)
c010719d:	e8 39 ff ff ff       	call   c01070db <cpu_invplg>
c01071a2:	83 c4 10             	add    $0x10,%esp
        uintptr_t pa = pmm_alloc_page(__current->pid, 0);
c01071a5:	a1 e0 bb 28 c0       	mov    0xc028bbe0,%eax
c01071aa:	8b 00                	mov    (%eax),%eax
c01071ac:	83 ec 08             	sub    $0x8,%esp
c01071af:	6a 00                	push   $0x0
c01071b1:	50                   	push   %eax
c01071b2:	e8 29 f7 ff ff       	call   c01068e0 <pmm_alloc_page>
c01071b7:	83 c4 10             	add    $0x10,%esp
c01071ba:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        *pte = *pte | pa | PG_PRESENT;
c01071bd:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01071c0:	8b 00                	mov    (%eax),%eax
c01071c2:	0b 45 e4             	or     -0x1c(%ebp),%eax
c01071c5:	83 c8 01             	or     $0x1,%eax
c01071c8:	89 c2                	mov    %eax,%edx
c01071ca:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01071cd:	89 10                	mov    %edx,(%eax)
        return;
c01071cf:	eb 4a                	jmp    c010721b <do_page_fault+0x134>
    }
    // page not present, bring it from disk or somewhere else
    kprintf("WIP page fault route,errcode = 0x%x,wrong address = 0x%x, pageaddress is 0x%x",err_code, address, ptr);
c01071d1:	ff 75 f4             	push   -0xc(%ebp)
c01071d4:	ff 75 0c             	push   0xc(%ebp)
c01071d7:	ff 75 08             	push   0x8(%ebp)
c01071da:	68 4c d2 28 c0       	push   $0xc028d24c
c01071df:	e8 c4 2c 00 00       	call   c0109ea8 <kprintf>
c01071e4:	83 c4 10             	add    $0x10,%esp
    while (1)
c01071e7:	eb fe                	jmp    c01071e7 <do_page_fault+0x100>
        goto segv_term;
c01071e9:	90                   	nop
c01071ea:	eb 07                	jmp    c01071f3 <do_page_fault+0x10c>
        goto segv_term;
c01071ec:	90                   	nop
c01071ed:	eb 04                	jmp    c01071f3 <do_page_fault+0x10c>
        goto segv_term;
c01071ef:	90                   	nop
c01071f0:	eb 01                	jmp    c01071f3 <do_page_fault+0x10c>
        goto segv_term;
c01071f2:	90                   	nop
        ;

segv_term:
    kprintf("[KERROR] (pid: %d) Segmentation fault on %x (%x)\n",
            __current->pid,
c01071f3:	a1 e0 bb 28 c0       	mov    0xc028bbe0,%eax
c01071f8:	8b 00                	mov    (%eax),%eax
    kprintf("[KERROR] (pid: %d) Segmentation fault on %x (%x)\n",
c01071fa:	ff 75 0c             	push   0xc(%ebp)
c01071fd:	ff 75 f4             	push   -0xc(%ebp)
c0107200:	50                   	push   %eax
c0107201:	68 9c d2 28 c0       	push   $0xc028d29c
c0107206:	e8 9d 2c 00 00       	call   c0109ea8 <kprintf>
c010720b:	83 c4 10             	add    $0x10,%esp
            ptr,
            address);
    terminate_proc(MXSEGFAULT);
c010720e:	83 ec 0c             	sub    $0xc,%esp
c0107211:	6a fb                	push   $0xfffffffb
c0107213:	e8 77 2a 00 00       	call   c0109c8f <terminate_proc>
c0107218:	83 c4 10             	add    $0x10,%esp
    // should not reach
c010721b:	c9                   	leave  
c010721c:	c3                   	ret    

c010721d <page_fault>:
c010721d:	87 04 24             	xchg   %eax,(%esp)
c0107220:	51                   	push   %ecx
c0107221:	52                   	push   %edx
c0107222:	1e                   	push   %ds
c0107223:	06                   	push   %es
c0107224:	0f a0                	push   %fs
c0107226:	ba 10 00 00 00       	mov    $0x10,%edx
c010722b:	8e da                	mov    %edx,%ds
c010722d:	8e c2                	mov    %edx,%es
c010722f:	8e e2                	mov    %edx,%fs
c0107231:	8d 54 24 18          	lea    0x18(%esp),%edx
c0107235:	52                   	push   %edx
c0107236:	50                   	push   %eax
c0107237:	e8 ab fe ff ff       	call   c01070e7 <do_page_fault>
c010723c:	0f a1                	pop    %fs
c010723e:	07                   	pop    %es
c010723f:	1f                   	pop    %ds
c0107240:	5a                   	pop    %edx
c0107241:	59                   	pop    %ecx
c0107242:	58                   	pop    %eax
c0107243:	cf                   	iret   

c0107244 <__llist_add>:
};

static inline void __llist_add(struct llist_header* elem,
            struct llist_header* prev,
            struct llist_header* next)
{
c0107244:	55                   	push   %ebp
c0107245:	89 e5                	mov    %esp,%ebp
    next->prev = elem;
c0107247:	8b 45 10             	mov    0x10(%ebp),%eax
c010724a:	8b 55 08             	mov    0x8(%ebp),%edx
c010724d:	89 10                	mov    %edx,(%eax)
    elem->next = next;
c010724f:	8b 45 08             	mov    0x8(%ebp),%eax
c0107252:	8b 55 10             	mov    0x10(%ebp),%edx
c0107255:	89 50 04             	mov    %edx,0x4(%eax)
    elem->prev = prev;
c0107258:	8b 45 08             	mov    0x8(%ebp),%eax
c010725b:	8b 55 0c             	mov    0xc(%ebp),%edx
c010725e:	89 10                	mov    %edx,(%eax)
    prev->next = elem;
c0107260:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107263:	8b 55 08             	mov    0x8(%ebp),%edx
c0107266:	89 50 04             	mov    %edx,0x4(%eax)
}
c0107269:	90                   	nop
c010726a:	5d                   	pop    %ebp
c010726b:	c3                   	ret    

c010726c <llist_init_head>:

static inline void llist_init_head(struct llist_header* head) {
c010726c:	55                   	push   %ebp
c010726d:	89 e5                	mov    %esp,%ebp
    head->next = head;
c010726f:	8b 45 08             	mov    0x8(%ebp),%eax
c0107272:	8b 55 08             	mov    0x8(%ebp),%edx
c0107275:	89 50 04             	mov    %edx,0x4(%eax)
    head->prev = head;
c0107278:	8b 45 08             	mov    0x8(%ebp),%eax
c010727b:	8b 55 08             	mov    0x8(%ebp),%edx
c010727e:	89 10                	mov    %edx,(%eax)
}
c0107280:	90                   	nop
c0107281:	5d                   	pop    %ebp
c0107282:	c3                   	ret    

c0107283 <llist_append>:

static inline void llist_append(struct llist_header* head, struct llist_header* elem)
{
c0107283:	55                   	push   %ebp
c0107284:	89 e5                	mov    %esp,%ebp
    __llist_add(elem, head, head->next);
c0107286:	8b 45 08             	mov    0x8(%ebp),%eax
c0107289:	8b 40 04             	mov    0x4(%eax),%eax
c010728c:	50                   	push   %eax
c010728d:	ff 75 08             	push   0x8(%ebp)
c0107290:	ff 75 0c             	push   0xc(%ebp)
c0107293:	e8 ac ff ff ff       	call   c0107244 <__llist_add>
c0107298:	83 c4 0c             	add    $0xc,%esp
}
c010729b:	90                   	nop
c010729c:	c9                   	leave  
c010729d:	c3                   	ret    

c010729e <region_add>:
#include <kernel/memory/region.h>
#include <kernel/memory/malloc.h>
#include <libs/list.h>
void region_add(struct m_pcb* proc,unsigned long start, unsigned long end, unsigned int attr) {
c010729e:	55                   	push   %ebp
c010729f:	89 e5                	mov    %esp,%ebp
c01072a1:	83 ec 28             	sub    $0x28,%esp
    struct mm_region* region = k_malloc(sizeof(struct mm_region));
c01072a4:	83 ec 0c             	sub    $0xc,%esp
c01072a7:	6a 14                	push   $0x14
c01072a9:	e8 7a fd ff ff       	call   c0107028 <k_malloc>
c01072ae:	83 c4 10             	add    $0x10,%esp
c01072b1:	89 45 f4             	mov    %eax,-0xc(%ebp)

    *region = (struct mm_region) {
c01072b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01072b7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c01072bd:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
c01072c4:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
c01072cb:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
c01072d2:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
c01072d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01072dc:	8b 55 0c             	mov    0xc(%ebp),%edx
c01072df:	89 50 08             	mov    %edx,0x8(%eax)
c01072e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01072e5:	8b 55 10             	mov    0x10(%ebp),%edx
c01072e8:	89 50 0c             	mov    %edx,0xc(%eax)
c01072eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01072ee:	8b 55 14             	mov    0x14(%ebp),%edx
c01072f1:	89 50 10             	mov    %edx,0x10(%eax)
        .attr = attr,
        .end = end,
        .start = start
    };
    if (!proc->process_mm) {
c01072f4:	8b 45 08             	mov    0x8(%ebp),%eax
c01072f7:	8b 40 58             	mov    0x58(%eax),%eax
c01072fa:	85 c0                	test   %eax,%eax
c01072fc:	75 1a                	jne    c0107318 <region_add+0x7a>
        llist_init_head(&region->head);
c01072fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107301:	83 ec 0c             	sub    $0xc,%esp
c0107304:	50                   	push   %eax
c0107305:	e8 62 ff ff ff       	call   c010726c <llist_init_head>
c010730a:	83 c4 10             	add    $0x10,%esp
        proc->process_mm = region;
c010730d:	8b 45 08             	mov    0x8(%ebp),%eax
c0107310:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0107313:	89 50 58             	mov    %edx,0x58(%eax)
    }
    else {
        llist_append(&proc->process_mm->head, &region->head);
    }
}
c0107316:	eb 16                	jmp    c010732e <region_add+0x90>
        llist_append(&proc->process_mm->head, &region->head);
c0107318:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010731b:	8b 55 08             	mov    0x8(%ebp),%edx
c010731e:	8b 52 58             	mov    0x58(%edx),%edx
c0107321:	83 ec 08             	sub    $0x8,%esp
c0107324:	50                   	push   %eax
c0107325:	52                   	push   %edx
c0107326:	e8 58 ff ff ff       	call   c0107283 <llist_append>
c010732b:	83 c4 10             	add    $0x10,%esp
}
c010732e:	90                   	nop
c010732f:	c9                   	leave  
c0107330:	c3                   	ret    

c0107331 <region_release_all>:

void region_release_all(struct m_pcb* proc) {
c0107331:	55                   	push   %ebp
c0107332:	89 e5                	mov    %esp,%ebp
c0107334:	83 ec 28             	sub    $0x28,%esp
    struct mm_region* head = proc->process_mm;
c0107337:	8b 45 08             	mov    0x8(%ebp),%eax
c010733a:	8b 40 58             	mov    0x58(%eax),%eax
c010733d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    struct mm_region *pos, *n;

    llist_for_each(pos, n, &head->head, head) {
c0107340:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0107343:	8b 40 04             	mov    0x4(%eax),%eax
c0107346:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0107349:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010734c:	89 45 f4             	mov    %eax,-0xc(%ebp)
c010734f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107352:	8b 40 04             	mov    0x4(%eax),%eax
c0107355:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c0107358:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010735b:	89 45 f0             	mov    %eax,-0x10(%ebp)
c010735e:	eb 23                	jmp    c0107383 <region_release_all+0x52>
        malloc_free(pos);
c0107360:	83 ec 0c             	sub    $0xc,%esp
c0107363:	ff 75 f4             	push   -0xc(%ebp)
c0107366:	e8 78 fc ff ff       	call   c0106fe3 <malloc_free>
c010736b:	83 c4 10             	add    $0x10,%esp
    llist_for_each(pos, n, &head->head, head) {
c010736e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107371:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0107374:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107377:	8b 40 04             	mov    0x4(%eax),%eax
c010737a:	89 45 e0             	mov    %eax,-0x20(%ebp)
c010737d:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0107380:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0107383:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107386:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0107389:	75 d5                	jne    c0107360 <region_release_all+0x2f>
    }

    proc->process_mm = NULL;
c010738b:	8b 45 08             	mov    0x8(%ebp),%eax
c010738e:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
}
c0107395:	90                   	nop
c0107396:	c9                   	leave  
c0107397:	c3                   	ret    

c0107398 <region_get>:

struct mm_region* region_get(struct m_pcb* proc, unsigned long vaddr) {
c0107398:	55                   	push   %ebp
c0107399:	89 e5                	mov    %esp,%ebp
c010739b:	83 ec 20             	sub    $0x20,%esp
    struct mm_region* head = proc->process_mm;
c010739e:	8b 45 08             	mov    0x8(%ebp),%eax
c01073a1:	8b 40 58             	mov    0x58(%eax),%eax
c01073a4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    
    if (!head) {
c01073a7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c01073ab:	75 07                	jne    c01073b4 <region_get+0x1c>
        return NULL;
c01073ad:	b8 00 00 00 00       	mov    $0x0,%eax
c01073b2:	eb 5d                	jmp    c0107411 <region_get+0x79>
    }

    struct mm_region *pos, *n;

    llist_for_each(pos, n, &head->head, head) {
c01073b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01073b7:	8b 40 04             	mov    0x4(%eax),%eax
c01073ba:	89 45 f0             	mov    %eax,-0x10(%ebp)
c01073bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01073c0:	89 45 fc             	mov    %eax,-0x4(%ebp)
c01073c3:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01073c6:	8b 40 04             	mov    0x4(%eax),%eax
c01073c9:	89 45 ec             	mov    %eax,-0x14(%ebp)
c01073cc:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01073cf:	89 45 f8             	mov    %eax,-0x8(%ebp)
c01073d2:	eb 30                	jmp    c0107404 <region_get+0x6c>
        if (vaddr >= pos->start && vaddr < pos->end) {
c01073d4:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01073d7:	8b 40 08             	mov    0x8(%eax),%eax
c01073da:	39 45 0c             	cmp    %eax,0xc(%ebp)
c01073dd:	72 10                	jb     c01073ef <region_get+0x57>
c01073df:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01073e2:	8b 40 0c             	mov    0xc(%eax),%eax
c01073e5:	39 45 0c             	cmp    %eax,0xc(%ebp)
c01073e8:	73 05                	jae    c01073ef <region_get+0x57>
            return pos;
c01073ea:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01073ed:	eb 22                	jmp    c0107411 <region_get+0x79>
    llist_for_each(pos, n, &head->head, head) {
c01073ef:	8b 45 f8             	mov    -0x8(%ebp),%eax
c01073f2:	89 45 fc             	mov    %eax,-0x4(%ebp)
c01073f5:	8b 45 f8             	mov    -0x8(%ebp),%eax
c01073f8:	8b 40 04             	mov    0x4(%eax),%eax
c01073fb:	89 45 e8             	mov    %eax,-0x18(%ebp)
c01073fe:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0107401:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0107404:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0107407:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c010740a:	75 c8                	jne    c01073d4 <region_get+0x3c>
        }
    }
    return NULL;
c010740c:	b8 00 00 00 00       	mov    $0x0,%eax
c0107411:	c9                   	leave  
c0107412:	c3                   	ret    

c0107413 <cpu_invplg>:
{
c0107413:	55                   	push   %ebp
c0107414:	89 e5                	mov    %esp,%ebp
    asm volatile("invlpg (%0)" ::"r"((unsigned int)va) : "memory");
c0107416:	8b 45 08             	mov    0x8(%ebp),%eax
c0107419:	0f 01 38             	invlpg (%eax)
};
c010741c:	90                   	nop
c010741d:	5d                   	pop    %ebp
c010741e:	c3                   	ret    

c010741f <vmm_init>:
#include <kernel/memory/vir_mem.h>
#include <libs/mstring.h>

void vmm_init() {
c010741f:	55                   	push   %ebp
c0107420:	89 e5                	mov    %esp,%ebp
    // TODO: something here?
}
c0107422:	90                   	nop
c0107423:	5d                   	pop    %ebp
c0107424:	c3                   	ret    

c0107425 <get_pd>:

// TODO: Move these nasty inline asm stuff into hal
//      These should be arch dependent
ptd_t* get_pd() {
c0107425:	55                   	push   %ebp
c0107426:	89 e5                	mov    %esp,%ebp
c0107428:	83 ec 10             	sub    $0x10,%esp
    ptd_t* pd;
    #ifdef __ARCH_IA32
    __asm__(
c010742b:	0f 20 d8             	mov    %cr3,%eax
c010742e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0107433:	89 45 fc             	mov    %eax,-0x4(%ebp)
        "movl %%cr3, %0\n"
        "andl $0xfffff000, %0"
        : "=r"(pd)
    );
    #endif
    return P2V(pd);
c0107436:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0107439:	2d 00 00 00 40       	sub    $0x40000000,%eax
}
c010743e:	c9                   	leave  
c010743f:	c3                   	ret    

c0107440 <set_pd>:

void set_pd(ptd_t* pd) {
c0107440:	55                   	push   %ebp
c0107441:	89 e5                	mov    %esp,%ebp
    #ifdef __ARCH_IA32
    __asm__(
c0107443:	8b 45 08             	mov    0x8(%ebp),%eax
c0107446:	89 c0                	mov    %eax,%eax
c0107448:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010744d:	0f 22 d8             	mov    %eax,%cr3
        "movl %%eax, %%cr3\n"
        :
        : "r" (pd)
    );
    #endif
}
c0107450:	90                   	nop
c0107451:	5d                   	pop    %ebp
c0107452:	c3                   	ret    

c0107453 <vmm_init_pd>:

ptd_t* vmm_init_pd() {
c0107453:	55                   	push   %ebp
c0107454:	89 e5                	mov    %esp,%ebp
c0107456:	83 ec 18             	sub    $0x18,%esp
    ptd_t* dir = pmm_alloc_page(KERNEL_PID, PP_FGPERSIST);
c0107459:	83 ec 08             	sub    $0x8,%esp
c010745c:	6a 01                	push   $0x1
c010745e:	6a ff                	push   $0xffffffff
c0107460:	e8 7b f4 ff ff       	call   c01068e0 <pmm_alloc_page>
c0107465:	83 c4 10             	add    $0x10,%esp
c0107468:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for (size_t i = 0; i < 1024; i++)
c010746b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0107472:	eb 19                	jmp    c010748d <vmm_init_pd+0x3a>
    {
        dir[i] = 0;
c0107474:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107477:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010747e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107481:	01 d0                	add    %edx,%eax
c0107483:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    for (size_t i = 0; i < 1024; i++)
c0107489:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010748d:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
c0107494:	76 de                	jbe    c0107474 <vmm_init_pd+0x21>
    }
    
    // 自己映射自己，方便我们在软件层面进行查表地址转换
    dir[1023] = PDE(T_SELF_REF_PERM, dir);
c0107496:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107499:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010749e:	89 c2                	mov    %eax,%edx
c01074a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01074a3:	05 fc 0f 00 00       	add    $0xffc,%eax
c01074a8:	83 ca 1b             	or     $0x1b,%edx
c01074ab:	89 10                	mov    %edx,(%eax)

    return dir;
c01074ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c01074b0:	c9                   	leave  
c01074b1:	c3                   	ret    

c01074b2 <__vmm_map_alloc>:
                   uint32_t l1_inx,
                   uint32_t l2_inx,
                   uintptr_t pa,
                   pt_attr attr,
                   int forced)
{
c01074b2:	55                   	push   %ebp
c01074b3:	89 e5                	mov    %esp,%ebp
c01074b5:	53                   	push   %ebx
c01074b6:	83 ec 14             	sub    $0x14,%esp
    ptd_t* ptd = (ptd_t*)PTD_BASE_VADDR;
c01074b9:	c7 45 f4 00 f0 ff ff 	movl   $0xfffff000,-0xc(%ebp)
    pt_t* pt = (uintptr_t)PT_VADDR(l1_inx);
c01074c0:	8b 45 0c             	mov    0xc(%ebp),%eax
c01074c3:	c1 e0 0c             	shl    $0xc,%eax
c01074c6:	0d 00 00 c0 ff       	or     $0xffc00000,%eax
c01074cb:	89 45 f0             	mov    %eax,-0x10(%ebp)


    // See if attr make sense
    assert(attr <= 128);
c01074ce:	81 7d 18 80 00 00 00 	cmpl   $0x80,0x18(%ebp)
c01074d5:	76 1a                	jbe    c01074f1 <__vmm_map_alloc+0x3f>
c01074d7:	83 ec 04             	sub    $0x4,%esp
c01074da:	68 9e 00 00 00       	push   $0x9e
c01074df:	68 ce d2 28 c0       	push   $0xc028d2ce
c01074e4:	68 e7 d2 28 c0       	push   $0xc028d2e7
c01074e9:	e8 43 1e 00 00       	call   c0109331 <__assert_fail>
c01074ee:	83 c4 10             	add    $0x10,%esp

    if (!ptd[l1_inx]) {
c01074f1:	8b 45 0c             	mov    0xc(%ebp),%eax
c01074f4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c01074fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01074fe:	01 d0                	add    %edx,%eax
c0107500:	8b 00                	mov    (%eax),%eax
c0107502:	85 c0                	test   %eax,%eax
c0107504:	75 6b                	jne    c0107571 <__vmm_map_alloc+0xbf>
        uint8_t* new_pt_pa = pmm_alloc_page(pid, PP_FGPERSIST);
c0107506:	83 ec 08             	sub    $0x8,%esp
c0107509:	6a 01                	push   $0x1
c010750b:	ff 75 08             	push   0x8(%ebp)
c010750e:	e8 cd f3 ff ff       	call   c01068e0 <pmm_alloc_page>
c0107513:	83 c4 10             	add    $0x10,%esp
c0107516:	89 45 ec             	mov    %eax,-0x14(%ebp)

        // 物理内存已满！
        if (!new_pt_pa) {
c0107519:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c010751d:	75 0a                	jne    c0107529 <__vmm_map_alloc+0x77>
            return 0;
c010751f:	b8 00 00 00 00       	mov    $0x0,%eax
c0107524:	e9 b2 00 00 00       	jmp    c01075db <__vmm_map_alloc+0x129>
        }

        // This must be writable
        ptd[l1_inx] = PDE(attr | PG_WRITE, new_pt_pa);
c0107529:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010752c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0107531:	89 c1                	mov    %eax,%ecx
c0107533:	8b 45 18             	mov    0x18(%ebp),%eax
c0107536:	83 c8 0a             	or     $0xa,%eax
c0107539:	25 ff 0f 00 00       	and    $0xfff,%eax
c010753e:	89 c2                	mov    %eax,%edx
c0107540:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107543:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
c010754a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010754d:	01 d8                	add    %ebx,%eax
c010754f:	09 ca                	or     %ecx,%edx
c0107551:	89 10                	mov    %edx,(%eax)
        memset((void*)PT_VADDR(l1_inx), 0, PM_PAGE_SIZE);
c0107553:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107556:	c1 e0 0c             	shl    $0xc,%eax
c0107559:	0d 00 00 c0 ff       	or     $0xffc00000,%eax
c010755e:	83 ec 04             	sub    $0x4,%esp
c0107561:	68 00 10 00 00       	push   $0x1000
c0107566:	6a 00                	push   $0x0
c0107568:	50                   	push   %eax
c0107569:	e8 d1 2b 00 00       	call   c010a13f <memset>
c010756e:	83 c4 10             	add    $0x10,%esp
    }

    if (pt[l2_inx]) {
c0107571:	8b 45 10             	mov    0x10(%ebp),%eax
c0107574:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010757b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010757e:	01 d0                	add    %edx,%eax
c0107580:	8b 00                	mov    (%eax),%eax
c0107582:	85 c0                	test   %eax,%eax
c0107584:	74 0d                	je     c0107593 <__vmm_map_alloc+0xe1>
        if (!forced) {
c0107586:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
c010758a:	75 07                	jne    c0107593 <__vmm_map_alloc+0xe1>
            return 0;
c010758c:	b8 00 00 00 00       	mov    $0x0,%eax
c0107591:	eb 48                	jmp    c01075db <__vmm_map_alloc+0x129>
        }
    }

    if ((HAS_FLAGS(attr, PG_PRESENT))) {
c0107593:	8b 45 18             	mov    0x18(%ebp),%eax
c0107596:	83 e0 01             	and    $0x1,%eax
c0107599:	85 c0                	test   %eax,%eax
c010759b:	74 12                	je     c01075af <__vmm_map_alloc+0xfd>
        // add one on reference count, regardless of existence.
        pmm_ref_page(pid, pa);
c010759d:	8b 45 14             	mov    0x14(%ebp),%eax
c01075a0:	83 ec 08             	sub    $0x8,%esp
c01075a3:	50                   	push   %eax
c01075a4:	ff 75 08             	push   0x8(%ebp)
c01075a7:	e8 fb f4 ff ff       	call   c0106aa7 <pmm_ref_page>
c01075ac:	83 c4 10             	add    $0x10,%esp
    }

    pt[l2_inx] = PTE(attr, pa);
c01075af:	8b 45 14             	mov    0x14(%ebp),%eax
c01075b2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c01075b7:	89 c1                	mov    %eax,%ecx
c01075b9:	8b 45 18             	mov    0x18(%ebp),%eax
c01075bc:	25 ff 0f 00 00       	and    $0xfff,%eax
c01075c1:	89 c2                	mov    %eax,%edx
c01075c3:	8b 45 10             	mov    0x10(%ebp),%eax
c01075c6:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
c01075cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01075d0:	01 d8                	add    %ebx,%eax
c01075d2:	09 ca                	or     %ecx,%edx
c01075d4:	89 10                	mov    %edx,(%eax)

    return 1;
c01075d6:	b8 01 00 00 00       	mov    $0x1,%eax
}
c01075db:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c01075de:	c9                   	leave  
c01075df:	c3                   	ret    

c01075e0 <vmm_map_page>:

void* vmm_map_page(pid_t pid, void* va, void* pa, pt_attr dattr, pt_attr tattr) {
c01075e0:	55                   	push   %ebp
c01075e1:	89 e5                	mov    %esp,%ebp
c01075e3:	53                   	push   %ebx
c01075e4:	83 ec 24             	sub    $0x24,%esp
    // 显然，对空指针进行映射没有意义。
    if (!pa || !va) {
c01075e7:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c01075eb:	74 06                	je     c01075f3 <vmm_map_page+0x13>
c01075ed:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c01075f1:	75 0a                	jne    c01075fd <vmm_map_page+0x1d>
        return NULL;
c01075f3:	b8 00 00 00 00       	mov    $0x0,%eax
c01075f8:	e9 d7 01 00 00       	jmp    c01077d4 <vmm_map_page+0x1f4>
    }

    uintptr_t pd_offset = PD_INDEX(va);
c01075fd:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107600:	c1 e8 16             	shr    $0x16,%eax
c0107603:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uintptr_t pt_offset = PT_INDEX(va);
c0107606:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107609:	c1 e8 0c             	shr    $0xc,%eax
c010760c:	25 ff 03 00 00       	and    $0x3ff,%eax
c0107611:	89 45 f0             	mov    %eax,-0x10(%ebp)
    ptd_t* ptd = (ptd_t*)PTD_BASE_VADDR;
c0107614:	c7 45 e4 00 f0 ff ff 	movl   $0xfffff000,-0x1c(%ebp)

    // 在页表与页目录中找到一个可用的空位进行映射（位于va或其附近）
    ptd_t* pde = ptd[pd_offset];
c010761b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010761e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0107625:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0107628:	01 d0                	add    %edx,%eax
c010762a:	8b 00                	mov    (%eax),%eax
c010762c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    pt_t* pt = (uintptr_t)PT_VADDR(pd_offset);
c010762f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107632:	c1 e0 0c             	shl    $0xc,%eax
c0107635:	0d 00 00 c0 ff       	or     $0xffc00000,%eax
c010763a:	89 45 e8             	mov    %eax,-0x18(%ebp)
    while (pde && pd_offset < 1024) {
c010763d:	e9 9b 00 00 00       	jmp    c01076dd <vmm_map_page+0xfd>
        if (pt_offset == 1024) {
c0107642:	81 7d f0 00 04 00 00 	cmpl   $0x400,-0x10(%ebp)
c0107649:	75 2d                	jne    c0107678 <vmm_map_page+0x98>
            pd_offset++;
c010764b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
            pt_offset = 0;
c010764f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            pde = ptd[pd_offset];
c0107656:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107659:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0107660:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0107663:	01 d0                	add    %edx,%eax
c0107665:	8b 00                	mov    (%eax),%eax
c0107667:	89 45 ec             	mov    %eax,-0x14(%ebp)
            pt = (pt_t*)PT_VADDR(pd_offset);
c010766a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010766d:	c1 e0 0c             	shl    $0xc,%eax
c0107670:	0d 00 00 c0 ff       	or     $0xffc00000,%eax
c0107675:	89 45 e8             	mov    %eax,-0x18(%ebp)
        }
        // 页表有空位，只需要开辟一个新的 PTE
        if (pt && !pt[pt_offset]) {
c0107678:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c010767c:	74 5b                	je     c01076d9 <vmm_map_page+0xf9>
c010767e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107681:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0107688:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010768b:	01 d0                	add    %edx,%eax
c010768d:	8b 00                	mov    (%eax),%eax
c010768f:	85 c0                	test   %eax,%eax
c0107691:	75 46                	jne    c01076d9 <vmm_map_page+0xf9>
            pt[pt_offset] = PTE(tattr, pa);
c0107693:	8b 45 10             	mov    0x10(%ebp),%eax
c0107696:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010769b:	89 c1                	mov    %eax,%ecx
c010769d:	8b 45 18             	mov    0x18(%ebp),%eax
c01076a0:	25 ff 0f 00 00       	and    $0xfff,%eax
c01076a5:	89 c2                	mov    %eax,%edx
c01076a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01076aa:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
c01076b1:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01076b4:	01 d8                	add    %ebx,%eax
c01076b6:	09 ca                	or     %ecx,%edx
c01076b8:	89 10                	mov    %edx,(%eax)
            return V_ADDR(pd_offset, pt_offset, PG_OFFSET(va));
c01076ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01076bd:	c1 e0 16             	shl    $0x16,%eax
c01076c0:	89 c2                	mov    %eax,%edx
c01076c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01076c5:	c1 e0 0c             	shl    $0xc,%eax
c01076c8:	09 c2                	or     %eax,%edx
c01076ca:	8b 45 0c             	mov    0xc(%ebp),%eax
c01076cd:	25 ff 0f 00 00       	and    $0xfff,%eax
c01076d2:	09 d0                	or     %edx,%eax
c01076d4:	e9 fb 00 00 00       	jmp    c01077d4 <vmm_map_page+0x1f4>
        }
        pt_offset++;
c01076d9:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    while (pde && pd_offset < 1024) {
c01076dd:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c01076e1:	74 0d                	je     c01076f0 <vmm_map_page+0x110>
c01076e3:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
c01076ea:	0f 86 52 ff ff ff    	jbe    c0107642 <vmm_map_page+0x62>
    }
    
    // 页目录与所有页表已满！
    if (pd_offset > 1024) {
c01076f0:	81 7d f4 00 04 00 00 	cmpl   $0x400,-0xc(%ebp)
c01076f7:	76 0a                	jbe    c0107703 <vmm_map_page+0x123>
        return NULL;
c01076f9:	b8 00 00 00 00       	mov    $0x0,%eax
c01076fe:	e9 d1 00 00 00       	jmp    c01077d4 <vmm_map_page+0x1f4>
    }

    // 页目录有空位，需要开辟一个新的 PDE
    uint8_t* new_pt_pa = pmm_alloc_page(pid, PP_FGPERSIST);
c0107703:	83 ec 08             	sub    $0x8,%esp
c0107706:	6a 01                	push   $0x1
c0107708:	ff 75 08             	push   0x8(%ebp)
c010770b:	e8 d0 f1 ff ff       	call   c01068e0 <pmm_alloc_page>
c0107710:	83 c4 10             	add    $0x10,%esp
c0107713:	89 45 e0             	mov    %eax,-0x20(%ebp)
    
    // 物理内存已满！
    if (!new_pt_pa) {
c0107716:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c010771a:	75 0a                	jne    c0107726 <vmm_map_page+0x146>
        return NULL;
c010771c:	b8 00 00 00 00       	mov    $0x0,%eax
c0107721:	e9 ae 00 00 00       	jmp    c01077d4 <vmm_map_page+0x1f4>
    }
    
    ptd[pd_offset] = PDE(dattr, new_pt_pa);
c0107726:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0107729:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010772e:	89 c1                	mov    %eax,%ecx
c0107730:	8b 45 14             	mov    0x14(%ebp),%eax
c0107733:	83 c8 08             	or     $0x8,%eax
c0107736:	25 ff 0f 00 00       	and    $0xfff,%eax
c010773b:	89 c2                	mov    %eax,%edx
c010773d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107740:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
c0107747:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010774a:	01 d8                	add    %ebx,%eax
c010774c:	09 ca                	or     %ecx,%edx
c010774e:	89 10                	mov    %edx,(%eax)
    
    memset((void*)PT_VADDR(pd_offset), 0, PM_PAGE_SIZE);
c0107750:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107753:	c1 e0 0c             	shl    $0xc,%eax
c0107756:	0d 00 00 c0 ff       	or     $0xffc00000,%eax
c010775b:	83 ec 04             	sub    $0x4,%esp
c010775e:	68 00 10 00 00       	push   $0x1000
c0107763:	6a 00                	push   $0x0
c0107765:	50                   	push   %eax
c0107766:	e8 d4 29 00 00       	call   c010a13f <memset>
c010776b:	83 c4 10             	add    $0x10,%esp


    if ((HAS_FLAGS(tattr, PG_PRESENT) && HAS_FLAGS(dattr, PG_PRESENT))) {
c010776e:	8b 45 18             	mov    0x18(%ebp),%eax
c0107771:	83 e0 01             	and    $0x1,%eax
c0107774:	85 c0                	test   %eax,%eax
c0107776:	74 1b                	je     c0107793 <vmm_map_page+0x1b3>
c0107778:	8b 45 14             	mov    0x14(%ebp),%eax
c010777b:	83 e0 01             	and    $0x1,%eax
c010777e:	85 c0                	test   %eax,%eax
c0107780:	74 11                	je     c0107793 <vmm_map_page+0x1b3>
        // add one on reference count, regardless of existence.
        pmm_ref_page(pid, pa);
c0107782:	83 ec 08             	sub    $0x8,%esp
c0107785:	ff 75 10             	push   0x10(%ebp)
c0107788:	ff 75 08             	push   0x8(%ebp)
c010778b:	e8 17 f3 ff ff       	call   c0106aa7 <pmm_ref_page>
c0107790:	83 c4 10             	add    $0x10,%esp
    }
    pt[pt_offset] = PTE(tattr, pa);
c0107793:	8b 45 10             	mov    0x10(%ebp),%eax
c0107796:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010779b:	89 c1                	mov    %eax,%ecx
c010779d:	8b 45 18             	mov    0x18(%ebp),%eax
c01077a0:	25 ff 0f 00 00       	and    $0xfff,%eax
c01077a5:	89 c2                	mov    %eax,%edx
c01077a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01077aa:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
c01077b1:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01077b4:	01 d8                	add    %ebx,%eax
c01077b6:	09 ca                	or     %ecx,%edx
c01077b8:	89 10                	mov    %edx,(%eax)

    return V_ADDR(pd_offset, pt_offset, PG_OFFSET(va));
c01077ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01077bd:	c1 e0 16             	shl    $0x16,%eax
c01077c0:	89 c2                	mov    %eax,%edx
c01077c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01077c5:	c1 e0 0c             	shl    $0xc,%eax
c01077c8:	09 c2                	or     %eax,%edx
c01077ca:	8b 45 0c             	mov    0xc(%ebp),%eax
c01077cd:	25 ff 0f 00 00       	and    $0xfff,%eax
c01077d2:	09 d0                	or     %edx,%eax
}
c01077d4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c01077d7:	c9                   	leave  
c01077d8:	c3                   	ret    

c01077d9 <vmm_cover_map_page>:

void* vmm_cover_map_page(pid_t pid, void* va, void* pa, pt_attr dattr, pt_attr tattr)
{
c01077d9:	55                   	push   %ebp
c01077da:	89 e5                	mov    %esp,%ebp
c01077dc:	53                   	push   %ebx
c01077dd:	83 ec 24             	sub    $0x24,%esp
        // 显然，对空指针进行映射没有意义。
    if (!pa || !va) {
c01077e0:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c01077e4:	74 06                	je     c01077ec <vmm_cover_map_page+0x13>
c01077e6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c01077ea:	75 0a                	jne    c01077f6 <vmm_cover_map_page+0x1d>
        return NULL;
c01077ec:	b8 00 00 00 00       	mov    $0x0,%eax
c01077f1:	e9 90 01 00 00       	jmp    c0107986 <vmm_cover_map_page+0x1ad>
    }

    uintptr_t pd_offset = PD_INDEX(va);
c01077f6:	8b 45 0c             	mov    0xc(%ebp),%eax
c01077f9:	c1 e8 16             	shr    $0x16,%eax
c01077fc:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uintptr_t pt_offset = PT_INDEX(va);
c01077ff:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107802:	c1 e8 0c             	shr    $0xc,%eax
c0107805:	25 ff 03 00 00       	and    $0x3ff,%eax
c010780a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    ptd_t* ptd = (ptd_t*)PTD_BASE_VADDR;
c010780d:	c7 45 ec 00 f0 ff ff 	movl   $0xfffff000,-0x14(%ebp)

    // 在页表与页目录中找到一个可用的空位进行映射（位于va或其附近）
    ptd_t* pde = ptd[pd_offset];
c0107814:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107817:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010781e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0107821:	01 d0                	add    %edx,%eax
c0107823:	8b 00                	mov    (%eax),%eax
c0107825:	89 45 e8             	mov    %eax,-0x18(%ebp)
    pt_t* pt = (uintptr_t)PT_VADDR(pd_offset); 
c0107828:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010782b:	c1 e0 0c             	shl    $0xc,%eax
c010782e:	0d 00 00 c0 ff       	or     $0xffc00000,%eax
c0107833:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(!pde)
c0107836:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c010783a:	75 6b                	jne    c01078a7 <vmm_cover_map_page+0xce>
    {
        uint8_t* new_pt_pa = pmm_alloc_page(pid, PP_FGPERSIST);
c010783c:	83 ec 08             	sub    $0x8,%esp
c010783f:	6a 01                	push   $0x1
c0107841:	ff 75 08             	push   0x8(%ebp)
c0107844:	e8 97 f0 ff ff       	call   c01068e0 <pmm_alloc_page>
c0107849:	83 c4 10             	add    $0x10,%esp
c010784c:	89 45 e0             	mov    %eax,-0x20(%ebp)
        if (!new_pt_pa) {
c010784f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0107853:	75 0a                	jne    c010785f <vmm_cover_map_page+0x86>
            return NULL;
c0107855:	b8 00 00 00 00       	mov    $0x0,%eax
c010785a:	e9 27 01 00 00       	jmp    c0107986 <vmm_cover_map_page+0x1ad>
        }

        ptd[pd_offset] = PDE(dattr, new_pt_pa);
c010785f:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0107862:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0107867:	89 c1                	mov    %eax,%ecx
c0107869:	8b 45 14             	mov    0x14(%ebp),%eax
c010786c:	83 c8 08             	or     $0x8,%eax
c010786f:	25 ff 0f 00 00       	and    $0xfff,%eax
c0107874:	89 c2                	mov    %eax,%edx
c0107876:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107879:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
c0107880:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0107883:	01 d8                	add    %ebx,%eax
c0107885:	09 ca                	or     %ecx,%edx
c0107887:	89 10                	mov    %edx,(%eax)
        memset((void*)PT_VADDR(pd_offset), 0, PM_PAGE_SIZE);
c0107889:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010788c:	c1 e0 0c             	shl    $0xc,%eax
c010788f:	0d 00 00 c0 ff       	or     $0xffc00000,%eax
c0107894:	83 ec 04             	sub    $0x4,%esp
c0107897:	68 00 10 00 00       	push   $0x1000
c010789c:	6a 00                	push   $0x0
c010789e:	50                   	push   %eax
c010789f:	e8 9b 28 00 00       	call   c010a13f <memset>
c01078a4:	83 c4 10             	add    $0x10,%esp

    }   

    // 页目录有空位，需要开辟一个新的 PDE
    uint8_t* new_pt_pa = pmm_alloc_page(pid, PP_FGPERSIST);
c01078a7:	83 ec 08             	sub    $0x8,%esp
c01078aa:	6a 01                	push   $0x1
c01078ac:	ff 75 08             	push   0x8(%ebp)
c01078af:	e8 2c f0 ff ff       	call   c01068e0 <pmm_alloc_page>
c01078b4:	83 c4 10             	add    $0x10,%esp
c01078b7:	89 45 dc             	mov    %eax,-0x24(%ebp)
    
    // 物理内存已满！
    if (!new_pt_pa) {
c01078ba:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c01078be:	75 0a                	jne    c01078ca <vmm_cover_map_page+0xf1>
        return NULL;
c01078c0:	b8 00 00 00 00       	mov    $0x0,%eax
c01078c5:	e9 bc 00 00 00       	jmp    c0107986 <vmm_cover_map_page+0x1ad>
    }
    
    ptd[pd_offset] = PDE(dattr, new_pt_pa);
c01078ca:	8b 45 dc             	mov    -0x24(%ebp),%eax
c01078cd:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c01078d2:	89 c1                	mov    %eax,%ecx
c01078d4:	8b 45 14             	mov    0x14(%ebp),%eax
c01078d7:	83 c8 08             	or     $0x8,%eax
c01078da:	25 ff 0f 00 00       	and    $0xfff,%eax
c01078df:	89 c2                	mov    %eax,%edx
c01078e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01078e4:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
c01078eb:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01078ee:	01 d8                	add    %ebx,%eax
c01078f0:	09 ca                	or     %ecx,%edx
c01078f2:	89 10                	mov    %edx,(%eax)
    
    memset((void*)PT_VADDR(pd_offset), 0, PM_PAGE_SIZE);
c01078f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01078f7:	c1 e0 0c             	shl    $0xc,%eax
c01078fa:	0d 00 00 c0 ff       	or     $0xffc00000,%eax
c01078ff:	83 ec 04             	sub    $0x4,%esp
c0107902:	68 00 10 00 00       	push   $0x1000
c0107907:	6a 00                	push   $0x0
c0107909:	50                   	push   %eax
c010790a:	e8 30 28 00 00       	call   c010a13f <memset>
c010790f:	83 c4 10             	add    $0x10,%esp

    if (HAS_FLAGS(tattr, PG_PRESENT) && HAS_FLAGS(dattr, PG_PRESENT)) {
c0107912:	8b 45 18             	mov    0x18(%ebp),%eax
c0107915:	83 e0 01             	and    $0x1,%eax
c0107918:	85 c0                	test   %eax,%eax
c010791a:	74 1b                	je     c0107937 <vmm_cover_map_page+0x15e>
c010791c:	8b 45 14             	mov    0x14(%ebp),%eax
c010791f:	83 e0 01             	and    $0x1,%eax
c0107922:	85 c0                	test   %eax,%eax
c0107924:	74 11                	je     c0107937 <vmm_cover_map_page+0x15e>
        // add one on reference count, regardless of existence.
        pmm_ref_page(pid, pa);
c0107926:	83 ec 08             	sub    $0x8,%esp
c0107929:	ff 75 10             	push   0x10(%ebp)
c010792c:	ff 75 08             	push   0x8(%ebp)
c010792f:	e8 73 f1 ff ff       	call   c0106aa7 <pmm_ref_page>
c0107934:	83 c4 10             	add    $0x10,%esp
    }
    pt[pt_offset] = PTE(tattr, pa);
c0107937:	8b 45 10             	mov    0x10(%ebp),%eax
c010793a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010793f:	89 c1                	mov    %eax,%ecx
c0107941:	8b 45 18             	mov    0x18(%ebp),%eax
c0107944:	25 ff 0f 00 00       	and    $0xfff,%eax
c0107949:	89 c2                	mov    %eax,%edx
c010794b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010794e:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
c0107955:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0107958:	01 d8                	add    %ebx,%eax
c010795a:	09 ca                	or     %ecx,%edx
c010795c:	89 10                	mov    %edx,(%eax)

    cpu_invplg(va);
c010795e:	83 ec 0c             	sub    $0xc,%esp
c0107961:	ff 75 0c             	push   0xc(%ebp)
c0107964:	e8 aa fa ff ff       	call   c0107413 <cpu_invplg>
c0107969:	83 c4 10             	add    $0x10,%esp

    return V_ADDR(pd_offset, pt_offset, PG_OFFSET(va));
c010796c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010796f:	c1 e0 16             	shl    $0x16,%eax
c0107972:	89 c2                	mov    %eax,%edx
c0107974:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107977:	c1 e0 0c             	shl    $0xc,%eax
c010797a:	09 c2                	or     %eax,%edx
c010797c:	8b 45 0c             	mov    0xc(%ebp),%eax
c010797f:	25 ff 0f 00 00       	and    $0xfff,%eax
c0107984:	09 d0                	or     %edx,%eax
}
c0107986:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0107989:	c9                   	leave  
c010798a:	c3                   	ret    

c010798b <vmm_alloc_page>:

void* vmm_alloc_page(pid_t pid, void* vpn, void** pa, pt_attr dattr, pt_attr tattr)
{
c010798b:	55                   	push   %ebp
c010798c:	89 e5                	mov    %esp,%ebp
c010798e:	83 ec 18             	sub    $0x18,%esp
    void* pp = pmm_alloc_page(pid, tattr);
c0107991:	83 ec 08             	sub    $0x8,%esp
c0107994:	ff 75 18             	push   0x18(%ebp)
c0107997:	ff 75 08             	push   0x8(%ebp)
c010799a:	e8 41 ef ff ff       	call   c01068e0 <pmm_alloc_page>
c010799f:	83 c4 10             	add    $0x10,%esp
c01079a2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    void* result = vmm_map_page(pid, vpn, pp, dattr, tattr);
c01079a5:	83 ec 0c             	sub    $0xc,%esp
c01079a8:	ff 75 18             	push   0x18(%ebp)
c01079ab:	ff 75 14             	push   0x14(%ebp)
c01079ae:	ff 75 f4             	push   -0xc(%ebp)
c01079b1:	ff 75 0c             	push   0xc(%ebp)
c01079b4:	ff 75 08             	push   0x8(%ebp)
c01079b7:	e8 24 fc ff ff       	call   c01075e0 <vmm_map_page>
c01079bc:	83 c4 20             	add    $0x20,%esp
c01079bf:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (!result) {
c01079c2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c01079c6:	75 11                	jne    c01079d9 <vmm_alloc_page+0x4e>
        pmm_free_page(pid, pp);
c01079c8:	83 ec 08             	sub    $0x8,%esp
c01079cb:	ff 75 f4             	push   -0xc(%ebp)
c01079ce:	ff 75 08             	push   0x8(%ebp)
c01079d1:	e8 3f f0 ff ff       	call   c0106a15 <pmm_free_page>
c01079d6:	83 c4 10             	add    $0x10,%esp
    }
    pa ? (*pa = pp) : 0;
c01079d9:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c01079dd:	74 08                	je     c01079e7 <vmm_alloc_page+0x5c>
c01079df:	8b 45 10             	mov    0x10(%ebp),%eax
c01079e2:	8b 55 f4             	mov    -0xc(%ebp),%edx
c01079e5:	89 10                	mov    %edx,(%eax)
    return result;
c01079e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c01079ea:	c9                   	leave  
c01079eb:	c3                   	ret    

c01079ec <vmm_alloc_pages>:

int vmm_alloc_pages(pid_t pid, void* va, size_t sz, pt_attr tattr, pp_attr_t pattr)
{
c01079ec:	55                   	push   %ebp
c01079ed:	89 e5                	mov    %esp,%ebp
c01079ef:	83 ec 28             	sub    $0x28,%esp
    assert((uintptr_t)va % PG_SIZE == 0) assert(sz % PG_SIZE == 0);
c01079f2:	8b 45 0c             	mov    0xc(%ebp),%eax
c01079f5:	25 ff 0f 00 00       	and    $0xfff,%eax
c01079fa:	85 c0                	test   %eax,%eax
c01079fc:	74 1a                	je     c0107a18 <vmm_alloc_pages+0x2c>
c01079fe:	83 ec 04             	sub    $0x4,%esp
c0107a01:	68 32 01 00 00       	push   $0x132
c0107a06:	68 ce d2 28 c0       	push   $0xc028d2ce
c0107a0b:	68 f3 d2 28 c0       	push   $0xc028d2f3
c0107a10:	e8 1c 19 00 00       	call   c0109331 <__assert_fail>
c0107a15:	83 c4 10             	add    $0x10,%esp
c0107a18:	8b 45 10             	mov    0x10(%ebp),%eax
c0107a1b:	25 ff 0f 00 00       	and    $0xfff,%eax
c0107a20:	85 c0                	test   %eax,%eax
c0107a22:	74 1a                	je     c0107a3e <vmm_alloc_pages+0x52>
c0107a24:	83 ec 04             	sub    $0x4,%esp
c0107a27:	68 32 01 00 00       	push   $0x132
c0107a2c:	68 ce d2 28 c0       	push   $0xc028d2ce
c0107a31:	68 10 d3 28 c0       	push   $0xc028d310
c0107a36:	e8 f6 18 00 00       	call   c0109331 <__assert_fail>
c0107a3b:	83 c4 10             	add    $0x10,%esp

    void* va_ = va;
c0107a3e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107a41:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for (size_t i = 0; i < (sz >> PG_SIZE_BITS); i++, va_ += PG_SIZE) {
c0107a44:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0107a4b:	e9 97 00 00 00       	jmp    c0107ae7 <vmm_alloc_pages+0xfb>
        void* pp = pmm_alloc_page(pid, pattr);
c0107a50:	83 ec 08             	sub    $0x8,%esp
c0107a53:	ff 75 18             	push   0x18(%ebp)
c0107a56:	ff 75 08             	push   0x8(%ebp)
c0107a59:	e8 82 ee ff ff       	call   c01068e0 <pmm_alloc_page>
c0107a5e:	83 c4 10             	add    $0x10,%esp
c0107a61:	89 45 e8             	mov    %eax,-0x18(%ebp)
        uint32_t l1_index = PD_INDEX(va_);
c0107a64:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107a67:	c1 e8 16             	shr    $0x16,%eax
c0107a6a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        uint32_t l2_index = PT_INDEX(va_);
c0107a6d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107a70:	c1 e8 0c             	shr    $0xc,%eax
c0107a73:	25 ff 03 00 00       	and    $0x3ff,%eax
c0107a78:	89 45 e0             	mov    %eax,-0x20(%ebp)
        if (!pp || !__vmm_map_alloc(
c0107a7b:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0107a7f:	74 21                	je     c0107aa2 <vmm_alloc_pages+0xb6>
c0107a81:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0107a84:	83 ec 08             	sub    $0x8,%esp
c0107a87:	6a 00                	push   $0x0
c0107a89:	ff 75 14             	push   0x14(%ebp)
c0107a8c:	50                   	push   %eax
c0107a8d:	ff 75 e0             	push   -0x20(%ebp)
c0107a90:	ff 75 e4             	push   -0x1c(%ebp)
c0107a93:	ff 75 08             	push   0x8(%ebp)
c0107a96:	e8 17 fa ff ff       	call   c01074b2 <__vmm_map_alloc>
c0107a9b:	83 c4 20             	add    $0x20,%esp
c0107a9e:	85 c0                	test   %eax,%eax
c0107aa0:	75 3a                	jne    c0107adc <vmm_alloc_pages+0xf0>
                     pid,
                     l1_index, l2_index, (uintptr_t)pp, tattr, false)) {
            // if one failed, release previous allocated pages.
            va_ = va;
c0107aa2:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107aa5:	89 45 f4             	mov    %eax,-0xc(%ebp)
            for (size_t j = 0; j < i; j++, va_ += PG_SIZE) {
c0107aa8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0107aaf:	eb 1c                	jmp    c0107acd <vmm_alloc_pages+0xe1>
                vmm_unmap_page(pid, va_);
c0107ab1:	83 ec 08             	sub    $0x8,%esp
c0107ab4:	ff 75 f4             	push   -0xc(%ebp)
c0107ab7:	ff 75 08             	push   0x8(%ebp)
c0107aba:	e8 8d 01 00 00       	call   c0107c4c <vmm_unmap_page>
c0107abf:	83 c4 10             	add    $0x10,%esp
            for (size_t j = 0; j < i; j++, va_ += PG_SIZE) {
c0107ac2:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0107ac6:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
c0107acd:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0107ad0:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0107ad3:	72 dc                	jb     c0107ab1 <vmm_alloc_pages+0xc5>
            }

            return false;
c0107ad5:	b8 00 00 00 00       	mov    $0x0,%eax
c0107ada:	eb 1f                	jmp    c0107afb <vmm_alloc_pages+0x10f>
    for (size_t i = 0; i < (sz >> PG_SIZE_BITS); i++, va_ += PG_SIZE) {
c0107adc:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0107ae0:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
c0107ae7:	8b 45 10             	mov    0x10(%ebp),%eax
c0107aea:	c1 e8 0c             	shr    $0xc,%eax
c0107aed:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c0107af0:	0f 82 5a ff ff ff    	jb     c0107a50 <vmm_alloc_pages+0x64>
        }
    }

    return true;
c0107af6:	b8 01 00 00 00       	mov    $0x1,%eax
}
c0107afb:	c9                   	leave  
c0107afc:	c3                   	ret    

c0107afd <vmm_set_mapping>:

int vmm_set_mapping(pid_t pid, void* va, void* pa, pt_attr attr)
{
c0107afd:	55                   	push   %ebp
c0107afe:	89 e5                	mov    %esp,%ebp
c0107b00:	83 ec 18             	sub    $0x18,%esp
    assert(((uintptr_t)va & 0xFFFU) == 0);
c0107b03:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107b06:	25 ff 0f 00 00       	and    $0xfff,%eax
c0107b0b:	85 c0                	test   %eax,%eax
c0107b0d:	74 1a                	je     c0107b29 <vmm_set_mapping+0x2c>
c0107b0f:	83 ec 04             	sub    $0x4,%esp
c0107b12:	68 4b 01 00 00       	push   $0x14b
c0107b17:	68 ce d2 28 c0       	push   $0xc028d2ce
c0107b1c:	68 22 d3 28 c0       	push   $0xc028d322
c0107b21:	e8 0b 18 00 00       	call   c0109331 <__assert_fail>
c0107b26:	83 c4 10             	add    $0x10,%esp

    uint32_t l1_index = PD_INDEX(va);
c0107b29:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107b2c:	c1 e8 16             	shr    $0x16,%eax
c0107b2f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t l2_index = PT_INDEX(va);
c0107b32:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107b35:	c1 e8 0c             	shr    $0xc,%eax
c0107b38:	25 ff 03 00 00       	and    $0x3ff,%eax
c0107b3d:	89 45 f0             	mov    %eax,-0x10(%ebp)

    // prevent map of recursive mapping region
    if (l1_index == 1023) {
c0107b40:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
c0107b47:	75 07                	jne    c0107b50 <vmm_set_mapping+0x53>
        return 0;
c0107b49:	b8 00 00 00 00       	mov    $0x0,%eax
c0107b4e:	eb 22                	jmp    c0107b72 <vmm_set_mapping+0x75>
    }
    
    __vmm_map_alloc(pid, l1_index, l2_index, (uintptr_t)pa, attr, false);
c0107b50:	8b 45 10             	mov    0x10(%ebp),%eax
c0107b53:	83 ec 08             	sub    $0x8,%esp
c0107b56:	6a 00                	push   $0x0
c0107b58:	ff 75 14             	push   0x14(%ebp)
c0107b5b:	50                   	push   %eax
c0107b5c:	ff 75 f0             	push   -0x10(%ebp)
c0107b5f:	ff 75 f4             	push   -0xc(%ebp)
c0107b62:	ff 75 08             	push   0x8(%ebp)
c0107b65:	e8 48 f9 ff ff       	call   c01074b2 <__vmm_map_alloc>
c0107b6a:	83 c4 20             	add    $0x20,%esp
    return 1;
c0107b6d:	b8 01 00 00 00       	mov    $0x1,%eax
}
c0107b72:	c9                   	leave  
c0107b73:	c3                   	ret    

c0107b74 <__vmm_unmap_unalloc>:

void __vmm_unmap_unalloc(pid_t pid, void* va, int free_ppage)
{
c0107b74:	55                   	push   %ebp
c0107b75:	89 e5                	mov    %esp,%ebp
c0107b77:	83 ec 28             	sub    $0x28,%esp
    assert(((uintptr_t)va & 0xFFFU) == 0);
c0107b7a:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107b7d:	25 ff 0f 00 00       	and    $0xfff,%eax
c0107b82:	85 c0                	test   %eax,%eax
c0107b84:	74 1a                	je     c0107ba0 <__vmm_unmap_unalloc+0x2c>
c0107b86:	83 ec 04             	sub    $0x4,%esp
c0107b89:	68 5b 01 00 00       	push   $0x15b
c0107b8e:	68 ce d2 28 c0       	push   $0xc028d2ce
c0107b93:	68 22 d3 28 c0       	push   $0xc028d322
c0107b98:	e8 94 17 00 00       	call   c0109331 <__assert_fail>
c0107b9d:	83 c4 10             	add    $0x10,%esp

    uint32_t l1_index = PD_INDEX(va);
c0107ba0:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107ba3:	c1 e8 16             	shr    $0x16,%eax
c0107ba6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t l2_index = PT_INDEX(va);
c0107ba9:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107bac:	c1 e8 0c             	shr    $0xc,%eax
c0107baf:	25 ff 03 00 00       	and    $0x3ff,%eax
c0107bb4:	89 45 f0             	mov    %eax,-0x10(%ebp)

    // prevent unmap of recursive mapping region
    if (l1_index == 1023) {
c0107bb7:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
c0107bbe:	0f 84 85 00 00 00    	je     c0107c49 <__vmm_unmap_unalloc+0xd5>
        return;
    }

    ptd_t* ptd = (ptd_t*)PTD_BASE_VADDR;
c0107bc4:	c7 45 ec 00 f0 ff ff 	movl   $0xfffff000,-0x14(%ebp)

    if (ptd[l1_index]) {
c0107bcb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107bce:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0107bd5:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0107bd8:	01 d0                	add    %edx,%eax
c0107bda:	8b 00                	mov    (%eax),%eax
c0107bdc:	85 c0                	test   %eax,%eax
c0107bde:	74 6a                	je     c0107c4a <__vmm_unmap_unalloc+0xd6>
        pt_t* pt = (uintptr_t)PT_VADDR(l1_index);
c0107be0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107be3:	c1 e0 0c             	shl    $0xc,%eax
c0107be6:	0d 00 00 c0 ff       	or     $0xffc00000,%eax
c0107beb:	89 45 e8             	mov    %eax,-0x18(%ebp)
        pt_t pte = pt[l2_index];
c0107bee:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107bf1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0107bf8:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0107bfb:	01 d0                	add    %edx,%eax
c0107bfd:	8b 00                	mov    (%eax),%eax
c0107bff:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if (IS_CACHED(pte) && free_ppage) {
c0107c02:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0107c05:	83 e0 01             	and    $0x1,%eax
c0107c08:	85 c0                	test   %eax,%eax
c0107c0a:	74 18                	je     c0107c24 <__vmm_unmap_unalloc+0xb0>
c0107c0c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0107c10:	74 12                	je     c0107c24 <__vmm_unmap_unalloc+0xb0>
            pmm_free_page(pid, (void*)pte);
c0107c12:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0107c15:	83 ec 08             	sub    $0x8,%esp
c0107c18:	50                   	push   %eax
c0107c19:	ff 75 08             	push   0x8(%ebp)
c0107c1c:	e8 f4 ed ff ff       	call   c0106a15 <pmm_free_page>
c0107c21:	83 c4 10             	add    $0x10,%esp
        }
        cpu_invplg(va);
c0107c24:	83 ec 0c             	sub    $0xc,%esp
c0107c27:	ff 75 0c             	push   0xc(%ebp)
c0107c2a:	e8 e4 f7 ff ff       	call   c0107413 <cpu_invplg>
c0107c2f:	83 c4 10             	add    $0x10,%esp

        pt[l2_index] = 0;
c0107c32:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107c35:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0107c3c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0107c3f:	01 d0                	add    %edx,%eax
c0107c41:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c0107c47:	eb 01                	jmp    c0107c4a <__vmm_unmap_unalloc+0xd6>
        return;
c0107c49:	90                   	nop
    }
}
c0107c4a:	c9                   	leave  
c0107c4b:	c3                   	ret    

c0107c4c <vmm_unmap_page>:

void vmm_unmap_page(pid_t pid, void* va)
{
c0107c4c:	55                   	push   %ebp
c0107c4d:	89 e5                	mov    %esp,%ebp
c0107c4f:	83 ec 08             	sub    $0x8,%esp
    __vmm_unmap_unalloc(pid, va, true);
c0107c52:	83 ec 04             	sub    $0x4,%esp
c0107c55:	6a 01                	push   $0x1
c0107c57:	ff 75 0c             	push   0xc(%ebp)
c0107c5a:	ff 75 08             	push   0x8(%ebp)
c0107c5d:	e8 12 ff ff ff       	call   c0107b74 <__vmm_unmap_unalloc>
c0107c62:	83 c4 10             	add    $0x10,%esp
}
c0107c65:	90                   	nop
c0107c66:	c9                   	leave  
c0107c67:	c3                   	ret    

c0107c68 <vmm_unset_mapping>:

void vmm_unset_mapping(void* va)
{
c0107c68:	55                   	push   %ebp
c0107c69:	89 e5                	mov    %esp,%ebp
c0107c6b:	83 ec 08             	sub    $0x8,%esp
    __vmm_unmap_unalloc(0, va, false);
c0107c6e:	83 ec 04             	sub    $0x4,%esp
c0107c71:	6a 00                	push   $0x0
c0107c73:	ff 75 08             	push   0x8(%ebp)
c0107c76:	6a 00                	push   $0x0
c0107c78:	e8 f7 fe ff ff       	call   c0107b74 <__vmm_unmap_unalloc>
c0107c7d:	83 c4 10             	add    $0x10,%esp
}
c0107c80:	90                   	nop
c0107c81:	c9                   	leave  
c0107c82:	c3                   	ret    

c0107c83 <vmm_lookup>:

v_mapping vmm_lookup(void* va)
{
c0107c83:	55                   	push   %ebp
c0107c84:	89 e5                	mov    %esp,%ebp
c0107c86:	83 ec 38             	sub    $0x38,%esp
    assert(((uintptr_t)va & 0xFFFU) == 0);
c0107c89:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107c8c:	25 ff 0f 00 00       	and    $0xfff,%eax
c0107c91:	85 c0                	test   %eax,%eax
c0107c93:	74 1a                	je     c0107caf <vmm_lookup+0x2c>
c0107c95:	83 ec 04             	sub    $0x4,%esp
c0107c98:	68 7f 01 00 00       	push   $0x17f
c0107c9d:	68 ce d2 28 c0       	push   $0xc028d2ce
c0107ca2:	68 22 d3 28 c0       	push   $0xc028d322
c0107ca7:	e8 85 16 00 00       	call   c0109331 <__assert_fail>
c0107cac:	83 c4 10             	add    $0x10,%esp

    uint32_t l1_index = PD_INDEX(va);
c0107caf:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107cb2:	c1 e8 16             	shr    $0x16,%eax
c0107cb5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t l2_index = PT_INDEX(va);
c0107cb8:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107cbb:	c1 e8 0c             	shr    $0xc,%eax
c0107cbe:	25 ff 03 00 00       	and    $0x3ff,%eax
c0107cc3:	89 45 f0             	mov    %eax,-0x10(%ebp)

    ptd_t* ptd = (ptd_t*)PTD_BASE_VADDR;
c0107cc6:	c7 45 ec 00 f0 ff ff 	movl   $0xfffff000,-0x14(%ebp)

    v_mapping mapping = { .flags = 0, .pa = 0, .pn = 0 };
c0107ccd:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
c0107cd4:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
c0107cdb:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
c0107ce2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    if (ptd[l1_index]) {
c0107ce9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107cec:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0107cf3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0107cf6:	01 d0                	add    %edx,%eax
c0107cf8:	8b 00                	mov    (%eax),%eax
c0107cfa:	85 c0                	test   %eax,%eax
c0107cfc:	74 4f                	je     c0107d4d <vmm_lookup+0xca>
        pt_t* pt = (uintptr_t)PT_VADDR(l1_index);
c0107cfe:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0107d01:	c1 e0 0c             	shl    $0xc,%eax
c0107d04:	0d 00 00 c0 ff       	or     $0xffc00000,%eax
c0107d09:	89 45 e8             	mov    %eax,-0x18(%ebp)
        pt_t* l2pte = &pt[l2_index];
c0107d0c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0107d0f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0107d16:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0107d19:	01 d0                	add    %edx,%eax
c0107d1b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if (l2pte) {
c0107d1e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0107d22:	74 29                	je     c0107d4d <vmm_lookup+0xca>
            mapping.flags = PG_ENTRY_FLAGS(*l2pte);
c0107d24:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0107d27:	8b 00                	mov    (%eax),%eax
c0107d29:	66 25 ff 0f          	and    $0xfff,%ax
c0107d2d:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
            mapping.pa = PG_ENTRY_ADDR(*l2pte);
c0107d31:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0107d34:	8b 00                	mov    (%eax),%eax
c0107d36:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0107d3b:	89 45 d8             	mov    %eax,-0x28(%ebp)
            mapping.pn = mapping.pa >> PG_SIZE_BITS;
c0107d3e:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0107d41:	c1 e8 0c             	shr    $0xc,%eax
c0107d44:	89 45 d4             	mov    %eax,-0x2c(%ebp)
            mapping.pte = l2pte;
c0107d47:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0107d4a:	89 45 e0             	mov    %eax,-0x20(%ebp)
        }
    }

    return mapping;
c0107d4d:	8b 45 08             	mov    0x8(%ebp),%eax
c0107d50:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c0107d53:	89 10                	mov    %edx,(%eax)
c0107d55:	8b 55 d8             	mov    -0x28(%ebp),%edx
c0107d58:	89 50 04             	mov    %edx,0x4(%eax)
c0107d5b:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0107d5e:	89 50 08             	mov    %edx,0x8(%eax)
c0107d61:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0107d64:	89 50 0c             	mov    %edx,0xc(%eax)
}
c0107d67:	8b 45 08             	mov    0x8(%ebp),%eax
c0107d6a:	c9                   	leave  
c0107d6b:	c2 04 00             	ret    $0x4

c0107d6e <vmm_v2p>:

void* vmm_v2p(void* va)
{
c0107d6e:	55                   	push   %ebp
c0107d6f:	89 e5                	mov    %esp,%ebp
c0107d71:	83 ec 18             	sub    $0x18,%esp
    return (void*)vmm_lookup(va).pa;
c0107d74:	8d 45 e8             	lea    -0x18(%ebp),%eax
c0107d77:	83 ec 08             	sub    $0x8,%esp
c0107d7a:	ff 75 08             	push   0x8(%ebp)
c0107d7d:	50                   	push   %eax
c0107d7e:	e8 00 ff ff ff       	call   c0107c83 <vmm_lookup>
c0107d83:	83 c4 0c             	add    $0xc,%esp
c0107d86:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
c0107d89:	c9                   	leave  
c0107d8a:	c3                   	ret    

c0107d8b <vmm_dup_page>:

void* vmm_dup_page(pid_t pid, void* pa)
{
c0107d8b:	55                   	push   %ebp
c0107d8c:	89 e5                	mov    %esp,%ebp
c0107d8e:	57                   	push   %edi
c0107d8f:	56                   	push   %esi
c0107d90:	53                   	push   %ebx
c0107d91:	83 ec 1c             	sub    $0x1c,%esp
    void* new_ppg = pmm_alloc_page(pid, 0);
c0107d94:	83 ec 08             	sub    $0x8,%esp
c0107d97:	6a 00                	push   $0x0
c0107d99:	ff 75 08             	push   0x8(%ebp)
c0107d9c:	e8 3f eb ff ff       	call   c01068e0 <pmm_alloc_page>
c0107da1:	83 c4 10             	add    $0x10,%esp
c0107da4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    vmm_cover_map_page(pid, PG_MOUNT_3, new_ppg, PG_PREM_RW,PG_PREM_RW);
c0107da7:	83 ec 0c             	sub    $0xc,%esp
c0107daa:	6a 03                	push   $0x3
c0107dac:	6a 03                	push   $0x3
c0107dae:	ff 75 e4             	push   -0x1c(%ebp)
c0107db1:	68 00 d0 7f af       	push   $0xaf7fd000
c0107db6:	ff 75 08             	push   0x8(%ebp)
c0107db9:	e8 1b fa ff ff       	call   c01077d9 <vmm_cover_map_page>
c0107dbe:	83 c4 20             	add    $0x20,%esp
    vmm_cover_map_page(pid, PG_MOUNT_4, pa, PG_PREM_RW,PG_PREM_RW);
c0107dc1:	83 ec 0c             	sub    $0xc,%esp
c0107dc4:	6a 03                	push   $0x3
c0107dc6:	6a 03                	push   $0x3
c0107dc8:	ff 75 0c             	push   0xc(%ebp)
c0107dcb:	68 00 c0 7f af       	push   $0xaf7fc000
c0107dd0:	ff 75 08             	push   0x8(%ebp)
c0107dd3:	e8 01 fa ff ff       	call   c01077d9 <vmm_cover_map_page>
c0107dd8:	83 c4 20             	add    $0x20,%esp

    asm volatile (
c0107ddb:	b8 00 04 00 00       	mov    $0x400,%eax
c0107de0:	ba 00 d0 7f af       	mov    $0xaf7fd000,%edx
c0107de5:	bb 00 c0 7f af       	mov    $0xaf7fc000,%ebx
c0107dea:	89 c1                	mov    %eax,%ecx
c0107dec:	89 d7                	mov    %edx,%edi
c0107dee:	89 de                	mov    %ebx,%esi
c0107df0:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
        "movl %2, %%esi\n"
        "rep movsl\n"
        :: "c"(1024), "r"(PG_MOUNT_3), "r"(PG_MOUNT_4)
        : "memory", "%edi", "%esi");

    vmm_unset_mapping(PG_MOUNT_3);
c0107df2:	83 ec 0c             	sub    $0xc,%esp
c0107df5:	68 00 d0 7f af       	push   $0xaf7fd000
c0107dfa:	e8 69 fe ff ff       	call   c0107c68 <vmm_unset_mapping>
c0107dff:	83 c4 10             	add    $0x10,%esp
    vmm_unset_mapping(PG_MOUNT_4);
c0107e02:	83 ec 0c             	sub    $0xc,%esp
c0107e05:	68 00 c0 7f af       	push   $0xaf7fc000
c0107e0a:	e8 59 fe ff ff       	call   c0107c68 <vmm_unset_mapping>
c0107e0f:	83 c4 10             	add    $0x10,%esp

    return new_ppg;
c0107e12:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
c0107e15:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0107e18:	5b                   	pop    %ebx
c0107e19:	5e                   	pop    %esi
c0107e1a:	5f                   	pop    %edi
c0107e1b:	5d                   	pop    %ebp
c0107e1c:	c3                   	ret    

c0107e1d <vmm_mount_pd>:

void* vmm_mount_pd(uintptr_t mnt, void* pde)
{
c0107e1d:	55                   	push   %ebp
c0107e1e:	89 e5                	mov    %esp,%ebp
c0107e20:	83 ec 10             	sub    $0x10,%esp
    ptd_t* l1pt = (ptd_t*)PTD_BASE_VADDR;
c0107e23:	c7 45 fc 00 f0 ff ff 	movl   $0xfffff000,-0x4(%ebp)
    l1pt[(mnt >> 22)] = PDE(T_SELF_REF_PERM, pde);
c0107e2a:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107e2d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0107e32:	89 c2                	mov    %eax,%edx
c0107e34:	8b 45 08             	mov    0x8(%ebp),%eax
c0107e37:	c1 e8 16             	shr    $0x16,%eax
c0107e3a:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
c0107e41:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0107e44:	01 c8                	add    %ecx,%eax
c0107e46:	83 ca 1b             	or     $0x1b,%edx
c0107e49:	89 10                	mov    %edx,(%eax)
    cpu_invplg(mnt);
c0107e4b:	8b 45 08             	mov    0x8(%ebp),%eax
c0107e4e:	50                   	push   %eax
c0107e4f:	e8 bf f5 ff ff       	call   c0107413 <cpu_invplg>
c0107e54:	83 c4 04             	add    $0x4,%esp
    return mnt;
c0107e57:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0107e5a:	c9                   	leave  
c0107e5b:	c3                   	ret    

c0107e5c <vmm_unmount_pd>:

void* vmm_unmount_pd(uintptr_t mnt)
{
c0107e5c:	55                   	push   %ebp
c0107e5d:	89 e5                	mov    %esp,%ebp
c0107e5f:	83 ec 10             	sub    $0x10,%esp
    ptd_t* l1pt = (ptd_t*)PTD_BASE_VADDR;
c0107e62:	c7 45 fc 00 f0 ff ff 	movl   $0xfffff000,-0x4(%ebp)
    l1pt[(mnt >> 22)] = 0;
c0107e69:	8b 45 08             	mov    0x8(%ebp),%eax
c0107e6c:	c1 e8 16             	shr    $0x16,%eax
c0107e6f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0107e76:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0107e79:	01 d0                	add    %edx,%eax
c0107e7b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    cpu_invplg(mnt);
c0107e81:	8b 45 08             	mov    0x8(%ebp),%eax
c0107e84:	50                   	push   %eax
c0107e85:	e8 89 f5 ff ff       	call   c0107413 <cpu_invplg>
c0107e8a:	83 c4 04             	add    $0x4,%esp
}
c0107e8d:	90                   	nop
c0107e8e:	c9                   	leave  
c0107e8f:	c3                   	ret    

c0107e90 <io_outb>:
                 : "memory", "cc");
}

static inline void
io_outb(int port, uint8_t data)
{
c0107e90:	55                   	push   %ebp
c0107e91:	89 e5                	mov    %esp,%ebp
c0107e93:	83 ec 04             	sub    $0x4,%esp
c0107e96:	8b 45 0c             	mov    0xc(%ebp),%eax
c0107e99:	88 45 fc             	mov    %al,-0x4(%ebp)
    asm volatile("outb %0, %w1" : : "a"(data), "d"(port));
c0107e9c:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0107ea0:	8b 55 08             	mov    0x8(%ebp),%edx
c0107ea3:	ee                   	out    %al,(%dx)
}
c0107ea4:	90                   	nop
c0107ea5:	c9                   	leave  
c0107ea6:	c3                   	ret    

c0107ea7 <frequence_set>:
uint32_t sched_ticks;
void do_intr_time_handler(isr_param int_param);

static void frequence_set(uint8_t counter_port, uint8_t counter_no, 
                         uint8_t rwl, uint8_t counter_mode, uint16_t counter_value)
{
c0107ea7:	55                   	push   %ebp
c0107ea8:	89 e5                	mov    %esp,%ebp
c0107eaa:	57                   	push   %edi
c0107eab:	56                   	push   %esi
c0107eac:	53                   	push   %ebx
c0107ead:	83 ec 14             	sub    $0x14,%esp
c0107eb0:	8b 75 08             	mov    0x8(%ebp),%esi
c0107eb3:	8b 5d 0c             	mov    0xc(%ebp),%ebx
c0107eb6:	8b 4d 10             	mov    0x10(%ebp),%ecx
c0107eb9:	8b 55 14             	mov    0x14(%ebp),%edx
c0107ebc:	8b 7d 18             	mov    0x18(%ebp),%edi
c0107ebf:	89 f0                	mov    %esi,%eax
c0107ec1:	88 45 f0             	mov    %al,-0x10(%ebp)
c0107ec4:	88 5d ec             	mov    %bl,-0x14(%ebp)
c0107ec7:	88 4d e8             	mov    %cl,-0x18(%ebp)
c0107eca:	88 55 e4             	mov    %dl,-0x1c(%ebp)
c0107ecd:	89 f8                	mov    %edi,%eax
c0107ecf:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
    io_outb(PIT_CONTROL_PORT, (uint8_t)(counter_no << 6 | rwl << 4 | counter_mode << 1));
c0107ed3:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0107ed7:	c1 e0 06             	shl    $0x6,%eax
c0107eda:	89 c2                	mov    %eax,%edx
c0107edc:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c0107ee0:	c1 e0 04             	shl    $0x4,%eax
c0107ee3:	09 c2                	or     %eax,%edx
c0107ee5:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0107ee9:	01 c0                	add    %eax,%eax
c0107eeb:	09 d0                	or     %edx,%eax
c0107eed:	0f b6 c0             	movzbl %al,%eax
c0107ef0:	50                   	push   %eax
c0107ef1:	6a 43                	push   $0x43
c0107ef3:	e8 98 ff ff ff       	call   c0107e90 <io_outb>
c0107ef8:	83 c4 08             	add    $0x8,%esp
    io_outb(counter_port, (uint8_t)counter_value);
c0107efb:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
c0107eff:	0f b6 d0             	movzbl %al,%edx
c0107f02:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
c0107f06:	52                   	push   %edx
c0107f07:	50                   	push   %eax
c0107f08:	e8 83 ff ff ff       	call   c0107e90 <io_outb>
c0107f0d:	83 c4 08             	add    $0x8,%esp
    io_outb(counter_port, (uint8_t)(counter_value >> 8));
c0107f10:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
c0107f14:	66 c1 e8 08          	shr    $0x8,%ax
c0107f18:	0f b6 d0             	movzbl %al,%edx
c0107f1b:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
c0107f1f:	52                   	push   %edx
c0107f20:	50                   	push   %eax
c0107f21:	e8 6a ff ff ff       	call   c0107e90 <io_outb>
c0107f26:	83 c4 08             	add    $0x8,%esp
}
c0107f29:	90                   	nop
c0107f2a:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0107f2d:	5b                   	pop    %ebx
c0107f2e:	5e                   	pop    %esi
c0107f2f:	5f                   	pop    %edi
c0107f30:	5d                   	pop    %ebp
c0107f31:	c3                   	ret    

c0107f32 <timer_init>:

void timer_init(){
c0107f32:	55                   	push   %ebp
c0107f33:	89 e5                	mov    %esp,%ebp
c0107f35:	83 ec 08             	sub    $0x8,%esp
    ticks = 0;
c0107f38:	c7 05 f0 b0 28 c0 00 	movl   $0x0,0xc028b0f0
c0107f3f:	00 00 00 
    kprintf("timer intr start\n");
c0107f42:	83 ec 0c             	sub    $0xc,%esp
c0107f45:	68 40 d3 28 c0       	push   $0xc028d340
c0107f4a:	e8 59 1f 00 00       	call   c0109ea8 <kprintf>
c0107f4f:	83 c4 10             	add    $0x10,%esp
    frequence_set(CURRENTR0_PORT, CURRENTR0_NO, READ_WRITE_LATCH, CURRENTR_MODE, CURRENTR0_VALUE);
c0107f52:	83 ec 0c             	sub    $0xc,%esp
c0107f55:	68 9b 2e 00 00       	push   $0x2e9b
c0107f5a:	6a 02                	push   $0x2
c0107f5c:	6a 03                	push   $0x3
c0107f5e:	6a 00                	push   $0x0
c0107f60:	6a 40                	push   $0x40
c0107f62:	e8 40 ff ff ff       	call   c0107ea7 <frequence_set>
c0107f67:	83 c4 20             	add    $0x20,%esp
    _set_idt_entry(HARDWARE_TIME_INT, 0x08, &intr_time_handler, 0);
c0107f6a:	6a 00                	push   $0x0
c0107f6c:	68 9c 85 10 c0       	push   $0xc010859c
c0107f71:	6a 08                	push   $0x8
c0107f73:	6a 20                	push   $0x20
c0107f75:	e8 d5 0a 00 00       	call   c0108a4f <_set_idt_entry>
c0107f7a:	83 c4 10             	add    $0x10,%esp
    intr_subscribe(MELOX_SYS_CALL, do_intr_time_handler);
c0107f7d:	83 ec 08             	sub    $0x8,%esp
c0107f80:	68 a6 7f 10 c0       	push   $0xc0107fa6
c0107f85:	68 80 00 00 00       	push   $0x80
c0107f8a:	e8 d8 02 00 00       	call   c0108267 <intr_subscribe>
c0107f8f:	83 c4 10             	add    $0x10,%esp
    kprintf("timer init down\n");
c0107f92:	83 ec 0c             	sub    $0xc,%esp
c0107f95:	68 52 d3 28 c0       	push   $0xc028d352
c0107f9a:	e8 09 1f 00 00       	call   c0109ea8 <kprintf>
c0107f9f:	83 c4 10             	add    $0x10,%esp
    asm("sti");
c0107fa2:	fb                   	sti    
}
c0107fa3:	90                   	nop
c0107fa4:	c9                   	leave  
c0107fa5:	c3                   	ret    

c0107fa6 <do_intr_time_handler>:

void do_intr_time_handler(isr_param int_param)
{
c0107fa6:	55                   	push   %ebp
c0107fa7:	89 e5                	mov    %esp,%ebp
c0107fa9:	83 ec 08             	sub    $0x8,%esp
    ticks++;
c0107fac:	a1 f0 b0 28 c0       	mov    0xc028b0f0,%eax
c0107fb1:	83 c0 01             	add    $0x1,%eax
c0107fb4:	a3 f0 b0 28 c0       	mov    %eax,0xc028b0f0
    __current->intr_contxt = int_param;
c0107fb9:	a1 e0 bb 28 c0       	mov    0xc028bbe0,%eax
c0107fbe:	8b 55 08             	mov    0x8(%ebp),%edx
c0107fc1:	89 50 08             	mov    %edx,0x8(%eax)
c0107fc4:	8b 55 0c             	mov    0xc(%ebp),%edx
c0107fc7:	89 50 0c             	mov    %edx,0xc(%eax)
c0107fca:	8b 55 10             	mov    0x10(%ebp),%edx
c0107fcd:	89 50 10             	mov    %edx,0x10(%eax)
c0107fd0:	8b 55 14             	mov    0x14(%ebp),%edx
c0107fd3:	89 50 14             	mov    %edx,0x14(%eax)
c0107fd6:	8b 55 18             	mov    0x18(%ebp),%edx
c0107fd9:	89 50 18             	mov    %edx,0x18(%eax)
c0107fdc:	8b 55 1c             	mov    0x1c(%ebp),%edx
c0107fdf:	89 50 1c             	mov    %edx,0x1c(%eax)
c0107fe2:	8b 55 20             	mov    0x20(%ebp),%edx
c0107fe5:	89 50 20             	mov    %edx,0x20(%eax)
c0107fe8:	8b 55 24             	mov    0x24(%ebp),%edx
c0107feb:	89 50 24             	mov    %edx,0x24(%eax)
c0107fee:	8b 55 28             	mov    0x28(%ebp),%edx
c0107ff1:	89 50 28             	mov    %edx,0x28(%eax)
c0107ff4:	8b 55 2c             	mov    0x2c(%ebp),%edx
c0107ff7:	89 50 2c             	mov    %edx,0x2c(%eax)
c0107ffa:	8b 55 30             	mov    0x30(%ebp),%edx
c0107ffd:	89 50 30             	mov    %edx,0x30(%eax)
c0108000:	8b 55 34             	mov    0x34(%ebp),%edx
c0108003:	89 50 34             	mov    %edx,0x34(%eax)
c0108006:	8b 55 38             	mov    0x38(%ebp),%edx
c0108009:	89 50 38             	mov    %edx,0x38(%eax)
c010800c:	8b 55 3c             	mov    0x3c(%ebp),%edx
c010800f:	89 50 3c             	mov    %edx,0x3c(%eax)
c0108012:	8b 55 40             	mov    0x40(%ebp),%edx
c0108015:	89 50 40             	mov    %edx,0x40(%eax)
    if(__current->pro_ticks == 0)
c0108018:	a1 e0 bb 28 c0       	mov    0xc028bbe0,%eax
c010801d:	8b 40 5c             	mov    0x5c(%eax),%eax
c0108020:	85 c0                	test   %eax,%eax
c0108022:	75 07                	jne    c010802b <do_intr_time_handler+0x85>
        schedule();
c0108024:	e8 d2 1a 00 00       	call   c0109afb <schedule>
    else
        __current->pro_ticks--;
c0108029:	eb 0e                	jmp    c0108039 <do_intr_time_handler+0x93>
        __current->pro_ticks--;
c010802b:	a1 e0 bb 28 c0       	mov    0xc028bbe0,%eax
c0108030:	8b 50 5c             	mov    0x5c(%eax),%edx
c0108033:	83 ea 01             	sub    $0x1,%edx
c0108036:	89 50 5c             	mov    %edx,0x5c(%eax)
c0108039:	90                   	nop
c010803a:	c9                   	leave  
c010803b:	c3                   	ret    

c010803c <syscall>:
void
syscall_install();

static void*
syscall(unsigned int callcode)
{
c010803c:	55                   	push   %ebp
c010803d:	89 e5                	mov    %esp,%ebp
c010803f:	57                   	push   %edi
    asm volatile("int %0" ::"i"(0x80), "D"(callcode) : "eax");
c0108040:	8b 55 08             	mov    0x8(%ebp),%edx
c0108043:	89 d7                	mov    %edx,%edi
c0108045:	cd 80                	int    $0x80
}
c0108047:	90                   	nop
c0108048:	8b 7d fc             	mov    -0x4(%ebp),%edi
c010804b:	c9                   	leave  
c010804c:	c3                   	ret    

c010804d <fork>:
#include <syscall/syscall.h>
#include <stdint.h>

typedef int32_t pid_t;

__MXSYSCALL(pid_t, fork)
c010804d:	55                   	push   %ebp
c010804e:	89 e5                	mov    %esp,%ebp
c0108050:	83 ec 10             	sub    $0x10,%esp
c0108053:	b8 01 00 00 00       	mov    $0x1,%eax
c0108058:	cd 80                	int    $0x80
c010805a:	89 45 fc             	mov    %eax,-0x4(%ebp)
c010805d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0108060:	c9                   	leave  
c0108061:	c3                   	ret    

c0108062 <getpid>:

// __MXSYSCALL1(int, sbrk, void*, addr)

// __MXSYSCALL1(void*, brk, unsigned long, size)

__MXSYSCALL(pid_t, getpid)
c0108062:	55                   	push   %ebp
c0108063:	89 e5                	mov    %esp,%ebp
c0108065:	83 ec 10             	sub    $0x10,%esp
c0108068:	b8 02 00 00 00       	mov    $0x2,%eax
c010806d:	cd 80                	int    $0x80
c010806f:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0108072:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0108075:	c9                   	leave  
c0108076:	c3                   	ret    

c0108077 <getppid>:

__MXSYSCALL(pid_t, getppid)
c0108077:	55                   	push   %ebp
c0108078:	89 e5                	mov    %esp,%ebp
c010807a:	83 ec 10             	sub    $0x10,%esp
c010807d:	b8 03 00 00 00       	mov    $0x3,%eax
c0108082:	cd 80                	int    $0x80
c0108084:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0108087:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010808a:	c9                   	leave  
c010808b:	c3                   	ret    

c010808c <_exit>:

__MXSYSCALL1(void, _exit, int, status)
c010808c:	55                   	push   %ebp
c010808d:	89 e5                	mov    %esp,%ebp
c010808f:	53                   	push   %ebx
c0108090:	83 ec 10             	sub    $0x10,%esp
c0108093:	8b 45 08             	mov    0x8(%ebp),%eax
c0108096:	89 c3                	mov    %eax,%ebx
c0108098:	b8 04 00 00 00       	mov    $0x4,%eax
c010809d:	cd 80                	int    $0x80
c010809f:	89 45 f8             	mov    %eax,-0x8(%ebp)
c01080a2:	90                   	nop
c01080a3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c01080a6:	c9                   	leave  
c01080a7:	c3                   	ret    

c01080a8 <__proc0>:
#include <syscall/meloxstd.h>

void init_platform();
extern void _mxinit_main(); /* mxinit.c */
void __proc0()
{
c01080a8:	55                   	push   %ebp
c01080a9:	89 e5                	mov    %esp,%ebp
c01080ab:	83 ec 08             	sub    $0x8,%esp
    init_platform();
c01080ae:	e8 33 00 00 00       	call   c01080e6 <init_platform>
    kprintf("This is proc0!");
c01080b3:	83 ec 0c             	sub    $0xc,%esp
c01080b6:	68 63 d3 28 c0       	push   $0xc028d363
c01080bb:	e8 e8 1d 00 00       	call   c0109ea8 <kprintf>
c01080c0:	83 c4 10             	add    $0x10,%esp
    if (!fork()) {
c01080c3:	e8 85 ff ff ff       	call   c010804d <fork>
c01080c8:	85 c0                	test   %eax,%eax
c01080ca:	75 15                	jne    c01080e1 <__proc0+0x39>
        kprintf("fork sucess!");
c01080cc:	83 ec 0c             	sub    $0xc,%esp
c01080cf:	68 72 d3 28 c0       	push   $0xc028d372
c01080d4:	e8 cf 1d 00 00       	call   c0109ea8 <kprintf>
c01080d9:	83 c4 10             	add    $0x10,%esp
        asm("jmp _mxinit_main");
c01080dc:	e9 89 00 00 00       	jmp    c010816a <_mxinit_main>
    }

    asm("1: jmp 1b");
c01080e1:	eb fe                	jmp    c01080e1 <__proc0+0x39>
}
c01080e3:	90                   	nop
c01080e4:	c9                   	leave  
c01080e5:	c3                   	ret    

c01080e6 <init_platform>:

void init_platform()
{
c01080e6:	55                   	push   %ebp
c01080e7:	89 e5                	mov    %esp,%ebp
c01080e9:	83 ec 08             	sub    $0x8,%esp
    timer_init();
c01080ec:	e8 41 fe ff ff       	call   c0107f32 <timer_init>
    init_keyboard();
c01080f1:	e8 e3 0e 00 00       	call   c0108fd9 <init_keyboard>

    syscall_install();
c01080f6:	e8 dc 11 00 00       	call   c01092d7 <syscall_install>
c01080fb:	90                   	nop
c01080fc:	c9                   	leave  
c01080fd:	c3                   	ret    

c01080fe <syscall>:
{
c01080fe:	55                   	push   %ebp
c01080ff:	89 e5                	mov    %esp,%ebp
c0108101:	57                   	push   %edi
    asm volatile("int %0" ::"i"(0x80), "D"(callcode) : "eax");
c0108102:	8b 55 08             	mov    0x8(%ebp),%edx
c0108105:	89 d7                	mov    %edx,%edi
c0108107:	cd 80                	int    $0x80
}
c0108109:	90                   	nop
c010810a:	8b 7d fc             	mov    -0x4(%ebp),%edi
c010810d:	c9                   	leave  
c010810e:	c3                   	ret    

c010810f <fork>:
__MXSYSCALL(pid_t, fork)
c010810f:	55                   	push   %ebp
c0108110:	89 e5                	mov    %esp,%ebp
c0108112:	83 ec 10             	sub    $0x10,%esp
c0108115:	b8 01 00 00 00       	mov    $0x1,%eax
c010811a:	cd 80                	int    $0x80
c010811c:	89 45 fc             	mov    %eax,-0x4(%ebp)
c010811f:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0108122:	c9                   	leave  
c0108123:	c3                   	ret    

c0108124 <getpid>:
__MXSYSCALL(pid_t, getpid)
c0108124:	55                   	push   %ebp
c0108125:	89 e5                	mov    %esp,%ebp
c0108127:	83 ec 10             	sub    $0x10,%esp
c010812a:	b8 02 00 00 00       	mov    $0x2,%eax
c010812f:	cd 80                	int    $0x80
c0108131:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0108134:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0108137:	c9                   	leave  
c0108138:	c3                   	ret    

c0108139 <getppid>:
__MXSYSCALL(pid_t, getppid)
c0108139:	55                   	push   %ebp
c010813a:	89 e5                	mov    %esp,%ebp
c010813c:	83 ec 10             	sub    $0x10,%esp
c010813f:	b8 03 00 00 00       	mov    $0x3,%eax
c0108144:	cd 80                	int    $0x80
c0108146:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0108149:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010814c:	c9                   	leave  
c010814d:	c3                   	ret    

c010814e <_exit>:
__MXSYSCALL1(void, _exit, int, status)
c010814e:	55                   	push   %ebp
c010814f:	89 e5                	mov    %esp,%ebp
c0108151:	53                   	push   %ebx
c0108152:	83 ec 10             	sub    $0x10,%esp
c0108155:	8b 45 08             	mov    0x8(%ebp),%eax
c0108158:	89 c3                	mov    %eax,%ebx
c010815a:	b8 04 00 00 00       	mov    $0x4,%eax
c010815f:	cd 80                	int    $0x80
c0108161:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0108164:	90                   	nop
c0108165:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0108168:	c9                   	leave  
c0108169:	c3                   	ret    

c010816a <_mxinit_main>:
#include <kernel/process/sched.h>
#include <syscall/meloxstd.h>
#include <syscall/syscall.h>

void _mxinit_main()
{
c010816a:	55                   	push   %ebp
c010816b:	89 e5                	mov    %esp,%ebp
c010816d:	83 ec 58             	sub    $0x58,%esp
    pid_t child = wait(&status);
    kprintf(
      "I am parent, my child (%d) terminated with code: %d.\n", child, status);
#endif

    for(int i = 0; i < 10000; i++);
c0108170:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0108177:	eb 04                	jmp    c010817d <_mxinit_main+0x13>
c0108179:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010817d:	81 7d f4 0f 27 00 00 	cmpl   $0x270f,-0xc(%ebp)
c0108184:	7e f3                	jle    c0108179 <_mxinit_main+0xf>

    for (size_t i = 0; i < 10; i++) {
c0108186:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c010818d:	e9 81 00 00 00       	jmp    c0108213 <_mxinit_main+0xa9>
        pid_t pid = 0;
c0108192:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
        if (!(pid = fork())) {
c0108199:	e8 71 ff ff ff       	call   c010810f <fork>
c010819e:	89 45 e8             	mov    %eax,-0x18(%ebp)
c01081a1:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c01081a5:	75 55                	jne    c01081fc <_mxinit_main+0x92>
            for(int i = 0; i < 10000; i++);
c01081a7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c01081ae:	eb 04                	jmp    c01081b4 <_mxinit_main+0x4a>
c01081b0:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c01081b4:	81 7d ec 0f 27 00 00 	cmpl   $0x270f,-0x14(%ebp)
c01081bb:	7e f3                	jle    c01081b0 <_mxinit_main+0x46>
            if (i == 3) {
c01081bd:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
c01081c1:	75 0a                	jne    c01081cd <_mxinit_main+0x63>
                i = *(int*)0xdeadc0de; // seg fault!
c01081c3:	b8 de c0 ad de       	mov    $0xdeadc0de,%eax
c01081c8:	8b 00                	mov    (%eax),%eax
c01081ca:	89 45 f0             	mov    %eax,-0x10(%ebp)
            }
            vga_put_char('0' + i);
c01081cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01081d0:	83 c0 30             	add    $0x30,%eax
c01081d3:	0f be c0             	movsbl %al,%eax
c01081d6:	83 ec 0c             	sub    $0xc,%esp
c01081d9:	50                   	push   %eax
c01081da:	e8 3f de ff ff       	call   c010601e <vga_put_char>
c01081df:	83 c4 10             	add    $0x10,%esp
            vga_put_char('\n');
c01081e2:	83 ec 0c             	sub    $0xc,%esp
c01081e5:	6a 0a                	push   $0xa
c01081e7:	e8 32 de ff ff       	call   c010601e <vga_put_char>
c01081ec:	83 c4 10             	add    $0x10,%esp
            _exit(0);
c01081ef:	83 ec 0c             	sub    $0xc,%esp
c01081f2:	6a 00                	push   $0x0
c01081f4:	e8 55 ff ff ff       	call   c010814e <_exit>
c01081f9:	83 c4 10             	add    $0x10,%esp
        }
        kprintf("Forked %d\n", pid);
c01081fc:	83 ec 08             	sub    $0x8,%esp
c01081ff:	ff 75 e8             	push   -0x18(%ebp)
c0108202:	68 7f d3 28 c0       	push   $0xc028d37f
c0108207:	e8 9c 1c 00 00       	call   c0109ea8 <kprintf>
c010820c:	83 c4 10             	add    $0x10,%esp
    for (size_t i = 0; i < 10; i++) {
c010820f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0108213:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
c0108217:	0f 86 75 ff ff ff    	jbe    c0108192 <_mxinit_main+0x28>
    }

    char buf[64];

    kprintf("Hello processes!\n");
c010821d:	83 ec 0c             	sub    $0xc,%esp
c0108220:	68 8a d3 28 c0       	push   $0xc028d38a
c0108225:	e8 7e 1c 00 00       	call   c0109ea8 <kprintf>
c010822a:	83 c4 10             	add    $0x10,%esp

    while(1);
c010822d:	eb fe                	jmp    c010822d <_mxinit_main+0xc3>

c010822f <io_outb>:
{
c010822f:	55                   	push   %ebp
c0108230:	89 e5                	mov    %esp,%ebp
c0108232:	83 ec 04             	sub    $0x4,%esp
c0108235:	8b 45 0c             	mov    0xc(%ebp),%eax
c0108238:	88 45 fc             	mov    %al,-0x4(%ebp)
    asm volatile("outb %0, %w1" : : "a"(data), "d"(port));
c010823b:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c010823f:	8b 55 08             	mov    0x8(%ebp),%edx
c0108242:	ee                   	out    %al,(%dx)
}
c0108243:	90                   	nop
c0108244:	c9                   	leave  
c0108245:	c3                   	ret    

c0108246 <pic_end_eoi>:

static inline void cpu_delay(){
    for(int i = 0; i < 3; i++);
}

static inline void pic_end_eoi(){
c0108246:	55                   	push   %ebp
c0108247:	89 e5                	mov    %esp,%ebp
    io_outb(0x20, 0x20);
c0108249:	6a 20                	push   $0x20
c010824b:	6a 20                	push   $0x20
c010824d:	e8 dd ff ff ff       	call   c010822f <io_outb>
c0108252:	83 c4 08             	add    $0x8,%esp
    io_outb(0xa0, 0x20);//EOI end the int
c0108255:	6a 20                	push   $0x20
c0108257:	68 a0 00 00 00       	push   $0xa0
c010825c:	e8 ce ff ff ff       	call   c010822f <io_outb>
c0108261:	83 c4 08             	add    $0x8,%esp
}
c0108264:	90                   	nop
c0108265:	c9                   	leave  
c0108266:	c3                   	ret    

c0108267 <intr_subscribe>:
#include <kernel/process/peocess.h>
#include <kernel/cpu/io.h>

static int_subscriber subscribers[256];

void intr_subscribe(const uint8_t vector, int_subscriber subscriber) {
c0108267:	55                   	push   %ebp
c0108268:	89 e5                	mov    %esp,%ebp
c010826a:	83 ec 04             	sub    $0x4,%esp
c010826d:	8b 45 08             	mov    0x8(%ebp),%eax
c0108270:	88 45 fc             	mov    %al,-0x4(%ebp)
    subscribers[vector] = subscriber;
c0108273:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0108277:	8b 55 0c             	mov    0xc(%ebp),%edx
c010827a:	89 14 85 00 b1 28 c0 	mov    %edx,-0x3fd74f00(,%eax,4)
}
c0108281:	90                   	nop
c0108282:	c9                   	leave  
c0108283:	c3                   	ret    

c0108284 <intr_unsubscribe>:

void intr_unsubscribe(const uint8_t vector, int_subscriber subscriber) {
c0108284:	55                   	push   %ebp
c0108285:	89 e5                	mov    %esp,%ebp
c0108287:	83 ec 04             	sub    $0x4,%esp
c010828a:	8b 45 08             	mov    0x8(%ebp),%eax
c010828d:	88 45 fc             	mov    %al,-0x4(%ebp)
    if (subscribers[vector] == subscriber) {
c0108290:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0108294:	8b 04 85 00 b1 28 c0 	mov    -0x3fd74f00(,%eax,4),%eax
c010829b:	39 45 0c             	cmp    %eax,0xc(%ebp)
c010829e:	75 0f                	jne    c01082af <intr_unsubscribe+0x2b>
        subscribers[vector] = (int_subscriber) 0;
c01082a0:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c01082a4:	c7 04 85 00 b1 28 c0 	movl   $0x0,-0x3fd74f00(,%eax,4)
c01082ab:	00 00 00 00 
    }
}
c01082af:	90                   	nop
c01082b0:	c9                   	leave  
c01082b1:	c3                   	ret    

c01082b2 <intr_handler>:

void intr_handler(isr_param* param)
{
c01082b2:	55                   	push   %ebp
c01082b3:	89 e5                	mov    %esp,%ebp
c01082b5:	53                   	push   %ebx
c01082b6:	83 ec 14             	sub    $0x14,%esp
	__current->intr_contxt = *param;
c01082b9:	a1 e0 bb 28 c0       	mov    0xc028bbe0,%eax
c01082be:	8b 55 08             	mov    0x8(%ebp),%edx
c01082c1:	8b 0a                	mov    (%edx),%ecx
c01082c3:	89 48 08             	mov    %ecx,0x8(%eax)
c01082c6:	8b 4a 04             	mov    0x4(%edx),%ecx
c01082c9:	89 48 0c             	mov    %ecx,0xc(%eax)
c01082cc:	8b 4a 08             	mov    0x8(%edx),%ecx
c01082cf:	89 48 10             	mov    %ecx,0x10(%eax)
c01082d2:	8b 4a 0c             	mov    0xc(%edx),%ecx
c01082d5:	89 48 14             	mov    %ecx,0x14(%eax)
c01082d8:	8b 4a 10             	mov    0x10(%edx),%ecx
c01082db:	89 48 18             	mov    %ecx,0x18(%eax)
c01082de:	8b 4a 14             	mov    0x14(%edx),%ecx
c01082e1:	89 48 1c             	mov    %ecx,0x1c(%eax)
c01082e4:	8b 4a 18             	mov    0x18(%edx),%ecx
c01082e7:	89 48 20             	mov    %ecx,0x20(%eax)
c01082ea:	8b 4a 1c             	mov    0x1c(%edx),%ecx
c01082ed:	89 48 24             	mov    %ecx,0x24(%eax)
c01082f0:	8b 4a 20             	mov    0x20(%edx),%ecx
c01082f3:	89 48 28             	mov    %ecx,0x28(%eax)
c01082f6:	8b 4a 24             	mov    0x24(%edx),%ecx
c01082f9:	89 48 2c             	mov    %ecx,0x2c(%eax)
c01082fc:	8b 4a 28             	mov    0x28(%edx),%ecx
c01082ff:	89 48 30             	mov    %ecx,0x30(%eax)
c0108302:	8b 4a 2c             	mov    0x2c(%edx),%ecx
c0108305:	89 48 34             	mov    %ecx,0x34(%eax)
c0108308:	8b 4a 30             	mov    0x30(%edx),%ecx
c010830b:	89 48 38             	mov    %ecx,0x38(%eax)
c010830e:	8b 4a 34             	mov    0x34(%edx),%ecx
c0108311:	89 48 3c             	mov    %ecx,0x3c(%eax)
c0108314:	8b 52 38             	mov    0x38(%edx),%edx
c0108317:	89 50 40             	mov    %edx,0x40(%eax)
    cpu_lcr3(__kernel_ptd);

    vmm_mount_pd(PD_MOUNT_1, __current->page_table);
#endif

    isr_param *lparam = &__current->intr_contxt;
c010831a:	a1 e0 bb 28 c0       	mov    0xc028bbe0,%eax
c010831f:	83 c0 08             	add    $0x8,%eax
c0108322:	89 45 f4             	mov    %eax,-0xc(%ebp)
    
    if (lparam->vector <= 255) {
c0108325:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108328:	8b 40 20             	mov    0x20(%eax),%eax
c010832b:	3d ff 00 00 00       	cmp    $0xff,%eax
c0108330:	77 26                	ja     c0108358 <intr_handler+0xa6>
        int_subscriber subscriber = subscribers[lparam->vector];
c0108332:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108335:	8b 40 20             	mov    0x20(%eax),%eax
c0108338:	8b 04 85 00 b1 28 c0 	mov    -0x3fd74f00(,%eax,4),%eax
c010833f:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if (subscriber) {
c0108342:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0108346:	74 10                	je     c0108358 <intr_handler+0xa6>
            subscriber(param);
c0108348:	83 ec 0c             	sub    $0xc,%esp
c010834b:	ff 75 08             	push   0x8(%ebp)
c010834e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0108351:	ff d0                	call   *%eax
c0108353:	83 c4 10             	add    $0x10,%esp
            goto done;
c0108356:	eb 2c                	jmp    c0108384 <intr_handler+0xd2>
    // if (fallback) {
    //     fallback(lparam);
    //     goto done;
    // }
    
    kprintf("INT %x: (%x) [%x: %x] Unknown",
c0108358:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010835b:	8b 58 28             	mov    0x28(%eax),%ebx
c010835e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108361:	8b 48 2c             	mov    0x2c(%eax),%ecx
c0108364:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108367:	8b 50 24             	mov    0x24(%eax),%edx
c010836a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010836d:	8b 40 20             	mov    0x20(%eax),%eax
c0108370:	83 ec 0c             	sub    $0xc,%esp
c0108373:	53                   	push   %ebx
c0108374:	51                   	push   %ecx
c0108375:	52                   	push   %edx
c0108376:	50                   	push   %eax
c0108377:	68 9c d3 28 c0       	push   $0xc028d39c
c010837c:	e8 27 1b 00 00       	call   c0109ea8 <kprintf>
c0108381:	83 c4 20             	add    $0x20,%esp
            lparam->eip);

done:
    // for all external interrupts except the spurious interrupt
    //  this is required by Intel Manual Vol.3A, section 10.8.1 & 10.8.5
    if (lparam->vector >= EXTERN_INTER) {
c0108384:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108387:	8b 40 20             	mov    0x20(%eax),%eax
c010838a:	83 f8 1f             	cmp    $0x1f,%eax
c010838d:	76 06                	jbe    c0108395 <intr_handler+0xe3>
        pic_end_eoi();
c010838f:	e8 b2 fe ff ff       	call   c0108246 <pic_end_eoi>
	}

#ifdef USE_KERNEL_PT
    cpu_lcr3(__current->page_table);
#endif
    return;
c0108394:	90                   	nop
c0108395:	90                   	nop
}
c0108396:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0108399:	c9                   	leave  
c010839a:	c3                   	ret    

c010839b <_divide_err>:

void _divide_err(unsigned long addr, int err_code)
{
c010839b:	55                   	push   %ebp
c010839c:	89 e5                	mov    %esp,%ebp
c010839e:	83 ec 08             	sub    $0x8,%esp
    vga_set_show(1,VGA_COLOR_BLACK,VGA_COLOR_BLUE);
c01083a1:	83 ec 04             	sub    $0x4,%esp
c01083a4:	6a 01                	push   $0x1
c01083a6:	6a 00                	push   $0x0
c01083a8:	6a 01                	push   $0x1
c01083aa:	e8 25 dd ff ff       	call   c01060d4 <vga_set_show>
c01083af:	83 c4 10             	add    $0x10,%esp
    kprintf("divide err addr = 0x%x,err code = %d\n", addr,err_code);
c01083b2:	83 ec 04             	sub    $0x4,%esp
c01083b5:	ff 75 0c             	push   0xc(%ebp)
c01083b8:	ff 75 08             	push   0x8(%ebp)
c01083bb:	68 bc d3 28 c0       	push   $0xc028d3bc
c01083c0:	e8 e3 1a 00 00       	call   c0109ea8 <kprintf>
c01083c5:	83 c4 10             	add    $0x10,%esp
}
c01083c8:	90                   	nop
c01083c9:	c9                   	leave  
c01083ca:	c3                   	ret    

c01083cb <do_double_fault>:

void do_double_fault(unsigned long addr, int err_code)
{
c01083cb:	55                   	push   %ebp
c01083cc:	89 e5                	mov    %esp,%ebp
c01083ce:	83 ec 08             	sub    $0x8,%esp
	kprintf("double_fault addr = 0x%x,err code = %d\n", addr,err_code);
c01083d1:	83 ec 04             	sub    $0x4,%esp
c01083d4:	ff 75 0c             	push   0xc(%ebp)
c01083d7:	ff 75 08             	push   0x8(%ebp)
c01083da:	68 e4 d3 28 c0       	push   $0xc028d3e4
c01083df:	e8 c4 1a 00 00       	call   c0109ea8 <kprintf>
c01083e4:	83 c4 10             	add    $0x10,%esp
}
c01083e7:	90                   	nop
c01083e8:	c9                   	leave  
c01083e9:	c3                   	ret    

c01083ea <do_general_protection>:

void do_general_protection(unsigned long addr, int err_code)
{
c01083ea:	55                   	push   %ebp
c01083eb:	89 e5                	mov    %esp,%ebp
c01083ed:	83 ec 08             	sub    $0x8,%esp
	kprintf("general_protection addr = 0x%x,err code = %d\n", addr,err_code);
c01083f0:	83 ec 04             	sub    $0x4,%esp
c01083f3:	ff 75 0c             	push   0xc(%ebp)
c01083f6:	ff 75 08             	push   0x8(%ebp)
c01083f9:	68 0c d4 28 c0       	push   $0xc028d40c
c01083fe:	e8 a5 1a 00 00       	call   c0109ea8 <kprintf>
c0108403:	83 c4 10             	add    $0x10,%esp
}
c0108406:	90                   	nop
c0108407:	c9                   	leave  
c0108408:	c3                   	ret    

c0108409 <do_int3>:


void do_int3(unsigned long addr, int err_code)
{
c0108409:	55                   	push   %ebp
c010840a:	89 e5                	mov    %esp,%ebp
c010840c:	83 ec 08             	sub    $0x8,%esp
    kprintf("int3 addr = 0x%x,err code = %d\n", addr,err_code);
c010840f:	83 ec 04             	sub    $0x4,%esp
c0108412:	ff 75 0c             	push   0xc(%ebp)
c0108415:	ff 75 08             	push   0x8(%ebp)
c0108418:	68 3c d4 28 c0       	push   $0xc028d43c
c010841d:	e8 86 1a 00 00       	call   c0109ea8 <kprintf>
c0108422:	83 c4 10             	add    $0x10,%esp
}
c0108425:	90                   	nop
c0108426:	c9                   	leave  
c0108427:	c3                   	ret    

c0108428 <do_nmi>:

void do_nmi(unsigned long addr, int err_code)
{
c0108428:	55                   	push   %ebp
c0108429:	89 e5                	mov    %esp,%ebp
c010842b:	83 ec 08             	sub    $0x8,%esp
	kprintf("nmi addr = 0x%x,err code = %d\n", addr,err_code);
c010842e:	83 ec 04             	sub    $0x4,%esp
c0108431:	ff 75 0c             	push   0xc(%ebp)
c0108434:	ff 75 08             	push   0x8(%ebp)
c0108437:	68 5c d4 28 c0       	push   $0xc028d45c
c010843c:	e8 67 1a 00 00       	call   c0109ea8 <kprintf>
c0108441:	83 c4 10             	add    $0x10,%esp
}
c0108444:	90                   	nop
c0108445:	c9                   	leave  
c0108446:	c3                   	ret    

c0108447 <do_debug>:

void do_debug(unsigned long addr, int err_code)
{
c0108447:	55                   	push   %ebp
c0108448:	89 e5                	mov    %esp,%ebp
c010844a:	83 ec 08             	sub    $0x8,%esp
	kprintf("debug addr = 0x%x,err code = %d\n", addr,err_code);
c010844d:	83 ec 04             	sub    $0x4,%esp
c0108450:	ff 75 0c             	push   0xc(%ebp)
c0108453:	ff 75 08             	push   0x8(%ebp)
c0108456:	68 7c d4 28 c0       	push   $0xc028d47c
c010845b:	e8 48 1a 00 00       	call   c0109ea8 <kprintf>
c0108460:	83 c4 10             	add    $0x10,%esp
}
c0108463:	90                   	nop
c0108464:	c9                   	leave  
c0108465:	c3                   	ret    

c0108466 <do_overflow>:

void do_overflow(unsigned long addr, int err_code)
{
c0108466:	55                   	push   %ebp
c0108467:	89 e5                	mov    %esp,%ebp
c0108469:	83 ec 08             	sub    $0x8,%esp
	kprintf("overflow addr = 0x%x,err code = %d\n", addr,err_code);
c010846c:	83 ec 04             	sub    $0x4,%esp
c010846f:	ff 75 0c             	push   0xc(%ebp)
c0108472:	ff 75 08             	push   0x8(%ebp)
c0108475:	68 a0 d4 28 c0       	push   $0xc028d4a0
c010847a:	e8 29 1a 00 00       	call   c0109ea8 <kprintf>
c010847f:	83 c4 10             	add    $0x10,%esp
}
c0108482:	90                   	nop
c0108483:	c9                   	leave  
c0108484:	c3                   	ret    

c0108485 <do_bounds>:

void do_bounds(unsigned long addr, int err_code)
{
c0108485:	55                   	push   %ebp
c0108486:	89 e5                	mov    %esp,%ebp
c0108488:	83 ec 08             	sub    $0x8,%esp
	kprintf("bounds addr = 0x%x,err code = %d\n", addr,err_code);
c010848b:	83 ec 04             	sub    $0x4,%esp
c010848e:	ff 75 0c             	push   0xc(%ebp)
c0108491:	ff 75 08             	push   0x8(%ebp)
c0108494:	68 c4 d4 28 c0       	push   $0xc028d4c4
c0108499:	e8 0a 1a 00 00       	call   c0109ea8 <kprintf>
c010849e:	83 c4 10             	add    $0x10,%esp
}
c01084a1:	90                   	nop
c01084a2:	c9                   	leave  
c01084a3:	c3                   	ret    

c01084a4 <do_invalid_op>:

void do_invalid_op(unsigned long addr, int err_code)
{
c01084a4:	55                   	push   %ebp
c01084a5:	89 e5                	mov    %esp,%ebp
c01084a7:	83 ec 08             	sub    $0x8,%esp
	kprintf("invalid_op addr = 0x%x,err code = %d\n", addr,err_code);
c01084aa:	83 ec 04             	sub    $0x4,%esp
c01084ad:	ff 75 0c             	push   0xc(%ebp)
c01084b0:	ff 75 08             	push   0x8(%ebp)
c01084b3:	68 e8 d4 28 c0       	push   $0xc028d4e8
c01084b8:	e8 eb 19 00 00       	call   c0109ea8 <kprintf>
c01084bd:	83 c4 10             	add    $0x10,%esp
}
c01084c0:	90                   	nop
c01084c1:	c9                   	leave  
c01084c2:	c3                   	ret    

c01084c3 <do_device_not_available>:

void do_device_not_available(unsigned long addr, int err_code)
{
c01084c3:	55                   	push   %ebp
c01084c4:	89 e5                	mov    %esp,%ebp
c01084c6:	83 ec 08             	sub    $0x8,%esp
	kprintf("device_not_availabel addr = 0x%x,err code = %d\n", addr,err_code);
c01084c9:	83 ec 04             	sub    $0x4,%esp
c01084cc:	ff 75 0c             	push   0xc(%ebp)
c01084cf:	ff 75 08             	push   0x8(%ebp)
c01084d2:	68 10 d5 28 c0       	push   $0xc028d510
c01084d7:	e8 cc 19 00 00       	call   c0109ea8 <kprintf>
c01084dc:	83 c4 10             	add    $0x10,%esp
}
c01084df:	90                   	nop
c01084e0:	c9                   	leave  
c01084e1:	c3                   	ret    

c01084e2 <do_coprocessor_segment_overrun>:

void do_coprocessor_segment_overrun(unsigned long addr, int err_code)
{
c01084e2:	55                   	push   %ebp
c01084e3:	89 e5                	mov    %esp,%ebp
c01084e5:	83 ec 08             	sub    $0x8,%esp
	kprintf("coprprocessor_segment_overrun addr = 0x%x,err code = %d\n", addr,err_code);
c01084e8:	83 ec 04             	sub    $0x4,%esp
c01084eb:	ff 75 0c             	push   0xc(%ebp)
c01084ee:	ff 75 08             	push   0x8(%ebp)
c01084f1:	68 40 d5 28 c0       	push   $0xc028d540
c01084f6:	e8 ad 19 00 00       	call   c0109ea8 <kprintf>
c01084fb:	83 c4 10             	add    $0x10,%esp
}
c01084fe:	90                   	nop
c01084ff:	c9                   	leave  
c0108500:	c3                   	ret    

c0108501 <do_invalid_TSS>:

void do_invalid_TSS(unsigned long addr, int err_code)
{
c0108501:	55                   	push   %ebp
c0108502:	89 e5                	mov    %esp,%ebp
c0108504:	83 ec 08             	sub    $0x8,%esp
	kprintf("invalid_TSS addr = 0x%x,err code = %d\n", addr,err_code);
c0108507:	83 ec 04             	sub    $0x4,%esp
c010850a:	ff 75 0c             	push   0xc(%ebp)
c010850d:	ff 75 08             	push   0x8(%ebp)
c0108510:	68 7c d5 28 c0       	push   $0xc028d57c
c0108515:	e8 8e 19 00 00       	call   c0109ea8 <kprintf>
c010851a:	83 c4 10             	add    $0x10,%esp
}
c010851d:	90                   	nop
c010851e:	c9                   	leave  
c010851f:	c3                   	ret    

c0108520 <do_segment_not_present>:

void do_segment_not_present(unsigned long addr, int err_code)
{
c0108520:	55                   	push   %ebp
c0108521:	89 e5                	mov    %esp,%ebp
c0108523:	83 ec 08             	sub    $0x8,%esp
	kprintf("segment not present addr = 0x%x,err code = %d\n", addr,err_code);
c0108526:	83 ec 04             	sub    $0x4,%esp
c0108529:	ff 75 0c             	push   0xc(%ebp)
c010852c:	ff 75 08             	push   0x8(%ebp)
c010852f:	68 a4 d5 28 c0       	push   $0xc028d5a4
c0108534:	e8 6f 19 00 00       	call   c0109ea8 <kprintf>
c0108539:	83 c4 10             	add    $0x10,%esp
}
c010853c:	90                   	nop
c010853d:	c9                   	leave  
c010853e:	c3                   	ret    

c010853f <do_stack_segment>:

void do_stack_segment(unsigned long addr, int err_code)
{
c010853f:	55                   	push   %ebp
c0108540:	89 e5                	mov    %esp,%ebp
c0108542:	83 ec 08             	sub    $0x8,%esp
	kprintf("stack_segment addr = 0x%x,err code = %d\n", addr,err_code);
c0108545:	83 ec 04             	sub    $0x4,%esp
c0108548:	ff 75 0c             	push   0xc(%ebp)
c010854b:	ff 75 08             	push   0x8(%ebp)
c010854e:	68 d4 d5 28 c0       	push   $0xc028d5d4
c0108553:	e8 50 19 00 00       	call   c0109ea8 <kprintf>
c0108558:	83 c4 10             	add    $0x10,%esp
}
c010855b:	90                   	nop
c010855c:	c9                   	leave  
c010855d:	c3                   	ret    

c010855e <do_coprocessor_error>:

void do_coprocessor_error(unsigned long addr, int err_code)
{
c010855e:	55                   	push   %ebp
c010855f:	89 e5                	mov    %esp,%ebp
c0108561:	83 ec 08             	sub    $0x8,%esp
    kprintf("coprocessor_err addr = 0x%x,err code = %d\n", addr,err_code);
c0108564:	83 ec 04             	sub    $0x4,%esp
c0108567:	ff 75 0c             	push   0xc(%ebp)
c010856a:	ff 75 08             	push   0x8(%ebp)
c010856d:	68 00 d6 28 c0       	push   $0xc028d600
c0108572:	e8 31 19 00 00       	call   c0109ea8 <kprintf>
c0108577:	83 c4 10             	add    $0x10,%esp
}
c010857a:	90                   	nop
c010857b:	c9                   	leave  
c010857c:	c3                   	ret    

c010857d <do_reserved>:

void do_reserved(unsigned long addr, int err_code)
{
c010857d:	55                   	push   %ebp
c010857e:	89 e5                	mov    %esp,%ebp
c0108580:	83 ec 08             	sub    $0x8,%esp
	kprintf("reserved addr = 0x%x,err code = %d\n", addr,err_code);
c0108583:	83 ec 04             	sub    $0x4,%esp
c0108586:	ff 75 0c             	push   0xc(%ebp)
c0108589:	ff 75 08             	push   0x8(%ebp)
c010858c:	68 2c d6 28 c0       	push   $0xc028d62c
c0108591:	e8 12 19 00 00       	call   c0109ea8 <kprintf>
c0108596:	83 c4 10             	add    $0x10,%esp
}
c0108599:	90                   	nop
c010859a:	c9                   	leave  
c010859b:	c3                   	ret    

c010859c <intr_time_handler>:
c010859c:	6a 00                	push   $0x0
c010859e:	6a 20                	push   $0x20
c01085a0:	eb 09                	jmp    c01085ab <interrupt_wrapper>

c01085a2 <intr_syscall_handler>:
c01085a2:	6a 00                	push   $0x0
c01085a4:	68 80 00 00 00       	push   $0x80
c01085a9:	eb 00                	jmp    c01085ab <interrupt_wrapper>

c01085ab <interrupt_wrapper>:
c01085ab:	54                   	push   %esp
c01085ac:	56                   	push   %esi
c01085ad:	55                   	push   %ebp
c01085ae:	57                   	push   %edi
c01085af:	52                   	push   %edx
c01085b0:	51                   	push   %ecx
c01085b1:	53                   	push   %ebx
c01085b2:	50                   	push   %eax
c01085b3:	89 e0                	mov    %esp,%eax
c01085b5:	83 e4 f0             	and    $0xfffffff0,%esp
c01085b8:	83 ec 10             	sub    $0x10,%esp
c01085bb:	89 04 24             	mov    %eax,(%esp)
c01085be:	e8 ef fc ff ff       	call   c01082b2 <intr_handler>

c01085c3 <soft_iret>:
c01085c3:	5c                   	pop    %esp
c01085c4:	58                   	pop    %eax
c01085c5:	5b                   	pop    %ebx
c01085c6:	59                   	pop    %ecx
c01085c7:	5a                   	pop    %edx
c01085c8:	5f                   	pop    %edi
c01085c9:	5d                   	pop    %ebp
c01085ca:	5e                   	pop    %esi
c01085cb:	5c                   	pop    %esp
c01085cc:	83 c4 08             	add    $0x8,%esp
c01085cf:	cf                   	iret   

c01085d0 <_no_err_code>:
c01085d0:	87 04 24             	xchg   %eax,(%esp)
c01085d3:	53                   	push   %ebx
c01085d4:	51                   	push   %ecx
c01085d5:	52                   	push   %edx
c01085d6:	57                   	push   %edi
c01085d7:	56                   	push   %esi
c01085d8:	55                   	push   %ebp
c01085d9:	1e                   	push   %ds
c01085da:	06                   	push   %es
c01085db:	0f a0                	push   %fs
c01085dd:	6a 00                	push   $0x0
c01085df:	8d 54 24 2c          	lea    0x2c(%esp),%edx
c01085e3:	52                   	push   %edx
c01085e4:	ba 10 00 00 00       	mov    $0x10,%edx
c01085e9:	8e da                	mov    %edx,%ds
c01085eb:	8e c2                	mov    %edx,%es
c01085ed:	8e e2                	mov    %edx,%fs
c01085ef:	ff d0                	call   *%eax
c01085f1:	83 c4 08             	add    $0x8,%esp
c01085f4:	0f a1                	pop    %fs
c01085f6:	07                   	pop    %es
c01085f7:	1f                   	pop    %ds
c01085f8:	5d                   	pop    %ebp
c01085f9:	5e                   	pop    %esi
c01085fa:	5f                   	pop    %edi
c01085fb:	5a                   	pop    %edx
c01085fc:	59                   	pop    %ecx
c01085fd:	5b                   	pop    %ebx
c01085fe:	58                   	pop    %eax
c01085ff:	cf                   	iret   

c0108600 <_err_code>:
c0108600:	87 44 24 04          	xchg   %eax,0x4(%esp)
c0108604:	87 1c 24             	xchg   %ebx,(%esp)
c0108607:	51                   	push   %ecx
c0108608:	52                   	push   %edx
c0108609:	57                   	push   %edi
c010860a:	56                   	push   %esi
c010860b:	55                   	push   %ebp
c010860c:	1e                   	push   %ds
c010860d:	06                   	push   %es
c010860e:	0f a0                	push   %fs
c0108610:	50                   	push   %eax
c0108611:	8d 44 24 2c          	lea    0x2c(%esp),%eax
c0108615:	50                   	push   %eax
c0108616:	b8 10 00 00 00       	mov    $0x10,%eax
c010861b:	8e d8                	mov    %eax,%ds
c010861d:	8e c0                	mov    %eax,%es
c010861f:	8e e0                	mov    %eax,%fs
c0108621:	ff d3                	call   *%ebx
c0108623:	83 c4 08             	add    $0x8,%esp
c0108626:	0f a1                	pop    %fs
c0108628:	07                   	pop    %es
c0108629:	1f                   	pop    %ds
c010862a:	5d                   	pop    %ebp
c010862b:	5e                   	pop    %esi
c010862c:	5f                   	pop    %edi
c010862d:	5a                   	pop    %edx
c010862e:	59                   	pop    %ecx
c010862f:	5b                   	pop    %ebx
c0108630:	58                   	pop    %eax
c0108631:	cf                   	iret   

c0108632 <divide_error>:
c0108632:	68 9b 83 10 c0       	push   $0xc010839b
c0108637:	eb 97                	jmp    c01085d0 <_no_err_code>

c0108639 <debug>:
c0108639:	68 09 84 10 c0       	push   $0xc0108409
c010863e:	eb 90                	jmp    c01085d0 <_no_err_code>

c0108640 <nmi>:
c0108640:	68 28 84 10 c0       	push   $0xc0108428
c0108645:	eb 89                	jmp    c01085d0 <_no_err_code>

c0108647 <int3>:
c0108647:	68 09 84 10 c0       	push   $0xc0108409
c010864c:	eb 82                	jmp    c01085d0 <_no_err_code>

c010864e <overflow>:
c010864e:	68 66 84 10 c0       	push   $0xc0108466
c0108653:	e9 78 ff ff ff       	jmp    c01085d0 <_no_err_code>

c0108658 <bounds>:
c0108658:	68 85 84 10 c0       	push   $0xc0108485
c010865d:	e9 6e ff ff ff       	jmp    c01085d0 <_no_err_code>

c0108662 <invalid_op>:
c0108662:	68 a4 84 10 c0       	push   $0xc01084a4
c0108667:	e9 64 ff ff ff       	jmp    c01085d0 <_no_err_code>

c010866c <coprocessor_segment_overrun>:
c010866c:	68 e2 84 10 c0       	push   $0xc01084e2
c0108671:	e9 5a ff ff ff       	jmp    c01085d0 <_no_err_code>

c0108676 <reserved>:
c0108676:	68 7d 85 10 c0       	push   $0xc010857d
c010867b:	e9 50 ff ff ff       	jmp    c01085d0 <_no_err_code>

c0108680 <invalid_TSS>:
c0108680:	68 01 85 10 c0       	push   $0xc0108501
c0108685:	e9 76 ff ff ff       	jmp    c0108600 <_err_code>

c010868a <segment_not_present>:
c010868a:	68 20 85 10 c0       	push   $0xc0108520
c010868f:	e9 6c ff ff ff       	jmp    c0108600 <_err_code>

c0108694 <stack_segment>:
c0108694:	68 3f 85 10 c0       	push   $0xc010853f
c0108699:	e9 62 ff ff ff       	jmp    c0108600 <_err_code>

c010869e <general_protection>:
c010869e:	68 ea 83 10 c0       	push   $0xc01083ea
c01086a3:	e9 58 ff ff ff       	jmp    c0108600 <_err_code>

c01086a8 <__get_cpuid_max>:
   pointer is non-null, then first four bytes of the signature
   (as found in ebx register) are returned in location pointed by sig.  */

static __inline unsigned int
__get_cpuid_max (unsigned int __ext, unsigned int *__sig)
{
c01086a8:	55                   	push   %ebp
c01086a9:	89 e5                	mov    %esp,%ebp
c01086ab:	53                   	push   %ebx
c01086ac:	83 ec 10             	sub    $0x10,%esp
  unsigned int __eax, __ebx, __ecx, __edx;

#ifndef __x86_64__
  /* See if we can use cpuid.  On AMD64 we always can.  */
#if __GNUC__ >= 3
  __asm__ ("pushf{l|d}\n\t"
c01086af:	9c                   	pushf  
c01086b0:	9c                   	pushf  
c01086b1:	5a                   	pop    %edx
c01086b2:	89 d0                	mov    %edx,%eax
c01086b4:	81 f2 00 00 20 00    	xor    $0x200000,%edx
c01086ba:	52                   	push   %edx
c01086bb:	9d                   	popf   
c01086bc:	9c                   	pushf  
c01086bd:	5a                   	pop    %edx
c01086be:	9d                   	popf   
c01086bf:	89 55 f8             	mov    %edx,-0x8(%ebp)
c01086c2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	   "popfl\n\t"
	   : "=&r" (__eax), "=&r" (__ebx)
	   : "i" (0x00200000));
#endif

  if (!((__eax ^ __ebx) & 0x00200000))
c01086c5:	8b 45 f8             	mov    -0x8(%ebp),%eax
c01086c8:	33 45 f4             	xor    -0xc(%ebp),%eax
c01086cb:	25 00 00 20 00       	and    $0x200000,%eax
c01086d0:	85 c0                	test   %eax,%eax
c01086d2:	75 07                	jne    c01086db <__get_cpuid_max+0x33>
    return 0;
c01086d4:	b8 00 00 00 00       	mov    $0x0,%eax
c01086d9:	eb 30                	jmp    c010870b <__get_cpuid_max+0x63>
#endif

  /* Host supports cpuid.  Return highest supported cpuid input value.  */
  __cpuid (__ext, __eax, __ebx, __ecx, __edx);
c01086db:	8b 45 08             	mov    0x8(%ebp),%eax
c01086de:	b9 00 00 00 00       	mov    $0x0,%ecx
c01086e3:	ba 00 00 00 00       	mov    $0x0,%edx
c01086e8:	89 cb                	mov    %ecx,%ebx
c01086ea:	89 d1                	mov    %edx,%ecx
c01086ec:	0f a2                	cpuid  
c01086ee:	89 45 f8             	mov    %eax,-0x8(%ebp)
c01086f1:	89 5d f4             	mov    %ebx,-0xc(%ebp)
c01086f4:	89 4d f0             	mov    %ecx,-0x10(%ebp)
c01086f7:	89 55 ec             	mov    %edx,-0x14(%ebp)

  if (__sig)
c01086fa:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c01086fe:	74 08                	je     c0108708 <__get_cpuid_max+0x60>
    *__sig = __ebx;
c0108700:	8b 45 0c             	mov    0xc(%ebp),%eax
c0108703:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0108706:	89 10                	mov    %edx,(%eax)

  return __eax;
c0108708:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
c010870b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c010870e:	c9                   	leave  
c010870f:	c3                   	ret    

c0108710 <__get_cpuid>:

static __inline int
__get_cpuid (unsigned int __leaf,
	     unsigned int *__eax, unsigned int *__ebx,
	     unsigned int *__ecx, unsigned int *__edx)
{
c0108710:	55                   	push   %ebp
c0108711:	89 e5                	mov    %esp,%ebp
c0108713:	56                   	push   %esi
c0108714:	53                   	push   %ebx
c0108715:	83 ec 10             	sub    $0x10,%esp
  unsigned int __ext = __leaf & 0x80000000;
c0108718:	8b 45 08             	mov    0x8(%ebp),%eax
c010871b:	25 00 00 00 80       	and    $0x80000000,%eax
c0108720:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned int __maxlevel = __get_cpuid_max (__ext, 0);
c0108723:	6a 00                	push   $0x0
c0108725:	ff 75 f4             	push   -0xc(%ebp)
c0108728:	e8 7b ff ff ff       	call   c01086a8 <__get_cpuid_max>
c010872d:	83 c4 08             	add    $0x8,%esp
c0108730:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if (__maxlevel == 0 || __maxlevel < __leaf)
c0108733:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0108737:	74 08                	je     c0108741 <__get_cpuid+0x31>
c0108739:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010873c:	3b 45 08             	cmp    0x8(%ebp),%eax
c010873f:	73 07                	jae    c0108748 <__get_cpuid+0x38>
    return 0;
c0108741:	b8 00 00 00 00       	mov    $0x0,%eax
c0108746:	eb 2c                	jmp    c0108774 <__get_cpuid+0x64>

  __cpuid (__leaf, *__eax, *__ebx, *__ecx, *__edx);
c0108748:	8b 45 08             	mov    0x8(%ebp),%eax
c010874b:	b9 00 00 00 00       	mov    $0x0,%ecx
c0108750:	ba 00 00 00 00       	mov    $0x0,%edx
c0108755:	89 cb                	mov    %ecx,%ebx
c0108757:	89 d1                	mov    %edx,%ecx
c0108759:	0f a2                	cpuid  
c010875b:	8b 75 0c             	mov    0xc(%ebp),%esi
c010875e:	89 06                	mov    %eax,(%esi)
c0108760:	8b 45 10             	mov    0x10(%ebp),%eax
c0108763:	89 18                	mov    %ebx,(%eax)
c0108765:	8b 45 14             	mov    0x14(%ebp),%eax
c0108768:	89 08                	mov    %ecx,(%eax)
c010876a:	8b 45 18             	mov    0x18(%ebp),%eax
c010876d:	89 10                	mov    %edx,(%eax)
  return 1;
c010876f:	b8 01 00 00 00       	mov    $0x1,%eax
}
c0108774:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0108777:	5b                   	pop    %ebx
c0108778:	5e                   	pop    %esi
c0108779:	5d                   	pop    %ebp
c010877a:	c3                   	ret    

c010877b <cpu_get_model>:
#include <kernel/cpu/cpu.h>
#include <stdint.h>
#include <cpuid.h>

void cpu_get_model(char* model_out) {
c010877b:	55                   	push   %ebp
c010877c:	89 e5                	mov    %esp,%ebp
c010877e:	83 ec 20             	sub    $0x20,%esp
    uint32_t* out = (uint32_t*)model_out;
c0108781:	8b 45 08             	mov    0x8(%ebp),%eax
c0108784:	89 45 fc             	mov    %eax,-0x4(%ebp)
    reg32 eax, ebx, edx, ecx;
    
    __get_cpuid(0, &eax, &ebx, &ecx, &edx);
c0108787:	8d 45 f0             	lea    -0x10(%ebp),%eax
c010878a:	50                   	push   %eax
c010878b:	8d 45 ec             	lea    -0x14(%ebp),%eax
c010878e:	50                   	push   %eax
c010878f:	8d 45 f4             	lea    -0xc(%ebp),%eax
c0108792:	50                   	push   %eax
c0108793:	8d 45 f8             	lea    -0x8(%ebp),%eax
c0108796:	50                   	push   %eax
c0108797:	6a 00                	push   $0x0
c0108799:	e8 72 ff ff ff       	call   c0108710 <__get_cpuid>
c010879e:	83 c4 14             	add    $0x14,%esp

    out[0] = ebx;
c01087a1:	8b 55 f4             	mov    -0xc(%ebp),%edx
c01087a4:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01087a7:	89 10                	mov    %edx,(%eax)
    out[1] = edx;
c01087a9:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01087ac:	8d 50 04             	lea    0x4(%eax),%edx
c01087af:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01087b2:	89 02                	mov    %eax,(%edx)
    out[2] = ecx;
c01087b4:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01087b7:	8d 50 08             	lea    0x8(%eax),%edx
c01087ba:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01087bd:	89 02                	mov    %eax,(%edx)
    model_out[12] = '\0';
c01087bf:	8b 45 08             	mov    0x8(%ebp),%eax
c01087c2:	83 c0 0c             	add    $0xc,%eax
c01087c5:	c6 00 00             	movb   $0x0,(%eax)
}
c01087c8:	90                   	nop
c01087c9:	c9                   	leave  
c01087ca:	c3                   	ret    

c01087cb <cpu_brand_string_supported>:

#define BRAND_LEAF 0x80000000UL

int cpu_brand_string_supported() {
c01087cb:	55                   	push   %ebp
c01087cc:	89 e5                	mov    %esp,%ebp
c01087ce:	83 ec 10             	sub    $0x10,%esp
    reg32 supported = __get_cpuid_max(BRAND_LEAF, 0);
c01087d1:	6a 00                	push   $0x0
c01087d3:	68 00 00 00 80       	push   $0x80000000
c01087d8:	e8 cb fe ff ff       	call   c01086a8 <__get_cpuid_max>
c01087dd:	83 c4 08             	add    $0x8,%esp
c01087e0:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return (supported >= 0x80000004UL);
c01087e3:	81 7d fc 03 00 00 80 	cmpl   $0x80000003,-0x4(%ebp)
c01087ea:	0f 97 c0             	seta   %al
c01087ed:	0f b6 c0             	movzbl %al,%eax
}
c01087f0:	c9                   	leave  
c01087f1:	c3                   	ret    

c01087f2 <cpu_get_brand>:

void cpu_get_brand(char* brand_out) {
c01087f2:	55                   	push   %ebp
c01087f3:	89 e5                	mov    %esp,%ebp
c01087f5:	83 ec 20             	sub    $0x20,%esp
    if(!cpu_brand_string_supported()) {
c01087f8:	e8 ce ff ff ff       	call   c01087cb <cpu_brand_string_supported>
c01087fd:	85 c0                	test   %eax,%eax
c01087ff:	75 0f                	jne    c0108810 <cpu_get_brand+0x1e>
        brand_out[0] = '?';
c0108801:	8b 45 08             	mov    0x8(%ebp),%eax
c0108804:	c6 00 3f             	movb   $0x3f,(%eax)
        brand_out[1] = '\0';
c0108807:	8b 45 08             	mov    0x8(%ebp),%eax
c010880a:	83 c0 01             	add    $0x1,%eax
c010880d:	c6 00 00             	movb   $0x0,(%eax)
    }
    uint32_t* out = (uint32_t*) brand_out;
c0108810:	8b 45 08             	mov    0x8(%ebp),%eax
c0108813:	89 45 f4             	mov    %eax,-0xc(%ebp)
    reg32 eax, ebx, edx, ecx;
    for (uint32_t i = 2, j = 0; i < 5; i++)
c0108816:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
c010881d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c0108824:	e9 83 00 00 00       	jmp    c01088ac <cpu_get_brand+0xba>
    {
        __get_cpuid(BRAND_LEAF + i, &eax, &ebx, &ecx, &edx);
c0108829:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010882c:	8d 90 00 00 00 80    	lea    -0x80000000(%eax),%edx
c0108832:	8d 45 e8             	lea    -0x18(%ebp),%eax
c0108835:	50                   	push   %eax
c0108836:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0108839:	50                   	push   %eax
c010883a:	8d 45 ec             	lea    -0x14(%ebp),%eax
c010883d:	50                   	push   %eax
c010883e:	8d 45 f0             	lea    -0x10(%ebp),%eax
c0108841:	50                   	push   %eax
c0108842:	52                   	push   %edx
c0108843:	e8 c8 fe ff ff       	call   c0108710 <__get_cpuid>
c0108848:	83 c4 14             	add    $0x14,%esp
        out[j] = eax;
c010884b:	8b 45 f8             	mov    -0x8(%ebp),%eax
c010884e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0108855:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108858:	01 c2                	add    %eax,%edx
c010885a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010885d:	89 02                	mov    %eax,(%edx)
        out[j + 1] = ebx;
c010885f:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0108862:	83 c0 01             	add    $0x1,%eax
c0108865:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010886c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010886f:	01 c2                	add    %eax,%edx
c0108871:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0108874:	89 02                	mov    %eax,(%edx)
        out[j + 2] = ecx;
c0108876:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0108879:	83 c0 02             	add    $0x2,%eax
c010887c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0108883:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0108886:	01 c2                	add    %eax,%edx
c0108888:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010888b:	89 02                	mov    %eax,(%edx)
        out[j + 3] = edx;
c010888d:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0108890:	83 c0 03             	add    $0x3,%eax
c0108893:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010889a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010889d:	01 c2                	add    %eax,%edx
c010889f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01088a2:	89 02                	mov    %eax,(%edx)
        j+=4;
c01088a4:	83 45 f8 04          	addl   $0x4,-0x8(%ebp)
    for (uint32_t i = 2, j = 0; i < 5; i++)
c01088a8:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c01088ac:	83 7d fc 04          	cmpl   $0x4,-0x4(%ebp)
c01088b0:	0f 86 73 ff ff ff    	jbe    c0108829 <cpu_get_brand+0x37>
    }
    brand_out[48] = '\0';
c01088b6:	8b 45 08             	mov    0x8(%ebp),%eax
c01088b9:	83 c0 30             	add    $0x30,%eax
c01088bc:	c6 00 00             	movb   $0x0,(%eax)
}
c01088bf:	90                   	nop
c01088c0:	c9                   	leave  
c01088c1:	c3                   	ret    

c01088c2 <cpu_r_cr0>:

reg32 cpu_r_cr0() {
c01088c2:	55                   	push   %ebp
c01088c3:	89 e5                	mov    %esp,%ebp
    asm volatile ("mov %cr0, %eax");
c01088c5:	0f 20 c0             	mov    %cr0,%eax
}
c01088c8:	90                   	nop
c01088c9:	5d                   	pop    %ebp
c01088ca:	c3                   	ret    

c01088cb <cpu_r_cr2>:

reg32 cpu_r_cr2() {
c01088cb:	55                   	push   %ebp
c01088cc:	89 e5                	mov    %esp,%ebp
    asm volatile ("mov %cr2, %eax");
c01088ce:	0f 20 d0             	mov    %cr2,%eax
}
c01088d1:	90                   	nop
c01088d2:	5d                   	pop    %ebp
c01088d3:	c3                   	ret    

c01088d4 <cpu_r_cr3>:

reg32 cpu_r_cr3() {
c01088d4:	55                   	push   %ebp
c01088d5:	89 e5                	mov    %esp,%ebp
    asm volatile ("mov %cr3, %eax");
c01088d7:	0f 20 d8             	mov    %cr3,%eax
}
c01088da:	90                   	nop
c01088db:	5d                   	pop    %ebp
c01088dc:	c3                   	ret    

c01088dd <cpu_w_cr0>:

void cpu_w_cr0(reg32 v) {
c01088dd:	55                   	push   %ebp
c01088de:	89 e5                	mov    %esp,%ebp
    asm volatile (
c01088e0:	8b 45 08             	mov    0x8(%ebp),%eax
c01088e3:	0f 22 c0             	mov    %eax,%cr0
        "mov %0, %%cr0"
        :: "r"(v)
    );
}
c01088e6:	90                   	nop
c01088e7:	5d                   	pop    %ebp
c01088e8:	c3                   	ret    

c01088e9 <cpu_w_cr2>:

void cpu_w_cr2(reg32 v) {
c01088e9:	55                   	push   %ebp
c01088ea:	89 e5                	mov    %esp,%ebp
    asm volatile (
c01088ec:	8b 45 08             	mov    0x8(%ebp),%eax
c01088ef:	0f 22 d0             	mov    %eax,%cr2
        "mov %0, %%cr2"
        :: "r"(v)
    );
}
c01088f2:	90                   	nop
c01088f3:	5d                   	pop    %ebp
c01088f4:	c3                   	ret    

c01088f5 <cpu_w_cr3>:

void cpu_w_cr3(reg32 v) {
c01088f5:	55                   	push   %ebp
c01088f6:	89 e5                	mov    %esp,%ebp
    asm volatile (
c01088f8:	8b 45 08             	mov    0x8(%ebp),%eax
c01088fb:	0f 22 d8             	mov    %eax,%cr3
        "mov %0, %%cr3"
        :: "r"(v)
    );
}
c01088fe:	90                   	nop
c01088ff:	5d                   	pop    %ebp
c0108900:	c3                   	ret    

c0108901 <_set_gdt_entry>:
uint64_t _gdt[5];
uint16_t _gdt_limit = sizeof(_gdt) - 1;

extern struct x86_tss _tss;

void _set_gdt_entry(uint32_t index, uint32_t base, uint32_t limit, uint32_t flags) {
c0108901:	55                   	push   %ebp
c0108902:	89 e5                	mov    %esp,%ebp
c0108904:	57                   	push   %edi
c0108905:	56                   	push   %esi
c0108906:	53                   	push   %ebx
c0108907:	83 ec 0c             	sub    $0xc,%esp
    _gdt[index] = SEG_BASE_H(base) | flags | SEG_LIM_H(limit) | SEG_BASE_M(base);
c010890a:	8b 45 0c             	mov    0xc(%ebp),%eax
c010890d:	25 00 00 00 ff       	and    $0xff000000,%eax
c0108912:	0b 45 14             	or     0x14(%ebp),%eax
c0108915:	89 c2                	mov    %eax,%edx
c0108917:	8b 45 10             	mov    0x10(%ebp),%eax
c010891a:	25 00 00 0f 00       	and    $0xf0000,%eax
c010891f:	09 c2                	or     %eax,%edx
c0108921:	8b 45 0c             	mov    0xc(%ebp),%eax
c0108924:	c1 e8 10             	shr    $0x10,%eax
c0108927:	0f b6 c0             	movzbl %al,%eax
c010892a:	09 d0                	or     %edx,%eax
c010892c:	ba 00 00 00 00       	mov    $0x0,%edx
c0108931:	8b 75 08             	mov    0x8(%ebp),%esi
c0108934:	89 04 f5 00 b5 28 c0 	mov    %eax,-0x3fd74b00(,%esi,8)
c010893b:	89 14 f5 04 b5 28 c0 	mov    %edx,-0x3fd74afc(,%esi,8)
    _gdt[index] <<= 32;
c0108942:	8b 45 08             	mov    0x8(%ebp),%eax
c0108945:	8b 14 c5 04 b5 28 c0 	mov    -0x3fd74afc(,%eax,8),%edx
c010894c:	8b 04 c5 00 b5 28 c0 	mov    -0x3fd74b00(,%eax,8),%eax
c0108953:	89 c2                	mov    %eax,%edx
c0108955:	b8 00 00 00 00       	mov    $0x0,%eax
c010895a:	8b 75 08             	mov    0x8(%ebp),%esi
c010895d:	89 04 f5 00 b5 28 c0 	mov    %eax,-0x3fd74b00(,%esi,8)
c0108964:	89 14 f5 04 b5 28 c0 	mov    %edx,-0x3fd74afc(,%esi,8)
    _gdt[index] |= SEG_BASE_L(base) | SEG_LIM_L(limit);
c010896b:	8b 45 08             	mov    0x8(%ebp),%eax
c010896e:	8b 14 c5 04 b5 28 c0 	mov    -0x3fd74afc(,%eax,8),%edx
c0108975:	8b 04 c5 00 b5 28 c0 	mov    -0x3fd74b00(,%eax,8),%eax
c010897c:	8b 75 0c             	mov    0xc(%ebp),%esi
c010897f:	89 f7                	mov    %esi,%edi
c0108981:	c1 e7 10             	shl    $0x10,%edi
c0108984:	8b 75 10             	mov    0x10(%ebp),%esi
c0108987:	0f b7 f6             	movzwl %si,%esi
c010898a:	09 fe                	or     %edi,%esi
c010898c:	bf 00 00 00 00       	mov    $0x0,%edi
c0108991:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0108994:	89 55 ec             	mov    %edx,-0x14(%ebp)
c0108997:	09 f0                	or     %esi,%eax
c0108999:	89 c1                	mov    %eax,%ecx
c010899b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010899e:	09 f8                	or     %edi,%eax
c01089a0:	89 c3                	mov    %eax,%ebx
c01089a2:	8b 45 08             	mov    0x8(%ebp),%eax
c01089a5:	89 0c c5 00 b5 28 c0 	mov    %ecx,-0x3fd74b00(,%eax,8)
c01089ac:	89 1c c5 04 b5 28 c0 	mov    %ebx,-0x3fd74afc(,%eax,8)
}
c01089b3:	90                   	nop
c01089b4:	83 c4 0c             	add    $0xc,%esp
c01089b7:	5b                   	pop    %ebx
c01089b8:	5e                   	pop    %esi
c01089b9:	5f                   	pop    %edi
c01089ba:	5d                   	pop    %ebp
c01089bb:	c3                   	ret    

c01089bc <_init_gdt>:
// 
void
_init_gdt() {
c01089bc:	55                   	push   %ebp
c01089bd:	89 e5                	mov    %esp,%ebp
    _set_gdt_entry(0, 0, 0, 0);
c01089bf:	6a 00                	push   $0x0
c01089c1:	6a 00                	push   $0x0
c01089c3:	6a 00                	push   $0x0
c01089c5:	6a 00                	push   $0x0
c01089c7:	e8 35 ff ff ff       	call   c0108901 <_set_gdt_entry>
c01089cc:	83 c4 10             	add    $0x10,%esp
    _set_gdt_entry(1, 0, 0xfffff, SEG_R0_CODE);
c01089cf:	68 00 9a c0 00       	push   $0xc09a00
c01089d4:	68 ff ff 0f 00       	push   $0xfffff
c01089d9:	6a 00                	push   $0x0
c01089db:	6a 01                	push   $0x1
c01089dd:	e8 1f ff ff ff       	call   c0108901 <_set_gdt_entry>
c01089e2:	83 c4 10             	add    $0x10,%esp
    _set_gdt_entry(2, 0, 0xfffff, SEG_R0_DATA);
c01089e5:	68 00 92 c0 00       	push   $0xc09200
c01089ea:	68 ff ff 0f 00       	push   $0xfffff
c01089ef:	6a 00                	push   $0x0
c01089f1:	6a 02                	push   $0x2
c01089f3:	e8 09 ff ff ff       	call   c0108901 <_set_gdt_entry>
c01089f8:	83 c4 10             	add    $0x10,%esp
    _set_gdt_entry(3, 0, 0xfffff, SEG_R3_CODE);
c01089fb:	68 00 fa c0 00       	push   $0xc0fa00
c0108a00:	68 ff ff 0f 00       	push   $0xfffff
c0108a05:	6a 00                	push   $0x0
c0108a07:	6a 03                	push   $0x3
c0108a09:	e8 f3 fe ff ff       	call   c0108901 <_set_gdt_entry>
c0108a0e:	83 c4 10             	add    $0x10,%esp
    _set_gdt_entry(4, 0, 0xfffff, SEG_R3_DATA);
c0108a11:	68 00 f2 c0 00       	push   $0xc0f200
c0108a16:	68 ff ff 0f 00       	push   $0xfffff
c0108a1b:	6a 00                	push   $0x0
c0108a1d:	6a 04                	push   $0x4
c0108a1f:	e8 dd fe ff ff       	call   c0108901 <_set_gdt_entry>
c0108a24:	83 c4 10             	add    $0x10,%esp
    _set_gdt_entry(5, &_tss, sizeof(struct x86_tss) - 1, SEG_TSS);
c0108a27:	b8 20 c0 28 c0       	mov    $0xc028c020,%eax
c0108a2c:	68 00 89 00 00       	push   $0x8900
c0108a31:	6a 67                	push   $0x67
c0108a33:	50                   	push   %eax
c0108a34:	6a 05                	push   $0x5
c0108a36:	e8 c6 fe ff ff       	call   c0108901 <_set_gdt_entry>
c0108a3b:	83 c4 10             	add    $0x10,%esp
c0108a3e:	90                   	nop
c0108a3f:	c9                   	leave  
c0108a40:	c3                   	ret    

c0108a41 <tss_update_esp>:
    .link = 0,
    .esp0 = KSTACK_START,
    .ss0  = KDATA_SEG
};

void tss_update_esp(uint32_t esp0) {
c0108a41:	55                   	push   %ebp
c0108a42:	89 e5                	mov    %esp,%ebp
    _tss.esp0 = esp0;
c0108a44:	8b 45 08             	mov    0x8(%ebp),%eax
c0108a47:	a3 24 c0 28 c0       	mov    %eax,0xc028c024
c0108a4c:	90                   	nop
c0108a4d:	5d                   	pop    %ebp
c0108a4e:	c3                   	ret    

c0108a4f <_set_idt_entry>:
#define IDT_ENTRY 80

uint64_t _idt[IDT_ENTRY];
uint16_t _idt_limit = sizeof(_idt) - 1;

void _set_idt_entry(uint32_t vector, uint16_t seg_selector, void (*isr)(), uint8_t dpl) {
c0108a4f:	55                   	push   %ebp
c0108a50:	89 e5                	mov    %esp,%ebp
c0108a52:	57                   	push   %edi
c0108a53:	56                   	push   %esi
c0108a54:	53                   	push   %ebx
c0108a55:	83 ec 24             	sub    $0x24,%esp
c0108a58:	8b 45 0c             	mov    0xc(%ebp),%eax
c0108a5b:	8b 55 14             	mov    0x14(%ebp),%edx
c0108a5e:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
c0108a62:	89 d0                	mov    %edx,%eax
c0108a64:	88 45 d8             	mov    %al,-0x28(%ebp)
    uintptr_t offset = (uintptr_t)isr;
c0108a67:	8b 45 10             	mov    0x10(%ebp),%eax
c0108a6a:	89 45 ec             	mov    %eax,-0x14(%ebp)
    _idt[vector] = (offset & 0xffff0000) | IDT_ATTR(dpl);
c0108a6d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0108a70:	66 b8 00 00          	mov    $0x0,%ax
c0108a74:	89 c2                	mov    %eax,%edx
c0108a76:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
c0108a7a:	c1 e0 0d             	shl    $0xd,%eax
c0108a7d:	25 00 60 00 00       	and    $0x6000,%eax
c0108a82:	09 d0                	or     %edx,%eax
c0108a84:	80 cc 8e             	or     $0x8e,%ah
c0108a87:	ba 00 00 00 00       	mov    $0x0,%edx
c0108a8c:	8b 75 08             	mov    0x8(%ebp),%esi
c0108a8f:	89 04 f5 40 b5 28 c0 	mov    %eax,-0x3fd74ac0(,%esi,8)
c0108a96:	89 14 f5 44 b5 28 c0 	mov    %edx,-0x3fd74abc(,%esi,8)
    _idt[vector] <<= 32;
c0108a9d:	8b 45 08             	mov    0x8(%ebp),%eax
c0108aa0:	8b 14 c5 44 b5 28 c0 	mov    -0x3fd74abc(,%eax,8),%edx
c0108aa7:	8b 04 c5 40 b5 28 c0 	mov    -0x3fd74ac0(,%eax,8),%eax
c0108aae:	89 c2                	mov    %eax,%edx
c0108ab0:	b8 00 00 00 00       	mov    $0x0,%eax
c0108ab5:	8b 75 08             	mov    0x8(%ebp),%esi
c0108ab8:	89 04 f5 40 b5 28 c0 	mov    %eax,-0x3fd74ac0(,%esi,8)
c0108abf:	89 14 f5 44 b5 28 c0 	mov    %edx,-0x3fd74abc(,%esi,8)
    _idt[vector] |= (seg_selector << 16) | (offset & 0x0000ffff);
c0108ac6:	8b 45 08             	mov    0x8(%ebp),%eax
c0108ac9:	8b 14 c5 44 b5 28 c0 	mov    -0x3fd74abc(,%eax,8),%edx
c0108ad0:	8b 04 c5 40 b5 28 c0 	mov    -0x3fd74ac0(,%eax,8),%eax
c0108ad7:	0f b7 75 dc          	movzwl -0x24(%ebp),%esi
c0108adb:	c1 e6 10             	shl    $0x10,%esi
c0108ade:	89 f7                	mov    %esi,%edi
c0108ae0:	8b 75 ec             	mov    -0x14(%ebp),%esi
c0108ae3:	0f b7 f6             	movzwl %si,%esi
c0108ae6:	09 fe                	or     %edi,%esi
c0108ae8:	bf 00 00 00 00       	mov    $0x0,%edi
c0108aed:	89 45 d0             	mov    %eax,-0x30(%ebp)
c0108af0:	89 55 d4             	mov    %edx,-0x2c(%ebp)
c0108af3:	09 f0                	or     %esi,%eax
c0108af5:	89 c1                	mov    %eax,%ecx
c0108af7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0108afa:	09 f8                	or     %edi,%eax
c0108afc:	89 c3                	mov    %eax,%ebx
c0108afe:	8b 45 08             	mov    0x8(%ebp),%eax
c0108b01:	89 0c c5 40 b5 28 c0 	mov    %ecx,-0x3fd74ac0(,%eax,8)
c0108b08:	89 1c c5 44 b5 28 c0 	mov    %ebx,-0x3fd74abc(,%eax,8)
}
c0108b0f:	90                   	nop
c0108b10:	83 c4 24             	add    $0x24,%esp
c0108b13:	5b                   	pop    %ebx
c0108b14:	5e                   	pop    %esi
c0108b15:	5f                   	pop    %edi
c0108b16:	5d                   	pop    %ebp
c0108b17:	c3                   	ret    

c0108b18 <_init_idt>:

void _init_idt()
{
c0108b18:	55                   	push   %ebp
c0108b19:	89 e5                	mov    %esp,%ebp
c0108b1b:	83 ec 10             	sub    $0x10,%esp
    _set_idt_entry(FAULT_DIVISION_ERROR, 0x08, &divide_error, 0);
c0108b1e:	6a 00                	push   $0x0
c0108b20:	68 32 86 10 c0       	push   $0xc0108632
c0108b25:	6a 08                	push   $0x8
c0108b27:	6a 00                	push   $0x0
c0108b29:	e8 21 ff ff ff       	call   c0108a4f <_set_idt_entry>
c0108b2e:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(FAULT_TRAP_DEBUG_EXCEPTION, 0x08, &debug, 0);
c0108b31:	6a 00                	push   $0x0
c0108b33:	68 39 86 10 c0       	push   $0xc0108639
c0108b38:	6a 08                	push   $0x8
c0108b3a:	6a 01                	push   $0x1
c0108b3c:	e8 0e ff ff ff       	call   c0108a4f <_set_idt_entry>
c0108b41:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(INT_NMI, 0x08, &nmi, 0);
c0108b44:	6a 00                	push   $0x0
c0108b46:	68 40 86 10 c0       	push   $0xc0108640
c0108b4b:	6a 08                	push   $0x8
c0108b4d:	6a 02                	push   $0x2
c0108b4f:	e8 fb fe ff ff       	call   c0108a4f <_set_idt_entry>
c0108b54:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(TRAP_BREAKPOINT, 0x08, &int3, 0);
c0108b57:	6a 00                	push   $0x0
c0108b59:	68 47 86 10 c0       	push   $0xc0108647
c0108b5e:	6a 08                	push   $0x8
c0108b60:	6a 03                	push   $0x3
c0108b62:	e8 e8 fe ff ff       	call   c0108a4f <_set_idt_entry>
c0108b67:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(TRAP_OVERFLOW, 0x08, &overflow, 0);
c0108b6a:	6a 00                	push   $0x0
c0108b6c:	68 4e 86 10 c0       	push   $0xc010864e
c0108b71:	6a 08                	push   $0x8
c0108b73:	6a 04                	push   $0x4
c0108b75:	e8 d5 fe ff ff       	call   c0108a4f <_set_idt_entry>
c0108b7a:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(FAULT_BOUND_EXCEED, 0x08, &bounds, 0);
c0108b7d:	6a 00                	push   $0x0
c0108b7f:	68 58 86 10 c0       	push   $0xc0108658
c0108b84:	6a 08                	push   $0x8
c0108b86:	6a 05                	push   $0x5
c0108b88:	e8 c2 fe ff ff       	call   c0108a4f <_set_idt_entry>
c0108b8d:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(FAULT_INVALID_OPCODE, 0x08, &invalid_op, 0);
c0108b90:	6a 00                	push   $0x0
c0108b92:	68 62 86 10 c0       	push   $0xc0108662
c0108b97:	6a 08                	push   $0x8
c0108b99:	6a 06                	push   $0x6
c0108b9b:	e8 af fe ff ff       	call   c0108a4f <_set_idt_entry>
c0108ba0:	83 c4 10             	add    $0x10,%esp
    //_set_idt_entry(FAULT_NO_MATH_PROCESSOR, 0x08, &device_not_available, 0);
    //_set_idt_entry(ABORT_DOUBLE_FAULT, 0x08, &double_fault, 0);
    _set_idt_entry(FAULT_RESERVED_0, 0x08, &coprocessor_segment_overrun, 0);
c0108ba3:	6a 00                	push   $0x0
c0108ba5:	68 6c 86 10 c0       	push   $0xc010866c
c0108baa:	6a 08                	push   $0x8
c0108bac:	6a 09                	push   $0x9
c0108bae:	e8 9c fe ff ff       	call   c0108a4f <_set_idt_entry>
c0108bb3:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(FAULT_INVALID_TSS, 0x08, &invalid_TSS, 0);
c0108bb6:	6a 00                	push   $0x0
c0108bb8:	68 80 86 10 c0       	push   $0xc0108680
c0108bbd:	6a 08                	push   $0x8
c0108bbf:	6a 0a                	push   $0xa
c0108bc1:	e8 89 fe ff ff       	call   c0108a4f <_set_idt_entry>
c0108bc6:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(FAULT_SEG_NOT_PRESENT, 0x08, &segment_not_present, 0);
c0108bc9:	6a 00                	push   $0x0
c0108bcb:	68 8a 86 10 c0       	push   $0xc010868a
c0108bd0:	6a 08                	push   $0x8
c0108bd2:	6a 0b                	push   $0xb
c0108bd4:	e8 76 fe ff ff       	call   c0108a4f <_set_idt_entry>
c0108bd9:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(FAULT_STACK_SEG_FAULT, 0x08, &stack_segment, 0);
c0108bdc:	6a 00                	push   $0x0
c0108bde:	68 94 86 10 c0       	push   $0xc0108694
c0108be3:	6a 08                	push   $0x8
c0108be5:	6a 0c                	push   $0xc
c0108be7:	e8 63 fe ff ff       	call   c0108a4f <_set_idt_entry>
c0108bec:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(FAULT_GENERAL_PROTECTION, 0x08, &general_protection, 0);
c0108bef:	6a 00                	push   $0x0
c0108bf1:	68 9e 86 10 c0       	push   $0xc010869e
c0108bf6:	6a 08                	push   $0x8
c0108bf8:	6a 0d                	push   $0xd
c0108bfa:	e8 50 fe ff ff       	call   c0108a4f <_set_idt_entry>
c0108bff:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(FAULT_PAGE_FAULT, 0x08, &page_fault, 0);
c0108c02:	6a 00                	push   $0x0
c0108c04:	68 1d 72 10 c0       	push   $0xc010721d
c0108c09:	6a 08                	push   $0x8
c0108c0b:	6a 0e                	push   $0xe
c0108c0d:	e8 3d fe ff ff       	call   c0108a4f <_set_idt_entry>
c0108c12:	83 c4 10             	add    $0x10,%esp
    _set_idt_entry(FAULT_RESERVED_1, 0x08, &reserved, 0);
c0108c15:	6a 00                	push   $0x0
c0108c17:	68 76 86 10 c0       	push   $0xc0108676
c0108c1c:	6a 08                	push   $0x8
c0108c1e:	6a 0f                	push   $0xf
c0108c20:	e8 2a fe ff ff       	call   c0108a4f <_set_idt_entry>
c0108c25:	83 c4 10             	add    $0x10,%esp
    //_set_idt_entry(FAULT_X87_FAULT, 0x08, coprocessor_error, 0);
    for (int i=17;i < 48;i++)
c0108c28:	c7 45 fc 11 00 00 00 	movl   $0x11,-0x4(%ebp)
c0108c2f:	eb 19                	jmp    c0108c4a <_init_idt+0x132>
		  _set_idt_entry(i, 0x08, &reserved, 0);
c0108c31:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0108c34:	6a 00                	push   $0x0
c0108c36:	68 76 86 10 c0       	push   $0xc0108676
c0108c3b:	6a 08                	push   $0x8
c0108c3d:	50                   	push   %eax
c0108c3e:	e8 0c fe ff ff       	call   c0108a4f <_set_idt_entry>
c0108c43:	83 c4 10             	add    $0x10,%esp
    for (int i=17;i < 48;i++)
c0108c46:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0108c4a:	83 7d fc 2f          	cmpl   $0x2f,-0x4(%ebp)
c0108c4e:	7e e1                	jle    c0108c31 <_init_idt+0x119>
    //_set_idt_entry(45, 0x08, irq13, 0);
    _set_idt_entry(MELOX_SYS_CALL, 0x08, &intr_syscall_handler, 3);
c0108c50:	6a 03                	push   $0x3
c0108c52:	68 a2 85 10 c0       	push   $0xc01085a2
c0108c57:	6a 08                	push   $0x8
c0108c59:	68 80 00 00 00       	push   $0x80
c0108c5e:	e8 ec fd ff ff       	call   c0108a4f <_set_idt_entry>
c0108c63:	83 c4 10             	add    $0x10,%esp
c0108c66:	90                   	nop
c0108c67:	c9                   	leave  
c0108c68:	c3                   	ret    

c0108c69 <_kernel_start>:
c0108c69:	e8 4e fd ff ff       	call   c01089bc <_init_gdt>
c0108c6e:	68 00 b5 28 c0       	push   $0xc028b500
c0108c73:	66 ff 35 00 c0 28 c0 	pushw  0xc028c000
c0108c7a:	0f 01 14 24          	lgdtl  (%esp)
c0108c7e:	66 b9 10 00          	mov    $0x10,%cx
c0108c82:	8e c1                	mov    %ecx,%es
c0108c84:	8e d9                	mov    %ecx,%ds
c0108c86:	8e e1                	mov    %ecx,%fs
c0108c88:	8e e9                	mov    %ecx,%gs
c0108c8a:	8e d1                	mov    %ecx,%ss
c0108c8c:	66 6a 08             	pushw  $0x8
c0108c8f:	68 95 8c 10 c0       	push   $0xc0108c95
c0108c94:	cb                   	lret   

c0108c95 <_after_gdt>:
c0108c95:	c7 04 24 00 10 10 00 	movl   $0x101000,(%esp)
c0108c9c:	e8 9d d5 ff ff       	call   c010623e <_kernel_init>
c0108ca1:	bc f0 ff bf ff       	mov    $0xffbffff0,%esp
c0108ca6:	e8 0f d9 ff ff       	call   c01065ba <_kernel_finnal_init>
c0108cab:	83 ec 06             	sub    $0x6,%esp
c0108cae:	c7 44 24 02 40 b5 28 	movl   $0xc028b540,0x2(%esp)
c0108cb5:	c0 
c0108cb6:	66 a1 88 c0 28 c0    	mov    0xc028c088,%ax
c0108cbc:	66 89 04 24          	mov    %ax,(%esp)
c0108cc0:	0f 01 1c 24          	lidtl  (%esp)
c0108cc4:	83 c4 06             	add    $0x6,%esp
c0108cc7:	e8 4e d9 ff ff       	call   c010661a <_kernel_main>

c0108ccc <j_>:
c0108ccc:	f4                   	hlt    
c0108ccd:	eb fd                	jmp    c0108ccc <j_>

c0108ccf <io_inb>:
{
c0108ccf:	55                   	push   %ebp
c0108cd0:	89 e5                	mov    %esp,%ebp
c0108cd2:	83 ec 10             	sub    $0x10,%esp
    asm volatile("inb %w1,%0" : "=a"(data) : "d"(port));
c0108cd5:	8b 45 08             	mov    0x8(%ebp),%eax
c0108cd8:	89 c2                	mov    %eax,%edx
c0108cda:	ec                   	in     (%dx),%al
c0108cdb:	88 45 ff             	mov    %al,-0x1(%ebp)
    return data;
c0108cde:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c0108ce2:	c9                   	leave  
c0108ce3:	c3                   	ret    

c0108ce4 <io_outb>:
{
c0108ce4:	55                   	push   %ebp
c0108ce5:	89 e5                	mov    %esp,%ebp
c0108ce7:	83 ec 04             	sub    $0x4,%esp
c0108cea:	8b 45 0c             	mov    0xc(%ebp),%eax
c0108ced:	88 45 fc             	mov    %al,-0x4(%ebp)
    asm volatile("outb %0, %w1" : : "a"(data), "d"(port));
c0108cf0:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0108cf4:	8b 55 08             	mov    0x8(%ebp),%edx
c0108cf7:	ee                   	out    %al,(%dx)
}
c0108cf8:	90                   	nop
c0108cf9:	c9                   	leave  
c0108cfa:	c3                   	ret    

c0108cfb <cpu_delay>:
static inline void cpu_delay(){
c0108cfb:	55                   	push   %ebp
c0108cfc:	89 e5                	mov    %esp,%ebp
c0108cfe:	83 ec 10             	sub    $0x10,%esp
    for(int i = 0; i < 3; i++);
c0108d01:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0108d08:	eb 04                	jmp    c0108d0e <cpu_delay+0x13>
c0108d0a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0108d0e:	83 7d fc 02          	cmpl   $0x2,-0x4(%ebp)
c0108d12:	7e f6                	jle    c0108d0a <cpu_delay+0xf>
}
c0108d14:	90                   	nop
c0108d15:	90                   	nop
c0108d16:	c9                   	leave  
c0108d17:	c3                   	ret    

c0108d18 <init_8259>:
//other keys tmp do not hand
};
#endif

void init_8259()
{
c0108d18:	55                   	push   %ebp
c0108d19:	89 e5                	mov    %esp,%ebp
    asm volatile("cli");
c0108d1b:	fa                   	cli    

    //ICW1
    io_outb(0x20, 0x11);
c0108d1c:	6a 11                	push   $0x11
c0108d1e:	6a 20                	push   $0x20
c0108d20:	e8 bf ff ff ff       	call   c0108ce4 <io_outb>
c0108d25:	83 c4 08             	add    $0x8,%esp
    cpu_delay();
c0108d28:	e8 ce ff ff ff       	call   c0108cfb <cpu_delay>
    io_outb(0xa0, 0x11);
c0108d2d:	6a 11                	push   $0x11
c0108d2f:	68 a0 00 00 00       	push   $0xa0
c0108d34:	e8 ab ff ff ff       	call   c0108ce4 <io_outb>
c0108d39:	83 c4 08             	add    $0x8,%esp
    cpu_delay();
c0108d3c:	e8 ba ff ff ff       	call   c0108cfb <cpu_delay>

    //ICW2
    io_outb(0x21, 0x20);
c0108d41:	6a 20                	push   $0x20
c0108d43:	6a 21                	push   $0x21
c0108d45:	e8 9a ff ff ff       	call   c0108ce4 <io_outb>
c0108d4a:	83 c4 08             	add    $0x8,%esp
    cpu_delay();
c0108d4d:	e8 a9 ff ff ff       	call   c0108cfb <cpu_delay>
    io_outb(0xa1, 0x28);
c0108d52:	6a 28                	push   $0x28
c0108d54:	68 a1 00 00 00       	push   $0xa1
c0108d59:	e8 86 ff ff ff       	call   c0108ce4 <io_outb>
c0108d5e:	83 c4 08             	add    $0x8,%esp
    cpu_delay();
c0108d61:	e8 95 ff ff ff       	call   c0108cfb <cpu_delay>

    //ICW3
    io_outb(0x21, 0x04);
c0108d66:	6a 04                	push   $0x4
c0108d68:	6a 21                	push   $0x21
c0108d6a:	e8 75 ff ff ff       	call   c0108ce4 <io_outb>
c0108d6f:	83 c4 08             	add    $0x8,%esp
    cpu_delay();
c0108d72:	e8 84 ff ff ff       	call   c0108cfb <cpu_delay>
    io_outb(0xa1, 0x02);
c0108d77:	6a 02                	push   $0x2
c0108d79:	68 a1 00 00 00       	push   $0xa1
c0108d7e:	e8 61 ff ff ff       	call   c0108ce4 <io_outb>
c0108d83:	83 c4 08             	add    $0x8,%esp
    cpu_delay();
c0108d86:	e8 70 ff ff ff       	call   c0108cfb <cpu_delay>

    //ICW4
    io_outb(0x21, 0x01);
c0108d8b:	6a 01                	push   $0x1
c0108d8d:	6a 21                	push   $0x21
c0108d8f:	e8 50 ff ff ff       	call   c0108ce4 <io_outb>
c0108d94:	83 c4 08             	add    $0x8,%esp
    cpu_delay();
c0108d97:	e8 5f ff ff ff       	call   c0108cfb <cpu_delay>
    io_outb(0xa1, 0x01);
c0108d9c:	6a 01                	push   $0x1
c0108d9e:	68 a1 00 00 00       	push   $0xa1
c0108da3:	e8 3c ff ff ff       	call   c0108ce4 <io_outb>
c0108da8:	83 c4 08             	add    $0x8,%esp
    cpu_delay();
c0108dab:	e8 4b ff ff ff       	call   c0108cfb <cpu_delay>

    //OCW1
    io_outb(0x21, 0xff);
c0108db0:	68 ff 00 00 00       	push   $0xff
c0108db5:	6a 21                	push   $0x21
c0108db7:	e8 28 ff ff ff       	call   c0108ce4 <io_outb>
c0108dbc:	83 c4 08             	add    $0x8,%esp
    cpu_delay();
c0108dbf:	e8 37 ff ff ff       	call   c0108cfb <cpu_delay>
    io_outb(0xa1, 0xff);
c0108dc4:	68 ff 00 00 00       	push   $0xff
c0108dc9:	68 a1 00 00 00       	push   $0xa1
c0108dce:	e8 11 ff ff ff       	call   c0108ce4 <io_outb>
c0108dd3:	83 c4 08             	add    $0x8,%esp

    asm volatile("sti");
c0108dd6:	fb                   	sti    
}
c0108dd7:	90                   	nop
c0108dd8:	c9                   	leave  
c0108dd9:	c3                   	ret    

c0108dda <ps2_post_cmd>:


static void ps2_post_cmd(uint8_t port, char cmd, uint16_t arg) {
c0108dda:	55                   	push   %ebp
c0108ddb:	89 e5                	mov    %esp,%ebp
c0108ddd:	83 ec 1c             	sub    $0x1c,%esp
c0108de0:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0108de3:	8b 55 0c             	mov    0xc(%ebp),%edx
c0108de6:	8b 45 10             	mov    0x10(%ebp),%eax
c0108de9:	88 4d ec             	mov    %cl,-0x14(%ebp)
c0108dec:	88 55 e8             	mov    %dl,-0x18(%ebp)
c0108def:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    char result;
    // 等待PS/2输入缓冲区清空，这样我们才可以写入命令
    while((result = io_inb(PS2_PORT_CTRL_STATUS)) & PS2_STATUS_IFULL);
c0108df3:	90                   	nop
c0108df4:	6a 64                	push   $0x64
c0108df6:	e8 d4 fe ff ff       	call   c0108ccf <io_inb>
c0108dfb:	83 c4 04             	add    $0x4,%esp
c0108dfe:	88 45 ff             	mov    %al,-0x1(%ebp)
c0108e01:	0f be 45 ff          	movsbl -0x1(%ebp),%eax
c0108e05:	83 e0 02             	and    $0x2,%eax
c0108e08:	85 c0                	test   %eax,%eax
c0108e0a:	75 e8                	jne    c0108df4 <ps2_post_cmd+0x1a>

    io_outb(port, cmd);
c0108e0c:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c0108e10:	0f b6 d0             	movzbl %al,%edx
c0108e13:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0108e17:	52                   	push   %edx
c0108e18:	50                   	push   %eax
c0108e19:	e8 c6 fe ff ff       	call   c0108ce4 <io_outb>
c0108e1e:	83 c4 08             	add    $0x8,%esp
    if (!(arg & PS2_NO_ARG)) {
c0108e21:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
c0108e25:	25 00 ff 00 00       	and    $0xff00,%eax
c0108e2a:	85 c0                	test   %eax,%eax
c0108e2c:	75 12                	jne    c0108e40 <ps2_post_cmd+0x66>
        // 所有参数一律通过0x60传入。
        io_outb(PS2_PORT_ENC_CMDREG, (uint8_t)(arg & 0x00ff));
c0108e2e:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
c0108e32:	0f b6 c0             	movzbl %al,%eax
c0108e35:	50                   	push   %eax
c0108e36:	6a 60                	push   $0x60
c0108e38:	e8 a7 fe ff ff       	call   c0108ce4 <io_outb>
c0108e3d:	83 c4 08             	add    $0x8,%esp
    }
}
c0108e40:	90                   	nop
c0108e41:	c9                   	leave  
c0108e42:	c3                   	ret    

c0108e43 <ps2_issue_cmd>:

static uint8_t ps2_issue_cmd(char cmd, uint16_t arg) {
c0108e43:	55                   	push   %ebp
c0108e44:	89 e5                	mov    %esp,%ebp
c0108e46:	83 ec 18             	sub    $0x18,%esp
c0108e49:	8b 55 08             	mov    0x8(%ebp),%edx
c0108e4c:	8b 45 0c             	mov    0xc(%ebp),%eax
c0108e4f:	88 55 ec             	mov    %dl,-0x14(%ebp)
c0108e52:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
    ps2_post_cmd(PS2_PORT_CTRL_CMDREG, cmd, arg);
c0108e56:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
c0108e5a:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
c0108e5e:	52                   	push   %edx
c0108e5f:	50                   	push   %eax
c0108e60:	6a 64                	push   $0x64
c0108e62:	e8 73 ff ff ff       	call   c0108dda <ps2_post_cmd>
c0108e67:	83 c4 0c             	add    $0xc,%esp

    char result;
    
    // 等待PS/2控制器返回。通过轮询（polling）状态寄存器的 bit 0
    // 如置位，则表明返回代码此时就在 0x60 IO口上等待读取。
    while(!((result = io_inb(PS2_PORT_CTRL_STATUS)) & PS2_STATUS_OFULL));
c0108e6a:	90                   	nop
c0108e6b:	6a 64                	push   $0x64
c0108e6d:	e8 5d fe ff ff       	call   c0108ccf <io_inb>
c0108e72:	83 c4 04             	add    $0x4,%esp
c0108e75:	88 45 ff             	mov    %al,-0x1(%ebp)
c0108e78:	0f be 45 ff          	movsbl -0x1(%ebp),%eax
c0108e7c:	83 e0 01             	and    $0x1,%eax
c0108e7f:	85 c0                	test   %eax,%eax
c0108e81:	74 e8                	je     c0108e6b <ps2_issue_cmd+0x28>

    return io_inb(PS2_PORT_ENC_CMDREG);
c0108e83:	6a 60                	push   $0x60
c0108e85:	e8 45 fe ff ff       	call   c0108ccf <io_inb>
c0108e8a:	83 c4 04             	add    $0x4,%esp
}
c0108e8d:	c9                   	leave  
c0108e8e:	c3                   	ret    

c0108e8f <ps2_issue_dev_cmd>:

static uint8_t ps2_issue_dev_cmd(char cmd, uint16_t arg) {
c0108e8f:	55                   	push   %ebp
c0108e90:	89 e5                	mov    %esp,%ebp
c0108e92:	83 ec 18             	sub    $0x18,%esp
c0108e95:	8b 55 08             	mov    0x8(%ebp),%edx
c0108e98:	8b 45 0c             	mov    0xc(%ebp),%eax
c0108e9b:	88 55 ec             	mov    %dl,-0x14(%ebp)
c0108e9e:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
    ps2_post_cmd(PS2_PORT_ENC_CMDREG, cmd, arg);
c0108ea2:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
c0108ea6:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
c0108eaa:	52                   	push   %edx
c0108eab:	50                   	push   %eax
c0108eac:	6a 60                	push   $0x60
c0108eae:	e8 27 ff ff ff       	call   c0108dda <ps2_post_cmd>
c0108eb3:	83 c4 0c             	add    $0xc,%esp

    char result;
    
    // 等待PS/2控制器返回。通过轮询（polling）状态寄存器的 bit 0
    // 如置位，则表明返回代码此时就在 0x60 IO口上等待读取。
    while(!((result = io_inb(PS2_PORT_CTRL_STATUS)) & PS2_STATUS_OFULL));
c0108eb6:	90                   	nop
c0108eb7:	6a 64                	push   $0x64
c0108eb9:	e8 11 fe ff ff       	call   c0108ccf <io_inb>
c0108ebe:	83 c4 04             	add    $0x4,%esp
c0108ec1:	88 45 ff             	mov    %al,-0x1(%ebp)
c0108ec4:	0f be 45 ff          	movsbl -0x1(%ebp),%eax
c0108ec8:	83 e0 01             	and    $0x1,%eax
c0108ecb:	85 c0                	test   %eax,%eax
c0108ecd:	74 e8                	je     c0108eb7 <ps2_issue_dev_cmd+0x28>

    return io_inb(PS2_PORT_ENC_CMDREG);
c0108ecf:	6a 60                	push   $0x60
c0108ed1:	e8 f9 fd ff ff       	call   c0108ccf <io_inb>
c0108ed6:	83 c4 04             	add    $0x4,%esp
}
c0108ed9:	c9                   	leave  
c0108eda:	c3                   	ret    

c0108edb <init_ps2k>:

void init_ps2k()
{
c0108edb:	55                   	push   %ebp
c0108edc:	89 e5                	mov    %esp,%ebp
c0108ede:	83 ec 18             	sub    $0x18,%esp
    asm volatile("cli");
c0108ee1:	fa                   	cli    

     // 1、禁用任何的PS/2设备
    ps2_post_cmd(PS2_PORT_CTRL_CMDREG, PS2_CMD_PORT1_DISABLE, PS2_NO_ARG);
c0108ee2:	68 00 ff 00 00       	push   $0xff00
c0108ee7:	6a ad                	push   $0xffffffad
c0108ee9:	6a 64                	push   $0x64
c0108eeb:	e8 ea fe ff ff       	call   c0108dda <ps2_post_cmd>
c0108ef0:	83 c4 0c             	add    $0xc,%esp
    ps2_post_cmd(PS2_PORT_CTRL_CMDREG, PS2_CMD_PORT2_DISABLE, PS2_NO_ARG);
c0108ef3:	68 00 ff 00 00       	push   $0xff00
c0108ef8:	6a a7                	push   $0xffffffa7
c0108efa:	6a 64                	push   $0x64
c0108efc:	e8 d9 fe ff ff       	call   c0108dda <ps2_post_cmd>
c0108f01:	83 c4 0c             	add    $0xc,%esp
    
    // 2、清空控制器缓冲区
    io_inb(PS2_PORT_ENC_DATA);
c0108f04:	6a 60                	push   $0x60
c0108f06:	e8 c4 fd ff ff       	call   c0108ccf <io_inb>
c0108f0b:	83 c4 04             	add    $0x4,%esp

    char result;

    // 3、屏蔽所有PS/2设备（端口1&2）IRQ，并且禁用键盘键码转换功能
    result = ps2_issue_cmd(PS2_CMD_READ_CFG, PS2_NO_ARG);
c0108f0e:	68 00 ff 00 00       	push   $0xff00
c0108f13:	6a 20                	push   $0x20
c0108f15:	e8 29 ff ff ff       	call   c0108e43 <ps2_issue_cmd>
c0108f1a:	83 c4 08             	add    $0x8,%esp
c0108f1d:	88 45 f7             	mov    %al,-0x9(%ebp)
    result = result & ~(PS2_CFG_P1INT | PS2_CFG_P2INT | PS2_CFG_TRANSLATION);
c0108f20:	80 65 f7 bc          	andb   $0xbc,-0x9(%ebp)
    ps2_post_cmd(PS2_PORT_CTRL_CMDREG, PS2_CMD_WRITE_CFG, result);
c0108f24:	66 0f be 45 f7       	movsbw -0x9(%ebp),%ax
c0108f29:	0f b7 c0             	movzwl %ax,%eax
c0108f2c:	50                   	push   %eax
c0108f2d:	6a 60                	push   $0x60
c0108f2f:	6a 64                	push   $0x64
c0108f31:	e8 a4 fe ff ff       	call   c0108dda <ps2_post_cmd>
c0108f36:	83 c4 0c             	add    $0xc,%esp

    // 4、控制器自检
    result = ps2_issue_cmd(PS2_CMD_SELFTEST, PS2_NO_ARG);
c0108f39:	68 00 ff 00 00       	push   $0xff00
c0108f3e:	6a aa                	push   $0xffffffaa
c0108f40:	e8 fe fe ff ff       	call   c0108e43 <ps2_issue_cmd>
c0108f45:	83 c4 08             	add    $0x8,%esp
c0108f48:	88 45 f7             	mov    %al,-0x9(%ebp)
    if (result != PS2_RESULT_TEST_OK) {
c0108f4b:	80 7d f7 55          	cmpb   $0x55,-0x9(%ebp)
c0108f4f:	74 12                	je     c0108f63 <init_ps2k+0x88>
        kprintf("Controller self-test failed.");
c0108f51:	83 ec 0c             	sub    $0xc,%esp
c0108f54:	68 50 d6 28 c0       	push   $0xc028d650
c0108f59:	e8 4a 0f 00 00       	call   c0109ea8 <kprintf>
c0108f5e:	83 c4 10             	add    $0x10,%esp
        goto done;
c0108f61:	eb 72                	jmp    c0108fd5 <init_ps2k+0xfa>
    }

    // 5、设备自检（端口1自检，通常是我们的键盘）
    result = ps2_issue_cmd(PS2_CMD_SELFTEST_PORT1, PS2_NO_ARG);
c0108f63:	83 ec 08             	sub    $0x8,%esp
c0108f66:	68 00 ff 00 00       	push   $0xff00
c0108f6b:	6a ab                	push   $0xffffffab
c0108f6d:	e8 d1 fe ff ff       	call   c0108e43 <ps2_issue_cmd>
c0108f72:	83 c4 10             	add    $0x10,%esp
c0108f75:	88 45 f7             	mov    %al,-0x9(%ebp)
    if (result != 0) {
c0108f78:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
c0108f7c:	74 12                	je     c0108f90 <init_ps2k+0xb5>
        kprintf("Interface test on port 1 failed.");
c0108f7e:	83 ec 0c             	sub    $0xc,%esp
c0108f81:	68 70 d6 28 c0       	push   $0xc028d670
c0108f86:	e8 1d 0f 00 00       	call   c0109ea8 <kprintf>
c0108f8b:	83 c4 10             	add    $0x10,%esp
        goto done;
c0108f8e:	eb 45                	jmp    c0108fd5 <init_ps2k+0xfa>
    }

    // 6、开启位于端口1的 IRQ，并启用端口1。不用理会端口2，那儿一般是鼠标。
    ps2_post_cmd(PS2_PORT_CTRL_CMDREG, PS2_CMD_PORT1_ENABLE, PS2_NO_ARG);
c0108f90:	83 ec 04             	sub    $0x4,%esp
c0108f93:	68 00 ff 00 00       	push   $0xff00
c0108f98:	6a ae                	push   $0xffffffae
c0108f9a:	6a 64                	push   $0x64
c0108f9c:	e8 39 fe ff ff       	call   c0108dda <ps2_post_cmd>
c0108fa1:	83 c4 10             	add    $0x10,%esp
    result = ps2_issue_cmd(PS2_CMD_READ_CFG, PS2_NO_ARG);
c0108fa4:	83 ec 08             	sub    $0x8,%esp
c0108fa7:	68 00 ff 00 00       	push   $0xff00
c0108fac:	6a 20                	push   $0x20
c0108fae:	e8 90 fe ff ff       	call   c0108e43 <ps2_issue_cmd>
c0108fb3:	83 c4 10             	add    $0x10,%esp
c0108fb6:	88 45 f7             	mov    %al,-0x9(%ebp)
    result = result | PS2_CFG_P1INT;
c0108fb9:	80 4d f7 01          	orb    $0x1,-0x9(%ebp)
    ps2_post_cmd(PS2_PORT_CTRL_CMDREG, PS2_CMD_WRITE_CFG, result);
c0108fbd:	66 0f be 45 f7       	movsbw -0x9(%ebp),%ax
c0108fc2:	0f b7 c0             	movzwl %ax,%eax
c0108fc5:	83 ec 04             	sub    $0x4,%esp
c0108fc8:	50                   	push   %eax
c0108fc9:	6a 60                	push   $0x60
c0108fcb:	6a 64                	push   $0x64
c0108fcd:	e8 08 fe ff ff       	call   c0108dda <ps2_post_cmd>
c0108fd2:	83 c4 10             	add    $0x10,%esp

    // 至此，PS/2控制器和设备已完成初始化，可以正常使用。

done:
    asm volatile("sti");
c0108fd5:	fb                   	sti    
}
c0108fd6:	90                   	nop
c0108fd7:	c9                   	leave  
c0108fd8:	c3                   	ret    

c0108fd9 <init_keyboard>:



void init_keyboard()
{
c0108fd9:	55                   	push   %ebp
c0108fda:	89 e5                	mov    %esp,%ebp
c0108fdc:	83 ec 18             	sub    $0x18,%esp
    asm("cli");
c0108fdf:	fa                   	cli    
    init_8259();
c0108fe0:	e8 33 fd ff ff       	call   c0108d18 <init_8259>

    uint8_t result = io_inb(0x21);
c0108fe5:	6a 21                	push   $0x21
c0108fe7:	e8 e3 fc ff ff       	call   c0108ccf <io_inb>
c0108fec:	83 c4 04             	add    $0x4,%esp
c0108fef:	88 45 f7             	mov    %al,-0x9(%ebp)
    io_outb(0x21, result & 0xfd);
c0108ff2:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0108ff6:	25 fd 00 00 00       	and    $0xfd,%eax
c0108ffb:	50                   	push   %eax
c0108ffc:	6a 21                	push   $0x21
c0108ffe:	e8 e1 fc ff ff       	call   c0108ce4 <io_outb>
c0109003:	83 c4 08             	add    $0x8,%esp
    cpu_delay();
c0109006:	e8 f0 fc ff ff       	call   c0108cfb <cpu_delay>
    result = io_inb(0x21);
c010900b:	6a 21                	push   $0x21
c010900d:	e8 bd fc ff ff       	call   c0108ccf <io_inb>
c0109012:	83 c4 04             	add    $0x4,%esp
c0109015:	88 45 f7             	mov    %al,-0x9(%ebp)

    init_ps2k();
c0109018:	e8 be fe ff ff       	call   c0108edb <init_ps2k>
    
    _set_idt_entry(0x21, 0x08, &handle_keywords, 0);
c010901d:	6a 00                	push   $0x0
c010901f:	68 34 90 10 c0       	push   $0xc0109034
c0109024:	6a 08                	push   $0x8
c0109026:	6a 21                	push   $0x21
c0109028:	e8 22 fa ff ff       	call   c0108a4f <_set_idt_entry>
c010902d:	83 c4 10             	add    $0x10,%esp
    asm("sti");
c0109030:	fb                   	sti    
}
c0109031:	90                   	nop
c0109032:	c9                   	leave  
c0109033:	c3                   	ret    

c0109034 <handle_keywords>:

static void handle_keywords()
{
c0109034:	55                   	push   %ebp
c0109035:	89 e5                	mov    %esp,%ebp
c0109037:	83 ec 18             	sub    $0x18,%esp
    crtl_status, shift_status, alt_status, caps_lock_status, ext_scancode = 0;
c010903a:	c6 05 c4 b7 28 c0 00 	movb   $0x0,0xc028b7c4
    asm volatile("cli");
c0109041:	fa                   	cli    
    io_outb(0x61, 0x20);
c0109042:	6a 20                	push   $0x20
c0109044:	6a 61                	push   $0x61
c0109046:	e8 99 fc ff ff       	call   c0108ce4 <io_outb>
c010904b:	83 c4 08             	add    $0x8,%esp
    uint8_t ctrl_down_last = crtl_status;
c010904e:	0f b6 05 c0 b7 28 c0 	movzbl 0xc028b7c0,%eax
c0109055:	88 45 f4             	mov    %al,-0xc(%ebp)
    uint8_t shift_down_last = shift_status;
c0109058:	0f b6 05 c1 b7 28 c0 	movzbl 0xc028b7c1,%eax
c010905f:	88 45 f3             	mov    %al,-0xd(%ebp)
    uint8_t caps_lock_last = caps_lock_status;
c0109062:	0f b6 05 c3 b7 28 c0 	movzbl 0xc028b7c3,%eax
c0109069:	88 45 f2             	mov    %al,-0xe(%ebp)

    uint8_t break_code;
    uint16_t scancode = io_inb(0x60);
c010906c:	6a 60                	push   $0x60
c010906e:	e8 5c fc ff ff       	call   c0108ccf <io_inb>
c0109073:	83 c4 04             	add    $0x4,%esp
c0109076:	0f b6 c0             	movzbl %al,%eax
c0109079:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
    
    if(scancode == 0xe0){
c010907d:	66 81 7d f6 e0 00    	cmpw   $0xe0,-0xa(%ebp)
c0109083:	75 25                	jne    c01090aa <handle_keywords+0x76>
        ext_scancode = 1;
c0109085:	c6 05 c4 b7 28 c0 01 	movb   $0x1,0xc028b7c4
        io_outb(0x20, 0x20);
c010908c:	6a 20                	push   $0x20
c010908e:	6a 20                	push   $0x20
c0109090:	e8 4f fc ff ff       	call   c0108ce4 <io_outb>
c0109095:	83 c4 08             	add    $0x8,%esp
        io_outb(0x20, 0x20);
c0109098:	6a 20                	push   $0x20
c010909a:	6a 20                	push   $0x20
c010909c:	e8 43 fc ff ff       	call   c0108ce4 <io_outb>
c01090a1:	83 c4 08             	add    $0x8,%esp
        asm volatile("sti");
c01090a4:	fb                   	sti    
        return;
c01090a5:	e9 1a 02 00 00       	jmp    c01092c4 <handle_keywords+0x290>
    }
    if(ext_scancode){
c01090aa:	0f b6 05 c4 b7 28 c0 	movzbl 0xc028b7c4,%eax
c01090b1:	84 c0                	test   %al,%al
c01090b3:	74 0d                	je     c01090c2 <handle_keywords+0x8e>
        scancode = ((0xe000) | scancode);
c01090b5:	66 81 4d f6 00 e0    	orw    $0xe000,-0xa(%ebp)
        ext_scancode = 0;
c01090bb:	c6 05 c4 b7 28 c0 00 	movb   $0x0,0xc028b7c4
    }

    break_code = ((0x0080 & scancode) != 0);
c01090c2:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c01090c6:	66 25 80 00          	and    $0x80,%ax
c01090ca:	66 85 c0             	test   %ax,%ax
c01090cd:	0f 95 c0             	setne  %al
c01090d0:	88 45 f1             	mov    %al,-0xf(%ebp)

    if(break_code)//tan qi ma
c01090d3:	80 7d f1 00          	cmpb   $0x0,-0xf(%ebp)
c01090d7:	74 6d                	je     c0109146 <handle_keywords+0x112>
    {
        uint16_t make_code = (scancode & 0xff7f);
c01090d9:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c01090dd:	24 7f                	and    $0x7f,%al
c01090df:	66 89 45 ec          	mov    %ax,-0x14(%ebp)

        if(make_code == crtl_l_make || make_code == crtl_r_make)
c01090e3:	66 83 7d ec 1d       	cmpw   $0x1d,-0x14(%ebp)
c01090e8:	74 08                	je     c01090f2 <handle_keywords+0xbe>
c01090ea:	66 81 7d ec 1d e0    	cmpw   $0xe01d,-0x14(%ebp)
c01090f0:	75 09                	jne    c01090fb <handle_keywords+0xc7>
        {
            crtl_status = 0;
c01090f2:	c6 05 c0 b7 28 c0 00 	movb   $0x0,0xc028b7c0
c01090f9:	eb 2d                	jmp    c0109128 <handle_keywords+0xf4>
        }else if(make_code == shift_l_make || make_code == shift_r_make){
c01090fb:	66 83 7d ec 2a       	cmpw   $0x2a,-0x14(%ebp)
c0109100:	74 07                	je     c0109109 <handle_keywords+0xd5>
c0109102:	66 83 7d ec 36       	cmpw   $0x36,-0x14(%ebp)
c0109107:	75 09                	jne    c0109112 <handle_keywords+0xde>
            shift_status = 0;
c0109109:	c6 05 c1 b7 28 c0 00 	movb   $0x0,0xc028b7c1
c0109110:	eb 16                	jmp    c0109128 <handle_keywords+0xf4>
        }else if(make_code == alt_l_make || make_code == alt_r_make){
c0109112:	66 83 7d ec 38       	cmpw   $0x38,-0x14(%ebp)
c0109117:	74 08                	je     c0109121 <handle_keywords+0xed>
c0109119:	66 81 7d ec 38 e0    	cmpw   $0xe038,-0x14(%ebp)
c010911f:	75 07                	jne    c0109128 <handle_keywords+0xf4>
            alt_status = 0;
c0109121:	c6 05 c2 b7 28 c0 00 	movb   $0x0,0xc028b7c2
        }
        io_outb(0x20, 0x20);
c0109128:	6a 20                	push   $0x20
c010912a:	6a 20                	push   $0x20
c010912c:	e8 b3 fb ff ff       	call   c0108ce4 <io_outb>
c0109131:	83 c4 08             	add    $0x8,%esp
        io_outb(0x20, 0x20);
c0109134:	6a 20                	push   $0x20
c0109136:	6a 20                	push   $0x20
c0109138:	e8 a7 fb ff ff       	call   c0108ce4 <io_outb>
c010913d:	83 c4 08             	add    $0x8,%esp
        asm volatile("sti");
c0109140:	fb                   	sti    
        return;
c0109141:	e9 7e 01 00 00       	jmp    c01092c4 <handle_keywords+0x290>
    }//if is common word, hand
    else if((scancode > 0x00 && scancode < 0x3b) ||\
c0109146:	66 83 7d f6 00       	cmpw   $0x0,-0xa(%ebp)
c010914b:	74 07                	je     c0109154 <handle_keywords+0x120>
c010914d:	66 83 7d f6 3a       	cmpw   $0x3a,-0xa(%ebp)
c0109152:	76 14                	jbe    c0109168 <handle_keywords+0x134>
c0109154:	66 81 7d f6 38 e0    	cmpw   $0xe038,-0xa(%ebp)
c010915a:	74 0c                	je     c0109168 <handle_keywords+0x134>
            (scancode == alt_r_make) || \
c010915c:	66 81 7d f6 1d e0    	cmpw   $0xe01d,-0xa(%ebp)
c0109162:	0f 85 20 01 00 00    	jne    c0109288 <handle_keywords+0x254>
            (scancode == crtl_r_make)){
        uint8_t shift = 0;
c0109168:	c6 45 f5 00          	movb   $0x0,-0xb(%ebp)
        if((scancode < 0x0e) || (scancode == 0x29) || \
c010916c:	66 83 7d f6 0d       	cmpw   $0xd,-0xa(%ebp)
c0109171:	76 3f                	jbe    c01091b2 <handle_keywords+0x17e>
c0109173:	66 83 7d f6 29       	cmpw   $0x29,-0xa(%ebp)
c0109178:	74 38                	je     c01091b2 <handle_keywords+0x17e>
c010917a:	66 83 7d f6 1a       	cmpw   $0x1a,-0xa(%ebp)
c010917f:	74 31                	je     c01091b2 <handle_keywords+0x17e>
           (scancode == 0x1a) || (scancode == 0x1b) ||\
c0109181:	66 83 7d f6 1b       	cmpw   $0x1b,-0xa(%ebp)
c0109186:	74 2a                	je     c01091b2 <handle_keywords+0x17e>
c0109188:	66 83 7d f6 2b       	cmpw   $0x2b,-0xa(%ebp)
c010918d:	74 23                	je     c01091b2 <handle_keywords+0x17e>
           (scancode == 0x2b) || (scancode == 0x27) ||\
c010918f:	66 83 7d f6 27       	cmpw   $0x27,-0xa(%ebp)
c0109194:	74 1c                	je     c01091b2 <handle_keywords+0x17e>
c0109196:	66 83 7d f6 28       	cmpw   $0x28,-0xa(%ebp)
c010919b:	74 15                	je     c01091b2 <handle_keywords+0x17e>
           (scancode == 0x28) || (scancode == 0x33) ||\
c010919d:	66 83 7d f6 33       	cmpw   $0x33,-0xa(%ebp)
c01091a2:	74 0e                	je     c01091b2 <handle_keywords+0x17e>
c01091a4:	66 83 7d f6 34       	cmpw   $0x34,-0xa(%ebp)
c01091a9:	74 07                	je     c01091b2 <handle_keywords+0x17e>
           (scancode == 0x34) || (scancode == 0x35)){
c01091ab:	66 83 7d f6 35       	cmpw   $0x35,-0xa(%ebp)
c01091b0:	75 34                	jne    c01091e6 <handle_keywords+0x1b2>
            if(shift_down_last)
c01091b2:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
c01091b6:	74 06                	je     c01091be <handle_keywords+0x18a>
                shift = 1;
c01091b8:	c6 45 f5 01          	movb   $0x1,-0xb(%ebp)
c01091bc:	eb 28                	jmp    c01091e6 <handle_keywords+0x1b2>
            else{
                if(shift_down_last && caps_lock_last)
c01091be:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
c01091c2:	74 0c                	je     c01091d0 <handle_keywords+0x19c>
c01091c4:	80 7d f2 00          	cmpb   $0x0,-0xe(%ebp)
c01091c8:	74 06                	je     c01091d0 <handle_keywords+0x19c>
                    shift = 0;
c01091ca:	c6 45 f5 00          	movb   $0x0,-0xb(%ebp)
c01091ce:	eb 16                	jmp    c01091e6 <handle_keywords+0x1b2>
                else if(shift_down_last || caps_lock_last)
c01091d0:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
c01091d4:	75 06                	jne    c01091dc <handle_keywords+0x1a8>
c01091d6:	80 7d f2 00          	cmpb   $0x0,-0xe(%ebp)
c01091da:	74 06                	je     c01091e2 <handle_keywords+0x1ae>
                    shift = 1;
c01091dc:	c6 45 f5 01          	movb   $0x1,-0xb(%ebp)
c01091e0:	eb 04                	jmp    c01091e6 <handle_keywords+0x1b2>
                else
                    shift = 0;
c01091e2:	c6 45 f5 00          	movb   $0x0,-0xb(%ebp)
                }
           }
        uint8_t index = (scancode &= 0x00ff);
c01091e6:	66 81 65 f6 ff 00    	andw   $0xff,-0xa(%ebp)
c01091ec:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c01091f0:	88 45 f0             	mov    %al,-0x10(%ebp)
        char cur_char = key_map[index][shift];
c01091f3:	0f b6 55 f0          	movzbl -0x10(%ebp),%edx
c01091f7:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
c01091fb:	0f b6 84 50 a0 c0 28 	movzbl -0x3fd73f60(%eax,%edx,2),%eax
c0109202:	c0 
c0109203:	88 45 ef             	mov    %al,-0x11(%ebp)

        if(cur_char){
c0109206:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
c010920a:	74 34                	je     c0109240 <handle_keywords+0x20c>
            vga_put_char(cur_char);
c010920c:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
c0109210:	83 ec 0c             	sub    $0xc,%esp
c0109213:	50                   	push   %eax
c0109214:	e8 05 ce ff ff       	call   c010601e <vga_put_char>
c0109219:	83 c4 10             	add    $0x10,%esp
            io_outb(0x20, 0x20);
c010921c:	83 ec 08             	sub    $0x8,%esp
c010921f:	6a 20                	push   $0x20
c0109221:	6a 20                	push   $0x20
c0109223:	e8 bc fa ff ff       	call   c0108ce4 <io_outb>
c0109228:	83 c4 10             	add    $0x10,%esp
            io_outb(0x20, 0x20);
c010922b:	83 ec 08             	sub    $0x8,%esp
c010922e:	6a 20                	push   $0x20
c0109230:	6a 20                	push   $0x20
c0109232:	e8 ad fa ff ff       	call   c0108ce4 <io_outb>
c0109237:	83 c4 10             	add    $0x10,%esp
            asm volatile("sti");
c010923a:	fb                   	sti    
            return;
c010923b:	e9 84 00 00 00       	jmp    c01092c4 <handle_keywords+0x290>
        }

        if(scancode == crtl_l_make || scancode == crtl_r_make)
c0109240:	66 83 7d f6 1d       	cmpw   $0x1d,-0xa(%ebp)
c0109245:	74 08                	je     c010924f <handle_keywords+0x21b>
c0109247:	66 81 7d f6 1d e0    	cmpw   $0xe01d,-0xa(%ebp)
c010924d:	75 09                	jne    c0109258 <handle_keywords+0x224>
            crtl_status = 1;
c010924f:	c6 05 c0 b7 28 c0 01 	movb   $0x1,0xc028b7c0
c0109256:	eb 2e                	jmp    c0109286 <handle_keywords+0x252>
        else if(scancode == shift_l_make || scancode == shift_r_make)
c0109258:	66 83 7d f6 2a       	cmpw   $0x2a,-0xa(%ebp)
c010925d:	74 07                	je     c0109266 <handle_keywords+0x232>
c010925f:	66 83 7d f6 36       	cmpw   $0x36,-0xa(%ebp)
c0109264:	75 09                	jne    c010926f <handle_keywords+0x23b>
            shift_status = 1;
c0109266:	c6 05 c1 b7 28 c0 01 	movb   $0x1,0xc028b7c1
c010926d:	eb 17                	jmp    c0109286 <handle_keywords+0x252>
        else if(scancode == caps_lock_make)
c010926f:	66 83 7d f6 3a       	cmpw   $0x3a,-0xa(%ebp)
c0109274:	75 4d                	jne    c01092c3 <handle_keywords+0x28f>
            caps_lock_status = ~caps_lock_status;
c0109276:	0f b6 05 c3 b7 28 c0 	movzbl 0xc028b7c3,%eax
c010927d:	f7 d0                	not    %eax
c010927f:	a2 c3 b7 28 c0       	mov    %al,0xc028b7c3
            (scancode == crtl_r_make)){
c0109284:	eb 3d                	jmp    c01092c3 <handle_keywords+0x28f>
c0109286:	eb 3b                	jmp    c01092c3 <handle_keywords+0x28f>
    }else{
        vga_put_char((char)(scancode && 0x00ff));
c0109288:	66 83 7d f6 00       	cmpw   $0x0,-0xa(%ebp)
c010928d:	0f 95 c0             	setne  %al
c0109290:	0f b6 c0             	movzbl %al,%eax
c0109293:	0f be c0             	movsbl %al,%eax
c0109296:	83 ec 0c             	sub    $0xc,%esp
c0109299:	50                   	push   %eax
c010929a:	e8 7f cd ff ff       	call   c010601e <vga_put_char>
c010929f:	83 c4 10             	add    $0x10,%esp
        io_outb(0x20, 0x20);
c01092a2:	83 ec 08             	sub    $0x8,%esp
c01092a5:	6a 20                	push   $0x20
c01092a7:	6a 20                	push   $0x20
c01092a9:	e8 36 fa ff ff       	call   c0108ce4 <io_outb>
c01092ae:	83 c4 10             	add    $0x10,%esp
        io_outb(0x20, 0x20);
c01092b1:	83 ec 08             	sub    $0x8,%esp
c01092b4:	6a 20                	push   $0x20
c01092b6:	6a 20                	push   $0x20
c01092b8:	e8 27 fa ff ff       	call   c0108ce4 <io_outb>
c01092bd:	83 c4 10             	add    $0x10,%esp
        asm volatile("sti");
c01092c0:	fb                   	sti    
c01092c1:	eb 01                	jmp    c01092c4 <handle_keywords+0x290>
            (scancode == crtl_r_make)){
c01092c3:	90                   	nop
    }
c01092c4:	c9                   	leave  
c01092c5:	c3                   	ret    

c01092c6 <syscall>:
{
c01092c6:	55                   	push   %ebp
c01092c7:	89 e5                	mov    %esp,%ebp
c01092c9:	57                   	push   %edi
    asm volatile("int %0" ::"i"(0x80), "D"(callcode) : "eax");
c01092ca:	8b 55 08             	mov    0x8(%ebp),%edx
c01092cd:	89 d7                	mov    %edx,%edi
c01092cf:	cd 80                	int    $0x80
}
c01092d1:	90                   	nop
c01092d2:	8b 7d fc             	mov    -0x4(%ebp),%edi
c01092d5:	c9                   	leave  
c01092d6:	c3                   	ret    

c01092d7 <syscall_install>:
#include <kernel/process/peocess.h>
#include <syscall/syscall.h>

extern void syscall_handlr(isr_param* param);

void syscall_install() {
c01092d7:	55                   	push   %ebp
c01092d8:	89 e5                	mov    %esp,%ebp
c01092da:	83 ec 08             	sub    $0x8,%esp
    intr_subscribe(MELOX_SYS_CALL, syscall_handlr);
c01092dd:	83 ec 08             	sub    $0x8,%esp
c01092e0:	68 f5 92 10 c0       	push   $0xc01092f5
c01092e5:	68 80 00 00 00       	push   $0x80
c01092ea:	e8 78 ef ff ff       	call   c0108267 <intr_subscribe>
c01092ef:	83 c4 10             	add    $0x10,%esp
}
c01092f2:	90                   	nop
c01092f3:	c9                   	leave  
c01092f4:	c3                   	ret    

c01092f5 <syscall_handlr>:
c01092f5:	55                   	push   %ebp
c01092f6:	8b 6c 24 08          	mov    0x8(%esp),%ebp
c01092fa:	8b 45 00             	mov    0x0(%ebp),%eax
c01092fd:	3d 00 01 00 00       	cmp    $0x100,%eax
c0109302:	73 0d                	jae    c0109311 <syscall_handlr+0x1c>
c0109304:	c1 e0 02             	shl    $0x2,%eax
c0109307:	05 74 c1 28 c0       	add    $0xc028c174,%eax
c010930c:	83 38 00             	cmpl   $0x0,(%eax)
c010930f:	75 04                	jne    c0109315 <syscall_handlr+0x20>
c0109311:	f7 d8                	neg    %eax
c0109313:	5d                   	pop    %ebp
c0109314:	c3                   	ret    
c0109315:	ff 75 18             	push   0x18(%ebp)
c0109318:	ff 75 14             	push   0x14(%ebp)
c010931b:	ff 75 10             	push   0x10(%ebp)
c010931e:	ff 75 0c             	push   0xc(%ebp)
c0109321:	ff 75 08             	push   0x8(%ebp)
c0109324:	ff 75 04             	push   0x4(%ebp)
c0109327:	ff 10                	call   *(%eax)
c0109329:	89 45 00             	mov    %eax,0x0(%ebp)
c010932c:	83 c4 18             	add    $0x18,%esp
c010932f:	5d                   	pop    %ebp
c0109330:	c3                   	ret    

c0109331 <__assert_fail>:
#include <common.h>
#include <libs/mstdio.h>

static char buffer[1024];

void __assert_fail(const char* expr, const char* file, unsigned int line) {
c0109331:	55                   	push   %ebp
c0109332:	89 e5                	mov    %esp,%ebp
c0109334:	57                   	push   %edi
c0109335:	83 ec 04             	sub    $0x4,%esp
    kprintf(buffer, "%s (%s:%u)", expr, file, line);
c0109338:	83 ec 0c             	sub    $0xc,%esp
c010933b:	ff 75 10             	push   0x10(%ebp)
c010933e:	ff 75 0c             	push   0xc(%ebp)
c0109341:	ff 75 08             	push   0x8(%ebp)
c0109344:	68 91 d6 28 c0       	push   $0xc028d691
c0109349:	68 e0 b7 28 c0       	push   $0xc028b7e0
c010934e:	e8 55 0b 00 00       	call   c0109ea8 <kprintf>
c0109353:	83 c4 20             	add    $0x20,%esp

    // Here we load the buffer's address into %edi ("D" constraint)
    //  This is a convention we made that the LUNAIX_SYS_PANIC syscall will
    //  print the panic message passed via %edi. (see kernel/asm/x86/interrupts.c)
    asm(
c0109356:	b8 e0 b7 28 c0       	mov    $0xc028b7e0,%eax
c010935b:	89 c7                	mov    %eax,%edi
c010935d:	cd 20                	int    $0x20
        "int %0"
        ::"i"(32), "D"(buffer)
    );

    while(1);     // never reach
c010935f:	eb fe                	jmp    c010935f <__assert_fail+0x2e>

c0109361 <cpu_invplg>:
{
c0109361:	55                   	push   %ebp
c0109362:	89 e5                	mov    %esp,%ebp
    asm volatile("invlpg (%0)" ::"r"((unsigned int)va) : "memory");
c0109364:	8b 45 08             	mov    0x8(%ebp),%eax
c0109367:	0f 01 38             	invlpg (%eax)
};
c010936a:	90                   	nop
c010936b:	5d                   	pop    %ebp
c010936c:	c3                   	ret    

c010936d <llist_init_head>:
static inline void llist_init_head(struct llist_header* head) {
c010936d:	55                   	push   %ebp
c010936e:	89 e5                	mov    %esp,%ebp
    head->next = head;
c0109370:	8b 45 08             	mov    0x8(%ebp),%eax
c0109373:	8b 55 08             	mov    0x8(%ebp),%edx
c0109376:	89 50 04             	mov    %edx,0x4(%eax)
    head->prev = head;
c0109379:	8b 45 08             	mov    0x8(%ebp),%eax
c010937c:	8b 55 08             	mov    0x8(%ebp),%edx
c010937f:	89 10                	mov    %edx,(%eax)
}
c0109381:	90                   	nop
c0109382:	5d                   	pop    %ebp
c0109383:	c3                   	ret    

c0109384 <syscall>:
{
c0109384:	55                   	push   %ebp
c0109385:	89 e5                	mov    %esp,%ebp
c0109387:	57                   	push   %edi
    asm volatile("int %0" ::"i"(0x80), "D"(callcode) : "eax");
c0109388:	8b 55 08             	mov    0x8(%ebp),%edx
c010938b:	89 d7                	mov    %edx,%edi
c010938d:	cd 80                	int    $0x80
}
c010938f:	90                   	nop
c0109390:	8b 7d fc             	mov    -0x4(%ebp),%edi
c0109393:	c9                   	leave  
c0109394:	c3                   	ret    

c0109395 <__mxsys_fork>:
#include <syscall/syscall.h>

extern volatile struct m_pcb* __current;//TODO MOVE TO .H AND TODO SCHEDULE

__DEFINE_MXSYSCALL(pid_t, fork)
{
c0109395:	55                   	push   %ebp
c0109396:	89 e5                	mov    %esp,%ebp
c0109398:	83 ec 08             	sub    $0x8,%esp
    return m_fork();
c010939b:	e8 71 02 00 00       	call   c0109611 <m_fork>
}
c01093a0:	c9                   	leave  
c01093a1:	c3                   	ret    

c01093a2 <__mxsys_getpid>:

__DEFINE_MXSYSCALL(pid_t, getpid)
{
c01093a2:	55                   	push   %ebp
c01093a3:	89 e5                	mov    %esp,%ebp
    return __current->pid;
c01093a5:	a1 e0 bb 28 c0       	mov    0xc028bbe0,%eax
c01093aa:	8b 00                	mov    (%eax),%eax
}
c01093ac:	5d                   	pop    %ebp
c01093ad:	c3                   	ret    

c01093ae <__mxsys_getppid>:

__DEFINE_MXSYSCALL(pid_t, getppid)
{
c01093ae:	55                   	push   %ebp
c01093af:	89 e5                	mov    %esp,%ebp
    return __current->parent->pid;
c01093b1:	a1 e0 bb 28 c0       	mov    0xc028bbe0,%eax
c01093b6:	8b 40 04             	mov    0x4(%eax),%eax
c01093b9:	8b 00                	mov    (%eax),%eax
}
c01093bb:	5d                   	pop    %ebp
c01093bc:	c3                   	ret    

c01093bd <init_proc>:

void init_proc(struct m_pcb* pcb)
{
c01093bd:	55                   	push   %ebp
c01093be:	89 e5                	mov    %esp,%ebp
c01093c0:	83 ec 08             	sub    $0x8,%esp
    memset(pcb, 0, sizeof(*pcb));
c01093c3:	83 ec 04             	sub    $0x4,%esp
c01093c6:	6a 6c                	push   $0x6c
c01093c8:	6a 00                	push   $0x0
c01093ca:	ff 75 08             	push   0x8(%ebp)
c01093cd:	e8 6d 0d 00 00       	call   c010a13f <memset>
c01093d2:	83 c4 10             	add    $0x10,%esp

    pcb->pid = alloc_pid();
c01093d5:	e8 92 07 00 00       	call   c0109b6c <alloc_pid>
c01093da:	8b 55 08             	mov    0x8(%ebp),%edx
c01093dd:	89 02                	mov    %eax,(%edx)
    pcb->state = PROC_CREATED;
c01093df:	8b 45 08             	mov    0x8(%ebp),%eax
c01093e2:	c6 40 44 10          	movb   $0x10,0x44(%eax)
    pcb->pro_ticks = 10;
c01093e6:	8b 45 08             	mov    0x8(%ebp),%eax
c01093e9:	c7 40 5c 0a 00 00 00 	movl   $0xa,0x5c(%eax)
}
c01093f0:	90                   	nop
c01093f1:	c9                   	leave  
c01093f2:	c3                   	ret    

c01093f3 <copy_page>:

void* copy_page(pid_t pid, uintptr_t mount_point)
{
c01093f3:	55                   	push   %ebp
c01093f4:	89 e5                	mov    %esp,%ebp
c01093f6:	83 ec 38             	sub    $0x38,%esp
    void* pid_ptd = pmm_alloc_page(pid, PP_FGPERSIST);
c01093f9:	83 ec 08             	sub    $0x8,%esp
c01093fc:	6a 01                	push   $0x1
c01093fe:	ff 75 08             	push   0x8(%ebp)
c0109401:	e8 da d4 ff ff       	call   c01068e0 <pmm_alloc_page>
c0109406:	83 c4 10             	add    $0x10,%esp
c0109409:	89 45 ec             	mov    %eax,-0x14(%ebp)
    ptd_t* vpid_ptd = vmm_cover_map_page(pid, PD_MOUNT_1, pid_ptd, PG_PREM_RW, PG_PREM_RW);
c010940c:	83 ec 0c             	sub    $0xc,%esp
c010940f:	6a 03                	push   $0x3
c0109411:	6a 03                	push   $0x3
c0109413:	ff 75 ec             	push   -0x14(%ebp)
c0109416:	68 00 00 c0 af       	push   $0xafc00000
c010941b:	ff 75 08             	push   0x8(%ebp)
c010941e:	e8 b6 e3 ff ff       	call   c01077d9 <vmm_cover_map_page>
c0109423:	83 c4 20             	add    $0x20,%esp
c0109426:	89 45 e8             	mov    %eax,-0x18(%ebp)
    ptd_t* mount_ptd = (ptd_t*)(mount_point | (0x3FFU << 12));
c0109429:	8b 45 0c             	mov    0xc(%ebp),%eax
c010942c:	0d 00 f0 3f 00       	or     $0x3ff000,%eax
c0109431:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    for(size_t i = 0; i < PG_MAX_ENTRIES - 1; i++)
c0109434:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c010943b:	e9 e9 00 00 00       	jmp    c0109529 <copy_page+0x136>
    {
        ptd_t mount_ptde = mount_ptd[i];
c0109440:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109443:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010944a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010944d:	01 d0                	add    %edx,%eax
c010944f:	8b 00                	mov    (%eax),%eax
c0109451:	89 45 e0             	mov    %eax,-0x20(%ebp)
        if(!mount_point || !(mount_ptde & PG_PRESENT))
c0109454:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0109458:	74 0a                	je     c0109464 <copy_page+0x71>
c010945a:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010945d:	83 e0 01             	and    $0x1,%eax
c0109460:	85 c0                	test   %eax,%eax
c0109462:	75 19                	jne    c010947d <copy_page+0x8a>
        {
            vpid_ptd[i] = mount_ptde;
c0109464:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109467:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010946e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0109471:	01 c2                	add    %eax,%edx
c0109473:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0109476:	89 02                	mov    %eax,(%edx)
            continue;
c0109478:	e9 a8 00 00 00       	jmp    c0109525 <copy_page+0x132>
        }

        void* pid_pt = pmm_alloc_page(pid, PP_FGPERSIST);
c010947d:	83 ec 08             	sub    $0x8,%esp
c0109480:	6a 01                	push   $0x1
c0109482:	ff 75 08             	push   0x8(%ebp)
c0109485:	e8 56 d4 ff ff       	call   c01068e0 <pmm_alloc_page>
c010948a:	83 c4 10             	add    $0x10,%esp
c010948d:	89 45 dc             	mov    %eax,-0x24(%ebp)
        pt_t* vpid_pt = vmm_cover_map_page(pid, PG_MOUNT_2, pid_pt, PG_PREM_RW, PG_PREM_RW);
c0109490:	83 ec 0c             	sub    $0xc,%esp
c0109493:	6a 03                	push   $0x3
c0109495:	6a 03                	push   $0x3
c0109497:	ff 75 dc             	push   -0x24(%ebp)
c010949a:	68 00 e0 7f af       	push   $0xaf7fe000
c010949f:	ff 75 08             	push   0x8(%ebp)
c01094a2:	e8 32 e3 ff ff       	call   c01077d9 <vmm_cover_map_page>
c01094a7:	83 c4 20             	add    $0x20,%esp
c01094aa:	89 45 d8             	mov    %eax,-0x28(%ebp)
        pt_t* mount_pt = (ptd_t*)(mount_point | (i << 12));
c01094ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01094b0:	c1 e0 0c             	shl    $0xc,%eax
c01094b3:	0b 45 0c             	or     0xc(%ebp),%eax
c01094b6:	89 45 d4             	mov    %eax,-0x2c(%ebp)

        for(size_t j = 0; j < PG_MAX_ENTRIES; j++)
c01094b9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c01094c0:	eb 43                	jmp    c0109505 <copy_page+0x112>
        {
            pt_t mount_pte = mount_pt[j];
c01094c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01094c5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c01094cc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c01094cf:	01 d0                	add    %edx,%eax
c01094d1:	8b 00                	mov    (%eax),%eax
c01094d3:	89 45 d0             	mov    %eax,-0x30(%ebp)
            pmm_ref_page(pid, PG_ENTRY_ADDR(mount_pte));
c01094d6:	8b 45 d0             	mov    -0x30(%ebp),%eax
c01094d9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c01094de:	83 ec 08             	sub    $0x8,%esp
c01094e1:	50                   	push   %eax
c01094e2:	ff 75 08             	push   0x8(%ebp)
c01094e5:	e8 bd d5 ff ff       	call   c0106aa7 <pmm_ref_page>
c01094ea:	83 c4 10             	add    $0x10,%esp
            vpid_pt[j] = mount_pte;
c01094ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01094f0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c01094f7:	8b 45 d8             	mov    -0x28(%ebp),%eax
c01094fa:	01 c2                	add    %eax,%edx
c01094fc:	8b 45 d0             	mov    -0x30(%ebp),%eax
c01094ff:	89 02                	mov    %eax,(%edx)
        for(size_t j = 0; j < PG_MAX_ENTRIES; j++)
c0109501:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0109505:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
c010950c:	76 b4                	jbe    c01094c2 <copy_page+0xcf>
        }

        vpid_ptd[i] = (uintptr_t)pid_pt | PG_PREM_RW;
c010950e:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0109511:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109514:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
c010951b:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010951e:	01 c8                	add    %ecx,%eax
c0109520:	83 ca 03             	or     $0x3,%edx
c0109523:	89 10                	mov    %edx,(%eax)
    for(size_t i = 0; i < PG_MAX_ENTRIES - 1; i++)
c0109525:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0109529:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
c0109530:	0f 86 0a ff ff ff    	jbe    c0109440 <copy_page+0x4d>
    }

    vpid_ptd[PG_MAX_ENTRIES - 1] = PDE(T_SELF_REF_PERM, pid_ptd);
c0109536:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0109539:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010953e:	89 c2                	mov    %eax,%edx
c0109540:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0109543:	05 fc 0f 00 00       	add    $0xffc,%eax
c0109548:	83 ca 1b             	or     $0x1b,%edx
c010954b:	89 10                	mov    %edx,(%eax)

    return pid_ptd;
c010954d:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
c0109550:	c9                   	leave  
c0109551:	c3                   	ret    

c0109552 <copy_all_page>:

void* copy_all_page(struct m_pcb* proc, uintptr_t usedMnt)
{
c0109552:	55                   	push   %ebp
c0109553:	89 e5                	mov    %esp,%ebp
c0109555:	83 ec 28             	sub    $0x28,%esp
    // copy the entire kernel page table
    pid_t pid = proc->pid;
c0109558:	8b 45 08             	mov    0x8(%ebp),%eax
c010955b:	8b 00                	mov    (%eax),%eax
c010955d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    void* pt_copy = copy_page(pid, usedMnt);
c0109560:	83 ec 08             	sub    $0x8,%esp
c0109563:	ff 75 0c             	push   0xc(%ebp)
c0109566:	ff 75 f0             	push   -0x10(%ebp)
c0109569:	e8 85 fe ff ff       	call   c01093f3 <copy_page>
c010956e:	83 c4 10             	add    $0x10,%esp
c0109571:	89 45 ec             	mov    %eax,-0x14(%ebp)

    vmm_mount_pd(PD_MOUNT_2, pt_copy); // 将新进程的页表挂载到挂载点#2
c0109574:	83 ec 08             	sub    $0x8,%esp
c0109577:	ff 75 ec             	push   -0x14(%ebp)
c010957a:	68 00 00 80 af       	push   $0xaf800000
c010957f:	e8 99 e8 ff ff       	call   c0107e1d <vmm_mount_pd>
c0109584:	83 c4 10             	add    $0x10,%esp

    // copy the kernel stack
    for (size_t i = KSTACK_START >> 12; i <= KSTACK_TOP >> 12; i++) {
c0109587:	c7 45 f4 f0 fb 0f 00 	movl   $0xffbf0,-0xc(%ebp)
c010958e:	eb 6c                	jmp    c01095fc <copy_all_page+0xaa>
        volatile pt_t* ppte = &PTE_MOUNTED(PD_MOUNT_2, i);
c0109590:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109593:	25 ff 03 00 00       	and    $0x3ff,%eax
c0109598:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010959f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01095a2:	c1 e0 02             	shl    $0x2,%eax
c01095a5:	25 00 f0 3f 00       	and    $0x3ff000,%eax
c01095aa:	0d 00 00 80 af       	or     $0xaf800000,%eax
c01095af:	01 d0                	add    %edx,%eax
c01095b1:	89 45 e8             	mov    %eax,-0x18(%ebp)

        /*
            The TLB caching keep the rewrite to PTE
            from updating. 
        */
        cpu_invplg(ppte);
c01095b4:	83 ec 0c             	sub    $0xc,%esp
c01095b7:	ff 75 e8             	push   -0x18(%ebp)
c01095ba:	e8 a2 fd ff ff       	call   c0109361 <cpu_invplg>
c01095bf:	83 c4 10             	add    $0x10,%esp

        pt_t p = *ppte;
c01095c2:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01095c5:	8b 00                	mov    (%eax),%eax
c01095c7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        void* ppa = vmm_dup_page(pid, PG_ENTRY_ADDR(p));
c01095ca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01095cd:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c01095d2:	83 ec 08             	sub    $0x8,%esp
c01095d5:	50                   	push   %eax
c01095d6:	ff 75 f0             	push   -0x10(%ebp)
c01095d9:	e8 ad e7 ff ff       	call   c0107d8b <vmm_dup_page>
c01095de:	83 c4 10             	add    $0x10,%esp
c01095e1:	89 45 e0             	mov    %eax,-0x20(%ebp)
        *ppte = (p & 0xfff) | (uintptr_t)ppa;
c01095e4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01095e7:	25 ff 0f 00 00       	and    $0xfff,%eax
c01095ec:	89 c2                	mov    %eax,%edx
c01095ee:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01095f1:	09 c2                	or     %eax,%edx
c01095f3:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01095f6:	89 10                	mov    %edx,(%eax)
    for (size_t i = KSTACK_START >> 12; i <= KSTACK_TOP >> 12; i++) {
c01095f8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c01095fc:	81 7d f4 ff fb 0f 00 	cmpl   $0xffbff,-0xc(%ebp)
c0109603:	76 8b                	jbe    c0109590 <copy_all_page+0x3e>
    // 都会导致eip落在区域外面，从而segmentation fault.

    // 定义用户栈区域，但是不分配实际的物理页。我们会在Page fault
    // handler里面实现动态分配物理页的逻辑。

    proc->page_table = pt_copy;
c0109605:	8b 45 08             	mov    0x8(%ebp),%eax
c0109608:	8b 55 ec             	mov    -0x14(%ebp),%edx
c010960b:	89 50 64             	mov    %edx,0x64(%eax)
}
c010960e:	90                   	nop
c010960f:	c9                   	leave  
c0109610:	c3                   	ret    

c0109611 <m_fork>:

pid_t m_fork()
{
c0109611:	55                   	push   %ebp
c0109612:	89 e5                	mov    %esp,%ebp
c0109614:	81 ec a8 00 00 00    	sub    $0xa8,%esp
    struct m_pcb curr_pcb;
    init_proc(&curr_pcb);
c010961a:	83 ec 0c             	sub    $0xc,%esp
c010961d:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
c0109623:	50                   	push   %eax
c0109624:	e8 94 fd ff ff       	call   c01093bd <init_proc>
c0109629:	83 c4 10             	add    $0x10,%esp

    curr_pcb.process_mm = __current->process_mm;
c010962c:	a1 e0 bb 28 c0       	mov    0xc028bbe0,%eax
c0109631:	8b 40 58             	mov    0x58(%eax),%eax
c0109634:	89 45 bc             	mov    %eax,-0x44(%ebp)
    curr_pcb.intr_contxt = __current->intr_contxt;
c0109637:	a1 e0 bb 28 c0       	mov    0xc028bbe0,%eax
c010963c:	8b 50 08             	mov    0x8(%eax),%edx
c010963f:	89 95 6c ff ff ff    	mov    %edx,-0x94(%ebp)
c0109645:	8b 50 0c             	mov    0xc(%eax),%edx
c0109648:	89 95 70 ff ff ff    	mov    %edx,-0x90(%ebp)
c010964e:	8b 50 10             	mov    0x10(%eax),%edx
c0109651:	89 95 74 ff ff ff    	mov    %edx,-0x8c(%ebp)
c0109657:	8b 50 14             	mov    0x14(%eax),%edx
c010965a:	89 95 78 ff ff ff    	mov    %edx,-0x88(%ebp)
c0109660:	8b 50 18             	mov    0x18(%eax),%edx
c0109663:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
c0109669:	8b 50 1c             	mov    0x1c(%eax),%edx
c010966c:	89 55 80             	mov    %edx,-0x80(%ebp)
c010966f:	8b 50 20             	mov    0x20(%eax),%edx
c0109672:	89 55 84             	mov    %edx,-0x7c(%ebp)
c0109675:	8b 50 24             	mov    0x24(%eax),%edx
c0109678:	89 55 88             	mov    %edx,-0x78(%ebp)
c010967b:	8b 50 28             	mov    0x28(%eax),%edx
c010967e:	89 55 8c             	mov    %edx,-0x74(%ebp)
c0109681:	8b 50 2c             	mov    0x2c(%eax),%edx
c0109684:	89 55 90             	mov    %edx,-0x70(%ebp)
c0109687:	8b 50 30             	mov    0x30(%eax),%edx
c010968a:	89 55 94             	mov    %edx,-0x6c(%ebp)
c010968d:	8b 50 34             	mov    0x34(%eax),%edx
c0109690:	89 55 98             	mov    %edx,-0x68(%ebp)
c0109693:	8b 50 38             	mov    0x38(%eax),%edx
c0109696:	89 55 9c             	mov    %edx,-0x64(%ebp)
c0109699:	8b 50 3c             	mov    0x3c(%eax),%edx
c010969c:	89 55 a0             	mov    %edx,-0x60(%ebp)
c010969f:	8b 40 40             	mov    0x40(%eax),%eax
c01096a2:	89 45 a4             	mov    %eax,-0x5c(%ebp)
    curr_pcb.parent = __current;
c01096a5:	a1 e0 bb 28 c0       	mov    0xc028bbe0,%eax
c01096aa:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)

#ifdef USE_KERNEL_PG
    copy_all_page(&pcb, PD_MOUNT_1); //挂载点#1是当前进程的页表
#else
    copy_all_page(&curr_pcb, PD_REFERENCED);
c01096b0:	83 ec 08             	sub    $0x8,%esp
c01096b3:	68 00 00 c0 ff       	push   $0xffc00000
c01096b8:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
c01096be:	50                   	push   %eax
c01096bf:	e8 8e fe ff ff       	call   c0109552 <copy_all_page>
c01096c4:	83 c4 10             	add    $0x10,%esp
#endif

        // 根据 mm_region 进一步配置页表
    if (!__current->process_mm) {
c01096c7:	a1 e0 bb 28 c0       	mov    0xc028bbe0,%eax
c01096cc:	8b 40 58             	mov    0x58(%eax),%eax
c01096cf:	85 c0                	test   %eax,%eax
c01096d1:	0f 84 68 01 00 00    	je     c010983f <m_fork+0x22e>
        goto not_copy;
    }

    llist_init_head(&curr_pcb.process_mm);
c01096d7:	83 ec 0c             	sub    $0xc,%esp
c01096da:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
c01096e0:	83 c0 58             	add    $0x58,%eax
c01096e3:	50                   	push   %eax
c01096e4:	e8 84 fc ff ff       	call   c010936d <llist_init_head>
c01096e9:	83 c4 10             	add    $0x10,%esp
    struct mm_region *pos, *n;
    llist_for_each(pos, n, &__current->process_mm->head, head)
c01096ec:	a1 e0 bb 28 c0       	mov    0xc028bbe0,%eax
c01096f1:	8b 40 58             	mov    0x58(%eax),%eax
c01096f4:	8b 40 04             	mov    0x4(%eax),%eax
c01096f7:	89 45 e8             	mov    %eax,-0x18(%ebp)
c01096fa:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01096fd:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0109700:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109703:	8b 40 04             	mov    0x4(%eax),%eax
c0109706:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c0109709:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c010970c:	89 45 f0             	mov    %eax,-0x10(%ebp)
c010970f:	e9 18 01 00 00       	jmp    c010982c <m_fork+0x21b>
    {
        region_add(&curr_pcb, pos->start, pos->end, pos->attr);
c0109714:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109717:	8b 48 10             	mov    0x10(%eax),%ecx
c010971a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010971d:	8b 50 0c             	mov    0xc(%eax),%edx
c0109720:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109723:	8b 40 08             	mov    0x8(%eax),%eax
c0109726:	51                   	push   %ecx
c0109727:	52                   	push   %edx
c0109728:	50                   	push   %eax
c0109729:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
c010972f:	50                   	push   %eax
c0109730:	e8 69 db ff ff       	call   c010729e <region_add>
c0109735:	83 c4 10             	add    $0x10,%esp

        // 如果写共享，则不作处理。
        if ((pos->attr & REGION_WSHARED)) {
c0109738:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010973b:	8b 40 10             	mov    0x10(%eax),%eax
c010973e:	83 e0 02             	and    $0x2,%eax
c0109741:	85 c0                	test   %eax,%eax
c0109743:	0f 85 cd 00 00 00    	jne    c0109816 <m_fork+0x205>
            continue;
        }

        uintptr_t start_vpn = PG_ALIGN(pos->start) >> 12;
c0109749:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010974c:	8b 40 08             	mov    0x8(%eax),%eax
c010974f:	c1 e8 0c             	shr    $0xc,%eax
c0109752:	89 45 e0             	mov    %eax,-0x20(%ebp)
        uintptr_t end_vpn = PG_ALIGN(pos->end) >> 12;
c0109755:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109758:	8b 40 0c             	mov    0xc(%eax),%eax
c010975b:	c1 e8 0c             	shr    $0xc,%eax
c010975e:	89 45 dc             	mov    %eax,-0x24(%ebp)
        for (size_t i = start_vpn; i < end_vpn; i++) {
c0109761:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0109764:	89 45 ec             	mov    %eax,-0x14(%ebp)
c0109767:	e9 9c 00 00 00       	jmp    c0109808 <m_fork+0x1f7>
            pt_t* curproc = &PTE_MOUNTED(PD_MOUNT_1, i);
c010976c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010976f:	25 ff 03 00 00       	and    $0x3ff,%eax
c0109774:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010977b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010977e:	c1 e0 02             	shl    $0x2,%eax
c0109781:	25 00 f0 3f 00       	and    $0x3ff000,%eax
c0109786:	0d 00 00 c0 af       	or     $0xafc00000,%eax
c010978b:	01 d0                	add    %edx,%eax
c010978d:	89 45 d8             	mov    %eax,-0x28(%ebp)
            pt_t* newproc = &PTE_MOUNTED(PD_MOUNT_2, i);
c0109790:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0109793:	25 ff 03 00 00       	and    $0x3ff,%eax
c0109798:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010979f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01097a2:	c1 e0 02             	shl    $0x2,%eax
c01097a5:	25 00 f0 3f 00       	and    $0x3ff000,%eax
c01097aa:	0d 00 00 80 af       	or     $0xaf800000,%eax
c01097af:	01 d0                	add    %edx,%eax
c01097b1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
            cpu_invplg(newproc);
c01097b4:	83 ec 0c             	sub    $0xc,%esp
c01097b7:	ff 75 d4             	push   -0x2c(%ebp)
c01097ba:	e8 a2 fb ff ff       	call   c0109361 <cpu_invplg>
c01097bf:	83 c4 10             	add    $0x10,%esp

            if (pos->attr == REGION_RSHARED) {
c01097c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01097c5:	8b 40 10             	mov    0x10(%eax),%eax
c01097c8:	83 f8 01             	cmp    $0x1,%eax
c01097cb:	75 2e                	jne    c01097fb <m_fork+0x1ea>
                // 如果读共享，则将两者的都标注为只读，那么任何写入都将会应用COW策略。
                cpu_invplg(curproc);
c01097cd:	83 ec 0c             	sub    $0xc,%esp
c01097d0:	ff 75 d8             	push   -0x28(%ebp)
c01097d3:	e8 89 fb ff ff       	call   c0109361 <cpu_invplg>
c01097d8:	83 c4 10             	add    $0x10,%esp
                *curproc = *curproc & ~PG_WRITE;
c01097db:	8b 45 d8             	mov    -0x28(%ebp),%eax
c01097de:	8b 00                	mov    (%eax),%eax
c01097e0:	83 e0 fd             	and    $0xfffffffd,%eax
c01097e3:	89 c2                	mov    %eax,%edx
c01097e5:	8b 45 d8             	mov    -0x28(%ebp),%eax
c01097e8:	89 10                	mov    %edx,(%eax)
                *newproc = *newproc & ~PG_WRITE;
c01097ea:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c01097ed:	8b 00                	mov    (%eax),%eax
c01097ef:	83 e0 fd             	and    $0xfffffffd,%eax
c01097f2:	89 c2                	mov    %eax,%edx
c01097f4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c01097f7:	89 10                	mov    %edx,(%eax)
c01097f9:	eb 09                	jmp    c0109804 <m_fork+0x1f3>
            } else {
                // 如果是私有页，则将该页从新进程中移除。
                *newproc = 0;
c01097fb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c01097fe:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        for (size_t i = start_vpn; i < end_vpn; i++) {
c0109804:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0109808:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010980b:	3b 45 dc             	cmp    -0x24(%ebp),%eax
c010980e:	0f 82 58 ff ff ff    	jb     c010976c <m_fork+0x15b>
c0109814:	eb 01                	jmp    c0109817 <m_fork+0x206>
            continue;
c0109816:	90                   	nop
    llist_for_each(pos, n, &__current->process_mm->head, head)
c0109817:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010981a:	89 45 f4             	mov    %eax,-0xc(%ebp)
c010981d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109820:	8b 40 04             	mov    0x4(%eax),%eax
c0109823:	89 45 d0             	mov    %eax,-0x30(%ebp)
c0109826:	8b 45 d0             	mov    -0x30(%ebp),%eax
c0109829:	89 45 f0             	mov    %eax,-0x10(%ebp)
c010982c:	a1 e0 bb 28 c0       	mov    0xc028bbe0,%eax
c0109831:	8b 40 58             	mov    0x58(%eax),%eax
c0109834:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0109837:	0f 85 d7 fe ff ff    	jne    c0109714 <m_fork+0x103>
            }
        }
    }

not_copy:
c010983d:	eb 01                	jmp    c0109840 <m_fork+0x22f>
        goto not_copy;
c010983f:	90                   	nop
    vmm_unmount_pd(PD_MOUNT_2);
c0109840:	83 ec 0c             	sub    $0xc,%esp
c0109843:	68 00 00 80 af       	push   $0xaf800000
c0109848:	e8 0f e6 ff ff       	call   c0107e5c <vmm_unmount_pd>
c010984d:	83 c4 10             	add    $0x10,%esp

    // 正如同fork，返回两次。
    curr_pcb.intr_contxt.registers.eax = 0;
c0109850:	c7 85 6c ff ff ff 00 	movl   $0x0,-0x94(%ebp)
c0109857:	00 00 00 

    push_process(&curr_pcb);
c010985a:	83 ec 0c             	sub    $0xc,%esp
c010985d:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
c0109863:	50                   	push   %eax
c0109864:	e8 57 03 00 00       	call   c0109bc0 <push_process>
c0109869:	83 c4 10             	add    $0x10,%esp

    return curr_pcb.pid;
c010986c:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
}
c0109872:	c9                   	leave  
c0109873:	c3                   	ret    

c0109874 <__del_pagetable>:

void __del_pagetable(pid_t pid, uintptr_t mount_point)
{
c0109874:	55                   	push   %ebp
c0109875:	89 e5                	mov    %esp,%ebp
c0109877:	83 ec 28             	sub    $0x28,%esp
    ptd_t* pptd = (ptd_t*)(mount_point | (0x3FF << 12));
c010987a:	8b 45 0c             	mov    0xc(%ebp),%eax
c010987d:	0d 00 f0 3f 00       	or     $0x3ff000,%eax
c0109882:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (size_t i = 0; i < PG_MAX_ENTRIES - 1; i++) {
c0109885:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c010988c:	e9 99 00 00 00       	jmp    c010992a <__del_pagetable+0xb6>
        ptd_t ptde = pptd[i];
c0109891:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109894:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c010989b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010989e:	01 d0                	add    %edx,%eax
c01098a0:	8b 00                	mov    (%eax),%eax
c01098a2:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if (!ptde || !(ptde & PG_PRESENT)) {
c01098a5:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c01098a9:	74 7a                	je     c0109925 <__del_pagetable+0xb1>
c01098ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01098ae:	83 e0 01             	and    $0x1,%eax
c01098b1:	85 c0                	test   %eax,%eax
c01098b3:	74 70                	je     c0109925 <__del_pagetable+0xb1>
            continue;
        }

        pt_t* ppt = (pt_t*)(mount_point | (i << 12));
c01098b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01098b8:	c1 e0 0c             	shl    $0xc,%eax
c01098bb:	0b 45 0c             	or     0xc(%ebp),%eax
c01098be:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        for (size_t j = 0; j < PG_MAX_ENTRIES; j++) {
c01098c1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c01098c8:	eb 39                	jmp    c0109903 <__del_pagetable+0x8f>
            pt_t pte = ppt[j];
c01098ca:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01098cd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c01098d4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c01098d7:	01 d0                	add    %edx,%eax
c01098d9:	8b 00                	mov    (%eax),%eax
c01098db:	89 45 e0             	mov    %eax,-0x20(%ebp)
            // free the 4KB data page
            if ((pte & PG_PRESENT)) {
c01098de:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01098e1:	83 e0 01             	and    $0x1,%eax
c01098e4:	85 c0                	test   %eax,%eax
c01098e6:	74 17                	je     c01098ff <__del_pagetable+0x8b>
                pmm_free_page(pid, PG_ENTRY_ADDR(pte));
c01098e8:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01098eb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c01098f0:	83 ec 08             	sub    $0x8,%esp
c01098f3:	50                   	push   %eax
c01098f4:	ff 75 08             	push   0x8(%ebp)
c01098f7:	e8 19 d1 ff ff       	call   c0106a15 <pmm_free_page>
c01098fc:	83 c4 10             	add    $0x10,%esp
        for (size_t j = 0; j < PG_MAX_ENTRIES; j++) {
c01098ff:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0109903:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
c010990a:	76 be                	jbe    c01098ca <__del_pagetable+0x56>
            }
        }
        // free the L2 page table
        pmm_free_page(pid, PG_ENTRY_ADDR(ptde));
c010990c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010990f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0109914:	83 ec 08             	sub    $0x8,%esp
c0109917:	50                   	push   %eax
c0109918:	ff 75 08             	push   0x8(%ebp)
c010991b:	e8 f5 d0 ff ff       	call   c0106a15 <pmm_free_page>
c0109920:	83 c4 10             	add    $0x10,%esp
c0109923:	eb 01                	jmp    c0109926 <__del_pagetable+0xb2>
            continue;
c0109925:	90                   	nop
    for (size_t i = 0; i < PG_MAX_ENTRIES - 1; i++) {
c0109926:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010992a:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
c0109931:	0f 86 5a ff ff ff    	jbe    c0109891 <__del_pagetable+0x1d>
    }
    // free the L1 directory
    pmm_free_page(pid, PG_ENTRY_ADDR(pptd[PG_MAX_ENTRIES - 1]));
c0109937:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010993a:	05 fc 0f 00 00       	add    $0xffc,%eax
c010993f:	8b 00                	mov    (%eax),%eax
c0109941:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0109946:	83 ec 08             	sub    $0x8,%esp
c0109949:	50                   	push   %eax
c010994a:	ff 75 08             	push   0x8(%ebp)
c010994d:	e8 c3 d0 ff ff       	call   c0106a15 <pmm_free_page>
c0109952:	83 c4 10             	add    $0x10,%esp
c0109955:	90                   	nop
c0109956:	c9                   	leave  
c0109957:	c3                   	ret    

c0109958 <cpu_lcr3>:
{
c0109958:	55                   	push   %ebp
c0109959:	89 e5                	mov    %esp,%ebp
    asm("mov %0, %%cr3" ::"r"(v));
c010995b:	8b 45 08             	mov    0x8(%ebp),%eax
c010995e:	0f 22 d8             	mov    %eax,%cr3
}
c0109961:	90                   	nop
c0109962:	5d                   	pop    %ebp
c0109963:	c3                   	ret    

c0109964 <__llist_add>:
{
c0109964:	55                   	push   %ebp
c0109965:	89 e5                	mov    %esp,%ebp
    next->prev = elem;
c0109967:	8b 45 10             	mov    0x10(%ebp),%eax
c010996a:	8b 55 08             	mov    0x8(%ebp),%edx
c010996d:	89 10                	mov    %edx,(%eax)
    elem->next = next;
c010996f:	8b 45 08             	mov    0x8(%ebp),%eax
c0109972:	8b 55 10             	mov    0x10(%ebp),%edx
c0109975:	89 50 04             	mov    %edx,0x4(%eax)
    elem->prev = prev;
c0109978:	8b 45 08             	mov    0x8(%ebp),%eax
c010997b:	8b 55 0c             	mov    0xc(%ebp),%edx
c010997e:	89 10                	mov    %edx,(%eax)
    prev->next = elem;
c0109980:	8b 45 0c             	mov    0xc(%ebp),%eax
c0109983:	8b 55 08             	mov    0x8(%ebp),%edx
c0109986:	89 50 04             	mov    %edx,0x4(%eax)
}
c0109989:	90                   	nop
c010998a:	5d                   	pop    %ebp
c010998b:	c3                   	ret    

c010998c <llist_init_head>:
static inline void llist_init_head(struct llist_header* head) {
c010998c:	55                   	push   %ebp
c010998d:	89 e5                	mov    %esp,%ebp
    head->next = head;
c010998f:	8b 45 08             	mov    0x8(%ebp),%eax
c0109992:	8b 55 08             	mov    0x8(%ebp),%edx
c0109995:	89 50 04             	mov    %edx,0x4(%eax)
    head->prev = head;
c0109998:	8b 45 08             	mov    0x8(%ebp),%eax
c010999b:	8b 55 08             	mov    0x8(%ebp),%edx
c010999e:	89 10                	mov    %edx,(%eax)
}
c01099a0:	90                   	nop
c01099a1:	5d                   	pop    %ebp
c01099a2:	c3                   	ret    

c01099a3 <llist_append>:
{
c01099a3:	55                   	push   %ebp
c01099a4:	89 e5                	mov    %esp,%ebp
    __llist_add(elem, head, head->next);
c01099a6:	8b 45 08             	mov    0x8(%ebp),%eax
c01099a9:	8b 40 04             	mov    0x4(%eax),%eax
c01099ac:	50                   	push   %eax
c01099ad:	ff 75 08             	push   0x8(%ebp)
c01099b0:	ff 75 0c             	push   0xc(%ebp)
c01099b3:	e8 ac ff ff ff       	call   c0109964 <__llist_add>
c01099b8:	83 c4 0c             	add    $0xc,%esp
}
c01099bb:	90                   	nop
c01099bc:	c9                   	leave  
c01099bd:	c3                   	ret    

c01099be <llist_empty>:

static inline int llist_empty(struct llist_header* elem) {
c01099be:	55                   	push   %ebp
c01099bf:	89 e5                	mov    %esp,%ebp
    return elem->next == elem;
c01099c1:	8b 45 08             	mov    0x8(%ebp),%eax
c01099c4:	8b 40 04             	mov    0x4(%eax),%eax
c01099c7:	39 45 08             	cmp    %eax,0x8(%ebp)
c01099ca:	0f 94 c0             	sete   %al
c01099cd:	0f b6 c0             	movzbl %al,%eax
}
c01099d0:	5d                   	pop    %ebp
c01099d1:	c3                   	ret    

c01099d2 <llist_delete>:

static inline void
llist_delete(struct llist_header* elem) {
c01099d2:	55                   	push   %ebp
c01099d3:	89 e5                	mov    %esp,%ebp
    elem->prev->next = elem->next;
c01099d5:	8b 45 08             	mov    0x8(%ebp),%eax
c01099d8:	8b 00                	mov    (%eax),%eax
c01099da:	8b 55 08             	mov    0x8(%ebp),%edx
c01099dd:	8b 52 04             	mov    0x4(%edx),%edx
c01099e0:	89 50 04             	mov    %edx,0x4(%eax)
    elem->next->prev = elem->next;
c01099e3:	8b 45 08             	mov    0x8(%ebp),%eax
c01099e6:	8b 40 04             	mov    0x4(%eax),%eax
c01099e9:	8b 55 08             	mov    0x8(%ebp),%edx
c01099ec:	8b 52 04             	mov    0x4(%edx),%edx
c01099ef:	89 10                	mov    %edx,(%eax)
    
    // make elem orphaned
    elem->prev = elem;
c01099f1:	8b 45 08             	mov    0x8(%ebp),%eax
c01099f4:	8b 55 08             	mov    0x8(%ebp),%edx
c01099f7:	89 10                	mov    %edx,(%eax)
    elem->next = elem;
c01099f9:	8b 45 08             	mov    0x8(%ebp),%eax
c01099fc:	8b 55 08             	mov    0x8(%ebp),%edx
c01099ff:	89 50 04             	mov    %edx,0x4(%eax)
}
c0109a02:	90                   	nop
c0109a03:	5d                   	pop    %ebp
c0109a04:	c3                   	ret    

c0109a05 <io_outb>:
{
c0109a05:	55                   	push   %ebp
c0109a06:	89 e5                	mov    %esp,%ebp
c0109a08:	83 ec 04             	sub    $0x4,%esp
c0109a0b:	8b 45 0c             	mov    0xc(%ebp),%eax
c0109a0e:	88 45 fc             	mov    %al,-0x4(%ebp)
    asm volatile("outb %0, %w1" : : "a"(data), "d"(port));
c0109a11:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0109a15:	8b 55 08             	mov    0x8(%ebp),%edx
c0109a18:	ee                   	out    %al,(%dx)
}
c0109a19:	90                   	nop
c0109a1a:	c9                   	leave  
c0109a1b:	c3                   	ret    

c0109a1c <syscall>:
{
c0109a1c:	55                   	push   %ebp
c0109a1d:	89 e5                	mov    %esp,%ebp
c0109a1f:	57                   	push   %edi
    asm volatile("int %0" ::"i"(0x80), "D"(callcode) : "eax");
c0109a20:	8b 55 08             	mov    0x8(%ebp),%edx
c0109a23:	89 d7                	mov    %edx,%edi
c0109a25:	cd 80                	int    $0x80
}
c0109a27:	90                   	nop
c0109a28:	8b 7d fc             	mov    -0x4(%ebp),%edi
c0109a2b:	c9                   	leave  
c0109a2c:	c3                   	ret    

c0109a2d <sched_init>:
extern void __proc_table;

struct scheduler sched_ctx;

void sched_init()
{
c0109a2d:	55                   	push   %ebp
c0109a2e:	89 e5                	mov    %esp,%ebp
c0109a30:	83 ec 18             	sub    $0x18,%esp
    size_t pg_size = ROUNDUP(sizeof(struct m_pcb) * MAX_PROCESS, 0x1000);
c0109a33:	c7 45 f4 00 e0 00 00 	movl   $0xe000,-0xc(%ebp)
    vmm_alloc_pages(KERNEL_PID, &__proc_table, pg_size, PG_PREM_RW, PP_FGPERSIST);
c0109a3a:	83 ec 0c             	sub    $0xc,%esp
c0109a3d:	6a 01                	push   $0x1
c0109a3f:	6a 03                	push   $0x3
c0109a41:	ff 75 f4             	push   -0xc(%ebp)
c0109a44:	68 00 40 29 c0       	push   $0xc0294000
c0109a49:	6a ff                	push   $0xffffffff
c0109a4b:	e8 9c df ff ff       	call   c01079ec <vmm_alloc_pages>
c0109a50:	83 c4 20             	add    $0x20,%esp

    sched_ctx = (struct scheduler){ ._procs = (struct m_pcb*)&__proc_table,
c0109a53:	c7 05 6c bc 28 c0 00 	movl   $0xc0294000,0xc028bc6c
c0109a5a:	40 29 c0 
c0109a5d:	c7 05 70 bc 28 c0 00 	movl   $0x0,0xc028bc70
c0109a64:	00 00 00 
c0109a67:	c7 05 74 bc 28 c0 00 	movl   $0x0,0xc028bc74
c0109a6e:	00 00 00 
                                    .ptable_len = 0,
                                    .procs_index = 0 };
}
c0109a71:	90                   	nop
c0109a72:	c9                   	leave  
c0109a73:	c3                   	ret    

c0109a74 <run>:

void run(struct m_pcb* proc)
{
c0109a74:	55                   	push   %ebp
c0109a75:	89 e5                	mov    %esp,%ebp
    if (!(__current->state & ~PROC_RUNNING)) {
c0109a77:	a1 e0 bb 28 c0       	mov    0xc028bbe0,%eax
c0109a7c:	0f b6 40 44          	movzbl 0x44(%eax),%eax
c0109a80:	0f b6 c0             	movzbl %al,%eax
c0109a83:	83 e0 fe             	and    $0xfffffffe,%eax
c0109a86:	85 c0                	test   %eax,%eax
c0109a88:	75 09                	jne    c0109a93 <run+0x1f>
        __current->state = PROC_STOPPED;
c0109a8a:	a1 e0 bb 28 c0       	mov    0xc028bbe0,%eax
c0109a8f:	c6 40 44 00          	movb   $0x0,0x44(%eax)
    }
    proc->state = PROC_RUNNING;
c0109a93:	8b 45 08             	mov    0x8(%ebp),%eax
c0109a96:	c6 40 44 01          	movb   $0x1,0x44(%eax)


    if (__current->page_table != proc->page_table) {
c0109a9a:	a1 e0 bb 28 c0       	mov    0xc028bbe0,%eax
c0109a9f:	8b 50 64             	mov    0x64(%eax),%edx
c0109aa2:	8b 45 08             	mov    0x8(%ebp),%eax
c0109aa5:	8b 40 64             	mov    0x64(%eax),%eax
c0109aa8:	39 c2                	cmp    %eax,%edx
c0109aaa:	74 1b                	je     c0109ac7 <run+0x53>
        __current = proc;
c0109aac:	8b 45 08             	mov    0x8(%ebp),%eax
c0109aaf:	a3 e0 bb 28 c0       	mov    %eax,0xc028bbe0
        cpu_lcr3(__current->page_table);
c0109ab4:	a1 e0 bb 28 c0       	mov    0xc028bbe0,%eax
c0109ab9:	8b 40 64             	mov    0x64(%eax),%eax
c0109abc:	50                   	push   %eax
c0109abd:	e8 96 fe ff ff       	call   c0109958 <cpu_lcr3>
c0109ac2:	83 c4 04             	add    $0x4,%esp
c0109ac5:	eb 08                	jmp    c0109acf <run+0x5b>
        // from now on, the we are in the kstack of another process
    } else {
        __current = proc;
c0109ac7:	8b 45 08             	mov    0x8(%ebp),%eax
c0109aca:	a3 e0 bb 28 c0       	mov    %eax,0xc028bbe0
    }

    io_outb(0x20, 0x20);
c0109acf:	6a 20                	push   $0x20
c0109ad1:	6a 20                	push   $0x20
c0109ad3:	e8 2d ff ff ff       	call   c0109a05 <io_outb>
c0109ad8:	83 c4 08             	add    $0x8,%esp
    io_outb(0xa0, 0x20);//EOI end the int
c0109adb:	6a 20                	push   $0x20
c0109add:	68 a0 00 00 00       	push   $0xa0
c0109ae2:	e8 1e ff ff ff       	call   c0109a05 <io_outb>
c0109ae7:	83 c4 08             	add    $0x8,%esp

    asm volatile("pushl %0\n"
                 "jmp soft_iret\n" ::"r"(&__current->intr_contxt)
c0109aea:	a1 e0 bb 28 c0       	mov    0xc028bbe0,%eax
c0109aef:	83 c0 08             	add    $0x8,%eax
    asm volatile("pushl %0\n"
c0109af2:	50                   	push   %eax
c0109af3:	e9 cb ea ff ff       	jmp    c01085c3 <soft_iret>
                 : "memory");
}
c0109af8:	90                   	nop
c0109af9:	c9                   	leave  
c0109afa:	c3                   	ret    

c0109afb <schedule>:

void schedule()
{
c0109afb:	55                   	push   %ebp
c0109afc:	89 e5                	mov    %esp,%ebp
c0109afe:	83 ec 10             	sub    $0x10,%esp
    if (!sched_ctx.ptable_len) {
c0109b01:	a1 74 bc 28 c0       	mov    0xc028bc74,%eax
c0109b06:	85 c0                	test   %eax,%eax
c0109b08:	74 5f                	je     c0109b69 <schedule+0x6e>
        return;
    }

    struct m_pcb* next;
    int prev_ptr = sched_ctx.procs_index;
c0109b0a:	a1 70 bc 28 c0       	mov    0xc028bc70,%eax
c0109b0f:	89 45 f8             	mov    %eax,-0x8(%ebp)
    int ptr = prev_ptr;
c0109b12:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0109b15:	89 45 fc             	mov    %eax,-0x4(%ebp)
    // round-robin scheduler
    do {
        ptr = (ptr + 1) % sched_ctx.ptable_len;
c0109b18:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0109b1b:	83 c0 01             	add    $0x1,%eax
c0109b1e:	8b 0d 74 bc 28 c0    	mov    0xc028bc74,%ecx
c0109b24:	ba 00 00 00 00       	mov    $0x0,%edx
c0109b29:	f7 f1                	div    %ecx
c0109b2b:	89 d0                	mov    %edx,%eax
c0109b2d:	89 45 fc             	mov    %eax,-0x4(%ebp)
        next = &sched_ctx._procs[ptr];
c0109b30:	8b 15 6c bc 28 c0    	mov    0xc028bc6c,%edx
c0109b36:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0109b39:	6b c0 6c             	imul   $0x6c,%eax,%eax
c0109b3c:	01 d0                	add    %edx,%eax
c0109b3e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    } while (next->state != PROC_STOPPED && ptr != prev_ptr);
c0109b41:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109b44:	0f b6 40 44          	movzbl 0x44(%eax),%eax
c0109b48:	84 c0                	test   %al,%al
c0109b4a:	74 08                	je     c0109b54 <schedule+0x59>
c0109b4c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0109b4f:	3b 45 f8             	cmp    -0x8(%ebp),%eax
c0109b52:	75 c4                	jne    c0109b18 <schedule+0x1d>

    sched_ctx.procs_index = ptr;
c0109b54:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0109b57:	a3 70 bc 28 c0       	mov    %eax,0xc028bc70

    run(next);
c0109b5c:	ff 75 f4             	push   -0xc(%ebp)
c0109b5f:	e8 10 ff ff ff       	call   c0109a74 <run>
c0109b64:	83 c4 04             	add    $0x4,%esp
c0109b67:	eb 01                	jmp    c0109b6a <schedule+0x6f>
        return;
c0109b69:	90                   	nop
}
c0109b6a:	c9                   	leave  
c0109b6b:	c3                   	ret    

c0109b6c <alloc_pid>:

pid_t alloc_pid()
{
c0109b6c:	55                   	push   %ebp
c0109b6d:	89 e5                	mov    %esp,%ebp
c0109b6f:	83 ec 18             	sub    $0x18,%esp
    pid_t i = 0;
c0109b72:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    for (;
c0109b79:	eb 04                	jmp    c0109b7f <alloc_pid+0x13>
         i < sched_ctx.ptable_len && sched_ctx._procs[i].state != PROC_DESTROY;
         i++)
c0109b7b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
         i < sched_ctx.ptable_len && sched_ctx._procs[i].state != PROC_DESTROY;
c0109b7f:	8b 15 74 bc 28 c0    	mov    0xc028bc74,%edx
c0109b85:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109b88:	39 c2                	cmp    %eax,%edx
c0109b8a:	76 16                	jbe    c0109ba2 <alloc_pid+0x36>
c0109b8c:	8b 15 6c bc 28 c0    	mov    0xc028bc6c,%edx
c0109b92:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109b95:	6b c0 6c             	imul   $0x6c,%eax,%eax
c0109b98:	01 d0                	add    %edx,%eax
c0109b9a:	0f b6 40 44          	movzbl 0x44(%eax),%eax
c0109b9e:	3c 04                	cmp    $0x4,%al
c0109ba0:	75 d9                	jne    c0109b7b <alloc_pid+0xf>
        ;

    if (i == MAX_PROCESS) {
c0109ba2:	81 7d f4 00 02 00 00 	cmpl   $0x200,-0xc(%ebp)
c0109ba9:	75 10                	jne    c0109bbb <alloc_pid+0x4f>
        kprintf("Panic in Ponyville shimmer!");
c0109bab:	83 ec 0c             	sub    $0xc,%esp
c0109bae:	68 9c d6 28 c0       	push   $0xc028d69c
c0109bb3:	e8 f0 02 00 00       	call   c0109ea8 <kprintf>
c0109bb8:	83 c4 10             	add    $0x10,%esp
    }
    return i;
c0109bbb:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0109bbe:	c9                   	leave  
c0109bbf:	c3                   	ret    

c0109bc0 <push_process>:

void
push_process(struct m_pcb* process)
{
c0109bc0:	55                   	push   %ebp
c0109bc1:	89 e5                	mov    %esp,%ebp
c0109bc3:	57                   	push   %edi
c0109bc4:	56                   	push   %esi
c0109bc5:	53                   	push   %ebx
c0109bc6:	83 ec 10             	sub    $0x10,%esp
    int index = process->pid;
c0109bc9:	8b 45 08             	mov    0x8(%ebp),%eax
c0109bcc:	8b 00                	mov    (%eax),%eax
c0109bce:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (index < 0 || index > sched_ctx.ptable_len) {
c0109bd1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0109bd5:	78 0d                	js     c0109be4 <push_process+0x24>
c0109bd7:	8b 15 74 bc 28 c0    	mov    0xc028bc74,%edx
c0109bdd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109be0:	39 c2                	cmp    %eax,%edx
c0109be2:	73 11                	jae    c0109bf5 <push_process+0x35>
        __current->k_status = MXINVLDPID;
c0109be4:	a1 e0 bb 28 c0       	mov    0xc028bbe0,%eax
c0109be9:	c7 40 68 fc ff ff ff 	movl   $0xfffffffc,0x68(%eax)
        return;
c0109bf0:	e9 92 00 00 00       	jmp    c0109c87 <push_process+0xc7>
    }

    if (index == sched_ctx.ptable_len) {
c0109bf5:	8b 15 74 bc 28 c0    	mov    0xc028bc74,%edx
c0109bfb:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109bfe:	39 c2                	cmp    %eax,%edx
c0109c00:	75 0d                	jne    c0109c0f <push_process+0x4f>
        sched_ctx.ptable_len++;
c0109c02:	a1 74 bc 28 c0       	mov    0xc028bc74,%eax
c0109c07:	83 c0 01             	add    $0x1,%eax
c0109c0a:	a3 74 bc 28 c0       	mov    %eax,0xc028bc74
    }

    sched_ctx._procs[index] = *process;
c0109c0f:	8b 15 6c bc 28 c0    	mov    0xc028bc6c,%edx
c0109c15:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109c18:	6b c0 6c             	imul   $0x6c,%eax,%eax
c0109c1b:	01 c2                	add    %eax,%edx
c0109c1d:	8b 45 08             	mov    0x8(%ebp),%eax
c0109c20:	89 c3                	mov    %eax,%ebx
c0109c22:	b8 1b 00 00 00       	mov    $0x1b,%eax
c0109c27:	89 d7                	mov    %edx,%edi
c0109c29:	89 de                	mov    %ebx,%esi
c0109c2b:	89 c1                	mov    %eax,%ecx
c0109c2d:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)

    process = &sched_ctx._procs[index];
c0109c2f:	8b 15 6c bc 28 c0    	mov    0xc028bc6c,%edx
c0109c35:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109c38:	6b c0 6c             	imul   $0x6c,%eax,%eax
c0109c3b:	01 d0                	add    %edx,%eax
c0109c3d:	89 45 08             	mov    %eax,0x8(%ebp)

    // make sure the address is in the range of process table
    llist_init_head(&process->children);
c0109c40:	8b 45 08             	mov    0x8(%ebp),%eax
c0109c43:	83 c0 50             	add    $0x50,%eax
c0109c46:	50                   	push   %eax
c0109c47:	e8 40 fd ff ff       	call   c010998c <llist_init_head>
c0109c4c:	83 c4 04             	add    $0x4,%esp
    // every process is the child of first process (pid=1)
    if (process->parent) {
c0109c4f:	8b 45 08             	mov    0x8(%ebp),%eax
c0109c52:	8b 40 04             	mov    0x4(%eax),%eax
c0109c55:	85 c0                	test   %eax,%eax
c0109c57:	74 1b                	je     c0109c74 <push_process+0xb4>
        llist_append(&process->parent->children, &process->siblings);
c0109c59:	8b 45 08             	mov    0x8(%ebp),%eax
c0109c5c:	8d 50 48             	lea    0x48(%eax),%edx
c0109c5f:	8b 45 08             	mov    0x8(%ebp),%eax
c0109c62:	8b 40 04             	mov    0x4(%eax),%eax
c0109c65:	83 c0 50             	add    $0x50,%eax
c0109c68:	52                   	push   %edx
c0109c69:	50                   	push   %eax
c0109c6a:	e8 34 fd ff ff       	call   c01099a3 <llist_append>
c0109c6f:	83 c4 08             	add    $0x8,%esp
c0109c72:	eb 0c                	jmp    c0109c80 <push_process+0xc0>
    } else {
        process->parent = &sched_ctx._procs[0];
c0109c74:	8b 15 6c bc 28 c0    	mov    0xc028bc6c,%edx
c0109c7a:	8b 45 08             	mov    0x8(%ebp),%eax
c0109c7d:	89 50 04             	mov    %edx,0x4(%eax)
    }

    process->state = PROC_STOPPED;
c0109c80:	8b 45 08             	mov    0x8(%ebp),%eax
c0109c83:	c6 40 44 00          	movb   $0x0,0x44(%eax)
}
c0109c87:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0109c8a:	5b                   	pop    %ebx
c0109c8b:	5e                   	pop    %esi
c0109c8c:	5f                   	pop    %edi
c0109c8d:	5d                   	pop    %ebp
c0109c8e:	c3                   	ret    

c0109c8f <terminate_proc>:

void terminate_proc(int exit_code)
{
c0109c8f:	55                   	push   %ebp
c0109c90:	89 e5                	mov    %esp,%ebp
    __current->state = PROC_TERMNAT;
c0109c92:	a1 e0 bb 28 c0       	mov    0xc028bbe0,%eax
c0109c97:	c6 40 44 02          	movb   $0x2,0x44(%eax)
    __current->exit_code = exit_code;
c0109c9b:	a1 e0 bb 28 c0       	mov    0xc028bbe0,%eax
c0109ca0:	8b 55 08             	mov    0x8(%ebp),%edx
c0109ca3:	89 50 60             	mov    %edx,0x60(%eax)

    schedule();
c0109ca6:	e8 50 fe ff ff       	call   c0109afb <schedule>
}
c0109cab:	90                   	nop
c0109cac:	5d                   	pop    %ebp
c0109cad:	c3                   	ret    

c0109cae <__mxsys_sleep>:

__DEFINE_MXSYSCALL1(unsigned int, sleep, unsigned int, seconds)
{
c0109cae:	55                   	push   %ebp
c0109caf:	89 e5                	mov    %esp,%ebp
    if (!seconds) {
c0109cb1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0109cb5:	75 07                	jne    c0109cbe <__mxsys_sleep+0x10>
        return 0;
c0109cb7:	b8 00 00 00 00       	mov    $0x0,%eax
c0109cbc:	eb 2f                	jmp    c0109ced <__mxsys_sleep+0x3f>
    }
    if (__current->pro_ticks) {
c0109cbe:	a1 e0 bb 28 c0       	mov    0xc028bbe0,%eax
c0109cc3:	8b 40 5c             	mov    0x5c(%eax),%eax
c0109cc6:	85 c0                	test   %eax,%eax
c0109cc8:	74 0a                	je     c0109cd4 <__mxsys_sleep+0x26>
        return __current->pro_ticks;
c0109cca:	a1 e0 bb 28 c0       	mov    0xc028bbe0,%eax
c0109ccf:	8b 40 5c             	mov    0x5c(%eax),%eax
c0109cd2:	eb 19                	jmp    c0109ced <__mxsys_sleep+0x3f>
    }

    __current->intr_contxt.registers.eax = seconds;
c0109cd4:	a1 e0 bb 28 c0       	mov    0xc028bbe0,%eax
c0109cd9:	8b 55 08             	mov    0x8(%ebp),%edx
c0109cdc:	89 50 08             	mov    %edx,0x8(%eax)
    __current->state = PROC_BLOCKED;
c0109cdf:	a1 e0 bb 28 c0       	mov    0xc028bbe0,%eax
c0109ce4:	c6 40 44 08          	movb   $0x8,0x44(%eax)
    schedule();
c0109ce8:	e8 0e fe ff ff       	call   c0109afb <schedule>
}
c0109ced:	5d                   	pop    %ebp
c0109cee:	c3                   	ret    

c0109cef <__mxsys_exit>:

__DEFINE_MXSYSCALL1(void, exit, int, status)
{
c0109cef:	55                   	push   %ebp
c0109cf0:	89 e5                	mov    %esp,%ebp
    terminate_proc(status);
c0109cf2:	ff 75 08             	push   0x8(%ebp)
c0109cf5:	e8 95 ff ff ff       	call   c0109c8f <terminate_proc>
c0109cfa:	83 c4 04             	add    $0x4,%esp
}
c0109cfd:	90                   	nop
c0109cfe:	c9                   	leave  
c0109cff:	c3                   	ret    

c0109d00 <__mxsys_yield>:

__DEFINE_MXSYSCALL(void, yield)
{
c0109d00:	55                   	push   %ebp
c0109d01:	89 e5                	mov    %esp,%ebp
    schedule();
c0109d03:	e8 f3 fd ff ff       	call   c0109afb <schedule>
}
c0109d08:	90                   	nop
c0109d09:	5d                   	pop    %ebp
c0109d0a:	c3                   	ret    

c0109d0b <__mxsys_wait>:

__DEFINE_MXSYSCALL1(pid_t, wait, int*, status)
{
c0109d0b:	55                   	push   %ebp
c0109d0c:	89 e5                	mov    %esp,%ebp
c0109d0e:	83 ec 28             	sub    $0x28,%esp
    pid_t cur = __current->pid;
c0109d11:	a1 e0 bb 28 c0       	mov    0xc028bbe0,%eax
c0109d16:	8b 00                	mov    (%eax),%eax
c0109d18:	89 45 ec             	mov    %eax,-0x14(%ebp)
    struct m_pcb *proc, *n;
    if (llist_empty(&__current->children)) {
c0109d1b:	a1 e0 bb 28 c0       	mov    0xc028bbe0,%eax
c0109d20:	83 c0 50             	add    $0x50,%eax
c0109d23:	50                   	push   %eax
c0109d24:	e8 95 fc ff ff       	call   c01099be <llist_empty>
c0109d29:	83 c4 04             	add    $0x4,%esp
c0109d2c:	85 c0                	test   %eax,%eax
c0109d2e:	74 07                	je     c0109d37 <__mxsys_wait+0x2c>
        return -1;
c0109d30:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0109d35:	eb 7d                	jmp    c0109db4 <__mxsys_wait+0xa9>
    }
repeat:
c0109d37:	90                   	nop
    llist_for_each(proc, n, &__current->children, siblings)
c0109d38:	a1 e0 bb 28 c0       	mov    0xc028bbe0,%eax
c0109d3d:	8b 40 54             	mov    0x54(%eax),%eax
c0109d40:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0109d43:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0109d46:	83 e8 48             	sub    $0x48,%eax
c0109d49:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0109d4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109d4f:	8b 40 4c             	mov    0x4c(%eax),%eax
c0109d52:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c0109d55:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0109d58:	83 e8 48             	sub    $0x48,%eax
c0109d5b:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0109d5e:	eb 23                	jmp    c0109d83 <__mxsys_wait+0x78>
    {
        if (proc->state == PROC_TERMNAT) {
c0109d60:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109d63:	0f b6 40 44          	movzbl 0x44(%eax),%eax
c0109d67:	3c 02                	cmp    $0x2,%al
c0109d69:	74 2c                	je     c0109d97 <__mxsys_wait+0x8c>
    llist_for_each(proc, n, &__current->children, siblings)
c0109d6b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109d6e:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0109d71:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109d74:	8b 40 4c             	mov    0x4c(%eax),%eax
c0109d77:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0109d7a:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0109d7d:	83 e8 48             	sub    $0x48,%eax
c0109d80:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0109d83:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109d86:	8d 50 48             	lea    0x48(%eax),%edx
c0109d89:	a1 e0 bb 28 c0       	mov    0xc028bbe0,%eax
c0109d8e:	83 c0 50             	add    $0x50,%eax
c0109d91:	39 c2                	cmp    %eax,%edx
c0109d93:	75 cb                	jne    c0109d60 <__mxsys_wait+0x55>
            goto done;
        }
    }
    // FIXME: 除了循环，也许有更高效的办法……
    // (在这里进行schedule，需要重写context switch!)
    goto repeat;
c0109d95:	eb a1                	jmp    c0109d38 <__mxsys_wait+0x2d>
            goto done;
c0109d97:	90                   	nop

done:
    *status = proc->exit_code;
c0109d98:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109d9b:	8b 50 60             	mov    0x60(%eax),%edx
c0109d9e:	8b 45 08             	mov    0x8(%ebp),%eax
c0109da1:	89 10                	mov    %edx,(%eax)
    return destroy_process(proc->pid);
c0109da3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109da6:	8b 00                	mov    (%eax),%eax
c0109da8:	83 ec 0c             	sub    $0xc,%esp
c0109dab:	50                   	push   %eax
c0109dac:	e8 05 00 00 00       	call   c0109db6 <destroy_process>
c0109db1:	83 c4 10             	add    $0x10,%esp
}
c0109db4:	c9                   	leave  
c0109db5:	c3                   	ret    

c0109db6 <destroy_process>:

extern void __del_pagetable(pid_t pid, uintptr_t mount_point);

pid_t destroy_process(pid_t pid)
{
c0109db6:	55                   	push   %ebp
c0109db7:	89 e5                	mov    %esp,%ebp
c0109db9:	83 ec 28             	sub    $0x28,%esp
    int index = pid;
c0109dbc:	8b 45 08             	mov    0x8(%ebp),%eax
c0109dbf:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (index <= 0 || index > sched_ctx.ptable_len) {
c0109dc2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0109dc6:	7e 0d                	jle    c0109dd5 <destroy_process+0x1f>
c0109dc8:	8b 15 74 bc 28 c0    	mov    0xc028bc74,%edx
c0109dce:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0109dd1:	39 c2                	cmp    %eax,%edx
c0109dd3:	73 12                	jae    c0109de7 <destroy_process+0x31>
        __current->k_status = MXINVLDPID;
c0109dd5:	a1 e0 bb 28 c0       	mov    0xc028bbe0,%eax
c0109dda:	c7 40 68 fc ff ff ff 	movl   $0xfffffffc,0x68(%eax)
        return;
c0109de1:	90                   	nop
c0109de2:	e9 bf 00 00 00       	jmp    c0109ea6 <destroy_process+0xf0>
    }
    struct m_pcb* proc = &sched_ctx._procs[index];
c0109de7:	8b 15 6c bc 28 c0    	mov    0xc028bc6c,%edx
c0109ded:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0109df0:	6b c0 6c             	imul   $0x6c,%eax,%eax
c0109df3:	01 d0                	add    %edx,%eax
c0109df5:	89 45 e8             	mov    %eax,-0x18(%ebp)
    proc->state = PROC_DESTROY;
c0109df8:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0109dfb:	c6 40 44 04          	movb   $0x4,0x44(%eax)
    llist_delete(&proc->siblings);
c0109dff:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0109e02:	83 c0 48             	add    $0x48,%eax
c0109e05:	50                   	push   %eax
c0109e06:	e8 c7 fb ff ff       	call   c01099d2 <llist_delete>
c0109e0b:	83 c4 04             	add    $0x4,%esp

    if (proc->process_mm) {
c0109e0e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0109e11:	8b 40 58             	mov    0x58(%eax),%eax
c0109e14:	85 c0                	test   %eax,%eax
c0109e16:	74 51                	je     c0109e69 <destroy_process+0xb3>
        struct mm_region *pos, *n;
        llist_for_each(pos, n, &proc->process_mm->head, head)
c0109e18:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0109e1b:	8b 40 58             	mov    0x58(%eax),%eax
c0109e1e:	8b 40 04             	mov    0x4(%eax),%eax
c0109e21:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c0109e24:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0109e27:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0109e2a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109e2d:	8b 40 04             	mov    0x4(%eax),%eax
c0109e30:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0109e33:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0109e36:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0109e39:	eb 23                	jmp    c0109e5e <destroy_process+0xa8>
        {
            malloc_free(pos);
c0109e3b:	83 ec 0c             	sub    $0xc,%esp
c0109e3e:	ff 75 f4             	push   -0xc(%ebp)
c0109e41:	e8 9d d1 ff ff       	call   c0106fe3 <malloc_free>
c0109e46:	83 c4 10             	add    $0x10,%esp
        llist_for_each(pos, n, &proc->process_mm->head, head)
c0109e49:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109e4c:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0109e4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109e52:	8b 40 04             	mov    0x4(%eax),%eax
c0109e55:	89 45 dc             	mov    %eax,-0x24(%ebp)
c0109e58:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0109e5b:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0109e5e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0109e61:	8b 40 58             	mov    0x58(%eax),%eax
c0109e64:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0109e67:	75 d2                	jne    c0109e3b <destroy_process+0x85>
        }
    }

    vmm_mount_pd(PD_MOUNT_2, proc->page_table);
c0109e69:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0109e6c:	8b 40 64             	mov    0x64(%eax),%eax
c0109e6f:	83 ec 08             	sub    $0x8,%esp
c0109e72:	50                   	push   %eax
c0109e73:	68 00 00 80 af       	push   $0xaf800000
c0109e78:	e8 a0 df ff ff       	call   c0107e1d <vmm_mount_pd>
c0109e7d:	83 c4 10             	add    $0x10,%esp

    __del_pagetable(pid, PD_MOUNT_2);
c0109e80:	83 ec 08             	sub    $0x8,%esp
c0109e83:	68 00 00 80 af       	push   $0xaf800000
c0109e88:	ff 75 08             	push   0x8(%ebp)
c0109e8b:	e8 e4 f9 ff ff       	call   c0109874 <__del_pagetable>
c0109e90:	83 c4 10             	add    $0x10,%esp

    vmm_unmount_pd(PD_MOUNT_2);
c0109e93:	83 ec 0c             	sub    $0xc,%esp
c0109e96:	68 00 00 80 af       	push   $0xaf800000
c0109e9b:	e8 bc df ff ff       	call   c0107e5c <vmm_unmount_pd>
c0109ea0:	83 c4 10             	add    $0x10,%esp

    return pid;
c0109ea3:	8b 45 08             	mov    0x8(%ebp),%eax
c0109ea6:	c9                   	leave  
c0109ea7:	c3                   	ret    

c0109ea8 <kprintf>:
#include <libs/mstdio.h>
#include <vga/vga.h>
void kprintf (const char *format, ...)
{
c0109ea8:	55                   	push   %ebp
c0109ea9:	89 e5                	mov    %esp,%ebp
c0109eab:	83 ec 38             	sub    $0x38,%esp
  char **arg = (char **) &format;
c0109eae:	8d 45 08             	lea    0x8(%ebp),%eax
c0109eb1:	89 45 f4             	mov    %eax,-0xc(%ebp)
  int c;
  char buf[20];

  arg++;
c0109eb4:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
  while ((c = *format++) != 0)
c0109eb8:	e9 83 01 00 00       	jmp    c010a040 <kprintf+0x198>
    {
      if (c != '%')
c0109ebd:	83 7d f0 25          	cmpl   $0x25,-0x10(%ebp)
c0109ec1:	74 17                	je     c0109eda <kprintf+0x32>
        vga_put_char (c);
c0109ec3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109ec6:	0f be c0             	movsbl %al,%eax
c0109ec9:	83 ec 0c             	sub    $0xc,%esp
c0109ecc:	50                   	push   %eax
c0109ecd:	e8 4c c1 ff ff       	call   c010601e <vga_put_char>
c0109ed2:	83 c4 10             	add    $0x10,%esp
c0109ed5:	e9 66 01 00 00       	jmp    c010a040 <kprintf+0x198>
      else
        {
          char *p, *p2;
          int pad0 = 0, pad = 0;
c0109eda:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
c0109ee1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
          
          c = *format++;
c0109ee8:	8b 45 08             	mov    0x8(%ebp),%eax
c0109eeb:	8d 50 01             	lea    0x1(%eax),%edx
c0109eee:	89 55 08             	mov    %edx,0x8(%ebp)
c0109ef1:	0f b6 00             	movzbl (%eax),%eax
c0109ef4:	0f be c0             	movsbl %al,%eax
c0109ef7:	89 45 f0             	mov    %eax,-0x10(%ebp)
          if (c == '0')
c0109efa:	83 7d f0 30          	cmpl   $0x30,-0x10(%ebp)
c0109efe:	75 19                	jne    c0109f19 <kprintf+0x71>
            {
              pad0 = 1;
c0109f00:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
              c = *format++;
c0109f07:	8b 45 08             	mov    0x8(%ebp),%eax
c0109f0a:	8d 50 01             	lea    0x1(%eax),%edx
c0109f0d:	89 55 08             	mov    %edx,0x8(%ebp)
c0109f10:	0f b6 00             	movzbl (%eax),%eax
c0109f13:	0f be c0             	movsbl %al,%eax
c0109f16:	89 45 f0             	mov    %eax,-0x10(%ebp)
            }

          if (c >= '0' && c <= '9')
c0109f19:	83 7d f0 2f          	cmpl   $0x2f,-0x10(%ebp)
c0109f1d:	7e 21                	jle    c0109f40 <kprintf+0x98>
c0109f1f:	83 7d f0 39          	cmpl   $0x39,-0x10(%ebp)
c0109f23:	7f 1b                	jg     c0109f40 <kprintf+0x98>
            {
              pad = c - '0';
c0109f25:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0109f28:	83 e8 30             	sub    $0x30,%eax
c0109f2b:	89 45 e0             	mov    %eax,-0x20(%ebp)
              c = *format++;
c0109f2e:	8b 45 08             	mov    0x8(%ebp),%eax
c0109f31:	8d 50 01             	lea    0x1(%eax),%edx
c0109f34:	89 55 08             	mov    %edx,0x8(%ebp)
c0109f37:	0f b6 00             	movzbl (%eax),%eax
c0109f3a:	0f be c0             	movsbl %al,%eax
c0109f3d:	89 45 f0             	mov    %eax,-0x10(%ebp)
            }

          switch (c)
c0109f40:	83 7d f0 78          	cmpl   $0x78,-0x10(%ebp)
c0109f44:	74 2b                	je     c0109f71 <kprintf+0xc9>
c0109f46:	83 7d f0 78          	cmpl   $0x78,-0x10(%ebp)
c0109f4a:	0f 8f d5 00 00 00    	jg     c010a025 <kprintf+0x17d>
c0109f50:	83 7d f0 75          	cmpl   $0x75,-0x10(%ebp)
c0109f54:	74 1b                	je     c0109f71 <kprintf+0xc9>
c0109f56:	83 7d f0 75          	cmpl   $0x75,-0x10(%ebp)
c0109f5a:	0f 8f c5 00 00 00    	jg     c010a025 <kprintf+0x17d>
c0109f60:	83 7d f0 64          	cmpl   $0x64,-0x10(%ebp)
c0109f64:	74 0b                	je     c0109f71 <kprintf+0xc9>
c0109f66:	83 7d f0 73          	cmpl   $0x73,-0x10(%ebp)
c0109f6a:	74 2b                	je     c0109f97 <kprintf+0xef>
c0109f6c:	e9 b4 00 00 00       	jmp    c010a025 <kprintf+0x17d>
            {
            case 'd':
            case 'u':
            case 'x':
              itoa (buf, c, *((int *) arg++));
c0109f71:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109f74:	8d 50 04             	lea    0x4(%eax),%edx
c0109f77:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0109f7a:	8b 00                	mov    (%eax),%eax
c0109f7c:	83 ec 04             	sub    $0x4,%esp
c0109f7f:	50                   	push   %eax
c0109f80:	ff 75 f0             	push   -0x10(%ebp)
c0109f83:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0109f86:	50                   	push   %eax
c0109f87:	e8 d4 00 00 00       	call   c010a060 <itoa>
c0109f8c:	83 c4 10             	add    $0x10,%esp
              p = buf;
c0109f8f:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0109f92:	89 45 ec             	mov    %eax,-0x14(%ebp)
              goto string;
c0109f95:	eb 1e                	jmp    c0109fb5 <kprintf+0x10d>
              break;

            case 's':
              p = *arg++;
c0109f97:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0109f9a:	8d 50 04             	lea    0x4(%eax),%edx
c0109f9d:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0109fa0:	8b 00                	mov    (%eax),%eax
c0109fa2:	89 45 ec             	mov    %eax,-0x14(%ebp)
              if (! p)
c0109fa5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0109fa9:	75 09                	jne    c0109fb4 <kprintf+0x10c>
                p = "(null)";
c0109fab:	c7 45 ec b8 d6 28 c0 	movl   $0xc028d6b8,-0x14(%ebp)
c0109fb2:	eb 01                	jmp    c0109fb5 <kprintf+0x10d>

            string:
c0109fb4:	90                   	nop
              for (p2 = p; *p2; p2++);
c0109fb5:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0109fb8:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0109fbb:	eb 04                	jmp    c0109fc1 <kprintf+0x119>
c0109fbd:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
c0109fc1:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0109fc4:	0f b6 00             	movzbl (%eax),%eax
c0109fc7:	84 c0                	test   %al,%al
c0109fc9:	75 f2                	jne    c0109fbd <kprintf+0x115>
              for (; p2 < p + pad; p2++)
c0109fcb:	eb 22                	jmp    c0109fef <kprintf+0x147>
                vga_put_char (pad0 ? '0' : ' ');
c0109fcd:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0109fd1:	74 07                	je     c0109fda <kprintf+0x132>
c0109fd3:	b8 30 00 00 00       	mov    $0x30,%eax
c0109fd8:	eb 05                	jmp    c0109fdf <kprintf+0x137>
c0109fda:	b8 20 00 00 00       	mov    $0x20,%eax
c0109fdf:	83 ec 0c             	sub    $0xc,%esp
c0109fe2:	50                   	push   %eax
c0109fe3:	e8 36 c0 ff ff       	call   c010601e <vga_put_char>
c0109fe8:	83 c4 10             	add    $0x10,%esp
              for (; p2 < p + pad; p2++)
c0109feb:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
c0109fef:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0109ff2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0109ff5:	01 d0                	add    %edx,%eax
c0109ff7:	39 45 e8             	cmp    %eax,-0x18(%ebp)
c0109ffa:	72 d1                	jb     c0109fcd <kprintf+0x125>
              while (*p)
c0109ffc:	eb 1b                	jmp    c010a019 <kprintf+0x171>
                vga_put_char (*p++);
c0109ffe:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010a001:	8d 50 01             	lea    0x1(%eax),%edx
c010a004:	89 55 ec             	mov    %edx,-0x14(%ebp)
c010a007:	0f b6 00             	movzbl (%eax),%eax
c010a00a:	0f be c0             	movsbl %al,%eax
c010a00d:	83 ec 0c             	sub    $0xc,%esp
c010a010:	50                   	push   %eax
c010a011:	e8 08 c0 ff ff       	call   c010601e <vga_put_char>
c010a016:	83 c4 10             	add    $0x10,%esp
              while (*p)
c010a019:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010a01c:	0f b6 00             	movzbl (%eax),%eax
c010a01f:	84 c0                	test   %al,%al
c010a021:	75 db                	jne    c0109ffe <kprintf+0x156>
              break;
c010a023:	eb 1b                	jmp    c010a040 <kprintf+0x198>

            default:
              vga_put_char (*((int *) arg++));
c010a025:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010a028:	8d 50 04             	lea    0x4(%eax),%edx
c010a02b:	89 55 f4             	mov    %edx,-0xc(%ebp)
c010a02e:	8b 00                	mov    (%eax),%eax
c010a030:	0f be c0             	movsbl %al,%eax
c010a033:	83 ec 0c             	sub    $0xc,%esp
c010a036:	50                   	push   %eax
c010a037:	e8 e2 bf ff ff       	call   c010601e <vga_put_char>
c010a03c:	83 c4 10             	add    $0x10,%esp
              break;
c010a03f:	90                   	nop
  while ((c = *format++) != 0)
c010a040:	8b 45 08             	mov    0x8(%ebp),%eax
c010a043:	8d 50 01             	lea    0x1(%eax),%edx
c010a046:	89 55 08             	mov    %edx,0x8(%ebp)
c010a049:	0f b6 00             	movzbl (%eax),%eax
c010a04c:	0f be c0             	movsbl %al,%eax
c010a04f:	89 45 f0             	mov    %eax,-0x10(%ebp)
c010a052:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c010a056:	0f 85 61 fe ff ff    	jne    c0109ebd <kprintf+0x15>
            }
        }
    }
}
c010a05c:	90                   	nop
c010a05d:	90                   	nop
c010a05e:	c9                   	leave  
c010a05f:	c3                   	ret    

c010a060 <itoa>:
#include <libs/mstdlib.h>

void
itoa (char *buf, int base, int d)
{
c010a060:	55                   	push   %ebp
c010a061:	89 e5                	mov    %esp,%ebp
c010a063:	83 ec 20             	sub    $0x20,%esp
  char *p = buf;
c010a066:	8b 45 08             	mov    0x8(%ebp),%eax
c010a069:	89 45 fc             	mov    %eax,-0x4(%ebp)
  char *p1, *p2;
  unsigned long ud = d;
c010a06c:	8b 45 10             	mov    0x10(%ebp),%eax
c010a06f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int divisor = 10;
c010a072:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
  
  /* If %d is specified and D is minus, put ‘-’ in the head. */
  if (base == 'd' && d < 0)
c010a079:	83 7d 0c 64          	cmpl   $0x64,0xc(%ebp)
c010a07d:	75 20                	jne    c010a09f <itoa+0x3f>
c010a07f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c010a083:	79 1a                	jns    c010a09f <itoa+0x3f>
    {
      *p++ = '-';
c010a085:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010a088:	8d 50 01             	lea    0x1(%eax),%edx
c010a08b:	89 55 fc             	mov    %edx,-0x4(%ebp)
c010a08e:	c6 00 2d             	movb   $0x2d,(%eax)
      buf++;
c010a091:	83 45 08 01          	addl   $0x1,0x8(%ebp)
      ud = -d;
c010a095:	8b 45 10             	mov    0x10(%ebp),%eax
c010a098:	f7 d8                	neg    %eax
c010a09a:	89 45 f0             	mov    %eax,-0x10(%ebp)
c010a09d:	eb 0d                	jmp    c010a0ac <itoa+0x4c>
    }
  else if (base == 'x')
c010a09f:	83 7d 0c 78          	cmpl   $0x78,0xc(%ebp)
c010a0a3:	75 07                	jne    c010a0ac <itoa+0x4c>
    divisor = 16;
c010a0a5:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)

  /* Divide UD by DIVISOR until UD == 0. */
  do
    {
      int remainder = ud % divisor;
c010a0ac:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c010a0af:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010a0b2:	ba 00 00 00 00       	mov    $0x0,%edx
c010a0b7:	f7 f1                	div    %ecx
c010a0b9:	89 d0                	mov    %edx,%eax
c010a0bb:	89 45 e8             	mov    %eax,-0x18(%ebp)
      
      *p++ = (remainder < 10) ? remainder + '0' : remainder + 'a' - 10;
c010a0be:	83 7d e8 09          	cmpl   $0x9,-0x18(%ebp)
c010a0c2:	7f 0a                	jg     c010a0ce <itoa+0x6e>
c010a0c4:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010a0c7:	83 c0 30             	add    $0x30,%eax
c010a0ca:	89 c1                	mov    %eax,%ecx
c010a0cc:	eb 08                	jmp    c010a0d6 <itoa+0x76>
c010a0ce:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010a0d1:	83 c0 57             	add    $0x57,%eax
c010a0d4:	89 c1                	mov    %eax,%ecx
c010a0d6:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010a0d9:	8d 50 01             	lea    0x1(%eax),%edx
c010a0dc:	89 55 fc             	mov    %edx,-0x4(%ebp)
c010a0df:	88 08                	mov    %cl,(%eax)
    }
  while (ud /= divisor);
c010a0e1:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c010a0e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010a0e7:	ba 00 00 00 00       	mov    $0x0,%edx
c010a0ec:	f7 f1                	div    %ecx
c010a0ee:	89 45 f0             	mov    %eax,-0x10(%ebp)
c010a0f1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c010a0f5:	75 b5                	jne    c010a0ac <itoa+0x4c>

  /* Terminate BUF. */
  *p = 0;
c010a0f7:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010a0fa:	c6 00 00             	movb   $0x0,(%eax)
  
  /* Reverse BUF. */
  p1 = buf;
c010a0fd:	8b 45 08             	mov    0x8(%ebp),%eax
c010a100:	89 45 f8             	mov    %eax,-0x8(%ebp)
  p2 = p - 1;
c010a103:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010a106:	83 e8 01             	sub    $0x1,%eax
c010a109:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (p1 < p2)
c010a10c:	eb 25                	jmp    c010a133 <itoa+0xd3>
    {
      char tmp = *p1;
c010a10e:	8b 45 f8             	mov    -0x8(%ebp),%eax
c010a111:	0f b6 00             	movzbl (%eax),%eax
c010a114:	88 45 e7             	mov    %al,-0x19(%ebp)
      *p1 = *p2;
c010a117:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010a11a:	0f b6 10             	movzbl (%eax),%edx
c010a11d:	8b 45 f8             	mov    -0x8(%ebp),%eax
c010a120:	88 10                	mov    %dl,(%eax)
      *p2 = tmp;
c010a122:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010a125:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
c010a129:	88 10                	mov    %dl,(%eax)
      p1++;
c010a12b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
      p2--;
c010a12f:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
  while (p1 < p2)
c010a133:	8b 45 f8             	mov    -0x8(%ebp),%eax
c010a136:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c010a139:	72 d3                	jb     c010a10e <itoa+0xae>
    }
c010a13b:	90                   	nop
c010a13c:	90                   	nop
c010a13d:	c9                   	leave  
c010a13e:	c3                   	ret    

c010a13f <memset>:
#include <libs/mstring.h>
#include <stdint.h>

void* memset(void* ptr, int value, size_t num)
{
c010a13f:	55                   	push   %ebp
c010a140:	89 e5                	mov    %esp,%ebp
c010a142:	83 ec 10             	sub    $0x10,%esp
    uint8_t* c_ptr = (uint8_t*)ptr;
c010a145:	8b 45 08             	mov    0x8(%ebp),%eax
c010a148:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for (size_t i = 0; i < num; i++) {
c010a14b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c010a152:	eb 11                	jmp    c010a165 <memset+0x26>
        *(c_ptr + i) = (uint8_t)value;
c010a154:	8b 55 f8             	mov    -0x8(%ebp),%edx
c010a157:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010a15a:	01 d0                	add    %edx,%eax
c010a15c:	8b 55 0c             	mov    0xc(%ebp),%edx
c010a15f:	88 10                	mov    %dl,(%eax)
    for (size_t i = 0; i < num; i++) {
c010a161:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c010a165:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010a168:	3b 45 10             	cmp    0x10(%ebp),%eax
c010a16b:	72 e7                	jb     c010a154 <memset+0x15>
    }
    return ptr;
c010a16d:	8b 45 08             	mov    0x8(%ebp),%eax
c010a170:	c9                   	leave  
c010a171:	c3                   	ret    
